/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, Outscale SAS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

 /*
  * This code is autogenerated, don't edit it directely
  */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "json.h"
#include "osc_sdk.h"
#include "main-helper.h"

#ifndef JSON_C_TO_STRING_COLOR
#define JSON_C_TO_STRING_COLOR 0
#endif

#define OAPI_RAW_OUTPUT 1

#define TRY(f, args...)						\
	do {							\
		if (f) {fprintf(stderr, args);  return 1;}	\
	} while(0)

static int argcmp(const char *s1, const char *s2)
{
	while (*s1 == *s2 && *s1 && *s2) {
		s1++;
		s2++;
	}
	if ((*s2 == '.' && *s1 == '\0') ||
	    (*s1 == '.' && *s2 == '\0'))
		return 0;
	return *s1 != *s2;
}

static void *cascade_struct;
static int (*cascade_parser)(void *, char *, char *, struct ptr_array *);

int accepter_net_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int access_key_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int access_key_secret_key_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int access_log_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int account_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int api_access_policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int api_access_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int application_sticky_cookie_policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int backend_vm_health_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int block_device_mapping_created_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int block_device_mapping_image_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int block_device_mapping_vm_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int block_device_mapping_vm_update_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int bsu_created_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int bsu_to_create_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int bsu_to_update_vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int ca_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int catalog_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int catalog_entry_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int client_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int consumption_entry_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int dhcp_options_set_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int direct_link_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int direct_link_interface_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int direct_link_interfaces_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int errors_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_access_keys_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_api_access_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_api_log_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_ca_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_client_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_dhcp_options_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_direct_link_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_direct_link_interface_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_flexible_gpu_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_image_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_internet_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_keypair_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_listener_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_load_balancer_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_nat_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_net_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_net_access_point_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_net_peering_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_nic_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_product_type_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_public_ip_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_quota_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_route_table_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_security_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_server_certificate_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_snapshot_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_subnet_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_subregion_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_virtual_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vm_type_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vms_state_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_volume_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vpn_connection_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int flexible_gpu_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int flexible_gpu_catalog_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int health_check_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int image_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int image_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int internet_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int keypair_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int keypair_created_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_nic_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_nic_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_nic_to_update_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_public_ip_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_public_ip_light_for_vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_route_table_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int linked_volume_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int listener_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int listener_for_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int listener_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int listener_rule_for_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int load_balancer_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int load_balancer_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int load_balancer_sticky_cookie_policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int load_balancer_tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int location_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int log_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int maintenance_event_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int nat_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_access_point_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_peering_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_peering_state_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_to_virtual_gateway_link_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int nic_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int nic_for_vm_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int nic_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int osu_api_key_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int osu_export_image_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int osu_export_snapshot_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int osu_export_to_create_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int permissions_on_resource_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int permissions_on_resource_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int phase1_options_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int phase2_options_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int placement_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int private_ip_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int private_ip_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int private_ip_light_for_vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int product_type_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int public_ip_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int public_ip_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int quota_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int quota_types_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int region_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int resource_load_balancer_tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int resource_tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int route_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int route_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int route_propagating_virtual_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int route_table_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int security_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int security_group_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int security_group_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int security_groups_member_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int server_certificate_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int snapshot_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int snapshot_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int source_net_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int source_security_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int state_comment_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int subnet_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int subregion_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vgw_telemetry_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int virtual_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_state_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_states_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_type_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int volume_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vpn_connection_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vpn_options_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int with_parser(void *s, char *str, char *aa, struct ptr_array *pa);

int accepter_net_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct accepter_net *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "IpRange")) {
            TRY(!aa, "IpRange argument missing\n");
            s->ip_range = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'AccepterNet'\n", str);
	}
	return 0;
}

int access_key_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct access_key *s = v_s;
	if (!argcmp(str, "AccessKeyId")) {
            TRY(!aa, "AccessKeyId argument missing\n");
            s->access_key_id = aa; // string string

         } else
	if (!argcmp(str, "CreationDate")) {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if (!argcmp(str, "ExpirationDate")) {
            TRY(!aa, "ExpirationDate argument missing\n");
            s->expiration_date = aa; // string string

         } else
	if (!argcmp(str, "LastModificationDate")) {
            TRY(!aa, "LastModificationDate argument missing\n");
            s->last_modification_date = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'AccessKey'\n", str);
	}
	return 0;
}

int access_key_secret_key_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct access_key_secret_key *s = v_s;
	if (!argcmp(str, "AccessKeyId")) {
            TRY(!aa, "AccessKeyId argument missing\n");
            s->access_key_id = aa; // string string

         } else
	if (!argcmp(str, "CreationDate")) {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if (!argcmp(str, "ExpirationDate")) {
            TRY(!aa, "ExpirationDate argument missing\n");
            s->expiration_date = aa; // string string

         } else
	if (!argcmp(str, "LastModificationDate")) {
            TRY(!aa, "LastModificationDate argument missing\n");
            s->last_modification_date = aa; // string string

         } else
	if (!argcmp(str, "SecretKey")) {
            TRY(!aa, "SecretKey argument missing\n");
            s->secret_key = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'AccessKeySecretKey'\n", str);
	}
	return 0;
}

int access_log_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct access_log *s = v_s;
	if (!argcmp(str, "IsEnabled")) {
            s->is_set_is_enabled = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_enabled = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_enabled = 0;
             } else {
            		fprintf(stderr, "IsEnabled require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "OsuBucketName")) {
            TRY(!aa, "OsuBucketName argument missing\n");
            s->osu_bucket_name = aa; // string string

         } else
	if (!argcmp(str, "OsuBucketPrefix")) {
            TRY(!aa, "OsuBucketPrefix argument missing\n");
            s->osu_bucket_prefix = aa; // string string

         } else
	if (!argcmp(str, "PublicationInterval")) {
            TRY(!aa, "PublicationInterval argument missing\n");
            s->is_set_publication_interval = 1;
            s->publication_interval = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'AccessLog'\n", str);
	}
	return 0;
}

int account_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct account *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "AdditionalEmails")) {
            	 TRY(!aa, "AdditionalEmails argument missing\n");
               s->additional_emails_str = aa;
         } else if (!strcmp(str, "AdditionalEmails[]")) {
               TRY(!aa, "AdditionalEmails[] argument missing\n");
               SET_NEXT(s->additional_emails, (aa), pa);
         } else
	if (!argcmp(str, "City")) {
            TRY(!aa, "City argument missing\n");
            s->city = aa; // string string

         } else
	if (!argcmp(str, "CompanyName")) {
            TRY(!aa, "CompanyName argument missing\n");
            s->company_name = aa; // string string

         } else
	if (!argcmp(str, "Country")) {
            TRY(!aa, "Country argument missing\n");
            s->country = aa; // string string

         } else
	if (!argcmp(str, "CustomerId")) {
            TRY(!aa, "CustomerId argument missing\n");
            s->customer_id = aa; // string string

         } else
	if (!argcmp(str, "Email")) {
            TRY(!aa, "Email argument missing\n");
            s->email = aa; // string string

         } else
	if (!argcmp(str, "FirstName")) {
            TRY(!aa, "FirstName argument missing\n");
            s->first_name = aa; // string string

         } else
	if (!argcmp(str, "JobTitle")) {
            TRY(!aa, "JobTitle argument missing\n");
            s->job_title = aa; // string string

         } else
	if (!argcmp(str, "LastName")) {
            TRY(!aa, "LastName argument missing\n");
            s->last_name = aa; // string string

         } else
	if (!argcmp(str, "MobileNumber")) {
            TRY(!aa, "MobileNumber argument missing\n");
            s->mobile_number = aa; // string string

         } else
	if (!argcmp(str, "PhoneNumber")) {
            TRY(!aa, "PhoneNumber argument missing\n");
            s->phone_number = aa; // string string

         } else
	if (!argcmp(str, "StateProvince")) {
            TRY(!aa, "StateProvince argument missing\n");
            s->state_province = aa; // string string

         } else
	if (!argcmp(str, "VatNumber")) {
            TRY(!aa, "VatNumber argument missing\n");
            s->vat_number = aa; // string string

         } else
	if (!argcmp(str, "ZipCode")) {
            TRY(!aa, "ZipCode argument missing\n");
            s->zip_code = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Account'\n", str);
	}
	return 0;
}

int api_access_policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct api_access_policy *s = v_s;
	if (!argcmp(str, "MaxAccessKeyExpirationSeconds")) {
            TRY(!aa, "MaxAccessKeyExpirationSeconds argument missing\n");
            s->is_set_max_access_key_expiration_seconds = 1;
            s->max_access_key_expiration_seconds = atoi(aa);
         } else
	if (!argcmp(str, "RequireTrustedEnv")) {
            s->is_set_require_trusted_env = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->require_trusted_env = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->require_trusted_env = 0;
             } else {
            		fprintf(stderr, "RequireTrustedEnv require true/false\n");
            		return 1;
             }
        } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ApiAccessPolicy'\n", str);
	}
	return 0;
}

int api_access_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct api_access_rule *s = v_s;
	if (!argcmp(str, "ApiAccessRuleId")) {
            TRY(!aa, "ApiAccessRuleId argument missing\n");
            s->api_access_rule_id = aa; // string string

         } else
	if (!argcmp(str, "CaIds")) {
            	 TRY(!aa, "CaIds argument missing\n");
               s->ca_ids_str = aa;
         } else if (!strcmp(str, "CaIds[]")) {
               TRY(!aa, "CaIds[] argument missing\n");
               SET_NEXT(s->ca_ids, (aa), pa);
         } else
	if (!argcmp(str, "Cns")) {
            	 TRY(!aa, "Cns argument missing\n");
               s->cns_str = aa;
         } else if (!strcmp(str, "Cns[]")) {
               TRY(!aa, "Cns[] argument missing\n");
               SET_NEXT(s->cns, (aa), pa);
         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "IpRanges")) {
            	 TRY(!aa, "IpRanges argument missing\n");
               s->ip_ranges_str = aa;
         } else if (!strcmp(str, "IpRanges[]")) {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ApiAccessRule'\n", str);
	}
	return 0;
}

int application_sticky_cookie_policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct application_sticky_cookie_policy *s = v_s;
	if (!argcmp(str, "CookieName")) {
            TRY(!aa, "CookieName argument missing\n");
            s->cookie_name = aa; // string string

         } else
	if (!argcmp(str, "PolicyName")) {
            TRY(!aa, "PolicyName argument missing\n");
            s->policy_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ApplicationStickyCookiePolicy'\n", str);
	}
	return 0;
}

int backend_vm_health_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct backend_vm_health *s = v_s;
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "StateReason")) {
            TRY(!aa, "StateReason argument missing\n");
            s->state_reason = aa; // string string

         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BackendVmHealth'\n", str);
	}
	return 0;
}

int block_device_mapping_created_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct block_device_mapping_created *s = v_s;
	if (!argcmp(str, "Bsu")) {
            char *dot_pos;

            TRY(!aa, "Bsu argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->bsu;
            	    cascade_parser = bsu_created_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    bsu_created_parser(&s->bsu, dot_pos, aa, pa);
            	    s->is_set_bsu = 1;
             } else {
                   s->bsu_str = aa;
             }
         } else
	if (!argcmp(str, "DeviceName")) {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BlockDeviceMappingCreated'\n", str);
	}
	return 0;
}

int block_device_mapping_image_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct block_device_mapping_image *s = v_s;
	if (!argcmp(str, "Bsu")) {
            char *dot_pos;

            TRY(!aa, "Bsu argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->bsu;
            	    cascade_parser = bsu_to_create_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    bsu_to_create_parser(&s->bsu, dot_pos, aa, pa);
            	    s->is_set_bsu = 1;
             } else {
                   s->bsu_str = aa;
             }
         } else
	if (!argcmp(str, "DeviceName")) {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	if (!argcmp(str, "VirtualDeviceName")) {
            TRY(!aa, "VirtualDeviceName argument missing\n");
            s->virtual_device_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BlockDeviceMappingImage'\n", str);
	}
	return 0;
}

int block_device_mapping_vm_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct block_device_mapping_vm_creation *s = v_s;
	if (!argcmp(str, "Bsu")) {
            char *dot_pos;

            TRY(!aa, "Bsu argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->bsu;
            	    cascade_parser = bsu_to_create_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    bsu_to_create_parser(&s->bsu, dot_pos, aa, pa);
            	    s->is_set_bsu = 1;
             } else {
                   s->bsu_str = aa;
             }
         } else
	if (!argcmp(str, "DeviceName")) {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	if (!argcmp(str, "NoDevice")) {
            TRY(!aa, "NoDevice argument missing\n");
            s->no_device = aa; // string string

         } else
	if (!argcmp(str, "VirtualDeviceName")) {
            TRY(!aa, "VirtualDeviceName argument missing\n");
            s->virtual_device_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BlockDeviceMappingVmCreation'\n", str);
	}
	return 0;
}

int block_device_mapping_vm_update_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct block_device_mapping_vm_update *s = v_s;
	if (!argcmp(str, "Bsu")) {
            char *dot_pos;

            TRY(!aa, "Bsu argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->bsu;
            	    cascade_parser = bsu_to_update_vm_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    bsu_to_update_vm_parser(&s->bsu, dot_pos, aa, pa);
            	    s->is_set_bsu = 1;
             } else {
                   s->bsu_str = aa;
             }
         } else
	if (!argcmp(str, "DeviceName")) {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	if (!argcmp(str, "NoDevice")) {
            TRY(!aa, "NoDevice argument missing\n");
            s->no_device = aa; // string string

         } else
	if (!argcmp(str, "VirtualDeviceName")) {
            TRY(!aa, "VirtualDeviceName argument missing\n");
            s->virtual_device_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BlockDeviceMappingVmUpdate'\n", str);
	}
	return 0;
}

int bsu_created_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct bsu_created *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkDate")) {
            TRY(!aa, "LinkDate argument missing\n");
            s->link_date = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "VolumeId")) {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BsuCreated'\n", str);
	}
	return 0;
}

int bsu_to_create_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct bsu_to_create *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "Iops")) {
            TRY(!aa, "Iops argument missing\n");
            s->is_set_iops = 1;
            s->iops = atoi(aa);
         } else
	if (!argcmp(str, "SnapshotId")) {
            TRY(!aa, "SnapshotId argument missing\n");
            s->snapshot_id = aa; // string string

         } else
	if (!argcmp(str, "VolumeSize")) {
            TRY(!aa, "VolumeSize argument missing\n");
            s->is_set_volume_size = 1;
            s->volume_size = atoi(aa);
         } else
	if (!argcmp(str, "VolumeType")) {
            TRY(!aa, "VolumeType argument missing\n");
            s->volume_type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BsuToCreate'\n", str);
	}
	return 0;
}

int bsu_to_update_vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct bsu_to_update_vm *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "VolumeId")) {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BsuToUpdateVm'\n", str);
	}
	return 0;
}

int ca_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct ca *s = v_s;
	if (!argcmp(str, "CaFingerprint")) {
            TRY(!aa, "CaFingerprint argument missing\n");
            s->ca_fingerprint = aa; // string string

         } else
	if (!argcmp(str, "CaId")) {
            TRY(!aa, "CaId argument missing\n");
            s->ca_id = aa; // string string

         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Ca'\n", str);
	}
	return 0;
}

int catalog_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct catalog *s = v_s;
	if (!argcmp(str, "Entries")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Entries' require an index (example array ref CatalogEntry.Entries.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Entries' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,entries, pa, pos, sizeof(*s->entries));
            	      cascade_struct = &s->entries[pos];
            	      cascade_parser = catalog_entry_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      catalog_entry_parser(&s->entries[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Entries argument missing\n");
            	s->entries_str = aa; // array ref CatalogEntry ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Catalog'\n", str);
	}
	return 0;
}

int catalog_entry_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct catalog_entry *s = v_s;
	if (!argcmp(str, "Category")) {
            TRY(!aa, "Category argument missing\n");
            s->category = aa; // string string

         } else
	if (!argcmp(str, "Flags")) {
            TRY(!aa, "Flags argument missing\n");
            s->flags = aa; // string string

         } else
	if (!argcmp(str, "Operation")) {
            TRY(!aa, "Operation argument missing\n");
            s->operation = aa; // string string

         } else
	if (!argcmp(str, "Service")) {
            TRY(!aa, "Service argument missing\n");
            s->service = aa; // string string

         } else
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if (!argcmp(str, "Title")) {
            TRY(!aa, "Title argument missing\n");
            s->title = aa; // string string

         } else
	if (!argcmp(str, "Type")) {
            TRY(!aa, "Type argument missing\n");
            s->type = aa; // string string

         } else
	if (!argcmp(str, "UnitPrice")) {
            TRY(!aa, "UnitPrice argument missing\n");
            s->is_set_unit_price = 1;
            s->unit_price = atof(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'CatalogEntry'\n", str);
	}
	return 0;
}

int client_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct client_gateway *s = v_s;
	if (!argcmp(str, "BgpAsn")) {
            TRY(!aa, "BgpAsn argument missing\n");
            s->is_set_bgp_asn = 1;
            s->bgp_asn = atoi(aa);
         } else
	if (!argcmp(str, "ClientGatewayId")) {
            TRY(!aa, "ClientGatewayId argument missing\n");
            s->client_gateway_id = aa; // string string

         } else
	if (!argcmp(str, "ConnectionType")) {
            TRY(!aa, "ConnectionType argument missing\n");
            s->connection_type = aa; // string string

         } else
	if (!argcmp(str, "PublicIp")) {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ClientGateway'\n", str);
	}
	return 0;
}

int consumption_entry_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct consumption_entry *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "Category")) {
            TRY(!aa, "Category argument missing\n");
            s->category = aa; // string string

         } else
	if (!argcmp(str, "FromDate")) {
            TRY(!aa, "FromDate argument missing\n");
            s->from_date = aa; // string string

         } else
	if (!argcmp(str, "Operation")) {
            TRY(!aa, "Operation argument missing\n");
            s->operation = aa; // string string

         } else
	if (!argcmp(str, "PayingAccountId")) {
            TRY(!aa, "PayingAccountId argument missing\n");
            s->paying_account_id = aa; // string string

         } else
	if (!argcmp(str, "Service")) {
            TRY(!aa, "Service argument missing\n");
            s->service = aa; // string string

         } else
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if (!argcmp(str, "Title")) {
            TRY(!aa, "Title argument missing\n");
            s->title = aa; // string string

         } else
	if (!argcmp(str, "ToDate")) {
            TRY(!aa, "ToDate argument missing\n");
            s->to_date = aa; // string string

         } else
	if (!argcmp(str, "Type")) {
            TRY(!aa, "Type argument missing\n");
            s->type = aa; // string string

         } else
	if (!argcmp(str, "Value")) {
            TRY(!aa, "Value argument missing\n");
            s->is_set_value = 1;
            s->value = atof(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ConsumptionEntry'\n", str);
	}
	return 0;
}

int dhcp_options_set_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct dhcp_options_set *s = v_s;
	if (!argcmp(str, "Default")) {
            s->is_set_default_arg = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->default_arg = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->default_arg = 0;
             } else {
            		fprintf(stderr, "Default require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "DhcpOptionsSetId")) {
            TRY(!aa, "DhcpOptionsSetId argument missing\n");
            s->dhcp_options_set_id = aa; // string string

         } else
	if (!argcmp(str, "DomainName")) {
            TRY(!aa, "DomainName argument missing\n");
            s->domain_name = aa; // string string

         } else
	if (!argcmp(str, "DomainNameServers")) {
            	 TRY(!aa, "DomainNameServers argument missing\n");
               s->domain_name_servers_str = aa;
         } else if (!strcmp(str, "DomainNameServers[]")) {
               TRY(!aa, "DomainNameServers[] argument missing\n");
               SET_NEXT(s->domain_name_servers, (aa), pa);
         } else
	if (!argcmp(str, "LogServers")) {
            	 TRY(!aa, "LogServers argument missing\n");
               s->log_servers_str = aa;
         } else if (!strcmp(str, "LogServers[]")) {
               TRY(!aa, "LogServers[] argument missing\n");
               SET_NEXT(s->log_servers, (aa), pa);
         } else
	if (!argcmp(str, "NtpServers")) {
            	 TRY(!aa, "NtpServers argument missing\n");
               s->ntp_servers_str = aa;
         } else if (!strcmp(str, "NtpServers[]")) {
               TRY(!aa, "NtpServers[] argument missing\n");
               SET_NEXT(s->ntp_servers, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DhcpOptionsSet'\n", str);
	}
	return 0;
}

int direct_link_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct direct_link *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "Bandwidth")) {
            TRY(!aa, "Bandwidth argument missing\n");
            s->bandwidth = aa; // string string

         } else
	if (!argcmp(str, "DirectLinkId")) {
            TRY(!aa, "DirectLinkId argument missing\n");
            s->direct_link_id = aa; // string string

         } else
	if (!argcmp(str, "DirectLinkName")) {
            TRY(!aa, "DirectLinkName argument missing\n");
            s->direct_link_name = aa; // string string

         } else
	if (!argcmp(str, "Location")) {
            TRY(!aa, "Location argument missing\n");
            s->location = aa; // string string

         } else
	if (!argcmp(str, "RegionName")) {
            TRY(!aa, "RegionName argument missing\n");
            s->region_name = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DirectLink'\n", str);
	}
	return 0;
}

int direct_link_interface_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct direct_link_interface *s = v_s;
	if (!argcmp(str, "BgpAsn")) {
            TRY(!aa, "BgpAsn argument missing\n");
            s->is_set_bgp_asn = 1;
            s->bgp_asn = atoi(aa);
         } else
	if (!argcmp(str, "BgpKey")) {
            TRY(!aa, "BgpKey argument missing\n");
            s->bgp_key = aa; // string string

         } else
	if (!argcmp(str, "ClientPrivateIp")) {
            TRY(!aa, "ClientPrivateIp argument missing\n");
            s->client_private_ip = aa; // string string

         } else
	if (!argcmp(str, "DirectLinkInterfaceName")) {
            TRY(!aa, "DirectLinkInterfaceName argument missing\n");
            s->direct_link_interface_name = aa; // string string

         } else
	if (!argcmp(str, "OutscalePrivateIp")) {
            TRY(!aa, "OutscalePrivateIp argument missing\n");
            s->outscale_private_ip = aa; // string string

         } else
	if (!argcmp(str, "VirtualGatewayId")) {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	if (!argcmp(str, "Vlan")) {
            TRY(!aa, "Vlan argument missing\n");
            s->is_set_vlan = 1;
            s->vlan = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DirectLinkInterface'\n", str);
	}
	return 0;
}

int direct_link_interfaces_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct direct_link_interfaces *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "BgpAsn")) {
            TRY(!aa, "BgpAsn argument missing\n");
            s->is_set_bgp_asn = 1;
            s->bgp_asn = atoi(aa);
         } else
	if (!argcmp(str, "BgpKey")) {
            TRY(!aa, "BgpKey argument missing\n");
            s->bgp_key = aa; // string string

         } else
	if (!argcmp(str, "ClientPrivateIp")) {
            TRY(!aa, "ClientPrivateIp argument missing\n");
            s->client_private_ip = aa; // string string

         } else
	if (!argcmp(str, "DirectLinkId")) {
            TRY(!aa, "DirectLinkId argument missing\n");
            s->direct_link_id = aa; // string string

         } else
	if (!argcmp(str, "DirectLinkInterfaceId")) {
            TRY(!aa, "DirectLinkInterfaceId argument missing\n");
            s->direct_link_interface_id = aa; // string string

         } else
	if (!argcmp(str, "DirectLinkInterfaceName")) {
            TRY(!aa, "DirectLinkInterfaceName argument missing\n");
            s->direct_link_interface_name = aa; // string string

         } else
	if (!argcmp(str, "InterfaceType")) {
            TRY(!aa, "InterfaceType argument missing\n");
            s->interface_type = aa; // string string

         } else
	if (!argcmp(str, "Location")) {
            TRY(!aa, "Location argument missing\n");
            s->location = aa; // string string

         } else
	if (!argcmp(str, "Mtu")) {
            TRY(!aa, "Mtu argument missing\n");
            s->is_set_mtu = 1;
            s->mtu = atoi(aa);
         } else
	if (!argcmp(str, "OutscalePrivateIp")) {
            TRY(!aa, "OutscalePrivateIp argument missing\n");
            s->outscale_private_ip = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "VirtualGatewayId")) {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	if (!argcmp(str, "Vlan")) {
            TRY(!aa, "Vlan argument missing\n");
            s->is_set_vlan = 1;
            s->vlan = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DirectLinkInterfaces'\n", str);
	}
	return 0;
}

int errors_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct errors *s = v_s;
	if (!argcmp(str, "Code")) {
            TRY(!aa, "Code argument missing\n");
            s->code = aa; // string string

         } else
	if (!argcmp(str, "Details")) {
            TRY(!aa, "Details argument missing\n");
            s->details = aa; // string string

         } else
	if (!argcmp(str, "Type")) {
            TRY(!aa, "Type argument missing\n");
            s->type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Errors'\n", str);
	}
	return 0;
}

int filters_access_keys_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_access_keys *s = v_s;
	if (!argcmp(str, "AccessKeyIds")) {
            	 TRY(!aa, "AccessKeyIds argument missing\n");
               s->access_key_ids_str = aa;
         } else if (!strcmp(str, "AccessKeyIds[]")) {
               TRY(!aa, "AccessKeyIds[] argument missing\n");
               SET_NEXT(s->access_key_ids, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersAccessKeys'\n", str);
	}
	return 0;
}

int filters_api_access_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_api_access_rule *s = v_s;
	if (!argcmp(str, "ApiAccessRuleIds")) {
            	 TRY(!aa, "ApiAccessRuleIds argument missing\n");
               s->api_access_rule_ids_str = aa;
         } else if (!strcmp(str, "ApiAccessRuleIds[]")) {
               TRY(!aa, "ApiAccessRuleIds[] argument missing\n");
               SET_NEXT(s->api_access_rule_ids, (aa), pa);
         } else
	if (!argcmp(str, "CaIds")) {
            	 TRY(!aa, "CaIds argument missing\n");
               s->ca_ids_str = aa;
         } else if (!strcmp(str, "CaIds[]")) {
               TRY(!aa, "CaIds[] argument missing\n");
               SET_NEXT(s->ca_ids, (aa), pa);
         } else
	if (!argcmp(str, "Cns")) {
            	 TRY(!aa, "Cns argument missing\n");
               s->cns_str = aa;
         } else if (!strcmp(str, "Cns[]")) {
               TRY(!aa, "Cns[] argument missing\n");
               SET_NEXT(s->cns, (aa), pa);
         } else
	if (!argcmp(str, "Descriptions")) {
            	 TRY(!aa, "Descriptions argument missing\n");
               s->descriptions_str = aa;
         } else if (!strcmp(str, "Descriptions[]")) {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if (!argcmp(str, "IpRanges")) {
            	 TRY(!aa, "IpRanges argument missing\n");
               s->ip_ranges_str = aa;
         } else if (!strcmp(str, "IpRanges[]")) {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersApiAccessRule'\n", str);
	}
	return 0;
}

int filters_api_log_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_api_log *s = v_s;
	if (!argcmp(str, "QueryAccessKeys")) {
            	 TRY(!aa, "QueryAccessKeys argument missing\n");
               s->query_access_keys_str = aa;
         } else if (!strcmp(str, "QueryAccessKeys[]")) {
               TRY(!aa, "QueryAccessKeys[] argument missing\n");
               SET_NEXT(s->query_access_keys, (aa), pa);
         } else
	if (!argcmp(str, "QueryApiNames")) {
            	 TRY(!aa, "QueryApiNames argument missing\n");
               s->query_api_names_str = aa;
         } else if (!strcmp(str, "QueryApiNames[]")) {
               TRY(!aa, "QueryApiNames[] argument missing\n");
               SET_NEXT(s->query_api_names, (aa), pa);
         } else
	if (!argcmp(str, "QueryCallNames")) {
            	 TRY(!aa, "QueryCallNames argument missing\n");
               s->query_call_names_str = aa;
         } else if (!strcmp(str, "QueryCallNames[]")) {
               TRY(!aa, "QueryCallNames[] argument missing\n");
               SET_NEXT(s->query_call_names, (aa), pa);
         } else
	if (!argcmp(str, "QueryDateAfter")) {
            TRY(!aa, "QueryDateAfter argument missing\n");
            s->query_date_after = aa; // string string

         } else
	if (!argcmp(str, "QueryDateBefore")) {
            TRY(!aa, "QueryDateBefore argument missing\n");
            s->query_date_before = aa; // string string

         } else
	if (!argcmp(str, "QueryIpAddresses")) {
            	 TRY(!aa, "QueryIpAddresses argument missing\n");
               s->query_ip_addresses_str = aa;
         } else if (!strcmp(str, "QueryIpAddresses[]")) {
               TRY(!aa, "QueryIpAddresses[] argument missing\n");
               SET_NEXT(s->query_ip_addresses, (aa), pa);
         } else
	if (!argcmp(str, "QueryUserAgents")) {
            	 TRY(!aa, "QueryUserAgents argument missing\n");
               s->query_user_agents_str = aa;
         } else if (!strcmp(str, "QueryUserAgents[]")) {
               TRY(!aa, "QueryUserAgents[] argument missing\n");
               SET_NEXT(s->query_user_agents, (aa), pa);
         } else
	if (!argcmp(str, "RequestIds")) {
            	 TRY(!aa, "RequestIds argument missing\n");
               s->request_ids_str = aa;
         } else if (!strcmp(str, "RequestIds[]")) {
               TRY(!aa, "RequestIds[] argument missing\n");
               SET_NEXT(s->request_ids, (aa), pa);
         } else
	if (!argcmp(str, "ResponseStatusCodes")) {
            	 TRY(!aa, "ResponseStatusCodes argument missing\n");
               s->response_status_codes_str = aa;
         } else if (!strcmp(str, "ResponseStatusCodes[]")) {
               TRY(!aa, "ResponseStatusCodes[] argument missing\n");
               SET_NEXT(s->response_status_codes, atoi(aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersApiLog'\n", str);
	}
	return 0;
}

int filters_ca_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_ca *s = v_s;
	if (!argcmp(str, "CaFingerprints")) {
            	 TRY(!aa, "CaFingerprints argument missing\n");
               s->ca_fingerprints_str = aa;
         } else if (!strcmp(str, "CaFingerprints[]")) {
               TRY(!aa, "CaFingerprints[] argument missing\n");
               SET_NEXT(s->ca_fingerprints, (aa), pa);
         } else
	if (!argcmp(str, "CaIds")) {
            	 TRY(!aa, "CaIds argument missing\n");
               s->ca_ids_str = aa;
         } else if (!strcmp(str, "CaIds[]")) {
               TRY(!aa, "CaIds[] argument missing\n");
               SET_NEXT(s->ca_ids, (aa), pa);
         } else
	if (!argcmp(str, "Descriptions")) {
            	 TRY(!aa, "Descriptions argument missing\n");
               s->descriptions_str = aa;
         } else if (!strcmp(str, "Descriptions[]")) {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersCa'\n", str);
	}
	return 0;
}

int filters_client_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_client_gateway *s = v_s;
	if (!argcmp(str, "BgpAsns")) {
            	 TRY(!aa, "BgpAsns argument missing\n");
               s->bgp_asns_str = aa;
         } else if (!strcmp(str, "BgpAsns[]")) {
               TRY(!aa, "BgpAsns[] argument missing\n");
               SET_NEXT(s->bgp_asns, atoi(aa), pa);
         } else
	if (!argcmp(str, "ClientGatewayIds")) {
            	 TRY(!aa, "ClientGatewayIds argument missing\n");
               s->client_gateway_ids_str = aa;
         } else if (!strcmp(str, "ClientGatewayIds[]")) {
               TRY(!aa, "ClientGatewayIds[] argument missing\n");
               SET_NEXT(s->client_gateway_ids, (aa), pa);
         } else
	if (!argcmp(str, "ConnectionTypes")) {
            	 TRY(!aa, "ConnectionTypes argument missing\n");
               s->connection_types_str = aa;
         } else if (!strcmp(str, "ConnectionTypes[]")) {
               TRY(!aa, "ConnectionTypes[] argument missing\n");
               SET_NEXT(s->connection_types, (aa), pa);
         } else
	if (!argcmp(str, "PublicIps")) {
            	 TRY(!aa, "PublicIps argument missing\n");
               s->public_ips_str = aa;
         } else if (!strcmp(str, "PublicIps[]")) {
               TRY(!aa, "PublicIps[] argument missing\n");
               SET_NEXT(s->public_ips, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersClientGateway'\n", str);
	}
	return 0;
}

int filters_dhcp_options_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_dhcp_options *s = v_s;
	if (!argcmp(str, "Default")) {
            s->is_set_default_arg = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->default_arg = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->default_arg = 0;
             } else {
            		fprintf(stderr, "Default require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "DhcpOptionsSetIds")) {
            	 TRY(!aa, "DhcpOptionsSetIds argument missing\n");
               s->dhcp_options_set_ids_str = aa;
         } else if (!strcmp(str, "DhcpOptionsSetIds[]")) {
               TRY(!aa, "DhcpOptionsSetIds[] argument missing\n");
               SET_NEXT(s->dhcp_options_set_ids, (aa), pa);
         } else
	if (!argcmp(str, "DomainNameServers")) {
            	 TRY(!aa, "DomainNameServers argument missing\n");
               s->domain_name_servers_str = aa;
         } else if (!strcmp(str, "DomainNameServers[]")) {
               TRY(!aa, "DomainNameServers[] argument missing\n");
               SET_NEXT(s->domain_name_servers, (aa), pa);
         } else
	if (!argcmp(str, "DomainNames")) {
            	 TRY(!aa, "DomainNames argument missing\n");
               s->domain_names_str = aa;
         } else if (!strcmp(str, "DomainNames[]")) {
               TRY(!aa, "DomainNames[] argument missing\n");
               SET_NEXT(s->domain_names, (aa), pa);
         } else
	if (!argcmp(str, "LogServers")) {
            	 TRY(!aa, "LogServers argument missing\n");
               s->log_servers_str = aa;
         } else if (!strcmp(str, "LogServers[]")) {
               TRY(!aa, "LogServers[] argument missing\n");
               SET_NEXT(s->log_servers, (aa), pa);
         } else
	if (!argcmp(str, "NtpServers")) {
            	 TRY(!aa, "NtpServers argument missing\n");
               s->ntp_servers_str = aa;
         } else if (!strcmp(str, "NtpServers[]")) {
               TRY(!aa, "NtpServers[] argument missing\n");
               SET_NEXT(s->ntp_servers, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersDhcpOptions'\n", str);
	}
	return 0;
}

int filters_direct_link_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_direct_link *s = v_s;
	if (!argcmp(str, "DirectLinkIds")) {
            	 TRY(!aa, "DirectLinkIds argument missing\n");
               s->direct_link_ids_str = aa;
         } else if (!strcmp(str, "DirectLinkIds[]")) {
               TRY(!aa, "DirectLinkIds[] argument missing\n");
               SET_NEXT(s->direct_link_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersDirectLink'\n", str);
	}
	return 0;
}

int filters_direct_link_interface_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_direct_link_interface *s = v_s;
	if (!argcmp(str, "DirectLinkIds")) {
            	 TRY(!aa, "DirectLinkIds argument missing\n");
               s->direct_link_ids_str = aa;
         } else if (!strcmp(str, "DirectLinkIds[]")) {
               TRY(!aa, "DirectLinkIds[] argument missing\n");
               SET_NEXT(s->direct_link_ids, (aa), pa);
         } else
	if (!argcmp(str, "DirectLinkInterfaceIds")) {
            	 TRY(!aa, "DirectLinkInterfaceIds argument missing\n");
               s->direct_link_interface_ids_str = aa;
         } else if (!strcmp(str, "DirectLinkInterfaceIds[]")) {
               TRY(!aa, "DirectLinkInterfaceIds[] argument missing\n");
               SET_NEXT(s->direct_link_interface_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersDirectLinkInterface'\n", str);
	}
	return 0;
}

int filters_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_export_task *s = v_s;
	if (!argcmp(str, "TaskIds")) {
            	 TRY(!aa, "TaskIds argument missing\n");
               s->task_ids_str = aa;
         } else if (!strcmp(str, "TaskIds[]")) {
               TRY(!aa, "TaskIds[] argument missing\n");
               SET_NEXT(s->task_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersExportTask'\n", str);
	}
	return 0;
}

int filters_flexible_gpu_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_flexible_gpu *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "FlexibleGpuIds")) {
            	 TRY(!aa, "FlexibleGpuIds argument missing\n");
               s->flexible_gpu_ids_str = aa;
         } else if (!strcmp(str, "FlexibleGpuIds[]")) {
               TRY(!aa, "FlexibleGpuIds[] argument missing\n");
               SET_NEXT(s->flexible_gpu_ids, (aa), pa);
         } else
	if (!argcmp(str, "Generations")) {
            	 TRY(!aa, "Generations argument missing\n");
               s->generations_str = aa;
         } else if (!strcmp(str, "Generations[]")) {
               TRY(!aa, "Generations[] argument missing\n");
               SET_NEXT(s->generations, (aa), pa);
         } else
	if (!argcmp(str, "ModelNames")) {
            	 TRY(!aa, "ModelNames argument missing\n");
               s->model_names_str = aa;
         } else if (!strcmp(str, "ModelNames[]")) {
               TRY(!aa, "ModelNames[] argument missing\n");
               SET_NEXT(s->model_names, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "SubregionNames")) {
            	 TRY(!aa, "SubregionNames argument missing\n");
               s->subregion_names_str = aa;
         } else if (!strcmp(str, "SubregionNames[]")) {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if (!argcmp(str, "VmIds")) {
            	 TRY(!aa, "VmIds argument missing\n");
               s->vm_ids_str = aa;
         } else if (!strcmp(str, "VmIds[]")) {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersFlexibleGpu'\n", str);
	}
	return 0;
}

int filters_image_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_image *s = v_s;
	if (!argcmp(str, "AccountAliases")) {
            	 TRY(!aa, "AccountAliases argument missing\n");
               s->account_aliases_str = aa;
         } else if (!strcmp(str, "AccountAliases[]")) {
               TRY(!aa, "AccountAliases[] argument missing\n");
               SET_NEXT(s->account_aliases, (aa), pa);
         } else
	if (!argcmp(str, "AccountIds")) {
            	 TRY(!aa, "AccountIds argument missing\n");
               s->account_ids_str = aa;
         } else if (!strcmp(str, "AccountIds[]")) {
               TRY(!aa, "AccountIds[] argument missing\n");
               SET_NEXT(s->account_ids, (aa), pa);
         } else
	if (!argcmp(str, "Architectures")) {
            	 TRY(!aa, "Architectures argument missing\n");
               s->architectures_str = aa;
         } else if (!strcmp(str, "Architectures[]")) {
               TRY(!aa, "Architectures[] argument missing\n");
               SET_NEXT(s->architectures, (aa), pa);
         } else
	if (!argcmp(str, "BlockDeviceMappingDeleteOnVmDeletion")) {
            s->is_set_block_device_mapping_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->block_device_mapping_delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->block_device_mapping_delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "BlockDeviceMappingDeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "BlockDeviceMappingDeviceNames")) {
            	 TRY(!aa, "BlockDeviceMappingDeviceNames argument missing\n");
               s->block_device_mapping_device_names_str = aa;
         } else if (!strcmp(str, "BlockDeviceMappingDeviceNames[]")) {
               TRY(!aa, "BlockDeviceMappingDeviceNames[] argument missing\n");
               SET_NEXT(s->block_device_mapping_device_names, (aa), pa);
         } else
	if (!argcmp(str, "BlockDeviceMappingSnapshotIds")) {
            	 TRY(!aa, "BlockDeviceMappingSnapshotIds argument missing\n");
               s->block_device_mapping_snapshot_ids_str = aa;
         } else if (!strcmp(str, "BlockDeviceMappingSnapshotIds[]")) {
               TRY(!aa, "BlockDeviceMappingSnapshotIds[] argument missing\n");
               SET_NEXT(s->block_device_mapping_snapshot_ids, (aa), pa);
         } else
	if (!argcmp(str, "BlockDeviceMappingVolumeSizes")) {
            	 TRY(!aa, "BlockDeviceMappingVolumeSizes argument missing\n");
               s->block_device_mapping_volume_sizes_str = aa;
         } else if (!strcmp(str, "BlockDeviceMappingVolumeSizes[]")) {
               TRY(!aa, "BlockDeviceMappingVolumeSizes[] argument missing\n");
               SET_NEXT(s->block_device_mapping_volume_sizes, atoi(aa), pa);
         } else
	if (!argcmp(str, "BlockDeviceMappingVolumeTypes")) {
            	 TRY(!aa, "BlockDeviceMappingVolumeTypes argument missing\n");
               s->block_device_mapping_volume_types_str = aa;
         } else if (!strcmp(str, "BlockDeviceMappingVolumeTypes[]")) {
               TRY(!aa, "BlockDeviceMappingVolumeTypes[] argument missing\n");
               SET_NEXT(s->block_device_mapping_volume_types, (aa), pa);
         } else
	if (!argcmp(str, "Descriptions")) {
            	 TRY(!aa, "Descriptions argument missing\n");
               s->descriptions_str = aa;
         } else if (!strcmp(str, "Descriptions[]")) {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if (!argcmp(str, "FileLocations")) {
            	 TRY(!aa, "FileLocations argument missing\n");
               s->file_locations_str = aa;
         } else if (!strcmp(str, "FileLocations[]")) {
               TRY(!aa, "FileLocations[] argument missing\n");
               SET_NEXT(s->file_locations, (aa), pa);
         } else
	if (!argcmp(str, "Hypervisors")) {
            	 TRY(!aa, "Hypervisors argument missing\n");
               s->hypervisors_str = aa;
         } else if (!strcmp(str, "Hypervisors[]")) {
               TRY(!aa, "Hypervisors[] argument missing\n");
               SET_NEXT(s->hypervisors, (aa), pa);
         } else
	if (!argcmp(str, "ImageIds")) {
            	 TRY(!aa, "ImageIds argument missing\n");
               s->image_ids_str = aa;
         } else if (!strcmp(str, "ImageIds[]")) {
               TRY(!aa, "ImageIds[] argument missing\n");
               SET_NEXT(s->image_ids, (aa), pa);
         } else
	if (!argcmp(str, "ImageNames")) {
            	 TRY(!aa, "ImageNames argument missing\n");
               s->image_names_str = aa;
         } else if (!strcmp(str, "ImageNames[]")) {
               TRY(!aa, "ImageNames[] argument missing\n");
               SET_NEXT(s->image_names, (aa), pa);
         } else
	if (!argcmp(str, "PermissionsToLaunchAccountIds")) {
            	 TRY(!aa, "PermissionsToLaunchAccountIds argument missing\n");
               s->permissions_to_launch_account_ids_str = aa;
         } else if (!strcmp(str, "PermissionsToLaunchAccountIds[]")) {
               TRY(!aa, "PermissionsToLaunchAccountIds[] argument missing\n");
               SET_NEXT(s->permissions_to_launch_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "PermissionsToLaunchGlobalPermission")) {
            s->is_set_permissions_to_launch_global_permission = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->permissions_to_launch_global_permission = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->permissions_to_launch_global_permission = 0;
             } else {
            		fprintf(stderr, "PermissionsToLaunchGlobalPermission require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "ProductCodes")) {
            	 TRY(!aa, "ProductCodes argument missing\n");
               s->product_codes_str = aa;
         } else if (!strcmp(str, "ProductCodes[]")) {
               TRY(!aa, "ProductCodes[] argument missing\n");
               SET_NEXT(s->product_codes, (aa), pa);
         } else
	if (!argcmp(str, "RootDeviceNames")) {
            	 TRY(!aa, "RootDeviceNames argument missing\n");
               s->root_device_names_str = aa;
         } else if (!strcmp(str, "RootDeviceNames[]")) {
               TRY(!aa, "RootDeviceNames[] argument missing\n");
               SET_NEXT(s->root_device_names, (aa), pa);
         } else
	if (!argcmp(str, "RootDeviceTypes")) {
            	 TRY(!aa, "RootDeviceTypes argument missing\n");
               s->root_device_types_str = aa;
         } else if (!strcmp(str, "RootDeviceTypes[]")) {
               TRY(!aa, "RootDeviceTypes[] argument missing\n");
               SET_NEXT(s->root_device_types, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if (!argcmp(str, "VirtualizationTypes")) {
            	 TRY(!aa, "VirtualizationTypes argument missing\n");
               s->virtualization_types_str = aa;
         } else if (!strcmp(str, "VirtualizationTypes[]")) {
               TRY(!aa, "VirtualizationTypes[] argument missing\n");
               SET_NEXT(s->virtualization_types, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersImage'\n", str);
	}
	return 0;
}

int filters_internet_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_internet_service *s = v_s;
	if (!argcmp(str, "InternetServiceIds")) {
            	 TRY(!aa, "InternetServiceIds argument missing\n");
               s->internet_service_ids_str = aa;
         } else if (!strcmp(str, "InternetServiceIds[]")) {
               TRY(!aa, "InternetServiceIds[] argument missing\n");
               SET_NEXT(s->internet_service_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkNetIds")) {
            	 TRY(!aa, "LinkNetIds argument missing\n");
               s->link_net_ids_str = aa;
         } else if (!strcmp(str, "LinkNetIds[]")) {
               TRY(!aa, "LinkNetIds[] argument missing\n");
               SET_NEXT(s->link_net_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkStates")) {
            	 TRY(!aa, "LinkStates argument missing\n");
               s->link_states_str = aa;
         } else if (!strcmp(str, "LinkStates[]")) {
               TRY(!aa, "LinkStates[] argument missing\n");
               SET_NEXT(s->link_states, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersInternetService'\n", str);
	}
	return 0;
}

int filters_keypair_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_keypair *s = v_s;
	if (!argcmp(str, "KeypairFingerprints")) {
            	 TRY(!aa, "KeypairFingerprints argument missing\n");
               s->keypair_fingerprints_str = aa;
         } else if (!strcmp(str, "KeypairFingerprints[]")) {
               TRY(!aa, "KeypairFingerprints[] argument missing\n");
               SET_NEXT(s->keypair_fingerprints, (aa), pa);
         } else
	if (!argcmp(str, "KeypairNames")) {
            	 TRY(!aa, "KeypairNames argument missing\n");
               s->keypair_names_str = aa;
         } else if (!strcmp(str, "KeypairNames[]")) {
               TRY(!aa, "KeypairNames[] argument missing\n");
               SET_NEXT(s->keypair_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersKeypair'\n", str);
	}
	return 0;
}

int filters_listener_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_listener_rule *s = v_s;
	if (!argcmp(str, "ListenerRuleNames")) {
            	 TRY(!aa, "ListenerRuleNames argument missing\n");
               s->listener_rule_names_str = aa;
         } else if (!strcmp(str, "ListenerRuleNames[]")) {
               TRY(!aa, "ListenerRuleNames[] argument missing\n");
               SET_NEXT(s->listener_rule_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersListenerRule'\n", str);
	}
	return 0;
}

int filters_load_balancer_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_load_balancer *s = v_s;
	if (!argcmp(str, "LoadBalancerNames")) {
            	 TRY(!aa, "LoadBalancerNames argument missing\n");
               s->load_balancer_names_str = aa;
         } else if (!strcmp(str, "LoadBalancerNames[]")) {
               TRY(!aa, "LoadBalancerNames[] argument missing\n");
               SET_NEXT(s->load_balancer_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersLoadBalancer'\n", str);
	}
	return 0;
}

int filters_nat_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_nat_service *s = v_s;
	if (!argcmp(str, "NatServiceIds")) {
            	 TRY(!aa, "NatServiceIds argument missing\n");
               s->nat_service_ids_str = aa;
         } else if (!strcmp(str, "NatServiceIds[]")) {
               TRY(!aa, "NatServiceIds[] argument missing\n");
               SET_NEXT(s->nat_service_ids, (aa), pa);
         } else
	if (!argcmp(str, "NetIds")) {
            	 TRY(!aa, "NetIds argument missing\n");
               s->net_ids_str = aa;
         } else if (!strcmp(str, "NetIds[]")) {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "SubnetIds")) {
            	 TRY(!aa, "SubnetIds argument missing\n");
               s->subnet_ids_str = aa;
         } else if (!strcmp(str, "SubnetIds[]")) {
               TRY(!aa, "SubnetIds[] argument missing\n");
               SET_NEXT(s->subnet_ids, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNatService'\n", str);
	}
	return 0;
}

int filters_net_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_net *s = v_s;
	if (!argcmp(str, "DhcpOptionsSetIds")) {
            	 TRY(!aa, "DhcpOptionsSetIds argument missing\n");
               s->dhcp_options_set_ids_str = aa;
         } else if (!strcmp(str, "DhcpOptionsSetIds[]")) {
               TRY(!aa, "DhcpOptionsSetIds[] argument missing\n");
               SET_NEXT(s->dhcp_options_set_ids, (aa), pa);
         } else
	if (!argcmp(str, "IpRanges")) {
            	 TRY(!aa, "IpRanges argument missing\n");
               s->ip_ranges_str = aa;
         } else if (!strcmp(str, "IpRanges[]")) {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "IsDefault")) {
            s->is_set_is_default_arg = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_default_arg = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_default_arg = 0;
             } else {
            		fprintf(stderr, "IsDefault require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "NetIds")) {
            	 TRY(!aa, "NetIds argument missing\n");
               s->net_ids_str = aa;
         } else if (!strcmp(str, "NetIds[]")) {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNet'\n", str);
	}
	return 0;
}

int filters_net_access_point_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_net_access_point *s = v_s;
	if (!argcmp(str, "NetAccessPointIds")) {
            	 TRY(!aa, "NetAccessPointIds argument missing\n");
               s->net_access_point_ids_str = aa;
         } else if (!strcmp(str, "NetAccessPointIds[]")) {
               TRY(!aa, "NetAccessPointIds[] argument missing\n");
               SET_NEXT(s->net_access_point_ids, (aa), pa);
         } else
	if (!argcmp(str, "NetIds")) {
            	 TRY(!aa, "NetIds argument missing\n");
               s->net_ids_str = aa;
         } else if (!strcmp(str, "NetIds[]")) {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if (!argcmp(str, "ServiceNames")) {
            	 TRY(!aa, "ServiceNames argument missing\n");
               s->service_names_str = aa;
         } else if (!strcmp(str, "ServiceNames[]")) {
               TRY(!aa, "ServiceNames[] argument missing\n");
               SET_NEXT(s->service_names, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNetAccessPoint'\n", str);
	}
	return 0;
}

int filters_net_peering_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_net_peering *s = v_s;
	if (!argcmp(str, "AccepterNetAccountIds")) {
            	 TRY(!aa, "AccepterNetAccountIds argument missing\n");
               s->accepter_net_account_ids_str = aa;
         } else if (!strcmp(str, "AccepterNetAccountIds[]")) {
               TRY(!aa, "AccepterNetAccountIds[] argument missing\n");
               SET_NEXT(s->accepter_net_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "AccepterNetIpRanges")) {
            	 TRY(!aa, "AccepterNetIpRanges argument missing\n");
               s->accepter_net_ip_ranges_str = aa;
         } else if (!strcmp(str, "AccepterNetIpRanges[]")) {
               TRY(!aa, "AccepterNetIpRanges[] argument missing\n");
               SET_NEXT(s->accepter_net_ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "AccepterNetNetIds")) {
            	 TRY(!aa, "AccepterNetNetIds argument missing\n");
               s->accepter_net_net_ids_str = aa;
         } else if (!strcmp(str, "AccepterNetNetIds[]")) {
               TRY(!aa, "AccepterNetNetIds[] argument missing\n");
               SET_NEXT(s->accepter_net_net_ids, (aa), pa);
         } else
	if (!argcmp(str, "NetPeeringIds")) {
            	 TRY(!aa, "NetPeeringIds argument missing\n");
               s->net_peering_ids_str = aa;
         } else if (!strcmp(str, "NetPeeringIds[]")) {
               TRY(!aa, "NetPeeringIds[] argument missing\n");
               SET_NEXT(s->net_peering_ids, (aa), pa);
         } else
	if (!argcmp(str, "SourceNetAccountIds")) {
            	 TRY(!aa, "SourceNetAccountIds argument missing\n");
               s->source_net_account_ids_str = aa;
         } else if (!strcmp(str, "SourceNetAccountIds[]")) {
               TRY(!aa, "SourceNetAccountIds[] argument missing\n");
               SET_NEXT(s->source_net_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "SourceNetIpRanges")) {
            	 TRY(!aa, "SourceNetIpRanges argument missing\n");
               s->source_net_ip_ranges_str = aa;
         } else if (!strcmp(str, "SourceNetIpRanges[]")) {
               TRY(!aa, "SourceNetIpRanges[] argument missing\n");
               SET_NEXT(s->source_net_ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "SourceNetNetIds")) {
            	 TRY(!aa, "SourceNetNetIds argument missing\n");
               s->source_net_net_ids_str = aa;
         } else if (!strcmp(str, "SourceNetNetIds[]")) {
               TRY(!aa, "SourceNetNetIds[] argument missing\n");
               SET_NEXT(s->source_net_net_ids, (aa), pa);
         } else
	if (!argcmp(str, "StateMessages")) {
            	 TRY(!aa, "StateMessages argument missing\n");
               s->state_messages_str = aa;
         } else if (!strcmp(str, "StateMessages[]")) {
               TRY(!aa, "StateMessages[] argument missing\n");
               SET_NEXT(s->state_messages, (aa), pa);
         } else
	if (!argcmp(str, "StateNames")) {
            	 TRY(!aa, "StateNames argument missing\n");
               s->state_names_str = aa;
         } else if (!strcmp(str, "StateNames[]")) {
               TRY(!aa, "StateNames[] argument missing\n");
               SET_NEXT(s->state_names, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNetPeering'\n", str);
	}
	return 0;
}

int filters_nic_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_nic *s = v_s;
	if (!argcmp(str, "Descriptions")) {
            	 TRY(!aa, "Descriptions argument missing\n");
               s->descriptions_str = aa;
         } else if (!strcmp(str, "Descriptions[]")) {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if (!argcmp(str, "IsSourceDestCheck")) {
            s->is_set_is_source_dest_check = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_check = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_check = 0;
             } else {
            		fprintf(stderr, "IsSourceDestCheck require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkNicDeleteOnVmDeletion")) {
            s->is_set_link_nic_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->link_nic_delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->link_nic_delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "LinkNicDeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkNicDeviceNumbers")) {
            	 TRY(!aa, "LinkNicDeviceNumbers argument missing\n");
               s->link_nic_device_numbers_str = aa;
         } else if (!strcmp(str, "LinkNicDeviceNumbers[]")) {
               TRY(!aa, "LinkNicDeviceNumbers[] argument missing\n");
               SET_NEXT(s->link_nic_device_numbers, atoi(aa), pa);
         } else
	if (!argcmp(str, "LinkNicLinkNicIds")) {
            	 TRY(!aa, "LinkNicLinkNicIds argument missing\n");
               s->link_nic_link_nic_ids_str = aa;
         } else if (!strcmp(str, "LinkNicLinkNicIds[]")) {
               TRY(!aa, "LinkNicLinkNicIds[] argument missing\n");
               SET_NEXT(s->link_nic_link_nic_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkNicStates")) {
            	 TRY(!aa, "LinkNicStates argument missing\n");
               s->link_nic_states_str = aa;
         } else if (!strcmp(str, "LinkNicStates[]")) {
               TRY(!aa, "LinkNicStates[] argument missing\n");
               SET_NEXT(s->link_nic_states, (aa), pa);
         } else
	if (!argcmp(str, "LinkNicVmAccountIds")) {
            	 TRY(!aa, "LinkNicVmAccountIds argument missing\n");
               s->link_nic_vm_account_ids_str = aa;
         } else if (!strcmp(str, "LinkNicVmAccountIds[]")) {
               TRY(!aa, "LinkNicVmAccountIds[] argument missing\n");
               SET_NEXT(s->link_nic_vm_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkNicVmIds")) {
            	 TRY(!aa, "LinkNicVmIds argument missing\n");
               s->link_nic_vm_ids_str = aa;
         } else if (!strcmp(str, "LinkNicVmIds[]")) {
               TRY(!aa, "LinkNicVmIds[] argument missing\n");
               SET_NEXT(s->link_nic_vm_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkPublicIpAccountIds")) {
            	 TRY(!aa, "LinkPublicIpAccountIds argument missing\n");
               s->link_public_ip_account_ids_str = aa;
         } else if (!strcmp(str, "LinkPublicIpAccountIds[]")) {
               TRY(!aa, "LinkPublicIpAccountIds[] argument missing\n");
               SET_NEXT(s->link_public_ip_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkPublicIpLinkPublicIpIds")) {
            	 TRY(!aa, "LinkPublicIpLinkPublicIpIds argument missing\n");
               s->link_public_ip_link_public_ip_ids_str = aa;
         } else if (!strcmp(str, "LinkPublicIpLinkPublicIpIds[]")) {
               TRY(!aa, "LinkPublicIpLinkPublicIpIds[] argument missing\n");
               SET_NEXT(s->link_public_ip_link_public_ip_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkPublicIpPublicIpIds")) {
            	 TRY(!aa, "LinkPublicIpPublicIpIds argument missing\n");
               s->link_public_ip_public_ip_ids_str = aa;
         } else if (!strcmp(str, "LinkPublicIpPublicIpIds[]")) {
               TRY(!aa, "LinkPublicIpPublicIpIds[] argument missing\n");
               SET_NEXT(s->link_public_ip_public_ip_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkPublicIpPublicIps")) {
            	 TRY(!aa, "LinkPublicIpPublicIps argument missing\n");
               s->link_public_ip_public_ips_str = aa;
         } else if (!strcmp(str, "LinkPublicIpPublicIps[]")) {
               TRY(!aa, "LinkPublicIpPublicIps[] argument missing\n");
               SET_NEXT(s->link_public_ip_public_ips, (aa), pa);
         } else
	if (!argcmp(str, "MacAddresses")) {
            	 TRY(!aa, "MacAddresses argument missing\n");
               s->mac_addresses_str = aa;
         } else if (!strcmp(str, "MacAddresses[]")) {
               TRY(!aa, "MacAddresses[] argument missing\n");
               SET_NEXT(s->mac_addresses, (aa), pa);
         } else
	if (!argcmp(str, "NetIds")) {
            	 TRY(!aa, "NetIds argument missing\n");
               s->net_ids_str = aa;
         } else if (!strcmp(str, "NetIds[]")) {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if (!argcmp(str, "NicIds")) {
            	 TRY(!aa, "NicIds argument missing\n");
               s->nic_ids_str = aa;
         } else if (!strcmp(str, "NicIds[]")) {
               TRY(!aa, "NicIds[] argument missing\n");
               SET_NEXT(s->nic_ids, (aa), pa);
         } else
	if (!argcmp(str, "PrivateDnsNames")) {
            	 TRY(!aa, "PrivateDnsNames argument missing\n");
               s->private_dns_names_str = aa;
         } else if (!strcmp(str, "PrivateDnsNames[]")) {
               TRY(!aa, "PrivateDnsNames[] argument missing\n");
               SET_NEXT(s->private_dns_names, (aa), pa);
         } else
	if (!argcmp(str, "PrivateIpsLinkPublicIpAccountIds")) {
            	 TRY(!aa, "PrivateIpsLinkPublicIpAccountIds argument missing\n");
               s->private_ips_link_public_ip_account_ids_str = aa;
         } else if (!strcmp(str, "PrivateIpsLinkPublicIpAccountIds[]")) {
               TRY(!aa, "PrivateIpsLinkPublicIpAccountIds[] argument missing\n");
               SET_NEXT(s->private_ips_link_public_ip_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "PrivateIpsLinkPublicIpPublicIps")) {
            	 TRY(!aa, "PrivateIpsLinkPublicIpPublicIps argument missing\n");
               s->private_ips_link_public_ip_public_ips_str = aa;
         } else if (!strcmp(str, "PrivateIpsLinkPublicIpPublicIps[]")) {
               TRY(!aa, "PrivateIpsLinkPublicIpPublicIps[] argument missing\n");
               SET_NEXT(s->private_ips_link_public_ip_public_ips, (aa), pa);
         } else
	if (!argcmp(str, "PrivateIpsPrimaryIp")) {
            s->is_set_private_ips_primary_ip = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->private_ips_primary_ip = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->private_ips_primary_ip = 0;
             } else {
            		fprintf(stderr, "PrivateIpsPrimaryIp require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "PrivateIpsPrivateIps")) {
            	 TRY(!aa, "PrivateIpsPrivateIps argument missing\n");
               s->private_ips_private_ips_str = aa;
         } else if (!strcmp(str, "PrivateIpsPrivateIps[]")) {
               TRY(!aa, "PrivateIpsPrivateIps[] argument missing\n");
               SET_NEXT(s->private_ips_private_ips, (aa), pa);
         } else
	if (!argcmp(str, "SecurityGroupIds")) {
            	 TRY(!aa, "SecurityGroupIds argument missing\n");
               s->security_group_ids_str = aa;
         } else if (!strcmp(str, "SecurityGroupIds[]")) {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if (!argcmp(str, "SecurityGroupNames")) {
            	 TRY(!aa, "SecurityGroupNames argument missing\n");
               s->security_group_names_str = aa;
         } else if (!strcmp(str, "SecurityGroupNames[]")) {
               TRY(!aa, "SecurityGroupNames[] argument missing\n");
               SET_NEXT(s->security_group_names, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "SubnetIds")) {
            	 TRY(!aa, "SubnetIds argument missing\n");
               s->subnet_ids_str = aa;
         } else if (!strcmp(str, "SubnetIds[]")) {
               TRY(!aa, "SubnetIds[] argument missing\n");
               SET_NEXT(s->subnet_ids, (aa), pa);
         } else
	if (!argcmp(str, "SubregionNames")) {
            	 TRY(!aa, "SubregionNames argument missing\n");
               s->subregion_names_str = aa;
         } else if (!strcmp(str, "SubregionNames[]")) {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNic'\n", str);
	}
	return 0;
}

int filters_product_type_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_product_type *s = v_s;
	if (!argcmp(str, "ProductTypeIds")) {
            	 TRY(!aa, "ProductTypeIds argument missing\n");
               s->product_type_ids_str = aa;
         } else if (!strcmp(str, "ProductTypeIds[]")) {
               TRY(!aa, "ProductTypeIds[] argument missing\n");
               SET_NEXT(s->product_type_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersProductType'\n", str);
	}
	return 0;
}

int filters_public_ip_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_public_ip *s = v_s;
	if (!argcmp(str, "LinkPublicIpIds")) {
            	 TRY(!aa, "LinkPublicIpIds argument missing\n");
               s->link_public_ip_ids_str = aa;
         } else if (!strcmp(str, "LinkPublicIpIds[]")) {
               TRY(!aa, "LinkPublicIpIds[] argument missing\n");
               SET_NEXT(s->link_public_ip_ids, (aa), pa);
         } else
	if (!argcmp(str, "NicAccountIds")) {
            	 TRY(!aa, "NicAccountIds argument missing\n");
               s->nic_account_ids_str = aa;
         } else if (!strcmp(str, "NicAccountIds[]")) {
               TRY(!aa, "NicAccountIds[] argument missing\n");
               SET_NEXT(s->nic_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "NicIds")) {
            	 TRY(!aa, "NicIds argument missing\n");
               s->nic_ids_str = aa;
         } else if (!strcmp(str, "NicIds[]")) {
               TRY(!aa, "NicIds[] argument missing\n");
               SET_NEXT(s->nic_ids, (aa), pa);
         } else
	if (!argcmp(str, "Placements")) {
            	 TRY(!aa, "Placements argument missing\n");
               s->placements_str = aa;
         } else if (!strcmp(str, "Placements[]")) {
               TRY(!aa, "Placements[] argument missing\n");
               SET_NEXT(s->placements, (aa), pa);
         } else
	if (!argcmp(str, "PrivateIps")) {
            	 TRY(!aa, "PrivateIps argument missing\n");
               s->private_ips_str = aa;
         } else if (!strcmp(str, "PrivateIps[]")) {
               TRY(!aa, "PrivateIps[] argument missing\n");
               SET_NEXT(s->private_ips, (aa), pa);
         } else
	if (!argcmp(str, "PublicIpIds")) {
            	 TRY(!aa, "PublicIpIds argument missing\n");
               s->public_ip_ids_str = aa;
         } else if (!strcmp(str, "PublicIpIds[]")) {
               TRY(!aa, "PublicIpIds[] argument missing\n");
               SET_NEXT(s->public_ip_ids, (aa), pa);
         } else
	if (!argcmp(str, "PublicIps")) {
            	 TRY(!aa, "PublicIps argument missing\n");
               s->public_ips_str = aa;
         } else if (!strcmp(str, "PublicIps[]")) {
               TRY(!aa, "PublicIps[] argument missing\n");
               SET_NEXT(s->public_ips, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if (!argcmp(str, "VmIds")) {
            	 TRY(!aa, "VmIds argument missing\n");
               s->vm_ids_str = aa;
         } else if (!strcmp(str, "VmIds[]")) {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersPublicIp'\n", str);
	}
	return 0;
}

int filters_quota_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_quota *s = v_s;
	if (!argcmp(str, "Collections")) {
            	 TRY(!aa, "Collections argument missing\n");
               s->collections_str = aa;
         } else if (!strcmp(str, "Collections[]")) {
               TRY(!aa, "Collections[] argument missing\n");
               SET_NEXT(s->collections, (aa), pa);
         } else
	if (!argcmp(str, "QuotaNames")) {
            	 TRY(!aa, "QuotaNames argument missing\n");
               s->quota_names_str = aa;
         } else if (!strcmp(str, "QuotaNames[]")) {
               TRY(!aa, "QuotaNames[] argument missing\n");
               SET_NEXT(s->quota_names, (aa), pa);
         } else
	if (!argcmp(str, "QuotaTypes")) {
            	 TRY(!aa, "QuotaTypes argument missing\n");
               s->quota_types_str = aa;
         } else if (!strcmp(str, "QuotaTypes[]")) {
               TRY(!aa, "QuotaTypes[] argument missing\n");
               SET_NEXT(s->quota_types, (aa), pa);
         } else
	if (!argcmp(str, "ShortDescriptions")) {
            	 TRY(!aa, "ShortDescriptions argument missing\n");
               s->short_descriptions_str = aa;
         } else if (!strcmp(str, "ShortDescriptions[]")) {
               TRY(!aa, "ShortDescriptions[] argument missing\n");
               SET_NEXT(s->short_descriptions, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersQuota'\n", str);
	}
	return 0;
}

int filters_route_table_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_route_table *s = v_s;
	if (!argcmp(str, "LinkRouteTableIds")) {
            	 TRY(!aa, "LinkRouteTableIds argument missing\n");
               s->link_route_table_ids_str = aa;
         } else if (!strcmp(str, "LinkRouteTableIds[]")) {
               TRY(!aa, "LinkRouteTableIds[] argument missing\n");
               SET_NEXT(s->link_route_table_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkRouteTableLinkRouteTableIds")) {
            	 TRY(!aa, "LinkRouteTableLinkRouteTableIds argument missing\n");
               s->link_route_table_link_route_table_ids_str = aa;
         } else if (!strcmp(str, "LinkRouteTableLinkRouteTableIds[]")) {
               TRY(!aa, "LinkRouteTableLinkRouteTableIds[] argument missing\n");
               SET_NEXT(s->link_route_table_link_route_table_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkRouteTableMain")) {
            s->is_set_link_route_table_main = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->link_route_table_main = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->link_route_table_main = 0;
             } else {
            		fprintf(stderr, "LinkRouteTableMain require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkSubnetIds")) {
            	 TRY(!aa, "LinkSubnetIds argument missing\n");
               s->link_subnet_ids_str = aa;
         } else if (!strcmp(str, "LinkSubnetIds[]")) {
               TRY(!aa, "LinkSubnetIds[] argument missing\n");
               SET_NEXT(s->link_subnet_ids, (aa), pa);
         } else
	if (!argcmp(str, "NetIds")) {
            	 TRY(!aa, "NetIds argument missing\n");
               s->net_ids_str = aa;
         } else if (!strcmp(str, "NetIds[]")) {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if (!argcmp(str, "RouteCreationMethods")) {
            	 TRY(!aa, "RouteCreationMethods argument missing\n");
               s->route_creation_methods_str = aa;
         } else if (!strcmp(str, "RouteCreationMethods[]")) {
               TRY(!aa, "RouteCreationMethods[] argument missing\n");
               SET_NEXT(s->route_creation_methods, (aa), pa);
         } else
	if (!argcmp(str, "RouteDestinationIpRanges")) {
            	 TRY(!aa, "RouteDestinationIpRanges argument missing\n");
               s->route_destination_ip_ranges_str = aa;
         } else if (!strcmp(str, "RouteDestinationIpRanges[]")) {
               TRY(!aa, "RouteDestinationIpRanges[] argument missing\n");
               SET_NEXT(s->route_destination_ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "RouteDestinationServiceIds")) {
            	 TRY(!aa, "RouteDestinationServiceIds argument missing\n");
               s->route_destination_service_ids_str = aa;
         } else if (!strcmp(str, "RouteDestinationServiceIds[]")) {
               TRY(!aa, "RouteDestinationServiceIds[] argument missing\n");
               SET_NEXT(s->route_destination_service_ids, (aa), pa);
         } else
	if (!argcmp(str, "RouteGatewayIds")) {
            	 TRY(!aa, "RouteGatewayIds argument missing\n");
               s->route_gateway_ids_str = aa;
         } else if (!strcmp(str, "RouteGatewayIds[]")) {
               TRY(!aa, "RouteGatewayIds[] argument missing\n");
               SET_NEXT(s->route_gateway_ids, (aa), pa);
         } else
	if (!argcmp(str, "RouteNatServiceIds")) {
            	 TRY(!aa, "RouteNatServiceIds argument missing\n");
               s->route_nat_service_ids_str = aa;
         } else if (!strcmp(str, "RouteNatServiceIds[]")) {
               TRY(!aa, "RouteNatServiceIds[] argument missing\n");
               SET_NEXT(s->route_nat_service_ids, (aa), pa);
         } else
	if (!argcmp(str, "RouteNetPeeringIds")) {
            	 TRY(!aa, "RouteNetPeeringIds argument missing\n");
               s->route_net_peering_ids_str = aa;
         } else if (!strcmp(str, "RouteNetPeeringIds[]")) {
               TRY(!aa, "RouteNetPeeringIds[] argument missing\n");
               SET_NEXT(s->route_net_peering_ids, (aa), pa);
         } else
	if (!argcmp(str, "RouteStates")) {
            	 TRY(!aa, "RouteStates argument missing\n");
               s->route_states_str = aa;
         } else if (!strcmp(str, "RouteStates[]")) {
               TRY(!aa, "RouteStates[] argument missing\n");
               SET_NEXT(s->route_states, (aa), pa);
         } else
	if (!argcmp(str, "RouteTableIds")) {
            	 TRY(!aa, "RouteTableIds argument missing\n");
               s->route_table_ids_str = aa;
         } else if (!strcmp(str, "RouteTableIds[]")) {
               TRY(!aa, "RouteTableIds[] argument missing\n");
               SET_NEXT(s->route_table_ids, (aa), pa);
         } else
	if (!argcmp(str, "RouteVmIds")) {
            	 TRY(!aa, "RouteVmIds argument missing\n");
               s->route_vm_ids_str = aa;
         } else if (!strcmp(str, "RouteVmIds[]")) {
               TRY(!aa, "RouteVmIds[] argument missing\n");
               SET_NEXT(s->route_vm_ids, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersRouteTable'\n", str);
	}
	return 0;
}

int filters_security_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_security_group *s = v_s;
	if (!argcmp(str, "AccountIds")) {
            	 TRY(!aa, "AccountIds argument missing\n");
               s->account_ids_str = aa;
         } else if (!strcmp(str, "AccountIds[]")) {
               TRY(!aa, "AccountIds[] argument missing\n");
               SET_NEXT(s->account_ids, (aa), pa);
         } else
	if (!argcmp(str, "Descriptions")) {
            	 TRY(!aa, "Descriptions argument missing\n");
               s->descriptions_str = aa;
         } else if (!strcmp(str, "Descriptions[]")) {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if (!argcmp(str, "InboundRuleAccountIds")) {
            	 TRY(!aa, "InboundRuleAccountIds argument missing\n");
               s->inbound_rule_account_ids_str = aa;
         } else if (!strcmp(str, "InboundRuleAccountIds[]")) {
               TRY(!aa, "InboundRuleAccountIds[] argument missing\n");
               SET_NEXT(s->inbound_rule_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "InboundRuleFromPortRanges")) {
            	 TRY(!aa, "InboundRuleFromPortRanges argument missing\n");
               s->inbound_rule_from_port_ranges_str = aa;
         } else if (!strcmp(str, "InboundRuleFromPortRanges[]")) {
               TRY(!aa, "InboundRuleFromPortRanges[] argument missing\n");
               SET_NEXT(s->inbound_rule_from_port_ranges, atoi(aa), pa);
         } else
	if (!argcmp(str, "InboundRuleIpRanges")) {
            	 TRY(!aa, "InboundRuleIpRanges argument missing\n");
               s->inbound_rule_ip_ranges_str = aa;
         } else if (!strcmp(str, "InboundRuleIpRanges[]")) {
               TRY(!aa, "InboundRuleIpRanges[] argument missing\n");
               SET_NEXT(s->inbound_rule_ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "InboundRuleProtocols")) {
            	 TRY(!aa, "InboundRuleProtocols argument missing\n");
               s->inbound_rule_protocols_str = aa;
         } else if (!strcmp(str, "InboundRuleProtocols[]")) {
               TRY(!aa, "InboundRuleProtocols[] argument missing\n");
               SET_NEXT(s->inbound_rule_protocols, (aa), pa);
         } else
	if (!argcmp(str, "InboundRuleSecurityGroupIds")) {
            	 TRY(!aa, "InboundRuleSecurityGroupIds argument missing\n");
               s->inbound_rule_security_group_ids_str = aa;
         } else if (!strcmp(str, "InboundRuleSecurityGroupIds[]")) {
               TRY(!aa, "InboundRuleSecurityGroupIds[] argument missing\n");
               SET_NEXT(s->inbound_rule_security_group_ids, (aa), pa);
         } else
	if (!argcmp(str, "InboundRuleSecurityGroupNames")) {
            	 TRY(!aa, "InboundRuleSecurityGroupNames argument missing\n");
               s->inbound_rule_security_group_names_str = aa;
         } else if (!strcmp(str, "InboundRuleSecurityGroupNames[]")) {
               TRY(!aa, "InboundRuleSecurityGroupNames[] argument missing\n");
               SET_NEXT(s->inbound_rule_security_group_names, (aa), pa);
         } else
	if (!argcmp(str, "InboundRuleToPortRanges")) {
            	 TRY(!aa, "InboundRuleToPortRanges argument missing\n");
               s->inbound_rule_to_port_ranges_str = aa;
         } else if (!strcmp(str, "InboundRuleToPortRanges[]")) {
               TRY(!aa, "InboundRuleToPortRanges[] argument missing\n");
               SET_NEXT(s->inbound_rule_to_port_ranges, atoi(aa), pa);
         } else
	if (!argcmp(str, "NetIds")) {
            	 TRY(!aa, "NetIds argument missing\n");
               s->net_ids_str = aa;
         } else if (!strcmp(str, "NetIds[]")) {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if (!argcmp(str, "OutboundRuleAccountIds")) {
            	 TRY(!aa, "OutboundRuleAccountIds argument missing\n");
               s->outbound_rule_account_ids_str = aa;
         } else if (!strcmp(str, "OutboundRuleAccountIds[]")) {
               TRY(!aa, "OutboundRuleAccountIds[] argument missing\n");
               SET_NEXT(s->outbound_rule_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "OutboundRuleFromPortRanges")) {
            	 TRY(!aa, "OutboundRuleFromPortRanges argument missing\n");
               s->outbound_rule_from_port_ranges_str = aa;
         } else if (!strcmp(str, "OutboundRuleFromPortRanges[]")) {
               TRY(!aa, "OutboundRuleFromPortRanges[] argument missing\n");
               SET_NEXT(s->outbound_rule_from_port_ranges, atoi(aa), pa);
         } else
	if (!argcmp(str, "OutboundRuleIpRanges")) {
            	 TRY(!aa, "OutboundRuleIpRanges argument missing\n");
               s->outbound_rule_ip_ranges_str = aa;
         } else if (!strcmp(str, "OutboundRuleIpRanges[]")) {
               TRY(!aa, "OutboundRuleIpRanges[] argument missing\n");
               SET_NEXT(s->outbound_rule_ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "OutboundRuleProtocols")) {
            	 TRY(!aa, "OutboundRuleProtocols argument missing\n");
               s->outbound_rule_protocols_str = aa;
         } else if (!strcmp(str, "OutboundRuleProtocols[]")) {
               TRY(!aa, "OutboundRuleProtocols[] argument missing\n");
               SET_NEXT(s->outbound_rule_protocols, (aa), pa);
         } else
	if (!argcmp(str, "OutboundRuleSecurityGroupIds")) {
            	 TRY(!aa, "OutboundRuleSecurityGroupIds argument missing\n");
               s->outbound_rule_security_group_ids_str = aa;
         } else if (!strcmp(str, "OutboundRuleSecurityGroupIds[]")) {
               TRY(!aa, "OutboundRuleSecurityGroupIds[] argument missing\n");
               SET_NEXT(s->outbound_rule_security_group_ids, (aa), pa);
         } else
	if (!argcmp(str, "OutboundRuleSecurityGroupNames")) {
            	 TRY(!aa, "OutboundRuleSecurityGroupNames argument missing\n");
               s->outbound_rule_security_group_names_str = aa;
         } else if (!strcmp(str, "OutboundRuleSecurityGroupNames[]")) {
               TRY(!aa, "OutboundRuleSecurityGroupNames[] argument missing\n");
               SET_NEXT(s->outbound_rule_security_group_names, (aa), pa);
         } else
	if (!argcmp(str, "OutboundRuleToPortRanges")) {
            	 TRY(!aa, "OutboundRuleToPortRanges argument missing\n");
               s->outbound_rule_to_port_ranges_str = aa;
         } else if (!strcmp(str, "OutboundRuleToPortRanges[]")) {
               TRY(!aa, "OutboundRuleToPortRanges[] argument missing\n");
               SET_NEXT(s->outbound_rule_to_port_ranges, atoi(aa), pa);
         } else
	if (!argcmp(str, "SecurityGroupIds")) {
            	 TRY(!aa, "SecurityGroupIds argument missing\n");
               s->security_group_ids_str = aa;
         } else if (!strcmp(str, "SecurityGroupIds[]")) {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if (!argcmp(str, "SecurityGroupNames")) {
            	 TRY(!aa, "SecurityGroupNames argument missing\n");
               s->security_group_names_str = aa;
         } else if (!strcmp(str, "SecurityGroupNames[]")) {
               TRY(!aa, "SecurityGroupNames[] argument missing\n");
               SET_NEXT(s->security_group_names, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersSecurityGroup'\n", str);
	}
	return 0;
}

int filters_server_certificate_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_server_certificate *s = v_s;
	if (!argcmp(str, "Paths")) {
            	 TRY(!aa, "Paths argument missing\n");
               s->paths_str = aa;
         } else if (!strcmp(str, "Paths[]")) {
               TRY(!aa, "Paths[] argument missing\n");
               SET_NEXT(s->paths, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersServerCertificate'\n", str);
	}
	return 0;
}

int filters_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_service *s = v_s;
	if (!argcmp(str, "ServiceIds")) {
            	 TRY(!aa, "ServiceIds argument missing\n");
               s->service_ids_str = aa;
         } else if (!strcmp(str, "ServiceIds[]")) {
               TRY(!aa, "ServiceIds[] argument missing\n");
               SET_NEXT(s->service_ids, (aa), pa);
         } else
	if (!argcmp(str, "ServiceNames")) {
            	 TRY(!aa, "ServiceNames argument missing\n");
               s->service_names_str = aa;
         } else if (!strcmp(str, "ServiceNames[]")) {
               TRY(!aa, "ServiceNames[] argument missing\n");
               SET_NEXT(s->service_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersService'\n", str);
	}
	return 0;
}

int filters_snapshot_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_snapshot *s = v_s;
	if (!argcmp(str, "AccountAliases")) {
            	 TRY(!aa, "AccountAliases argument missing\n");
               s->account_aliases_str = aa;
         } else if (!strcmp(str, "AccountAliases[]")) {
               TRY(!aa, "AccountAliases[] argument missing\n");
               SET_NEXT(s->account_aliases, (aa), pa);
         } else
	if (!argcmp(str, "AccountIds")) {
            	 TRY(!aa, "AccountIds argument missing\n");
               s->account_ids_str = aa;
         } else if (!strcmp(str, "AccountIds[]")) {
               TRY(!aa, "AccountIds[] argument missing\n");
               SET_NEXT(s->account_ids, (aa), pa);
         } else
	if (!argcmp(str, "Descriptions")) {
            	 TRY(!aa, "Descriptions argument missing\n");
               s->descriptions_str = aa;
         } else if (!strcmp(str, "Descriptions[]")) {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if (!argcmp(str, "PermissionsToCreateVolumeAccountIds")) {
            	 TRY(!aa, "PermissionsToCreateVolumeAccountIds argument missing\n");
               s->permissions_to_create_volume_account_ids_str = aa;
         } else if (!strcmp(str, "PermissionsToCreateVolumeAccountIds[]")) {
               TRY(!aa, "PermissionsToCreateVolumeAccountIds[] argument missing\n");
               SET_NEXT(s->permissions_to_create_volume_account_ids, (aa), pa);
         } else
	if (!argcmp(str, "PermissionsToCreateVolumeGlobalPermission")) {
            s->is_set_permissions_to_create_volume_global_permission = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->permissions_to_create_volume_global_permission = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->permissions_to_create_volume_global_permission = 0;
             } else {
            		fprintf(stderr, "PermissionsToCreateVolumeGlobalPermission require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "Progresses")) {
            	 TRY(!aa, "Progresses argument missing\n");
               s->progresses_str = aa;
         } else if (!strcmp(str, "Progresses[]")) {
               TRY(!aa, "Progresses[] argument missing\n");
               SET_NEXT(s->progresses, atoi(aa), pa);
         } else
	if (!argcmp(str, "SnapshotIds")) {
            	 TRY(!aa, "SnapshotIds argument missing\n");
               s->snapshot_ids_str = aa;
         } else if (!strcmp(str, "SnapshotIds[]")) {
               TRY(!aa, "SnapshotIds[] argument missing\n");
               SET_NEXT(s->snapshot_ids, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if (!argcmp(str, "VolumeIds")) {
            	 TRY(!aa, "VolumeIds argument missing\n");
               s->volume_ids_str = aa;
         } else if (!strcmp(str, "VolumeIds[]")) {
               TRY(!aa, "VolumeIds[] argument missing\n");
               SET_NEXT(s->volume_ids, (aa), pa);
         } else
	if (!argcmp(str, "VolumeSizes")) {
            	 TRY(!aa, "VolumeSizes argument missing\n");
               s->volume_sizes_str = aa;
         } else if (!strcmp(str, "VolumeSizes[]")) {
               TRY(!aa, "VolumeSizes[] argument missing\n");
               SET_NEXT(s->volume_sizes, atoi(aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersSnapshot'\n", str);
	}
	return 0;
}

int filters_subnet_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_subnet *s = v_s;
	if (!argcmp(str, "AvailableIpsCounts")) {
            	 TRY(!aa, "AvailableIpsCounts argument missing\n");
               s->available_ips_counts_str = aa;
         } else if (!strcmp(str, "AvailableIpsCounts[]")) {
               TRY(!aa, "AvailableIpsCounts[] argument missing\n");
               SET_NEXT(s->available_ips_counts, atoi(aa), pa);
         } else
	if (!argcmp(str, "IpRanges")) {
            	 TRY(!aa, "IpRanges argument missing\n");
               s->ip_ranges_str = aa;
         } else if (!strcmp(str, "IpRanges[]")) {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "NetIds")) {
            	 TRY(!aa, "NetIds argument missing\n");
               s->net_ids_str = aa;
         } else if (!strcmp(str, "NetIds[]")) {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "SubnetIds")) {
            	 TRY(!aa, "SubnetIds argument missing\n");
               s->subnet_ids_str = aa;
         } else if (!strcmp(str, "SubnetIds[]")) {
               TRY(!aa, "SubnetIds[] argument missing\n");
               SET_NEXT(s->subnet_ids, (aa), pa);
         } else
	if (!argcmp(str, "SubregionNames")) {
            	 TRY(!aa, "SubregionNames argument missing\n");
               s->subregion_names_str = aa;
         } else if (!strcmp(str, "SubregionNames[]")) {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersSubnet'\n", str);
	}
	return 0;
}

int filters_subregion_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_subregion *s = v_s;
	if (!argcmp(str, "SubregionNames")) {
            	 TRY(!aa, "SubregionNames argument missing\n");
               s->subregion_names_str = aa;
         } else if (!strcmp(str, "SubregionNames[]")) {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersSubregion'\n", str);
	}
	return 0;
}

int filters_tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_tag *s = v_s;
	if (!argcmp(str, "Keys")) {
            	 TRY(!aa, "Keys argument missing\n");
               s->keys_str = aa;
         } else if (!strcmp(str, "Keys[]")) {
               TRY(!aa, "Keys[] argument missing\n");
               SET_NEXT(s->keys, (aa), pa);
         } else
	if (!argcmp(str, "ResourceIds")) {
            	 TRY(!aa, "ResourceIds argument missing\n");
               s->resource_ids_str = aa;
         } else if (!strcmp(str, "ResourceIds[]")) {
               TRY(!aa, "ResourceIds[] argument missing\n");
               SET_NEXT(s->resource_ids, (aa), pa);
         } else
	if (!argcmp(str, "ResourceTypes")) {
            	 TRY(!aa, "ResourceTypes argument missing\n");
               s->resource_types_str = aa;
         } else if (!strcmp(str, "ResourceTypes[]")) {
               TRY(!aa, "ResourceTypes[] argument missing\n");
               SET_NEXT(s->resource_types, (aa), pa);
         } else
	if (!argcmp(str, "Values")) {
            	 TRY(!aa, "Values argument missing\n");
               s->values_str = aa;
         } else if (!strcmp(str, "Values[]")) {
               TRY(!aa, "Values[] argument missing\n");
               SET_NEXT(s->values, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersTag'\n", str);
	}
	return 0;
}

int filters_virtual_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_virtual_gateway *s = v_s;
	if (!argcmp(str, "ConnectionTypes")) {
            	 TRY(!aa, "ConnectionTypes argument missing\n");
               s->connection_types_str = aa;
         } else if (!strcmp(str, "ConnectionTypes[]")) {
               TRY(!aa, "ConnectionTypes[] argument missing\n");
               SET_NEXT(s->connection_types, (aa), pa);
         } else
	if (!argcmp(str, "LinkNetIds")) {
            	 TRY(!aa, "LinkNetIds argument missing\n");
               s->link_net_ids_str = aa;
         } else if (!strcmp(str, "LinkNetIds[]")) {
               TRY(!aa, "LinkNetIds[] argument missing\n");
               SET_NEXT(s->link_net_ids, (aa), pa);
         } else
	if (!argcmp(str, "LinkStates")) {
            	 TRY(!aa, "LinkStates argument missing\n");
               s->link_states_str = aa;
         } else if (!strcmp(str, "LinkStates[]")) {
               TRY(!aa, "LinkStates[] argument missing\n");
               SET_NEXT(s->link_states, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if (!argcmp(str, "VirtualGatewayIds")) {
            	 TRY(!aa, "VirtualGatewayIds argument missing\n");
               s->virtual_gateway_ids_str = aa;
         } else if (!strcmp(str, "VirtualGatewayIds[]")) {
               TRY(!aa, "VirtualGatewayIds[] argument missing\n");
               SET_NEXT(s->virtual_gateway_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVirtualGateway'\n", str);
	}
	return 0;
}

int filters_vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vm *s = v_s;
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if (!argcmp(str, "VmIds")) {
            	 TRY(!aa, "VmIds argument missing\n");
               s->vm_ids_str = aa;
         } else if (!strcmp(str, "VmIds[]")) {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVm'\n", str);
	}
	return 0;
}

int filters_vm_type_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vm_type *s = v_s;
	if (!argcmp(str, "BsuOptimized")) {
            s->is_set_bsu_optimized = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->bsu_optimized = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->bsu_optimized = 0;
             } else {
            		fprintf(stderr, "BsuOptimized require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "MemorySizes")) {
            	 TRY(!aa, "MemorySizes argument missing\n");
               s->memory_sizes_str = aa;
         } else if (!strcmp(str, "MemorySizes[]")) {
               TRY(!aa, "MemorySizes[] argument missing\n");
               SET_NEXT(s->memory_sizes, atof(aa), pa);
         } else
	if (!argcmp(str, "VcoreCounts")) {
            	 TRY(!aa, "VcoreCounts argument missing\n");
               s->vcore_counts_str = aa;
         } else if (!strcmp(str, "VcoreCounts[]")) {
               TRY(!aa, "VcoreCounts[] argument missing\n");
               SET_NEXT(s->vcore_counts, atoi(aa), pa);
         } else
	if (!argcmp(str, "VmTypeNames")) {
            	 TRY(!aa, "VmTypeNames argument missing\n");
               s->vm_type_names_str = aa;
         } else if (!strcmp(str, "VmTypeNames[]")) {
               TRY(!aa, "VmTypeNames[] argument missing\n");
               SET_NEXT(s->vm_type_names, (aa), pa);
         } else
	if (!argcmp(str, "VolumeCounts")) {
            	 TRY(!aa, "VolumeCounts argument missing\n");
               s->volume_counts_str = aa;
         } else if (!strcmp(str, "VolumeCounts[]")) {
               TRY(!aa, "VolumeCounts[] argument missing\n");
               SET_NEXT(s->volume_counts, atoi(aa), pa);
         } else
	if (!argcmp(str, "VolumeSizes")) {
            	 TRY(!aa, "VolumeSizes argument missing\n");
               s->volume_sizes_str = aa;
         } else if (!strcmp(str, "VolumeSizes[]")) {
               TRY(!aa, "VolumeSizes[] argument missing\n");
               SET_NEXT(s->volume_sizes, atoi(aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVmType'\n", str);
	}
	return 0;
}

int filters_vms_state_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vms_state *s = v_s;
	if (!argcmp(str, "MaintenanceEventCodes")) {
            	 TRY(!aa, "MaintenanceEventCodes argument missing\n");
               s->maintenance_event_codes_str = aa;
         } else if (!strcmp(str, "MaintenanceEventCodes[]")) {
               TRY(!aa, "MaintenanceEventCodes[] argument missing\n");
               SET_NEXT(s->maintenance_event_codes, (aa), pa);
         } else
	if (!argcmp(str, "MaintenanceEventDescriptions")) {
            	 TRY(!aa, "MaintenanceEventDescriptions argument missing\n");
               s->maintenance_event_descriptions_str = aa;
         } else if (!strcmp(str, "MaintenanceEventDescriptions[]")) {
               TRY(!aa, "MaintenanceEventDescriptions[] argument missing\n");
               SET_NEXT(s->maintenance_event_descriptions, (aa), pa);
         } else
	if (!argcmp(str, "MaintenanceEventsNotAfter")) {
            	 TRY(!aa, "MaintenanceEventsNotAfter argument missing\n");
               s->maintenance_events_not_after_str = aa;
         } else if (!strcmp(str, "MaintenanceEventsNotAfter[]")) {
               TRY(!aa, "MaintenanceEventsNotAfter[] argument missing\n");
               SET_NEXT(s->maintenance_events_not_after, (aa), pa);
         } else
	if (!argcmp(str, "MaintenanceEventsNotBefore")) {
            	 TRY(!aa, "MaintenanceEventsNotBefore argument missing\n");
               s->maintenance_events_not_before_str = aa;
         } else if (!strcmp(str, "MaintenanceEventsNotBefore[]")) {
               TRY(!aa, "MaintenanceEventsNotBefore[] argument missing\n");
               SET_NEXT(s->maintenance_events_not_before, (aa), pa);
         } else
	if (!argcmp(str, "SubregionNames")) {
            	 TRY(!aa, "SubregionNames argument missing\n");
               s->subregion_names_str = aa;
         } else if (!strcmp(str, "SubregionNames[]")) {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if (!argcmp(str, "VmIds")) {
            	 TRY(!aa, "VmIds argument missing\n");
               s->vm_ids_str = aa;
         } else if (!strcmp(str, "VmIds[]")) {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	if (!argcmp(str, "VmStates")) {
            	 TRY(!aa, "VmStates argument missing\n");
               s->vm_states_str = aa;
         } else if (!strcmp(str, "VmStates[]")) {
               TRY(!aa, "VmStates[] argument missing\n");
               SET_NEXT(s->vm_states, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVmsState'\n", str);
	}
	return 0;
}

int filters_volume_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_volume *s = v_s;
	if (!argcmp(str, "CreationDates")) {
            	 TRY(!aa, "CreationDates argument missing\n");
               s->creation_dates_str = aa;
         } else if (!strcmp(str, "CreationDates[]")) {
               TRY(!aa, "CreationDates[] argument missing\n");
               SET_NEXT(s->creation_dates, (aa), pa);
         } else
	if (!argcmp(str, "LinkVolumeDeleteOnVmDeletion")) {
            s->is_set_link_volume_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->link_volume_delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->link_volume_delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "LinkVolumeDeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkVolumeDeviceNames")) {
            	 TRY(!aa, "LinkVolumeDeviceNames argument missing\n");
               s->link_volume_device_names_str = aa;
         } else if (!strcmp(str, "LinkVolumeDeviceNames[]")) {
               TRY(!aa, "LinkVolumeDeviceNames[] argument missing\n");
               SET_NEXT(s->link_volume_device_names, (aa), pa);
         } else
	if (!argcmp(str, "LinkVolumeLinkDates")) {
            	 TRY(!aa, "LinkVolumeLinkDates argument missing\n");
               s->link_volume_link_dates_str = aa;
         } else if (!strcmp(str, "LinkVolumeLinkDates[]")) {
               TRY(!aa, "LinkVolumeLinkDates[] argument missing\n");
               SET_NEXT(s->link_volume_link_dates, (aa), pa);
         } else
	if (!argcmp(str, "LinkVolumeLinkStates")) {
            	 TRY(!aa, "LinkVolumeLinkStates argument missing\n");
               s->link_volume_link_states_str = aa;
         } else if (!strcmp(str, "LinkVolumeLinkStates[]")) {
               TRY(!aa, "LinkVolumeLinkStates[] argument missing\n");
               SET_NEXT(s->link_volume_link_states, (aa), pa);
         } else
	if (!argcmp(str, "LinkVolumeVmIds")) {
            	 TRY(!aa, "LinkVolumeVmIds argument missing\n");
               s->link_volume_vm_ids_str = aa;
         } else if (!strcmp(str, "LinkVolumeVmIds[]")) {
               TRY(!aa, "LinkVolumeVmIds[] argument missing\n");
               SET_NEXT(s->link_volume_vm_ids, (aa), pa);
         } else
	if (!argcmp(str, "SnapshotIds")) {
            	 TRY(!aa, "SnapshotIds argument missing\n");
               s->snapshot_ids_str = aa;
         } else if (!strcmp(str, "SnapshotIds[]")) {
               TRY(!aa, "SnapshotIds[] argument missing\n");
               SET_NEXT(s->snapshot_ids, (aa), pa);
         } else
	if (!argcmp(str, "SubregionNames")) {
            	 TRY(!aa, "SubregionNames argument missing\n");
               s->subregion_names_str = aa;
         } else if (!strcmp(str, "SubregionNames[]")) {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if (!argcmp(str, "VolumeIds")) {
            	 TRY(!aa, "VolumeIds argument missing\n");
               s->volume_ids_str = aa;
         } else if (!strcmp(str, "VolumeIds[]")) {
               TRY(!aa, "VolumeIds[] argument missing\n");
               SET_NEXT(s->volume_ids, (aa), pa);
         } else
	if (!argcmp(str, "VolumeSizes")) {
            	 TRY(!aa, "VolumeSizes argument missing\n");
               s->volume_sizes_str = aa;
         } else if (!strcmp(str, "VolumeSizes[]")) {
               TRY(!aa, "VolumeSizes[] argument missing\n");
               SET_NEXT(s->volume_sizes, atoi(aa), pa);
         } else
	if (!argcmp(str, "VolumeStates")) {
            	 TRY(!aa, "VolumeStates argument missing\n");
               s->volume_states_str = aa;
         } else if (!strcmp(str, "VolumeStates[]")) {
               TRY(!aa, "VolumeStates[] argument missing\n");
               SET_NEXT(s->volume_states, (aa), pa);
         } else
	if (!argcmp(str, "VolumeTypes")) {
            	 TRY(!aa, "VolumeTypes argument missing\n");
               s->volume_types_str = aa;
         } else if (!strcmp(str, "VolumeTypes[]")) {
               TRY(!aa, "VolumeTypes[] argument missing\n");
               SET_NEXT(s->volume_types, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVolume'\n", str);
	}
	return 0;
}

int filters_vpn_connection_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vpn_connection *s = v_s;
	if (!argcmp(str, "BgpAsns")) {
            	 TRY(!aa, "BgpAsns argument missing\n");
               s->bgp_asns_str = aa;
         } else if (!strcmp(str, "BgpAsns[]")) {
               TRY(!aa, "BgpAsns[] argument missing\n");
               SET_NEXT(s->bgp_asns, atoi(aa), pa);
         } else
	if (!argcmp(str, "ClientGatewayIds")) {
            	 TRY(!aa, "ClientGatewayIds argument missing\n");
               s->client_gateway_ids_str = aa;
         } else if (!strcmp(str, "ClientGatewayIds[]")) {
               TRY(!aa, "ClientGatewayIds[] argument missing\n");
               SET_NEXT(s->client_gateway_ids, (aa), pa);
         } else
	if (!argcmp(str, "ConnectionTypes")) {
            	 TRY(!aa, "ConnectionTypes argument missing\n");
               s->connection_types_str = aa;
         } else if (!strcmp(str, "ConnectionTypes[]")) {
               TRY(!aa, "ConnectionTypes[] argument missing\n");
               SET_NEXT(s->connection_types, (aa), pa);
         } else
	if (!argcmp(str, "RouteDestinationIpRanges")) {
            	 TRY(!aa, "RouteDestinationIpRanges argument missing\n");
               s->route_destination_ip_ranges_str = aa;
         } else if (!strcmp(str, "RouteDestinationIpRanges[]")) {
               TRY(!aa, "RouteDestinationIpRanges[] argument missing\n");
               SET_NEXT(s->route_destination_ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "States")) {
            	 TRY(!aa, "States argument missing\n");
               s->states_str = aa;
         } else if (!strcmp(str, "States[]")) {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if (!argcmp(str, "StaticRoutesOnly")) {
            s->is_set_static_routes_only = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->static_routes_only = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->static_routes_only = 0;
             } else {
            		fprintf(stderr, "StaticRoutesOnly require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "TagKeys")) {
            	 TRY(!aa, "TagKeys argument missing\n");
               s->tag_keys_str = aa;
         } else if (!strcmp(str, "TagKeys[]")) {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if (!argcmp(str, "TagValues")) {
            	 TRY(!aa, "TagValues argument missing\n");
               s->tag_values_str = aa;
         } else if (!strcmp(str, "TagValues[]")) {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            	 TRY(!aa, "Tags argument missing\n");
               s->tags_str = aa;
         } else if (!strcmp(str, "Tags[]")) {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if (!argcmp(str, "VirtualGatewayIds")) {
            	 TRY(!aa, "VirtualGatewayIds argument missing\n");
               s->virtual_gateway_ids_str = aa;
         } else if (!strcmp(str, "VirtualGatewayIds[]")) {
               TRY(!aa, "VirtualGatewayIds[] argument missing\n");
               SET_NEXT(s->virtual_gateway_ids, (aa), pa);
         } else
	if (!argcmp(str, "VpnConnectionIds")) {
            	 TRY(!aa, "VpnConnectionIds argument missing\n");
               s->vpn_connection_ids_str = aa;
         } else if (!strcmp(str, "VpnConnectionIds[]")) {
               TRY(!aa, "VpnConnectionIds[] argument missing\n");
               SET_NEXT(s->vpn_connection_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVpnConnection'\n", str);
	}
	return 0;
}

int flexible_gpu_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct flexible_gpu *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "FlexibleGpuId")) {
            TRY(!aa, "FlexibleGpuId argument missing\n");
            s->flexible_gpu_id = aa; // string string

         } else
	if (!argcmp(str, "Generation")) {
            TRY(!aa, "Generation argument missing\n");
            s->generation = aa; // string string

         } else
	if (!argcmp(str, "ModelName")) {
            TRY(!aa, "ModelName argument missing\n");
            s->model_name = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FlexibleGpu'\n", str);
	}
	return 0;
}

int flexible_gpu_catalog_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct flexible_gpu_catalog *s = v_s;
	if (!argcmp(str, "Generations")) {
            	 TRY(!aa, "Generations argument missing\n");
               s->generations_str = aa;
         } else if (!strcmp(str, "Generations[]")) {
               TRY(!aa, "Generations[] argument missing\n");
               SET_NEXT(s->generations, (aa), pa);
         } else
	if (!argcmp(str, "MaxCpu")) {
            TRY(!aa, "MaxCpu argument missing\n");
            s->is_set_max_cpu = 1;
            s->max_cpu = atoi(aa);
         } else
	if (!argcmp(str, "MaxRam")) {
            TRY(!aa, "MaxRam argument missing\n");
            s->is_set_max_ram = 1;
            s->max_ram = atoi(aa);
         } else
	if (!argcmp(str, "ModelName")) {
            TRY(!aa, "ModelName argument missing\n");
            s->model_name = aa; // string string

         } else
	if (!argcmp(str, "VRam")) {
            TRY(!aa, "VRam argument missing\n");
            s->is_set_vram = 1;
            s->vram = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FlexibleGpuCatalog'\n", str);
	}
	return 0;
}

int health_check_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct health_check *s = v_s;
	if (!argcmp(str, "CheckInterval")) {
            TRY(!aa, "CheckInterval argument missing\n");
            s->is_set_check_interval = 1;
            s->check_interval = atoi(aa);
         } else
	if (!argcmp(str, "HealthyThreshold")) {
            TRY(!aa, "HealthyThreshold argument missing\n");
            s->is_set_healthy_threshold = 1;
            s->healthy_threshold = atoi(aa);
         } else
	if (!argcmp(str, "Path")) {
            TRY(!aa, "Path argument missing\n");
            s->path = aa; // string string

         } else
	if (!argcmp(str, "Port")) {
            TRY(!aa, "Port argument missing\n");
            s->is_set_port = 1;
            s->port = atoi(aa);
         } else
	if (!argcmp(str, "Protocol")) {
            TRY(!aa, "Protocol argument missing\n");
            s->protocol = aa; // string string

         } else
	if (!argcmp(str, "Timeout")) {
            TRY(!aa, "Timeout argument missing\n");
            s->is_set_timeout = 1;
            s->timeout = atoi(aa);
         } else
	if (!argcmp(str, "UnhealthyThreshold")) {
            TRY(!aa, "UnhealthyThreshold argument missing\n");
            s->is_set_unhealthy_threshold = 1;
            s->unhealthy_threshold = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'HealthCheck'\n", str);
	}
	return 0;
}

int image_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct image *s = v_s;
	if (!argcmp(str, "AccountAlias")) {
            TRY(!aa, "AccountAlias argument missing\n");
            s->account_alias = aa; // string string

         } else
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "Architecture")) {
            TRY(!aa, "Architecture argument missing\n");
            s->architecture = aa; // string string

         } else
	if (!argcmp(str, "BlockDeviceMappings")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingImage.BlockDeviceMappings.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'BlockDeviceMappings' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
            	      cascade_struct = &s->block_device_mappings[pos];
            	      cascade_parser = block_device_mapping_image_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      block_device_mapping_image_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "BlockDeviceMappings argument missing\n");
            	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingImage ref
            }
         } else
	if (!argcmp(str, "CreationDate")) {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "FileLocation")) {
            TRY(!aa, "FileLocation argument missing\n");
            s->file_location = aa; // string string

         } else
	if (!argcmp(str, "ImageId")) {
            TRY(!aa, "ImageId argument missing\n");
            s->image_id = aa; // string string

         } else
	if (!argcmp(str, "ImageName")) {
            TRY(!aa, "ImageName argument missing\n");
            s->image_name = aa; // string string

         } else
	if (!argcmp(str, "ImageType")) {
            TRY(!aa, "ImageType argument missing\n");
            s->image_type = aa; // string string

         } else
	if (!argcmp(str, "PermissionsToLaunch")) {
            char *dot_pos;

            TRY(!aa, "PermissionsToLaunch argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->permissions_to_launch;
            	    cascade_parser = permissions_on_resource_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    permissions_on_resource_parser(&s->permissions_to_launch, dot_pos, aa, pa);
            	    s->is_set_permissions_to_launch = 1;
             } else {
                   s->permissions_to_launch_str = aa;
             }
         } else
	if (!argcmp(str, "ProductCodes")) {
            	 TRY(!aa, "ProductCodes argument missing\n");
               s->product_codes_str = aa;
         } else if (!strcmp(str, "ProductCodes[]")) {
               TRY(!aa, "ProductCodes[] argument missing\n");
               SET_NEXT(s->product_codes, (aa), pa);
         } else
	if (!argcmp(str, "RootDeviceName")) {
            TRY(!aa, "RootDeviceName argument missing\n");
            s->root_device_name = aa; // string string

         } else
	if (!argcmp(str, "RootDeviceType")) {
            TRY(!aa, "RootDeviceType argument missing\n");
            s->root_device_type = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "StateComment")) {
            char *dot_pos;

            TRY(!aa, "StateComment argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->state_comment;
            	    cascade_parser = state_comment_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    state_comment_parser(&s->state_comment, dot_pos, aa, pa);
            	    s->is_set_state_comment = 1;
             } else {
                   s->state_comment_str = aa;
             }
         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Image'\n", str);
	}
	return 0;
}

int image_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct image_export_task *s = v_s;
	if (!argcmp(str, "Comment")) {
            TRY(!aa, "Comment argument missing\n");
            s->comment = aa; // string string

         } else
	if (!argcmp(str, "ImageId")) {
            TRY(!aa, "ImageId argument missing\n");
            s->image_id = aa; // string string

         } else
	if (!argcmp(str, "OsuExport")) {
            char *dot_pos;

            TRY(!aa, "OsuExport argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->osu_export;
            	    cascade_parser = osu_export_image_export_task_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    osu_export_image_export_task_parser(&s->osu_export, dot_pos, aa, pa);
            	    s->is_set_osu_export = 1;
             } else {
                   s->osu_export_str = aa;
             }
         } else
	if (!argcmp(str, "Progress")) {
            TRY(!aa, "Progress argument missing\n");
            s->is_set_progress = 1;
            s->progress = atoi(aa);
         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "TaskId")) {
            TRY(!aa, "TaskId argument missing\n");
            s->task_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ImageExportTask'\n", str);
	}
	return 0;
}

int internet_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct internet_service *s = v_s;
	if (!argcmp(str, "InternetServiceId")) {
            TRY(!aa, "InternetServiceId argument missing\n");
            s->internet_service_id = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'InternetService'\n", str);
	}
	return 0;
}

int keypair_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct keypair *s = v_s;
	if (!argcmp(str, "KeypairFingerprint")) {
            TRY(!aa, "KeypairFingerprint argument missing\n");
            s->keypair_fingerprint = aa; // string string

         } else
	if (!argcmp(str, "KeypairName")) {
            TRY(!aa, "KeypairName argument missing\n");
            s->keypair_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Keypair'\n", str);
	}
	return 0;
}

int keypair_created_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct keypair_created *s = v_s;
	if (!argcmp(str, "KeypairFingerprint")) {
            TRY(!aa, "KeypairFingerprint argument missing\n");
            s->keypair_fingerprint = aa; // string string

         } else
	if (!argcmp(str, "KeypairName")) {
            TRY(!aa, "KeypairName argument missing\n");
            s->keypair_name = aa; // string string

         } else
	if (!argcmp(str, "PrivateKey")) {
            TRY(!aa, "PrivateKey argument missing\n");
            s->private_key = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'KeypairCreated'\n", str);
	}
	return 0;
}

int link_nic_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_nic *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "DeviceNumber")) {
            TRY(!aa, "DeviceNumber argument missing\n");
            s->is_set_device_number = 1;
            s->device_number = atoi(aa);
         } else
	if (!argcmp(str, "LinkNicId")) {
            TRY(!aa, "LinkNicId argument missing\n");
            s->link_nic_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "VmAccountId")) {
            TRY(!aa, "VmAccountId argument missing\n");
            s->vm_account_id = aa; // string string

         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkNic'\n", str);
	}
	return 0;
}

int link_nic_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_nic_light *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "DeviceNumber")) {
            TRY(!aa, "DeviceNumber argument missing\n");
            s->is_set_device_number = 1;
            s->device_number = atoi(aa);
         } else
	if (!argcmp(str, "LinkNicId")) {
            TRY(!aa, "LinkNicId argument missing\n");
            s->link_nic_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkNicLight'\n", str);
	}
	return 0;
}

int link_nic_to_update_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_nic_to_update *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkNicId")) {
            TRY(!aa, "LinkNicId argument missing\n");
            s->link_nic_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkNicToUpdate'\n", str);
	}
	return 0;
}

int link_public_ip_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_public_ip *s = v_s;
	if (!argcmp(str, "LinkPublicIpId")) {
            TRY(!aa, "LinkPublicIpId argument missing\n");
            s->link_public_ip_id = aa; // string string

         } else
	if (!argcmp(str, "PublicDnsName")) {
            TRY(!aa, "PublicDnsName argument missing\n");
            s->public_dns_name = aa; // string string

         } else
	if (!argcmp(str, "PublicIp")) {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if (!argcmp(str, "PublicIpAccountId")) {
            TRY(!aa, "PublicIpAccountId argument missing\n");
            s->public_ip_account_id = aa; // string string

         } else
	if (!argcmp(str, "PublicIpId")) {
            TRY(!aa, "PublicIpId argument missing\n");
            s->public_ip_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkPublicIp'\n", str);
	}
	return 0;
}

int link_public_ip_light_for_vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_public_ip_light_for_vm *s = v_s;
	if (!argcmp(str, "PublicDnsName")) {
            TRY(!aa, "PublicDnsName argument missing\n");
            s->public_dns_name = aa; // string string

         } else
	if (!argcmp(str, "PublicIp")) {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if (!argcmp(str, "PublicIpAccountId")) {
            TRY(!aa, "PublicIpAccountId argument missing\n");
            s->public_ip_account_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkPublicIpLightForVm'\n", str);
	}
	return 0;
}

int link_route_table_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_route_table *s = v_s;
	if (!argcmp(str, "LinkRouteTableId")) {
            TRY(!aa, "LinkRouteTableId argument missing\n");
            s->link_route_table_id = aa; // string string

         } else
	if (!argcmp(str, "Main")) {
            s->is_set_main = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->main = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->main = 0;
             } else {
            		fprintf(stderr, "Main require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "RouteTableId")) {
            TRY(!aa, "RouteTableId argument missing\n");
            s->route_table_id = aa; // string string

         } else
	if (!argcmp(str, "SubnetId")) {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkRouteTable'\n", str);
	}
	return 0;
}

int linked_volume_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct linked_volume *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "DeviceName")) {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	if (!argcmp(str, "VolumeId")) {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkedVolume'\n", str);
	}
	return 0;
}

int listener_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct listener *s = v_s;
	if (!argcmp(str, "BackendPort")) {
            TRY(!aa, "BackendPort argument missing\n");
            s->is_set_backend_port = 1;
            s->backend_port = atoi(aa);
         } else
	if (!argcmp(str, "BackendProtocol")) {
            TRY(!aa, "BackendProtocol argument missing\n");
            s->backend_protocol = aa; // string string

         } else
	if (!argcmp(str, "LoadBalancerPort")) {
            TRY(!aa, "LoadBalancerPort argument missing\n");
            s->is_set_load_balancer_port = 1;
            s->load_balancer_port = atoi(aa);
         } else
	if (!argcmp(str, "LoadBalancerProtocol")) {
            TRY(!aa, "LoadBalancerProtocol argument missing\n");
            s->load_balancer_protocol = aa; // string string

         } else
	if (!argcmp(str, "PolicyNames")) {
            	 TRY(!aa, "PolicyNames argument missing\n");
               s->policy_names_str = aa;
         } else if (!strcmp(str, "PolicyNames[]")) {
               TRY(!aa, "PolicyNames[] argument missing\n");
               SET_NEXT(s->policy_names, (aa), pa);
         } else
	if (!argcmp(str, "ServerCertificateId")) {
            TRY(!aa, "ServerCertificateId argument missing\n");
            s->server_certificate_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Listener'\n", str);
	}
	return 0;
}

int listener_for_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct listener_for_creation *s = v_s;
	if (!argcmp(str, "BackendPort")) {
            TRY(!aa, "BackendPort argument missing\n");
            s->is_set_backend_port = 1;
            s->backend_port = atoi(aa);
         } else
	if (!argcmp(str, "BackendProtocol")) {
            TRY(!aa, "BackendProtocol argument missing\n");
            s->backend_protocol = aa; // string string

         } else
	if (!argcmp(str, "LoadBalancerPort")) {
            TRY(!aa, "LoadBalancerPort argument missing\n");
            s->is_set_load_balancer_port = 1;
            s->load_balancer_port = atoi(aa);
         } else
	if (!argcmp(str, "LoadBalancerProtocol")) {
            TRY(!aa, "LoadBalancerProtocol argument missing\n");
            s->load_balancer_protocol = aa; // string string

         } else
	if (!argcmp(str, "ServerCertificateId")) {
            TRY(!aa, "ServerCertificateId argument missing\n");
            s->server_certificate_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ListenerForCreation'\n", str);
	}
	return 0;
}

int listener_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct listener_rule *s = v_s;
	if (!argcmp(str, "Action")) {
            TRY(!aa, "Action argument missing\n");
            s->action = aa; // string string

         } else
	if (!argcmp(str, "HostNamePattern")) {
            TRY(!aa, "HostNamePattern argument missing\n");
            s->host_name_pattern = aa; // string string

         } else
	if (!argcmp(str, "ListenerId")) {
            TRY(!aa, "ListenerId argument missing\n");
            s->is_set_listener_id = 1;
            s->listener_id = atoi(aa);
         } else
	if (!argcmp(str, "ListenerRuleId")) {
            TRY(!aa, "ListenerRuleId argument missing\n");
            s->is_set_listener_rule_id = 1;
            s->listener_rule_id = atoi(aa);
         } else
	if (!argcmp(str, "ListenerRuleName")) {
            TRY(!aa, "ListenerRuleName argument missing\n");
            s->listener_rule_name = aa; // string string

         } else
	if (!argcmp(str, "PathPattern")) {
            TRY(!aa, "PathPattern argument missing\n");
            s->path_pattern = aa; // string string

         } else
	if (!argcmp(str, "Priority")) {
            TRY(!aa, "Priority argument missing\n");
            s->is_set_priority = 1;
            s->priority = atoi(aa);
         } else
	if (!argcmp(str, "VmIds")) {
            	 TRY(!aa, "VmIds argument missing\n");
               s->vm_ids_str = aa;
         } else if (!strcmp(str, "VmIds[]")) {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ListenerRule'\n", str);
	}
	return 0;
}

int listener_rule_for_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct listener_rule_for_creation *s = v_s;
	if (!argcmp(str, "Action")) {
            TRY(!aa, "Action argument missing\n");
            s->action = aa; // string string

         } else
	if (!argcmp(str, "HostNamePattern")) {
            TRY(!aa, "HostNamePattern argument missing\n");
            s->host_name_pattern = aa; // string string

         } else
	if (!argcmp(str, "ListenerRuleName")) {
            TRY(!aa, "ListenerRuleName argument missing\n");
            s->listener_rule_name = aa; // string string

         } else
	if (!argcmp(str, "PathPattern")) {
            TRY(!aa, "PathPattern argument missing\n");
            s->path_pattern = aa; // string string

         } else
	if (!argcmp(str, "Priority")) {
            TRY(!aa, "Priority argument missing\n");
            s->is_set_priority = 1;
            s->priority = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ListenerRuleForCreation'\n", str);
	}
	return 0;
}

int load_balancer_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct load_balancer *s = v_s;
	if (!argcmp(str, "AccessLog")) {
            char *dot_pos;

            TRY(!aa, "AccessLog argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->access_log;
            	    cascade_parser = access_log_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    access_log_parser(&s->access_log, dot_pos, aa, pa);
            	    s->is_set_access_log = 1;
             } else {
                   s->access_log_str = aa;
             }
         } else
	if (!argcmp(str, "ApplicationStickyCookiePolicies")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'ApplicationStickyCookiePolicies' require an index (example array ref ApplicationStickyCookiePolicy.ApplicationStickyCookiePolicies.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'ApplicationStickyCookiePolicies' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,application_sticky_cookie_policies, pa, pos, sizeof(*s->application_sticky_cookie_policies));
            	      cascade_struct = &s->application_sticky_cookie_policies[pos];
            	      cascade_parser = application_sticky_cookie_policy_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      application_sticky_cookie_policy_parser(&s->application_sticky_cookie_policies[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "ApplicationStickyCookiePolicies argument missing\n");
            	s->application_sticky_cookie_policies_str = aa; // array ref ApplicationStickyCookiePolicy ref
            }
         } else
	if (!argcmp(str, "BackendIps")) {
            	 TRY(!aa, "BackendIps argument missing\n");
               s->backend_ips_str = aa;
         } else if (!strcmp(str, "BackendIps[]")) {
               TRY(!aa, "BackendIps[] argument missing\n");
               SET_NEXT(s->backend_ips, (aa), pa);
         } else
	if (!argcmp(str, "BackendVmIds")) {
            	 TRY(!aa, "BackendVmIds argument missing\n");
               s->backend_vm_ids_str = aa;
         } else if (!strcmp(str, "BackendVmIds[]")) {
               TRY(!aa, "BackendVmIds[] argument missing\n");
               SET_NEXT(s->backend_vm_ids, (aa), pa);
         } else
	if (!argcmp(str, "DnsName")) {
            TRY(!aa, "DnsName argument missing\n");
            s->dns_name = aa; // string string

         } else
	if (!argcmp(str, "HealthCheck")) {
            char *dot_pos;

            TRY(!aa, "HealthCheck argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->health_check;
            	    cascade_parser = health_check_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    health_check_parser(&s->health_check, dot_pos, aa, pa);
            	    s->is_set_health_check = 1;
             } else {
                   s->health_check_str = aa;
             }
         } else
	if (!argcmp(str, "Listeners")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Listeners' require an index (example array ref Listener.Listeners.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Listeners' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,listeners, pa, pos, sizeof(*s->listeners));
            	      cascade_struct = &s->listeners[pos];
            	      cascade_parser = listener_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      listener_parser(&s->listeners[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Listeners argument missing\n");
            	s->listeners_str = aa; // array ref Listener ref
            }
         } else
	if (!argcmp(str, "LoadBalancerName")) {
            TRY(!aa, "LoadBalancerName argument missing\n");
            s->load_balancer_name = aa; // string string

         } else
	if (!argcmp(str, "LoadBalancerStickyCookiePolicies")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'LoadBalancerStickyCookiePolicies' require an index (example array ref LoadBalancerStickyCookiePolicy.LoadBalancerStickyCookiePolicies.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'LoadBalancerStickyCookiePolicies' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,load_balancer_sticky_cookie_policies, pa, pos, sizeof(*s->load_balancer_sticky_cookie_policies));
            	      cascade_struct = &s->load_balancer_sticky_cookie_policies[pos];
            	      cascade_parser = load_balancer_sticky_cookie_policy_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      load_balancer_sticky_cookie_policy_parser(&s->load_balancer_sticky_cookie_policies[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "LoadBalancerStickyCookiePolicies argument missing\n");
            	s->load_balancer_sticky_cookie_policies_str = aa; // array ref LoadBalancerStickyCookiePolicy ref
            }
         } else
	if (!argcmp(str, "LoadBalancerType")) {
            TRY(!aa, "LoadBalancerType argument missing\n");
            s->load_balancer_type = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "PublicIp")) {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if (!argcmp(str, "SecuredCookies")) {
            s->is_set_secured_cookies = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->secured_cookies = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->secured_cookies = 0;
             } else {
            		fprintf(stderr, "SecuredCookies require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "SecurityGroups")) {
            	 TRY(!aa, "SecurityGroups argument missing\n");
               s->security_groups_str = aa;
         } else if (!strcmp(str, "SecurityGroups[]")) {
               TRY(!aa, "SecurityGroups[] argument missing\n");
               SET_NEXT(s->security_groups, (aa), pa);
         } else
	if (!argcmp(str, "SourceSecurityGroup")) {
            char *dot_pos;

            TRY(!aa, "SourceSecurityGroup argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->source_security_group;
            	    cascade_parser = source_security_group_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    source_security_group_parser(&s->source_security_group, dot_pos, aa, pa);
            	    s->is_set_source_security_group = 1;
             } else {
                   s->source_security_group_str = aa;
             }
         } else
	if (!argcmp(str, "Subnets")) {
            	 TRY(!aa, "Subnets argument missing\n");
               s->subnets_str = aa;
         } else if (!strcmp(str, "Subnets[]")) {
               TRY(!aa, "Subnets[] argument missing\n");
               SET_NEXT(s->subnets, (aa), pa);
         } else
	if (!argcmp(str, "SubregionNames")) {
            	 TRY(!aa, "SubregionNames argument missing\n");
               s->subregion_names_str = aa;
         } else if (!strcmp(str, "SubregionNames[]")) {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LoadBalancer'\n", str);
	}
	return 0;
}

int load_balancer_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct load_balancer_light *s = v_s;
	if (!argcmp(str, "LoadBalancerName")) {
            TRY(!aa, "LoadBalancerName argument missing\n");
            s->load_balancer_name = aa; // string string

         } else
	if (!argcmp(str, "LoadBalancerPort")) {
            TRY(!aa, "LoadBalancerPort argument missing\n");
            s->is_set_load_balancer_port = 1;
            s->load_balancer_port = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LoadBalancerLight'\n", str);
	}
	return 0;
}

int load_balancer_sticky_cookie_policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct load_balancer_sticky_cookie_policy *s = v_s;
	if (!argcmp(str, "CookieExpirationPeriod")) {
            TRY(!aa, "CookieExpirationPeriod argument missing\n");
            s->is_set_cookie_expiration_period = 1;
            s->cookie_expiration_period = atoi(aa);
         } else
	if (!argcmp(str, "PolicyName")) {
            TRY(!aa, "PolicyName argument missing\n");
            s->policy_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LoadBalancerStickyCookiePolicy'\n", str);
	}
	return 0;
}

int load_balancer_tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct load_balancer_tag *s = v_s;
	if (!argcmp(str, "Key")) {
            TRY(!aa, "Key argument missing\n");
            s->key = aa; // string string

         } else
	if (!argcmp(str, "LoadBalancerName")) {
            TRY(!aa, "LoadBalancerName argument missing\n");
            s->load_balancer_name = aa; // string string

         } else
	if (!argcmp(str, "Value")) {
            TRY(!aa, "Value argument missing\n");
            s->value = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LoadBalancerTag'\n", str);
	}
	return 0;
}

int location_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct location *s = v_s;
	if (!argcmp(str, "Code")) {
            TRY(!aa, "Code argument missing\n");
            s->code = aa; // string string

         } else
	if (!argcmp(str, "Name")) {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Location'\n", str);
	}
	return 0;
}

int log_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct log *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "CallDuration")) {
            TRY(!aa, "CallDuration argument missing\n");
            s->is_set_call_duration = 1;
            s->call_duration = atoi(aa);
         } else
	if (!argcmp(str, "QueryAccessKey")) {
            TRY(!aa, "QueryAccessKey argument missing\n");
            s->query_access_key = aa; // string string

         } else
	if (!argcmp(str, "QueryApiName")) {
            TRY(!aa, "QueryApiName argument missing\n");
            s->query_api_name = aa; // string string

         } else
	if (!argcmp(str, "QueryApiVersion")) {
            TRY(!aa, "QueryApiVersion argument missing\n");
            s->query_api_version = aa; // string string

         } else
	if (!argcmp(str, "QueryCallName")) {
            TRY(!aa, "QueryCallName argument missing\n");
            s->query_call_name = aa; // string string

         } else
	if (!argcmp(str, "QueryDate")) {
            TRY(!aa, "QueryDate argument missing\n");
            s->query_date = aa; // string string

         } else
	if (!argcmp(str, "QueryHeaderRaw")) {
            TRY(!aa, "QueryHeaderRaw argument missing\n");
            s->query_header_raw = aa; // string string

         } else
	if (!argcmp(str, "QueryHeaderSize")) {
            TRY(!aa, "QueryHeaderSize argument missing\n");
            s->is_set_query_header_size = 1;
            s->query_header_size = atoi(aa);
         } else
	if (!argcmp(str, "QueryIpAddress")) {
            TRY(!aa, "QueryIpAddress argument missing\n");
            s->query_ip_address = aa; // string string

         } else
	if (!argcmp(str, "QueryPayloadRaw")) {
            TRY(!aa, "QueryPayloadRaw argument missing\n");
            s->query_payload_raw = aa; // string string

         } else
	if (!argcmp(str, "QueryPayloadSize")) {
            TRY(!aa, "QueryPayloadSize argument missing\n");
            s->is_set_query_payload_size = 1;
            s->query_payload_size = atoi(aa);
         } else
	if (!argcmp(str, "QueryUserAgent")) {
            TRY(!aa, "QueryUserAgent argument missing\n");
            s->query_user_agent = aa; // string string

         } else
	if (!argcmp(str, "RequestId")) {
            TRY(!aa, "RequestId argument missing\n");
            s->request_id = aa; // string string

         } else
	if (!argcmp(str, "ResponseSize")) {
            TRY(!aa, "ResponseSize argument missing\n");
            s->is_set_response_size = 1;
            s->response_size = atoi(aa);
         } else
	if (!argcmp(str, "ResponseStatusCode")) {
            TRY(!aa, "ResponseStatusCode argument missing\n");
            s->is_set_response_status_code = 1;
            s->response_status_code = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Log'\n", str);
	}
	return 0;
}

int maintenance_event_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct maintenance_event *s = v_s;
	if (!argcmp(str, "Code")) {
            TRY(!aa, "Code argument missing\n");
            s->code = aa; // string string

         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "NotAfter")) {
            TRY(!aa, "NotAfter argument missing\n");
            s->not_after = aa; // string string

         } else
	if (!argcmp(str, "NotBefore")) {
            TRY(!aa, "NotBefore argument missing\n");
            s->not_before = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'MaintenanceEvent'\n", str);
	}
	return 0;
}

int nat_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct nat_service *s = v_s;
	if (!argcmp(str, "NatServiceId")) {
            TRY(!aa, "NatServiceId argument missing\n");
            s->nat_service_id = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "PublicIps")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'PublicIps' require an index (example array ref PublicIpLight.PublicIps.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'PublicIps' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,public_ips, pa, pos, sizeof(*s->public_ips));
            	      cascade_struct = &s->public_ips[pos];
            	      cascade_parser = public_ip_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      public_ip_light_parser(&s->public_ips[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "PublicIps argument missing\n");
            	s->public_ips_str = aa; // array ref PublicIpLight ref
            }
         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "SubnetId")) {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NatService'\n", str);
	}
	return 0;
}

int net_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net *s = v_s;
	if (!argcmp(str, "DhcpOptionsSetId")) {
            TRY(!aa, "DhcpOptionsSetId argument missing\n");
            s->dhcp_options_set_id = aa; // string string

         } else
	if (!argcmp(str, "IpRange")) {
            TRY(!aa, "IpRange argument missing\n");
            s->ip_range = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "Tenancy")) {
            TRY(!aa, "Tenancy argument missing\n");
            s->tenancy = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Net'\n", str);
	}
	return 0;
}

int net_access_point_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net_access_point *s = v_s;
	if (!argcmp(str, "NetAccessPointId")) {
            TRY(!aa, "NetAccessPointId argument missing\n");
            s->net_access_point_id = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "RouteTableIds")) {
            	 TRY(!aa, "RouteTableIds argument missing\n");
               s->route_table_ids_str = aa;
         } else if (!strcmp(str, "RouteTableIds[]")) {
               TRY(!aa, "RouteTableIds[] argument missing\n");
               SET_NEXT(s->route_table_ids, (aa), pa);
         } else
	if (!argcmp(str, "ServiceName")) {
            TRY(!aa, "ServiceName argument missing\n");
            s->service_name = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NetAccessPoint'\n", str);
	}
	return 0;
}

int net_peering_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net_peering *s = v_s;
	if (!argcmp(str, "AccepterNet")) {
            char *dot_pos;

            TRY(!aa, "AccepterNet argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->accepter_net;
            	    cascade_parser = accepter_net_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    accepter_net_parser(&s->accepter_net, dot_pos, aa, pa);
            	    s->is_set_accepter_net = 1;
             } else {
                   s->accepter_net_str = aa;
             }
         } else
	if (!argcmp(str, "NetPeeringId")) {
            TRY(!aa, "NetPeeringId argument missing\n");
            s->net_peering_id = aa; // string string

         } else
	if (!argcmp(str, "SourceNet")) {
            char *dot_pos;

            TRY(!aa, "SourceNet argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->source_net;
            	    cascade_parser = source_net_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    source_net_parser(&s->source_net, dot_pos, aa, pa);
            	    s->is_set_source_net = 1;
             } else {
                   s->source_net_str = aa;
             }
         } else
	if (!argcmp(str, "State")) {
            char *dot_pos;

            TRY(!aa, "State argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->state;
            	    cascade_parser = net_peering_state_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    net_peering_state_parser(&s->state, dot_pos, aa, pa);
            	    s->is_set_state = 1;
             } else {
                   s->state_str = aa;
             }
         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NetPeering'\n", str);
	}
	return 0;
}

int net_peering_state_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net_peering_state *s = v_s;
	if (!argcmp(str, "Message")) {
            TRY(!aa, "Message argument missing\n");
            s->message = aa; // string string

         } else
	if (!argcmp(str, "Name")) {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NetPeeringState'\n", str);
	}
	return 0;
}

int net_to_virtual_gateway_link_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net_to_virtual_gateway_link *s = v_s;
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NetToVirtualGatewayLink'\n", str);
	}
	return 0;
}

int nic_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct nic *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "IsSourceDestChecked")) {
            s->is_set_is_source_dest_checked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_checked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_checked = 0;
             } else {
            		fprintf(stderr, "IsSourceDestChecked require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkNic")) {
            char *dot_pos;

            TRY(!aa, "LinkNic argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_nic;
            	    cascade_parser = link_nic_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    link_nic_parser(&s->link_nic, dot_pos, aa, pa);
            	    s->is_set_link_nic = 1;
             } else {
                   s->link_nic_str = aa;
             }
         } else
	if (!argcmp(str, "LinkPublicIp")) {
            char *dot_pos;

            TRY(!aa, "LinkPublicIp argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_public_ip;
            	    cascade_parser = link_public_ip_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    link_public_ip_parser(&s->link_public_ip, dot_pos, aa, pa);
            	    s->is_set_link_public_ip = 1;
             } else {
                   s->link_public_ip_str = aa;
             }
         } else
	if (!argcmp(str, "MacAddress")) {
            TRY(!aa, "MacAddress argument missing\n");
            s->mac_address = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "NicId")) {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if (!argcmp(str, "PrivateDnsName")) {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if (!argcmp(str, "PrivateIps")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'PrivateIps' require an index (example array ref PrivateIp.PrivateIps.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'PrivateIps' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,private_ips, pa, pos, sizeof(*s->private_ips));
            	      cascade_struct = &s->private_ips[pos];
            	      cascade_parser = private_ip_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      private_ip_parser(&s->private_ips[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "PrivateIps argument missing\n");
            	s->private_ips_str = aa; // array ref PrivateIp ref
            }
         } else
	if (!argcmp(str, "SecurityGroups")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'SecurityGroups' require an index (example array ref SecurityGroupLight.SecurityGroups.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'SecurityGroups' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,security_groups, pa, pos, sizeof(*s->security_groups));
            	      cascade_struct = &s->security_groups[pos];
            	      cascade_parser = security_group_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      security_group_light_parser(&s->security_groups[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "SecurityGroups argument missing\n");
            	s->security_groups_str = aa; // array ref SecurityGroupLight ref
            }
         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "SubnetId")) {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Nic'\n", str);
	}
	return 0;
}

int nic_for_vm_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct nic_for_vm_creation *s = v_s;
	if (!argcmp(str, "DeleteOnVmDeletion")) {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "DeviceNumber")) {
            TRY(!aa, "DeviceNumber argument missing\n");
            s->is_set_device_number = 1;
            s->device_number = atoi(aa);
         } else
	if (!argcmp(str, "NicId")) {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if (!argcmp(str, "PrivateIps")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'PrivateIps' require an index (example array ref PrivateIpLight.PrivateIps.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'PrivateIps' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,private_ips, pa, pos, sizeof(*s->private_ips));
            	      cascade_struct = &s->private_ips[pos];
            	      cascade_parser = private_ip_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      private_ip_light_parser(&s->private_ips[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "PrivateIps argument missing\n");
            	s->private_ips_str = aa; // array ref PrivateIpLight ref
            }
         } else
	if (!argcmp(str, "SecondaryPrivateIpCount")) {
            TRY(!aa, "SecondaryPrivateIpCount argument missing\n");
            s->is_set_secondary_private_ip_count = 1;
            s->secondary_private_ip_count = atoi(aa);
         } else
	if (!argcmp(str, "SecurityGroupIds")) {
            	 TRY(!aa, "SecurityGroupIds argument missing\n");
               s->security_group_ids_str = aa;
         } else if (!strcmp(str, "SecurityGroupIds[]")) {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if (!argcmp(str, "SubnetId")) {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NicForVmCreation'\n", str);
	}
	return 0;
}

int nic_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct nic_light *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "IsSourceDestChecked")) {
            s->is_set_is_source_dest_checked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_checked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_checked = 0;
             } else {
            		fprintf(stderr, "IsSourceDestChecked require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkNic")) {
            char *dot_pos;

            TRY(!aa, "LinkNic argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_nic;
            	    cascade_parser = link_nic_light_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    link_nic_light_parser(&s->link_nic, dot_pos, aa, pa);
            	    s->is_set_link_nic = 1;
             } else {
                   s->link_nic_str = aa;
             }
         } else
	if (!argcmp(str, "LinkPublicIp")) {
            char *dot_pos;

            TRY(!aa, "LinkPublicIp argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_public_ip;
            	    cascade_parser = link_public_ip_light_for_vm_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    link_public_ip_light_for_vm_parser(&s->link_public_ip, dot_pos, aa, pa);
            	    s->is_set_link_public_ip = 1;
             } else {
                   s->link_public_ip_str = aa;
             }
         } else
	if (!argcmp(str, "MacAddress")) {
            TRY(!aa, "MacAddress argument missing\n");
            s->mac_address = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "NicId")) {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if (!argcmp(str, "PrivateDnsName")) {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if (!argcmp(str, "PrivateIps")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'PrivateIps' require an index (example array ref PrivateIpLightForVm.PrivateIps.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'PrivateIps' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,private_ips, pa, pos, sizeof(*s->private_ips));
            	      cascade_struct = &s->private_ips[pos];
            	      cascade_parser = private_ip_light_for_vm_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      private_ip_light_for_vm_parser(&s->private_ips[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "PrivateIps argument missing\n");
            	s->private_ips_str = aa; // array ref PrivateIpLightForVm ref
            }
         } else
	if (!argcmp(str, "SecurityGroups")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'SecurityGroups' require an index (example array ref SecurityGroupLight.SecurityGroups.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'SecurityGroups' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,security_groups, pa, pos, sizeof(*s->security_groups));
            	      cascade_struct = &s->security_groups[pos];
            	      cascade_parser = security_group_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      security_group_light_parser(&s->security_groups[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "SecurityGroups argument missing\n");
            	s->security_groups_str = aa; // array ref SecurityGroupLight ref
            }
         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "SubnetId")) {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NicLight'\n", str);
	}
	return 0;
}

int osu_api_key_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct osu_api_key *s = v_s;
	if (!argcmp(str, "ApiKeyId")) {
            TRY(!aa, "ApiKeyId argument missing\n");
            s->api_key_id = aa; // string string

         } else
	if (!argcmp(str, "SecretKey")) {
            TRY(!aa, "SecretKey argument missing\n");
            s->secret_key = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'OsuApiKey'\n", str);
	}
	return 0;
}

int osu_export_image_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct osu_export_image_export_task *s = v_s;
	if (!argcmp(str, "DiskImageFormat")) {
            TRY(!aa, "DiskImageFormat argument missing\n");
            s->disk_image_format = aa; // string string

         } else
	if (!argcmp(str, "OsuBucket")) {
            TRY(!aa, "OsuBucket argument missing\n");
            s->osu_bucket = aa; // string string

         } else
	if (!argcmp(str, "OsuManifestUrl")) {
            TRY(!aa, "OsuManifestUrl argument missing\n");
            s->osu_manifest_url = aa; // string string

         } else
	if (!argcmp(str, "OsuPrefix")) {
            TRY(!aa, "OsuPrefix argument missing\n");
            s->osu_prefix = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'OsuExportImageExportTask'\n", str);
	}
	return 0;
}

int osu_export_snapshot_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct osu_export_snapshot_export_task *s = v_s;
	if (!argcmp(str, "DiskImageFormat")) {
            TRY(!aa, "DiskImageFormat argument missing\n");
            s->disk_image_format = aa; // string string

         } else
	if (!argcmp(str, "OsuBucket")) {
            TRY(!aa, "OsuBucket argument missing\n");
            s->osu_bucket = aa; // string string

         } else
	if (!argcmp(str, "OsuPrefix")) {
            TRY(!aa, "OsuPrefix argument missing\n");
            s->osu_prefix = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'OsuExportSnapshotExportTask'\n", str);
	}
	return 0;
}

int osu_export_to_create_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct osu_export_to_create *s = v_s;
	if (!argcmp(str, "DiskImageFormat")) {
            TRY(!aa, "DiskImageFormat argument missing\n");
            s->disk_image_format = aa; // string string

         } else
	if (!argcmp(str, "OsuApiKey")) {
            char *dot_pos;

            TRY(!aa, "OsuApiKey argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->osu_api_key;
            	    cascade_parser = osu_api_key_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    osu_api_key_parser(&s->osu_api_key, dot_pos, aa, pa);
            	    s->is_set_osu_api_key = 1;
             } else {
                   s->osu_api_key_str = aa;
             }
         } else
	if (!argcmp(str, "OsuBucket")) {
            TRY(!aa, "OsuBucket argument missing\n");
            s->osu_bucket = aa; // string string

         } else
	if (!argcmp(str, "OsuManifestUrl")) {
            TRY(!aa, "OsuManifestUrl argument missing\n");
            s->osu_manifest_url = aa; // string string

         } else
	if (!argcmp(str, "OsuPrefix")) {
            TRY(!aa, "OsuPrefix argument missing\n");
            s->osu_prefix = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'OsuExportToCreate'\n", str);
	}
	return 0;
}

int permissions_on_resource_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct permissions_on_resource *s = v_s;
	if (!argcmp(str, "AccountIds")) {
            	 TRY(!aa, "AccountIds argument missing\n");
               s->account_ids_str = aa;
         } else if (!strcmp(str, "AccountIds[]")) {
               TRY(!aa, "AccountIds[] argument missing\n");
               SET_NEXT(s->account_ids, (aa), pa);
         } else
	if (!argcmp(str, "GlobalPermission")) {
            s->is_set_global_permission = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->global_permission = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->global_permission = 0;
             } else {
            		fprintf(stderr, "GlobalPermission require true/false\n");
            		return 1;
             }
        } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PermissionsOnResource'\n", str);
	}
	return 0;
}

int permissions_on_resource_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct permissions_on_resource_creation *s = v_s;
	if (!argcmp(str, "Additions")) {
            char *dot_pos;

            TRY(!aa, "Additions argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->additions;
            	    cascade_parser = permissions_on_resource_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    permissions_on_resource_parser(&s->additions, dot_pos, aa, pa);
            	    s->is_set_additions = 1;
             } else {
                   s->additions_str = aa;
             }
         } else
	if (!argcmp(str, "Removals")) {
            char *dot_pos;

            TRY(!aa, "Removals argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->removals;
            	    cascade_parser = permissions_on_resource_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    permissions_on_resource_parser(&s->removals, dot_pos, aa, pa);
            	    s->is_set_removals = 1;
             } else {
                   s->removals_str = aa;
             }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PermissionsOnResourceCreation'\n", str);
	}
	return 0;
}

int phase1_options_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct phase1_options *s = v_s;
	if (!argcmp(str, "DpdTimeoutAction")) {
            TRY(!aa, "DpdTimeoutAction argument missing\n");
            s->dpd_timeout_action = aa; // string string

         } else
	if (!argcmp(str, "DpdTimeoutSeconds")) {
            TRY(!aa, "DpdTimeoutSeconds argument missing\n");
            s->is_set_dpd_timeout_seconds = 1;
            s->dpd_timeout_seconds = atoi(aa);
         } else
	if (!argcmp(str, "IkeVersions")) {
            	 TRY(!aa, "IkeVersions argument missing\n");
               s->ike_versions_str = aa;
         } else if (!strcmp(str, "IkeVersions[]")) {
               TRY(!aa, "IkeVersions[] argument missing\n");
               SET_NEXT(s->ike_versions, (aa), pa);
         } else
	if (!argcmp(str, "Phase1DhGroupNumbers")) {
            	 TRY(!aa, "Phase1DhGroupNumbers argument missing\n");
               s->phase1_dh_group_numbers_str = aa;
         } else if (!strcmp(str, "Phase1DhGroupNumbers[]")) {
               TRY(!aa, "Phase1DhGroupNumbers[] argument missing\n");
               SET_NEXT(s->phase1_dh_group_numbers, atoi(aa), pa);
         } else
	if (!argcmp(str, "Phase1EncryptionAlgorithms")) {
            	 TRY(!aa, "Phase1EncryptionAlgorithms argument missing\n");
               s->phase1_encryption_algorithms_str = aa;
         } else if (!strcmp(str, "Phase1EncryptionAlgorithms[]")) {
               TRY(!aa, "Phase1EncryptionAlgorithms[] argument missing\n");
               SET_NEXT(s->phase1_encryption_algorithms, (aa), pa);
         } else
	if (!argcmp(str, "Phase1IntegrityAlgorithms")) {
            	 TRY(!aa, "Phase1IntegrityAlgorithms argument missing\n");
               s->phase1_integrity_algorithms_str = aa;
         } else if (!strcmp(str, "Phase1IntegrityAlgorithms[]")) {
               TRY(!aa, "Phase1IntegrityAlgorithms[] argument missing\n");
               SET_NEXT(s->phase1_integrity_algorithms, (aa), pa);
         } else
	if (!argcmp(str, "Phase1LifetimeSeconds")) {
            TRY(!aa, "Phase1LifetimeSeconds argument missing\n");
            s->is_set_phase1_lifetime_seconds = 1;
            s->phase1_lifetime_seconds = atoi(aa);
         } else
	if (!argcmp(str, "ReplayWindowSize")) {
            TRY(!aa, "ReplayWindowSize argument missing\n");
            s->is_set_replay_window_size = 1;
            s->replay_window_size = atoi(aa);
         } else
	if (!argcmp(str, "StartupAction")) {
            TRY(!aa, "StartupAction argument missing\n");
            s->startup_action = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Phase1Options'\n", str);
	}
	return 0;
}

int phase2_options_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct phase2_options *s = v_s;
	if (!argcmp(str, "Phase2DhGroupNumbers")) {
            	 TRY(!aa, "Phase2DhGroupNumbers argument missing\n");
               s->phase2_dh_group_numbers_str = aa;
         } else if (!strcmp(str, "Phase2DhGroupNumbers[]")) {
               TRY(!aa, "Phase2DhGroupNumbers[] argument missing\n");
               SET_NEXT(s->phase2_dh_group_numbers, atoi(aa), pa);
         } else
	if (!argcmp(str, "Phase2EncryptionAlgorithms")) {
            	 TRY(!aa, "Phase2EncryptionAlgorithms argument missing\n");
               s->phase2_encryption_algorithms_str = aa;
         } else if (!strcmp(str, "Phase2EncryptionAlgorithms[]")) {
               TRY(!aa, "Phase2EncryptionAlgorithms[] argument missing\n");
               SET_NEXT(s->phase2_encryption_algorithms, (aa), pa);
         } else
	if (!argcmp(str, "Phase2IntegrityAlgorithms")) {
            	 TRY(!aa, "Phase2IntegrityAlgorithms argument missing\n");
               s->phase2_integrity_algorithms_str = aa;
         } else if (!strcmp(str, "Phase2IntegrityAlgorithms[]")) {
               TRY(!aa, "Phase2IntegrityAlgorithms[] argument missing\n");
               SET_NEXT(s->phase2_integrity_algorithms, (aa), pa);
         } else
	if (!argcmp(str, "Phase2LifetimeSeconds")) {
            TRY(!aa, "Phase2LifetimeSeconds argument missing\n");
            s->is_set_phase2_lifetime_seconds = 1;
            s->phase2_lifetime_seconds = atoi(aa);
         } else
	if (!argcmp(str, "PreSharedKey")) {
            TRY(!aa, "PreSharedKey argument missing\n");
            s->pre_shared_key = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Phase2Options'\n", str);
	}
	return 0;
}

int placement_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct placement *s = v_s;
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if (!argcmp(str, "Tenancy")) {
            TRY(!aa, "Tenancy argument missing\n");
            s->tenancy = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Placement'\n", str);
	}
	return 0;
}

int private_ip_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct private_ip *s = v_s;
	if (!argcmp(str, "IsPrimary")) {
            s->is_set_is_primary = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_primary = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_primary = 0;
             } else {
            		fprintf(stderr, "IsPrimary require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkPublicIp")) {
            char *dot_pos;

            TRY(!aa, "LinkPublicIp argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_public_ip;
            	    cascade_parser = link_public_ip_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    link_public_ip_parser(&s->link_public_ip, dot_pos, aa, pa);
            	    s->is_set_link_public_ip = 1;
             } else {
                   s->link_public_ip_str = aa;
             }
         } else
	if (!argcmp(str, "PrivateDnsName")) {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if (!argcmp(str, "PrivateIp")) {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PrivateIp'\n", str);
	}
	return 0;
}

int private_ip_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct private_ip_light *s = v_s;
	if (!argcmp(str, "IsPrimary")) {
            s->is_set_is_primary = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_primary = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_primary = 0;
             } else {
            		fprintf(stderr, "IsPrimary require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "PrivateIp")) {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PrivateIpLight'\n", str);
	}
	return 0;
}

int private_ip_light_for_vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct private_ip_light_for_vm *s = v_s;
	if (!argcmp(str, "IsPrimary")) {
            s->is_set_is_primary = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_primary = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_primary = 0;
             } else {
            		fprintf(stderr, "IsPrimary require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "LinkPublicIp")) {
            char *dot_pos;

            TRY(!aa, "LinkPublicIp argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_public_ip;
            	    cascade_parser = link_public_ip_light_for_vm_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    link_public_ip_light_for_vm_parser(&s->link_public_ip, dot_pos, aa, pa);
            	    s->is_set_link_public_ip = 1;
             } else {
                   s->link_public_ip_str = aa;
             }
         } else
	if (!argcmp(str, "PrivateDnsName")) {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if (!argcmp(str, "PrivateIp")) {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PrivateIpLightForVm'\n", str);
	}
	return 0;
}

int product_type_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct product_type *s = v_s;
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "ProductTypeId")) {
            TRY(!aa, "ProductTypeId argument missing\n");
            s->product_type_id = aa; // string string

         } else
	if (!argcmp(str, "Vendor")) {
            TRY(!aa, "Vendor argument missing\n");
            s->vendor = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ProductType'\n", str);
	}
	return 0;
}

int public_ip_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct public_ip *s = v_s;
	if (!argcmp(str, "LinkPublicIpId")) {
            TRY(!aa, "LinkPublicIpId argument missing\n");
            s->link_public_ip_id = aa; // string string

         } else
	if (!argcmp(str, "NicAccountId")) {
            TRY(!aa, "NicAccountId argument missing\n");
            s->nic_account_id = aa; // string string

         } else
	if (!argcmp(str, "NicId")) {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if (!argcmp(str, "PrivateIp")) {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	if (!argcmp(str, "PublicIp")) {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if (!argcmp(str, "PublicIpId")) {
            TRY(!aa, "PublicIpId argument missing\n");
            s->public_ip_id = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PublicIp'\n", str);
	}
	return 0;
}

int public_ip_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct public_ip_light *s = v_s;
	if (!argcmp(str, "PublicIp")) {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if (!argcmp(str, "PublicIpId")) {
            TRY(!aa, "PublicIpId argument missing\n");
            s->public_ip_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PublicIpLight'\n", str);
	}
	return 0;
}

int quota_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct quota *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "MaxValue")) {
            TRY(!aa, "MaxValue argument missing\n");
            s->is_set_max_value = 1;
            s->max_value = atoi(aa);
         } else
	if (!argcmp(str, "Name")) {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	if (!argcmp(str, "QuotaCollection")) {
            TRY(!aa, "QuotaCollection argument missing\n");
            s->quota_collection = aa; // string string

         } else
	if (!argcmp(str, "ShortDescription")) {
            TRY(!aa, "ShortDescription argument missing\n");
            s->short_description = aa; // string string

         } else
	if (!argcmp(str, "UsedValue")) {
            TRY(!aa, "UsedValue argument missing\n");
            s->is_set_used_value = 1;
            s->used_value = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Quota'\n", str);
	}
	return 0;
}

int quota_types_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct quota_types *s = v_s;
	if (!argcmp(str, "QuotaType")) {
            TRY(!aa, "QuotaType argument missing\n");
            s->quota_type = aa; // string string

         } else
	if (!argcmp(str, "Quotas")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Quotas' require an index (example array ref Quota.Quotas.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Quotas' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,quotas, pa, pos, sizeof(*s->quotas));
            	      cascade_struct = &s->quotas[pos];
            	      cascade_parser = quota_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      quota_parser(&s->quotas[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Quotas argument missing\n");
            	s->quotas_str = aa; // array ref Quota ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'QuotaTypes'\n", str);
	}
	return 0;
}

int region_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct region *s = v_s;
	if (!argcmp(str, "Endpoint")) {
            TRY(!aa, "Endpoint argument missing\n");
            s->endpoint = aa; // string string

         } else
	if (!argcmp(str, "RegionName")) {
            TRY(!aa, "RegionName argument missing\n");
            s->region_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Region'\n", str);
	}
	return 0;
}

int resource_load_balancer_tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct resource_load_balancer_tag *s = v_s;
	if (!argcmp(str, "Key")) {
            TRY(!aa, "Key argument missing\n");
            s->key = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ResourceLoadBalancerTag'\n", str);
	}
	return 0;
}

int resource_tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct resource_tag *s = v_s;
	if (!argcmp(str, "Key")) {
            TRY(!aa, "Key argument missing\n");
            s->key = aa; // string string

         } else
	if (!argcmp(str, "Value")) {
            TRY(!aa, "Value argument missing\n");
            s->value = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ResourceTag'\n", str);
	}
	return 0;
}

int route_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct route *s = v_s;
	if (!argcmp(str, "CreationMethod")) {
            TRY(!aa, "CreationMethod argument missing\n");
            s->creation_method = aa; // string string

         } else
	if (!argcmp(str, "DestinationIpRange")) {
            TRY(!aa, "DestinationIpRange argument missing\n");
            s->destination_ip_range = aa; // string string

         } else
	if (!argcmp(str, "DestinationServiceId")) {
            TRY(!aa, "DestinationServiceId argument missing\n");
            s->destination_service_id = aa; // string string

         } else
	if (!argcmp(str, "GatewayId")) {
            TRY(!aa, "GatewayId argument missing\n");
            s->gateway_id = aa; // string string

         } else
	if (!argcmp(str, "NatServiceId")) {
            TRY(!aa, "NatServiceId argument missing\n");
            s->nat_service_id = aa; // string string

         } else
	if (!argcmp(str, "NetAccessPointId")) {
            TRY(!aa, "NetAccessPointId argument missing\n");
            s->net_access_point_id = aa; // string string

         } else
	if (!argcmp(str, "NetPeeringId")) {
            TRY(!aa, "NetPeeringId argument missing\n");
            s->net_peering_id = aa; // string string

         } else
	if (!argcmp(str, "NicId")) {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "VmAccountId")) {
            TRY(!aa, "VmAccountId argument missing\n");
            s->vm_account_id = aa; // string string

         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Route'\n", str);
	}
	return 0;
}

int route_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct route_light *s = v_s;
	if (!argcmp(str, "DestinationIpRange")) {
            TRY(!aa, "DestinationIpRange argument missing\n");
            s->destination_ip_range = aa; // string string

         } else
	if (!argcmp(str, "RouteType")) {
            TRY(!aa, "RouteType argument missing\n");
            s->route_type = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'RouteLight'\n", str);
	}
	return 0;
}

int route_propagating_virtual_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct route_propagating_virtual_gateway *s = v_s;
	if (!argcmp(str, "VirtualGatewayId")) {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'RoutePropagatingVirtualGateway'\n", str);
	}
	return 0;
}

int route_table_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct route_table *s = v_s;
	if (!argcmp(str, "LinkRouteTables")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'LinkRouteTables' require an index (example array ref LinkRouteTable.LinkRouteTables.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'LinkRouteTables' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,link_route_tables, pa, pos, sizeof(*s->link_route_tables));
            	      cascade_struct = &s->link_route_tables[pos];
            	      cascade_parser = link_route_table_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      link_route_table_parser(&s->link_route_tables[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "LinkRouteTables argument missing\n");
            	s->link_route_tables_str = aa; // array ref LinkRouteTable ref
            }
         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "RoutePropagatingVirtualGateways")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'RoutePropagatingVirtualGateways' require an index (example array ref RoutePropagatingVirtualGateway.RoutePropagatingVirtualGateways.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'RoutePropagatingVirtualGateways' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,route_propagating_virtual_gateways, pa, pos, sizeof(*s->route_propagating_virtual_gateways));
            	      cascade_struct = &s->route_propagating_virtual_gateways[pos];
            	      cascade_parser = route_propagating_virtual_gateway_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      route_propagating_virtual_gateway_parser(&s->route_propagating_virtual_gateways[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "RoutePropagatingVirtualGateways argument missing\n");
            	s->route_propagating_virtual_gateways_str = aa; // array ref RoutePropagatingVirtualGateway ref
            }
         } else
	if (!argcmp(str, "RouteTableId")) {
            TRY(!aa, "RouteTableId argument missing\n");
            s->route_table_id = aa; // string string

         } else
	if (!argcmp(str, "Routes")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Routes' require an index (example array ref Route.Routes.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Routes' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,routes, pa, pos, sizeof(*s->routes));
            	      cascade_struct = &s->routes[pos];
            	      cascade_parser = route_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      route_parser(&s->routes[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Routes argument missing\n");
            	s->routes_str = aa; // array ref Route ref
            }
         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'RouteTable'\n", str);
	}
	return 0;
}

int security_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct security_group *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "InboundRules")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'InboundRules' require an index (example array ref SecurityGroupRule.InboundRules.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'InboundRules' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,inbound_rules, pa, pos, sizeof(*s->inbound_rules));
            	      cascade_struct = &s->inbound_rules[pos];
            	      cascade_parser = security_group_rule_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      security_group_rule_parser(&s->inbound_rules[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "InboundRules argument missing\n");
            	s->inbound_rules_str = aa; // array ref SecurityGroupRule ref
            }
         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "OutboundRules")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'OutboundRules' require an index (example array ref SecurityGroupRule.OutboundRules.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'OutboundRules' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,outbound_rules, pa, pos, sizeof(*s->outbound_rules));
            	      cascade_struct = &s->outbound_rules[pos];
            	      cascade_parser = security_group_rule_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      security_group_rule_parser(&s->outbound_rules[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "OutboundRules argument missing\n");
            	s->outbound_rules_str = aa; // array ref SecurityGroupRule ref
            }
         } else
	if (!argcmp(str, "SecurityGroupId")) {
            TRY(!aa, "SecurityGroupId argument missing\n");
            s->security_group_id = aa; // string string

         } else
	if (!argcmp(str, "SecurityGroupName")) {
            TRY(!aa, "SecurityGroupName argument missing\n");
            s->security_group_name = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SecurityGroup'\n", str);
	}
	return 0;
}

int security_group_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct security_group_light *s = v_s;
	if (!argcmp(str, "SecurityGroupId")) {
            TRY(!aa, "SecurityGroupId argument missing\n");
            s->security_group_id = aa; // string string

         } else
	if (!argcmp(str, "SecurityGroupName")) {
            TRY(!aa, "SecurityGroupName argument missing\n");
            s->security_group_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SecurityGroupLight'\n", str);
	}
	return 0;
}

int security_group_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct security_group_rule *s = v_s;
	if (!argcmp(str, "FromPortRange")) {
            TRY(!aa, "FromPortRange argument missing\n");
            s->is_set_from_port_range = 1;
            s->from_port_range = atoi(aa);
         } else
	if (!argcmp(str, "IpProtocol")) {
            TRY(!aa, "IpProtocol argument missing\n");
            s->ip_protocol = aa; // string string

         } else
	if (!argcmp(str, "IpRanges")) {
            	 TRY(!aa, "IpRanges argument missing\n");
               s->ip_ranges_str = aa;
         } else if (!strcmp(str, "IpRanges[]")) {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "SecurityGroupsMembers")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'SecurityGroupsMembers' require an index (example array ref SecurityGroupsMember.SecurityGroupsMembers.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'SecurityGroupsMembers' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,security_groups_members, pa, pos, sizeof(*s->security_groups_members));
            	      cascade_struct = &s->security_groups_members[pos];
            	      cascade_parser = security_groups_member_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      security_groups_member_parser(&s->security_groups_members[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "SecurityGroupsMembers argument missing\n");
            	s->security_groups_members_str = aa; // array ref SecurityGroupsMember ref
            }
         } else
	if (!argcmp(str, "ServiceIds")) {
            	 TRY(!aa, "ServiceIds argument missing\n");
               s->service_ids_str = aa;
         } else if (!strcmp(str, "ServiceIds[]")) {
               TRY(!aa, "ServiceIds[] argument missing\n");
               SET_NEXT(s->service_ids, (aa), pa);
         } else
	if (!argcmp(str, "ToPortRange")) {
            TRY(!aa, "ToPortRange argument missing\n");
            s->is_set_to_port_range = 1;
            s->to_port_range = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SecurityGroupRule'\n", str);
	}
	return 0;
}

int security_groups_member_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct security_groups_member *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "SecurityGroupId")) {
            TRY(!aa, "SecurityGroupId argument missing\n");
            s->security_group_id = aa; // string string

         } else
	if (!argcmp(str, "SecurityGroupName")) {
            TRY(!aa, "SecurityGroupName argument missing\n");
            s->security_group_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SecurityGroupsMember'\n", str);
	}
	return 0;
}

int server_certificate_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct server_certificate *s = v_s;
	if (!argcmp(str, "ExpirationDate")) {
            TRY(!aa, "ExpirationDate argument missing\n");
            s->expiration_date = aa; // string string

         } else
	if (!argcmp(str, "Id")) {
            TRY(!aa, "Id argument missing\n");
            s->id = aa; // string string

         } else
	if (!argcmp(str, "Name")) {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	if (!argcmp(str, "Orn")) {
            TRY(!aa, "Orn argument missing\n");
            s->orn = aa; // string string

         } else
	if (!argcmp(str, "Path")) {
            TRY(!aa, "Path argument missing\n");
            s->path = aa; // string string

         } else
	if (!argcmp(str, "UploadDate")) {
            TRY(!aa, "UploadDate argument missing\n");
            s->upload_date = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ServerCertificate'\n", str);
	}
	return 0;
}

int service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct service *s = v_s;
	if (!argcmp(str, "IpRanges")) {
            	 TRY(!aa, "IpRanges argument missing\n");
               s->ip_ranges_str = aa;
         } else if (!strcmp(str, "IpRanges[]")) {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	if (!argcmp(str, "ServiceId")) {
            TRY(!aa, "ServiceId argument missing\n");
            s->service_id = aa; // string string

         } else
	if (!argcmp(str, "ServiceName")) {
            TRY(!aa, "ServiceName argument missing\n");
            s->service_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Service'\n", str);
	}
	return 0;
}

int snapshot_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct snapshot *s = v_s;
	if (!argcmp(str, "AccountAlias")) {
            TRY(!aa, "AccountAlias argument missing\n");
            s->account_alias = aa; // string string

         } else
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "CreationDate")) {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if (!argcmp(str, "Description")) {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if (!argcmp(str, "PermissionsToCreateVolume")) {
            char *dot_pos;

            TRY(!aa, "PermissionsToCreateVolume argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->permissions_to_create_volume;
            	    cascade_parser = permissions_on_resource_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    permissions_on_resource_parser(&s->permissions_to_create_volume, dot_pos, aa, pa);
            	    s->is_set_permissions_to_create_volume = 1;
             } else {
                   s->permissions_to_create_volume_str = aa;
             }
         } else
	if (!argcmp(str, "Progress")) {
            TRY(!aa, "Progress argument missing\n");
            s->is_set_progress = 1;
            s->progress = atoi(aa);
         } else
	if (!argcmp(str, "SnapshotId")) {
            TRY(!aa, "SnapshotId argument missing\n");
            s->snapshot_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "VolumeId")) {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	if (!argcmp(str, "VolumeSize")) {
            TRY(!aa, "VolumeSize argument missing\n");
            s->is_set_volume_size = 1;
            s->volume_size = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Snapshot'\n", str);
	}
	return 0;
}

int snapshot_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct snapshot_export_task *s = v_s;
	if (!argcmp(str, "Comment")) {
            TRY(!aa, "Comment argument missing\n");
            s->comment = aa; // string string

         } else
	if (!argcmp(str, "OsuExport")) {
            char *dot_pos;

            TRY(!aa, "OsuExport argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->osu_export;
            	    cascade_parser = osu_export_snapshot_export_task_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    osu_export_snapshot_export_task_parser(&s->osu_export, dot_pos, aa, pa);
            	    s->is_set_osu_export = 1;
             } else {
                   s->osu_export_str = aa;
             }
         } else
	if (!argcmp(str, "Progress")) {
            TRY(!aa, "Progress argument missing\n");
            s->is_set_progress = 1;
            s->progress = atoi(aa);
         } else
	if (!argcmp(str, "SnapshotId")) {
            TRY(!aa, "SnapshotId argument missing\n");
            s->snapshot_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "TaskId")) {
            TRY(!aa, "TaskId argument missing\n");
            s->task_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SnapshotExportTask'\n", str);
	}
	return 0;
}

int source_net_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct source_net *s = v_s;
	if (!argcmp(str, "AccountId")) {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if (!argcmp(str, "IpRange")) {
            TRY(!aa, "IpRange argument missing\n");
            s->ip_range = aa; // string string

         } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SourceNet'\n", str);
	}
	return 0;
}

int source_security_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct source_security_group *s = v_s;
	if (!argcmp(str, "SecurityGroupAccountId")) {
            TRY(!aa, "SecurityGroupAccountId argument missing\n");
            s->security_group_account_id = aa; // string string

         } else
	if (!argcmp(str, "SecurityGroupName")) {
            TRY(!aa, "SecurityGroupName argument missing\n");
            s->security_group_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SourceSecurityGroup'\n", str);
	}
	return 0;
}

int state_comment_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct state_comment *s = v_s;
	if (!argcmp(str, "StateCode")) {
            TRY(!aa, "StateCode argument missing\n");
            s->state_code = aa; // string string

         } else
	if (!argcmp(str, "StateMessage")) {
            TRY(!aa, "StateMessage argument missing\n");
            s->state_message = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'StateComment'\n", str);
	}
	return 0;
}

int subnet_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct subnet *s = v_s;
	if (!argcmp(str, "AvailableIpsCount")) {
            TRY(!aa, "AvailableIpsCount argument missing\n");
            s->is_set_available_ips_count = 1;
            s->available_ips_count = atoi(aa);
         } else
	if (!argcmp(str, "IpRange")) {
            TRY(!aa, "IpRange argument missing\n");
            s->ip_range = aa; // string string

         } else
	if (!argcmp(str, "MapPublicIpOnLaunch")) {
            s->is_set_map_public_ip_on_launch = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->map_public_ip_on_launch = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->map_public_ip_on_launch = 0;
             } else {
            		fprintf(stderr, "MapPublicIpOnLaunch require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "SubnetId")) {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Subnet'\n", str);
	}
	return 0;
}

int subregion_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct subregion *s = v_s;
	if (!argcmp(str, "LocationCode")) {
            TRY(!aa, "LocationCode argument missing\n");
            s->location_code = aa; // string string

         } else
	if (!argcmp(str, "RegionName")) {
            TRY(!aa, "RegionName argument missing\n");
            s->region_name = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Subregion'\n", str);
	}
	return 0;
}

int tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct tag *s = v_s;
	if (!argcmp(str, "Key")) {
            TRY(!aa, "Key argument missing\n");
            s->key = aa; // string string

         } else
	if (!argcmp(str, "ResourceId")) {
            TRY(!aa, "ResourceId argument missing\n");
            s->resource_id = aa; // string string

         } else
	if (!argcmp(str, "ResourceType")) {
            TRY(!aa, "ResourceType argument missing\n");
            s->resource_type = aa; // string string

         } else
	if (!argcmp(str, "Value")) {
            TRY(!aa, "Value argument missing\n");
            s->value = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Tag'\n", str);
	}
	return 0;
}

int vgw_telemetry_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vgw_telemetry *s = v_s;
	if (!argcmp(str, "AcceptedRouteCount")) {
            TRY(!aa, "AcceptedRouteCount argument missing\n");
            s->is_set_accepted_route_count = 1;
            s->accepted_route_count = atoi(aa);
         } else
	if (!argcmp(str, "LastStateChangeDate")) {
            TRY(!aa, "LastStateChangeDate argument missing\n");
            s->last_state_change_date = aa; // string string

         } else
	if (!argcmp(str, "OutsideIpAddress")) {
            TRY(!aa, "OutsideIpAddress argument missing\n");
            s->outside_ip_address = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "StateDescription")) {
            TRY(!aa, "StateDescription argument missing\n");
            s->state_description = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VgwTelemetry'\n", str);
	}
	return 0;
}

int virtual_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct virtual_gateway *s = v_s;
	if (!argcmp(str, "ConnectionType")) {
            TRY(!aa, "ConnectionType argument missing\n");
            s->connection_type = aa; // string string

         } else
	if (!argcmp(str, "NetToVirtualGatewayLinks")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'NetToVirtualGatewayLinks' require an index (example array ref NetToVirtualGatewayLink.NetToVirtualGatewayLinks.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'NetToVirtualGatewayLinks' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,net_to_virtual_gateway_links, pa, pos, sizeof(*s->net_to_virtual_gateway_links));
            	      cascade_struct = &s->net_to_virtual_gateway_links[pos];
            	      cascade_parser = net_to_virtual_gateway_link_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      net_to_virtual_gateway_link_parser(&s->net_to_virtual_gateway_links[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "NetToVirtualGatewayLinks argument missing\n");
            	s->net_to_virtual_gateway_links_str = aa; // array ref NetToVirtualGatewayLink ref
            }
         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "VirtualGatewayId")) {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VirtualGateway'\n", str);
	}
	return 0;
}

int vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm *s = v_s;
	if (!argcmp(str, "Architecture")) {
            TRY(!aa, "Architecture argument missing\n");
            s->architecture = aa; // string string

         } else
	if (!argcmp(str, "BlockDeviceMappings")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingCreated.BlockDeviceMappings.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'BlockDeviceMappings' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
            	      cascade_struct = &s->block_device_mappings[pos];
            	      cascade_parser = block_device_mapping_created_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      block_device_mapping_created_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "BlockDeviceMappings argument missing\n");
            	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingCreated ref
            }
         } else
	if (!argcmp(str, "BsuOptimized")) {
            s->is_set_bsu_optimized = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->bsu_optimized = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->bsu_optimized = 0;
             } else {
            		fprintf(stderr, "BsuOptimized require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "ClientToken")) {
            TRY(!aa, "ClientToken argument missing\n");
            s->client_token = aa; // string string

         } else
	if (!argcmp(str, "CreationDate")) {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if (!argcmp(str, "DeletionProtection")) {
            s->is_set_deletion_protection = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->deletion_protection = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->deletion_protection = 0;
             } else {
            		fprintf(stderr, "DeletionProtection require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "Hypervisor")) {
            TRY(!aa, "Hypervisor argument missing\n");
            s->hypervisor = aa; // string string

         } else
	if (!argcmp(str, "ImageId")) {
            TRY(!aa, "ImageId argument missing\n");
            s->image_id = aa; // string string

         } else
	if (!argcmp(str, "IsSourceDestChecked")) {
            s->is_set_is_source_dest_checked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_checked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_checked = 0;
             } else {
            		fprintf(stderr, "IsSourceDestChecked require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "KeypairName")) {
            TRY(!aa, "KeypairName argument missing\n");
            s->keypair_name = aa; // string string

         } else
	if (!argcmp(str, "LaunchNumber")) {
            TRY(!aa, "LaunchNumber argument missing\n");
            s->is_set_launch_number = 1;
            s->launch_number = atoi(aa);
         } else
	if (!argcmp(str, "NestedVirtualization")) {
            s->is_set_nested_virtualization = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->nested_virtualization = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->nested_virtualization = 0;
             } else {
            		fprintf(stderr, "NestedVirtualization require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "NetId")) {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if (!argcmp(str, "Nics")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Nics' require an index (example array ref NicLight.Nics.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Nics' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,nics, pa, pos, sizeof(*s->nics));
            	      cascade_struct = &s->nics[pos];
            	      cascade_parser = nic_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      nic_light_parser(&s->nics[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Nics argument missing\n");
            	s->nics_str = aa; // array ref NicLight ref
            }
         } else
	if (!argcmp(str, "OsFamily")) {
            TRY(!aa, "OsFamily argument missing\n");
            s->os_family = aa; // string string

         } else
	if (!argcmp(str, "Performance")) {
            TRY(!aa, "Performance argument missing\n");
            s->performance = aa; // string string

         } else
	if (!argcmp(str, "Placement")) {
            char *dot_pos;

            TRY(!aa, "Placement argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->placement;
            	    cascade_parser = placement_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    placement_parser(&s->placement, dot_pos, aa, pa);
            	    s->is_set_placement = 1;
             } else {
                   s->placement_str = aa;
             }
         } else
	if (!argcmp(str, "PrivateDnsName")) {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if (!argcmp(str, "PrivateIp")) {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	if (!argcmp(str, "ProductCodes")) {
            	 TRY(!aa, "ProductCodes argument missing\n");
               s->product_codes_str = aa;
         } else if (!strcmp(str, "ProductCodes[]")) {
               TRY(!aa, "ProductCodes[] argument missing\n");
               SET_NEXT(s->product_codes, (aa), pa);
         } else
	if (!argcmp(str, "PublicDnsName")) {
            TRY(!aa, "PublicDnsName argument missing\n");
            s->public_dns_name = aa; // string string

         } else
	if (!argcmp(str, "PublicIp")) {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if (!argcmp(str, "ReservationId")) {
            TRY(!aa, "ReservationId argument missing\n");
            s->reservation_id = aa; // string string

         } else
	if (!argcmp(str, "RootDeviceName")) {
            TRY(!aa, "RootDeviceName argument missing\n");
            s->root_device_name = aa; // string string

         } else
	if (!argcmp(str, "RootDeviceType")) {
            TRY(!aa, "RootDeviceType argument missing\n");
            s->root_device_type = aa; // string string

         } else
	if (!argcmp(str, "SecurityGroups")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'SecurityGroups' require an index (example array ref SecurityGroupLight.SecurityGroups.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'SecurityGroups' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,security_groups, pa, pos, sizeof(*s->security_groups));
            	      cascade_struct = &s->security_groups[pos];
            	      cascade_parser = security_group_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      security_group_light_parser(&s->security_groups[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "SecurityGroups argument missing\n");
            	s->security_groups_str = aa; // array ref SecurityGroupLight ref
            }
         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "StateReason")) {
            TRY(!aa, "StateReason argument missing\n");
            s->state_reason = aa; // string string

         } else
	if (!argcmp(str, "SubnetId")) {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "UserData")) {
            TRY(!aa, "UserData argument missing\n");
            s->user_data = aa; // string string

         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	if (!argcmp(str, "VmInitiatedShutdownBehavior")) {
            TRY(!aa, "VmInitiatedShutdownBehavior argument missing\n");
            s->vm_initiated_shutdown_behavior = aa; // string string

         } else
	if (!argcmp(str, "VmType")) {
            TRY(!aa, "VmType argument missing\n");
            s->vm_type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Vm'\n", str);
	}
	return 0;
}

int vm_state_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm_state *s = v_s;
	if (!argcmp(str, "CurrentState")) {
            TRY(!aa, "CurrentState argument missing\n");
            s->current_state = aa; // string string

         } else
	if (!argcmp(str, "PreviousState")) {
            TRY(!aa, "PreviousState argument missing\n");
            s->previous_state = aa; // string string

         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VmState'\n", str);
	}
	return 0;
}

int vm_states_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm_states *s = v_s;
	if (!argcmp(str, "MaintenanceEvents")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'MaintenanceEvents' require an index (example array ref MaintenanceEvent.MaintenanceEvents.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'MaintenanceEvents' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,maintenance_events, pa, pos, sizeof(*s->maintenance_events));
            	      cascade_struct = &s->maintenance_events[pos];
            	      cascade_parser = maintenance_event_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      maintenance_event_parser(&s->maintenance_events[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "MaintenanceEvents argument missing\n");
            	s->maintenance_events_str = aa; // array ref MaintenanceEvent ref
            }
         } else
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if (!argcmp(str, "VmId")) {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	if (!argcmp(str, "VmState")) {
            TRY(!aa, "VmState argument missing\n");
            s->vm_state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VmStates'\n", str);
	}
	return 0;
}

int vm_type_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm_type *s = v_s;
	if (!argcmp(str, "BsuOptimized")) {
            s->is_set_bsu_optimized = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->bsu_optimized = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->bsu_optimized = 0;
             } else {
            		fprintf(stderr, "BsuOptimized require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "MaxPrivateIps")) {
            TRY(!aa, "MaxPrivateIps argument missing\n");
            s->is_set_max_private_ips = 1;
            s->max_private_ips = atoi(aa);
         } else
	if (!argcmp(str, "MemorySize")) {
            TRY(!aa, "MemorySize argument missing\n");
            s->is_set_memory_size = 1;
            s->memory_size = atof(aa);
         } else
	if (!argcmp(str, "VcoreCount")) {
            TRY(!aa, "VcoreCount argument missing\n");
            s->is_set_vcore_count = 1;
            s->vcore_count = atoi(aa);
         } else
	if (!argcmp(str, "VmTypeName")) {
            TRY(!aa, "VmTypeName argument missing\n");
            s->vm_type_name = aa; // string string

         } else
	if (!argcmp(str, "VolumeCount")) {
            TRY(!aa, "VolumeCount argument missing\n");
            s->is_set_volume_count = 1;
            s->volume_count = atoi(aa);
         } else
	if (!argcmp(str, "VolumeSize")) {
            TRY(!aa, "VolumeSize argument missing\n");
            s->is_set_volume_size = 1;
            s->volume_size = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VmType'\n", str);
	}
	return 0;
}

int volume_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct volume *s = v_s;
	if (!argcmp(str, "CreationDate")) {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if (!argcmp(str, "Iops")) {
            TRY(!aa, "Iops argument missing\n");
            s->is_set_iops = 1;
            s->iops = atoi(aa);
         } else
	if (!argcmp(str, "LinkedVolumes")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'LinkedVolumes' require an index (example array ref LinkedVolume.LinkedVolumes.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'LinkedVolumes' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,linked_volumes, pa, pos, sizeof(*s->linked_volumes));
            	      cascade_struct = &s->linked_volumes[pos];
            	      cascade_parser = linked_volume_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      linked_volume_parser(&s->linked_volumes[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "LinkedVolumes argument missing\n");
            	s->linked_volumes_str = aa; // array ref LinkedVolume ref
            }
         } else
	if (!argcmp(str, "Size")) {
            TRY(!aa, "Size argument missing\n");
            s->is_set_size = 1;
            s->size = atoi(aa);
         } else
	if (!argcmp(str, "SnapshotId")) {
            TRY(!aa, "SnapshotId argument missing\n");
            s->snapshot_id = aa; // string string

         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "SubregionName")) {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "VolumeId")) {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	if (!argcmp(str, "VolumeType")) {
            TRY(!aa, "VolumeType argument missing\n");
            s->volume_type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Volume'\n", str);
	}
	return 0;
}

int vpn_connection_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vpn_connection *s = v_s;
	if (!argcmp(str, "ClientGatewayConfiguration")) {
            TRY(!aa, "ClientGatewayConfiguration argument missing\n");
            s->client_gateway_configuration = aa; // string string

         } else
	if (!argcmp(str, "ClientGatewayId")) {
            TRY(!aa, "ClientGatewayId argument missing\n");
            s->client_gateway_id = aa; // string string

         } else
	if (!argcmp(str, "ConnectionType")) {
            TRY(!aa, "ConnectionType argument missing\n");
            s->connection_type = aa; // string string

         } else
	if (!argcmp(str, "Routes")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Routes' require an index (example array ref RouteLight.Routes.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Routes' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,routes, pa, pos, sizeof(*s->routes));
            	      cascade_struct = &s->routes[pos];
            	      cascade_parser = route_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      route_light_parser(&s->routes[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Routes argument missing\n");
            	s->routes_str = aa; // array ref RouteLight ref
            }
         } else
	if (!argcmp(str, "State")) {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if (!argcmp(str, "StaticRoutesOnly")) {
            s->is_set_static_routes_only = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->static_routes_only = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->static_routes_only = 0;
             } else {
            		fprintf(stderr, "StaticRoutesOnly require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "Tags")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'Tags' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if (!argcmp(str, "VgwTelemetries")) {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos) {
            		      fprintf(stderr, "'VgwTelemetries' require an index (example array ref VgwTelemetry.VgwTelemetries.0)\n");
            		      return -1;
            	      } else if (*endptr != '.') {
            		      fprintf(stderr, "'VgwTelemetries' require a .\n");
            		      return -1;
            	      }
            	      TRY_ALLOC_AT(s,vgw_telemetries, pa, pos, sizeof(*s->vgw_telemetries));
            	      cascade_struct = &s->vgw_telemetries[pos];
            	      cascade_parser = vgw_telemetry_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      vgw_telemetry_parser(&s->vgw_telemetries[pos], endptr + 1, aa, pa);
             } else {
            	TRY(!aa, "VgwTelemetries argument missing\n");
            	s->vgw_telemetries_str = aa; // array ref VgwTelemetry ref
            }
         } else
	if (!argcmp(str, "VirtualGatewayId")) {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	if (!argcmp(str, "VpnConnectionId")) {
            TRY(!aa, "VpnConnectionId argument missing\n");
            s->vpn_connection_id = aa; // string string

         } else
	if (!argcmp(str, "VpnOptions")) {
            char *dot_pos;

            TRY(!aa, "VpnOptions argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->vpn_options;
            	    cascade_parser = vpn_options_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    vpn_options_parser(&s->vpn_options, dot_pos, aa, pa);
            	    s->is_set_vpn_options = 1;
             } else {
                   s->vpn_options_str = aa;
             }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VpnConnection'\n", str);
	}
	return 0;
}

int vpn_options_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vpn_options *s = v_s;
	if (!argcmp(str, "Phase1Options")) {
            char *dot_pos;

            TRY(!aa, "Phase1Options argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->phase1_options;
            	    cascade_parser = phase1_options_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    phase1_options_parser(&s->phase1_options, dot_pos, aa, pa);
            	    s->is_set_phase1_options = 1;
             } else {
                   s->phase1_options_str = aa;
             }
         } else
	if (!argcmp(str, "Phase2Options")) {
            char *dot_pos;

            TRY(!aa, "Phase2Options argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->phase2_options;
            	    cascade_parser = phase2_options_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    phase2_options_parser(&s->phase2_options, dot_pos, aa, pa);
            	    s->is_set_phase2_options = 1;
             } else {
                   s->phase2_options_str = aa;
             }
         } else
	if (!argcmp(str, "TunnelInsideIpRange")) {
            TRY(!aa, "TunnelInsideIpRange argument missing\n");
            s->tunnel_inside_ip_range = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VpnOptions'\n", str);
	}
	return 0;
}

int with_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct with *s = v_s;
	if (!argcmp(str, "AccountId")) {
            s->is_set_account_id = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->account_id = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->account_id = 0;
             } else {
            		fprintf(stderr, "AccountId require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "CallDuration")) {
            s->is_set_call_duration = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->call_duration = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->call_duration = 0;
             } else {
            		fprintf(stderr, "CallDuration require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryAccessKey")) {
            s->is_set_query_access_key = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_access_key = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_access_key = 0;
             } else {
            		fprintf(stderr, "QueryAccessKey require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryApiName")) {
            s->is_set_query_api_name = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_api_name = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_api_name = 0;
             } else {
            		fprintf(stderr, "QueryApiName require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryApiVersion")) {
            s->is_set_query_api_version = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_api_version = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_api_version = 0;
             } else {
            		fprintf(stderr, "QueryApiVersion require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryCallName")) {
            s->is_set_query_call_name = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_call_name = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_call_name = 0;
             } else {
            		fprintf(stderr, "QueryCallName require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryDate")) {
            s->is_set_query_date = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_date = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_date = 0;
             } else {
            		fprintf(stderr, "QueryDate require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryHeaderRaw")) {
            s->is_set_query_header_raw = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_header_raw = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_header_raw = 0;
             } else {
            		fprintf(stderr, "QueryHeaderRaw require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryHeaderSize")) {
            s->is_set_query_header_size = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_header_size = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_header_size = 0;
             } else {
            		fprintf(stderr, "QueryHeaderSize require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryIpAddress")) {
            s->is_set_query_ip_address = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_ip_address = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_ip_address = 0;
             } else {
            		fprintf(stderr, "QueryIpAddress require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryPayloadRaw")) {
            s->is_set_query_payload_raw = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_payload_raw = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_payload_raw = 0;
             } else {
            		fprintf(stderr, "QueryPayloadRaw require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryPayloadSize")) {
            s->is_set_query_payload_size = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_payload_size = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_payload_size = 0;
             } else {
            		fprintf(stderr, "QueryPayloadSize require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "QueryUserAgent")) {
            s->is_set_query_user_agent = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_user_agent = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_user_agent = 0;
             } else {
            		fprintf(stderr, "QueryUserAgent require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "RequestId")) {
            s->is_set_request_id = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->request_id = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->request_id = 0;
             } else {
            		fprintf(stderr, "RequestId require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "ResponseSize")) {
            s->is_set_response_size = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->response_size = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->response_size = 0;
             } else {
            		fprintf(stderr, "ResponseSize require true/false\n");
            		return 1;
             }
        } else
	if (!argcmp(str, "ResponseStatusCode")) {
            s->is_set_response_status_code = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->response_status_code = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->response_status_code = 0;
             } else {
            		fprintf(stderr, "ResponseStatusCode require true/false\n");
            		return 1;
             }
        } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'With'\n", str);
	}
	return 0;
}


int main(int ac, char **av)
{
	auto_osc_env struct osc_env e;
	auto_osc_str struct osc_str r;
	int color_flag = 0;
	int i;
	char *help_appent = getenv("COGNAC_HELP_APPEND");
	unsigned int flag = 0;
	unsigned int program_flag = 0;
	char *program_name = rindex(av[0], '/');
	int ret = 1;

	if (!program_name)
		program_name = av[0];
	else
		++program_name;
	for (i = 1; i < ac; ++i) {
		if (!strcmp("--verbose", av[i])) {
		  flag |= OSC_VERBOSE_MODE;
		} else if (!strcmp("--insecure", av[i])) {
		  flag |= OSC_INSECURE_MODE;
		}
	}
	TRY(osc_init_sdk(&e, NULL, flag), "fail to init C sdk\n");
	osc_init_str(&r);

	if (ac < 2) {
	show_help:
		printf("Usage: %s [--help] CallName [options] [--Params ParamArgument]\n"
		       "options:\n"
		       "\t--insecure	\tdoesn't verify SSL certificats\n"
		       "\t--raw-print	\tdoesn't format the output\n"
		       "\t--verbose	\tcurl backend is now verbose\n"
		       "\t--help [CallName]\tthis, can be used with call name, example:\n\t\t\t\t%s --help ReadVms\n"
		       "\t--color	\t\ttry to colorize json if json-c support it\n%s%s",
		       program_name, program_name, help_appent ? help_appent : "",
		       help_appent ? "\n" : "");
		return 0;
	}

	for (i = 1; i < ac; ++i) {
		if (!strcmp("--verbose", av[i]) || !strcmp("--insecure", av[i])) {
			/* Avoid Unknow Calls */
		} else if (!strcmp("--help", av[i])) {
			if (av[i+1]) {
				const char *cd = osc_find_description(av[i+1]);
				const char *cad = osc_find_args_description(av[i+1]);
				if (cd) {
					puts(cd);
					puts("Arguments Description:");
					puts(cad);
					goto good;
				} else {
					printf("Unknow Call %s\n", av[i+1]);
					goto out;
				}
			}
			goto show_help;
		} else if (!strcmp("--raw-print", av[i])) {
			program_flag |= OAPI_RAW_OUTPUT;
		} else if (!strcmp("--color", av[i])) {
			color_flag |= JSON_C_TO_STRING_COLOR;
		} else
              if (!strcmp("UpdateVpnConnection", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_vpn_connection_arg a = {0};
		     struct osc_update_vpn_connection_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_vpn_connection_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_vpn_connection_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "ClientGatewayId") ) {
				          TRY(!aa, "ClientGatewayId argument missing\n");
				          s->client_gateway_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VirtualGatewayId") ) {
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VpnConnectionId") ) {
				          TRY(!aa, "VpnConnectionId argument missing\n");
				          s->vpn_connection_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VpnOptions") ) {
				          char *dot_pos;

				          TRY(!aa, "VpnOptions argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->vpn_options;
				          	    cascade_parser = vpn_options_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    vpn_options_parser(&s->vpn_options, dot_pos, aa, pa);
				          	    s->is_set_vpn_options = 1;
				           } else {
				                 s->vpn_options_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateVpnConnection'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_vpn_connection_arg;
		     }
		     cret = osc_update_vpn_connection(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateVpnConnection: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateVolume", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_volume_arg a = {0};
		     struct osc_update_volume_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Iops") ) {
				          TRY(!aa, "Iops argument missing\n");
				          s->is_set_iops = 1;
				          s->iops = atoi(aa);
				       } else
			      if (!argcmp(next_a, "Size") ) {
				          TRY(!aa, "Size argument missing\n");
				          s->is_set_size = 1;
				          s->size = atoi(aa);
				       } else
			      if (!argcmp(next_a, "VolumeId") ) {
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VolumeType") ) {
				          TRY(!aa, "VolumeType argument missing\n");
				          s->volume_type = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateVolume'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_volume_arg;
		     }
		     cret = osc_update_volume(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateVolume: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateVm", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_vm_arg a = {0};
		     struct osc_update_vm_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_vm_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_vm_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "BlockDeviceMappings") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingVmUpdate.BlockDeviceMappings.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'BlockDeviceMappings' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
				          	      cascade_struct = &s->block_device_mappings[pos];
				          	      cascade_parser = block_device_mapping_vm_update_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      block_device_mapping_vm_update_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "BlockDeviceMappings argument missing\n");
				          	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingVmUpdate ref
				          }
				       } else
			      if (!argcmp(next_a, "BsuOptimized") ) {
				          s->is_set_bsu_optimized = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->bsu_optimized = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->bsu_optimized = 0;
				           } else {
				          		fprintf(stderr, "BsuOptimized require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "DeletionProtection") ) {
				          s->is_set_deletion_protection = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->deletion_protection = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->deletion_protection = 0;
				           } else {
				          		fprintf(stderr, "DeletionProtection require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "IsSourceDestChecked") ) {
				          s->is_set_is_source_dest_checked = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->is_source_dest_checked = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->is_source_dest_checked = 0;
				           } else {
				          		fprintf(stderr, "IsSourceDestChecked require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "KeypairName") ) {
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "NestedVirtualization") ) {
				          s->is_set_nested_virtualization = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->nested_virtualization = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->nested_virtualization = 0;
				           } else {
				          		fprintf(stderr, "NestedVirtualization require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Performance") ) {
				          TRY(!aa, "Performance argument missing\n");
				          s->performance = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroupIds") ) {
				          	 TRY(!aa, "SecurityGroupIds argument missing\n");
				             s->security_group_ids_str = aa;
				       } else if (!strcmp(str, "SecurityGroupIds[]")) {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "UserData") ) {
				          TRY(!aa, "UserData argument missing\n");
				          s->user_data = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmInitiatedShutdownBehavior") ) {
				          TRY(!aa, "VmInitiatedShutdownBehavior argument missing\n");
				          s->vm_initiated_shutdown_behavior = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmType") ) {
				          TRY(!aa, "VmType argument missing\n");
				          s->vm_type = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateVm'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_vm_arg;
		     }
		     cret = osc_update_vm(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateVm: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateSubnet", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_subnet_arg a = {0};
		     struct osc_update_subnet_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_subnet_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_subnet_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "MapPublicIpOnLaunch") ) {
				          s->is_set_map_public_ip_on_launch = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->map_public_ip_on_launch = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->map_public_ip_on_launch = 0;
				           } else {
				          		fprintf(stderr, "MapPublicIpOnLaunch require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "SubnetId") ) {
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateSubnet'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_subnet_arg;
		     }
		     cret = osc_update_subnet(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateSubnet: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateSnapshot", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_snapshot_arg a = {0};
		     struct osc_update_snapshot_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_snapshot_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_snapshot_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "PermissionsToCreateVolume") ) {
				          char *dot_pos;

				          TRY(!aa, "PermissionsToCreateVolume argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->permissions_to_create_volume;
				          	    cascade_parser = permissions_on_resource_creation_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    permissions_on_resource_creation_parser(&s->permissions_to_create_volume, dot_pos, aa, pa);
				          	    s->is_set_permissions_to_create_volume = 1;
				           } else {
				                 s->permissions_to_create_volume_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "SnapshotId") ) {
				          TRY(!aa, "SnapshotId argument missing\n");
				          s->snapshot_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateSnapshot'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_snapshot_arg;
		     }
		     cret = osc_update_snapshot(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateSnapshot: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateServerCertificate", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_server_certificate_arg a = {0};
		     struct osc_update_server_certificate_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_server_certificate_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_server_certificate_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Name") ) {
				          TRY(!aa, "Name argument missing\n");
				          s->name = aa; // string string

				       } else
			      if (!argcmp(next_a, "NewName") ) {
				          TRY(!aa, "NewName argument missing\n");
				          s->new_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "NewPath") ) {
				          TRY(!aa, "NewPath argument missing\n");
				          s->new_path = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateServerCertificate'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_server_certificate_arg;
		     }
		     cret = osc_update_server_certificate(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateServerCertificate: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateRoutePropagation", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_route_propagation_arg a = {0};
		     struct osc_update_route_propagation_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_route_propagation_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_route_propagation_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Enable") ) {
				          s->is_set_enable = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->enable = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->enable = 0;
				           } else {
				          		fprintf(stderr, "Enable require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "RouteTableId") ) {
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VirtualGatewayId") ) {
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateRoutePropagation'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_route_propagation_arg;
		     }
		     cret = osc_update_route_propagation(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateRoutePropagation: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateRoute", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_route_arg a = {0};
		     struct osc_update_route_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DestinationIpRange") ) {
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "GatewayId") ) {
				          TRY(!aa, "GatewayId argument missing\n");
				          s->gateway_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "NatServiceId") ) {
				          TRY(!aa, "NatServiceId argument missing\n");
				          s->nat_service_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "NetPeeringId") ) {
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "NicId") ) {
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "RouteTableId") ) {
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateRoute'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_route_arg;
		     }
		     cret = osc_update_route(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateRoute: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateNic", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_nic_arg a = {0};
		     struct osc_update_nic_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LinkNic") ) {
				          char *dot_pos;

				          TRY(!aa, "LinkNic argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->link_nic;
				          	    cascade_parser = link_nic_to_update_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    link_nic_to_update_parser(&s->link_nic, dot_pos, aa, pa);
				          	    s->is_set_link_nic = 1;
				           } else {
				                 s->link_nic_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "NicId") ) {
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroupIds") ) {
				          	 TRY(!aa, "SecurityGroupIds argument missing\n");
				             s->security_group_ids_str = aa;
				       } else if (!strcmp(str, "SecurityGroupIds[]")) {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateNic'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_nic_arg;
		     }
		     cret = osc_update_nic(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateNic: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateNetAccessPoint", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_net_access_point_arg a = {0};
		     struct osc_update_net_access_point_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_net_access_point_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_net_access_point_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AddRouteTableIds") ) {
				          	 TRY(!aa, "AddRouteTableIds argument missing\n");
				             s->add_route_table_ids_str = aa;
				       } else if (!strcmp(str, "AddRouteTableIds[]")) {
				             TRY(!aa, "AddRouteTableIds[] argument missing\n");
				             SET_NEXT(s->add_route_table_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetAccessPointId") ) {
				          TRY(!aa, "NetAccessPointId argument missing\n");
				          s->net_access_point_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "RemoveRouteTableIds") ) {
				          	 TRY(!aa, "RemoveRouteTableIds argument missing\n");
				             s->remove_route_table_ids_str = aa;
				       } else if (!strcmp(str, "RemoveRouteTableIds[]")) {
				             TRY(!aa, "RemoveRouteTableIds[] argument missing\n");
				             SET_NEXT(s->remove_route_table_ids, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateNetAccessPoint'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_net_access_point_arg;
		     }
		     cret = osc_update_net_access_point(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateNetAccessPoint: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateNet", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_net_arg a = {0};
		     struct osc_update_net_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_net_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_net_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DhcpOptionsSetId") ) {
				          TRY(!aa, "DhcpOptionsSetId argument missing\n");
				          s->dhcp_options_set_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateNet'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_net_arg;
		     }
		     cret = osc_update_net(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateNet: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateLoadBalancer", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_load_balancer_arg a = {0};
		     struct osc_update_load_balancer_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AccessLog") ) {
				          char *dot_pos;

				          TRY(!aa, "AccessLog argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->access_log;
				          	    cascade_parser = access_log_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    access_log_parser(&s->access_log, dot_pos, aa, pa);
				          	    s->is_set_access_log = 1;
				           } else {
				                 s->access_log_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "HealthCheck") ) {
				          char *dot_pos;

				          TRY(!aa, "HealthCheck argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->health_check;
				          	    cascade_parser = health_check_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    health_check_parser(&s->health_check, dot_pos, aa, pa);
				          	    s->is_set_health_check = 1;
				           } else {
				                 s->health_check_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "LoadBalancerPort") ) {
				          TRY(!aa, "LoadBalancerPort argument missing\n");
				          s->is_set_load_balancer_port = 1;
				          s->load_balancer_port = atoi(aa);
				       } else
			      if (!argcmp(next_a, "PolicyNames") ) {
				          	 TRY(!aa, "PolicyNames argument missing\n");
				             s->policy_names_str = aa;
				       } else if (!strcmp(str, "PolicyNames[]")) {
				             TRY(!aa, "PolicyNames[] argument missing\n");
				             SET_NEXT(s->policy_names, (aa), pa);
				       } else
			      if (!argcmp(next_a, "PublicIp") ) {
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecuredCookies") ) {
				          s->is_set_secured_cookies = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->secured_cookies = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->secured_cookies = 0;
				           } else {
				          		fprintf(stderr, "SecuredCookies require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "SecurityGroups") ) {
				          	 TRY(!aa, "SecurityGroups argument missing\n");
				             s->security_groups_str = aa;
				       } else if (!strcmp(str, "SecurityGroups[]")) {
				             TRY(!aa, "SecurityGroups[] argument missing\n");
				             SET_NEXT(s->security_groups, (aa), pa);
				       } else
			      if (!argcmp(next_a, "ServerCertificateId") ) {
				          TRY(!aa, "ServerCertificateId argument missing\n");
				          s->server_certificate_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateLoadBalancer'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_load_balancer_arg;
		     }
		     cret = osc_update_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateLoadBalancer: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateListenerRule", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_listener_rule_arg a = {0};
		     struct osc_update_listener_rule_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_listener_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_listener_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "HostPattern") ) {
				          TRY(!aa, "HostPattern argument missing\n");
				          s->host_pattern = aa; // string string

				       } else
			      if (!argcmp(next_a, "ListenerRuleName") ) {
				          TRY(!aa, "ListenerRuleName argument missing\n");
				          s->listener_rule_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "PathPattern") ) {
				          TRY(!aa, "PathPattern argument missing\n");
				          s->path_pattern = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateListenerRule'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_listener_rule_arg;
		     }
		     cret = osc_update_listener_rule(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateListenerRule: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateImage", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_image_arg a = {0};
		     struct osc_update_image_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_image_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_image_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ImageId") ) {
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "PermissionsToLaunch") ) {
				          char *dot_pos;

				          TRY(!aa, "PermissionsToLaunch argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->permissions_to_launch;
				          	    cascade_parser = permissions_on_resource_creation_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    permissions_on_resource_creation_parser(&s->permissions_to_launch, dot_pos, aa, pa);
				          	    s->is_set_permissions_to_launch = 1;
				           } else {
				                 s->permissions_to_launch_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateImage'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_image_arg;
		     }
		     cret = osc_update_image(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateImage: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateFlexibleGpu", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_flexible_gpu_arg a = {0};
		     struct osc_update_flexible_gpu_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DeleteOnVmDeletion") ) {
				          s->is_set_delete_on_vm_deletion = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->delete_on_vm_deletion = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->delete_on_vm_deletion = 0;
				           } else {
				          		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "FlexibleGpuId") ) {
				          TRY(!aa, "FlexibleGpuId argument missing\n");
				          s->flexible_gpu_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateFlexibleGpu'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_flexible_gpu_arg;
		     }
		     cret = osc_update_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateDirectLinkInterface", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_direct_link_interface_arg a = {0};
		     struct osc_update_direct_link_interface_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_direct_link_interface_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_direct_link_interface_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DirectLinkInterfaceId") ) {
				          TRY(!aa, "DirectLinkInterfaceId argument missing\n");
				          s->direct_link_interface_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Mtu") ) {
				          TRY(!aa, "Mtu argument missing\n");
				          s->is_set_mtu = 1;
				          s->mtu = atoi(aa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateDirectLinkInterface'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_direct_link_interface_arg;
		     }
		     cret = osc_update_direct_link_interface(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateDirectLinkInterface: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateCa", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_ca_arg a = {0};
		     struct osc_update_ca_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_ca_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_ca_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "CaId") ) {
				          TRY(!aa, "CaId argument missing\n");
				          s->ca_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateCa'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_ca_arg;
		     }
		     cret = osc_update_ca(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateCa: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateApiAccessRule", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_api_access_rule_arg a = {0};
		     struct osc_update_api_access_rule_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_api_access_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_api_access_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "ApiAccessRuleId") ) {
				          TRY(!aa, "ApiAccessRuleId argument missing\n");
				          s->api_access_rule_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "CaIds") ) {
				          	 TRY(!aa, "CaIds argument missing\n");
				             s->ca_ids_str = aa;
				       } else if (!strcmp(str, "CaIds[]")) {
				             TRY(!aa, "CaIds[] argument missing\n");
				             SET_NEXT(s->ca_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Cns") ) {
				          	 TRY(!aa, "Cns argument missing\n");
				             s->cns_str = aa;
				       } else if (!strcmp(str, "Cns[]")) {
				             TRY(!aa, "Cns[] argument missing\n");
				             SET_NEXT(s->cns, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "IpRanges") ) {
				          	 TRY(!aa, "IpRanges argument missing\n");
				             s->ip_ranges_str = aa;
				       } else if (!strcmp(str, "IpRanges[]")) {
				             TRY(!aa, "IpRanges[] argument missing\n");
				             SET_NEXT(s->ip_ranges, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateApiAccessRule'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_api_access_rule_arg;
		     }
		     cret = osc_update_api_access_rule(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateApiAccessRule: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateApiAccessPolicy", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_api_access_policy_arg a = {0};
		     struct osc_update_api_access_policy_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_api_access_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_api_access_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "MaxAccessKeyExpirationSeconds") ) {
				          TRY(!aa, "MaxAccessKeyExpirationSeconds argument missing\n");
				          s->is_set_max_access_key_expiration_seconds = 1;
				          s->max_access_key_expiration_seconds = atoi(aa);
				       } else
			      if (!argcmp(next_a, "RequireTrustedEnv") ) {
				          s->is_set_require_trusted_env = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->require_trusted_env = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->require_trusted_env = 0;
				           } else {
				          		fprintf(stderr, "RequireTrustedEnv require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateApiAccessPolicy'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_api_access_policy_arg;
		     }
		     cret = osc_update_api_access_policy(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateApiAccessPolicy: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateAccount", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_account_arg a = {0};
		     struct osc_update_account_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_account_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_account_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AdditionalEmails") ) {
				          	 TRY(!aa, "AdditionalEmails argument missing\n");
				             s->additional_emails_str = aa;
				       } else if (!strcmp(str, "AdditionalEmails[]")) {
				             TRY(!aa, "AdditionalEmails[] argument missing\n");
				             SET_NEXT(s->additional_emails, (aa), pa);
				       } else
			      if (!argcmp(next_a, "City") ) {
				          TRY(!aa, "City argument missing\n");
				          s->city = aa; // string string

				       } else
			      if (!argcmp(next_a, "CompanyName") ) {
				          TRY(!aa, "CompanyName argument missing\n");
				          s->company_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "Country") ) {
				          TRY(!aa, "Country argument missing\n");
				          s->country = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Email") ) {
				          TRY(!aa, "Email argument missing\n");
				          s->email = aa; // string string

				       } else
			      if (!argcmp(next_a, "FirstName") ) {
				          TRY(!aa, "FirstName argument missing\n");
				          s->first_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "JobTitle") ) {
				          TRY(!aa, "JobTitle argument missing\n");
				          s->job_title = aa; // string string

				       } else
			      if (!argcmp(next_a, "LastName") ) {
				          TRY(!aa, "LastName argument missing\n");
				          s->last_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "MobileNumber") ) {
				          TRY(!aa, "MobileNumber argument missing\n");
				          s->mobile_number = aa; // string string

				       } else
			      if (!argcmp(next_a, "PhoneNumber") ) {
				          TRY(!aa, "PhoneNumber argument missing\n");
				          s->phone_number = aa; // string string

				       } else
			      if (!argcmp(next_a, "StateProvince") ) {
				          TRY(!aa, "StateProvince argument missing\n");
				          s->state_province = aa; // string string

				       } else
			      if (!argcmp(next_a, "VatNumber") ) {
				          TRY(!aa, "VatNumber argument missing\n");
				          s->vat_number = aa; // string string

				       } else
			      if (!argcmp(next_a, "ZipCode") ) {
				          TRY(!aa, "ZipCode argument missing\n");
				          s->zip_code = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateAccount'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_account_arg;
		     }
		     cret = osc_update_account(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateAccount: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UpdateAccessKey", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_access_key_arg a = {0};
		     struct osc_update_access_key_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_access_key_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto update_access_key_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AccessKeyId") ) {
				          TRY(!aa, "AccessKeyId argument missing\n");
				          s->access_key_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ExpirationDate") ) {
				          TRY(!aa, "ExpirationDate argument missing\n");
				          s->expiration_date = aa; // string string

				       } else
			      if (!argcmp(next_a, "State") ) {
				          TRY(!aa, "State argument missing\n");
				          s->state = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UpdateAccessKey'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto update_access_key_arg;
		     }
		     cret = osc_update_access_key(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateAccessKey: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkVolume", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_volume_arg a = {0};
		     struct osc_unlink_volume_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ForceUnlink") ) {
				          s->is_set_force_unlink = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->force_unlink = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->force_unlink = 0;
				           } else {
				          		fprintf(stderr, "ForceUnlink require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VolumeId") ) {
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkVolume'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_volume_arg;
		     }
		     cret = osc_unlink_volume(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkVolume: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkVirtualGateway", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_virtual_gateway_arg a = {0};
		     struct osc_unlink_virtual_gateway_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_virtual_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_virtual_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VirtualGatewayId") ) {
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkVirtualGateway'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_virtual_gateway_arg;
		     }
		     cret = osc_unlink_virtual_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkVirtualGateway: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkRouteTable", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_route_table_arg a = {0};
		     struct osc_unlink_route_table_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_route_table_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_route_table_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LinkRouteTableId") ) {
				          TRY(!aa, "LinkRouteTableId argument missing\n");
				          s->link_route_table_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkRouteTable'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_route_table_arg;
		     }
		     cret = osc_unlink_route_table(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkRouteTable: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkPublicIp", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_public_ip_arg a = {0};
		     struct osc_unlink_public_ip_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_public_ip_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_public_ip_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LinkPublicIpId") ) {
				          TRY(!aa, "LinkPublicIpId argument missing\n");
				          s->link_public_ip_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "PublicIp") ) {
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkPublicIp'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_public_ip_arg;
		     }
		     cret = osc_unlink_public_ip(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkPublicIp: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkPrivateIps", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_private_ips_arg a = {0};
		     struct osc_unlink_private_ips_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_private_ips_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_private_ips_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NicId") ) {
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "PrivateIps") ) {
				          	 TRY(!aa, "PrivateIps argument missing\n");
				             s->private_ips_str = aa;
				       } else if (!strcmp(str, "PrivateIps[]")) {
				             TRY(!aa, "PrivateIps[] argument missing\n");
				             SET_NEXT(s->private_ips, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkPrivateIps'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_private_ips_arg;
		     }
		     cret = osc_unlink_private_ips(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkPrivateIps: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkNic", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_nic_arg a = {0};
		     struct osc_unlink_nic_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LinkNicId") ) {
				          TRY(!aa, "LinkNicId argument missing\n");
				          s->link_nic_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkNic'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_nic_arg;
		     }
		     cret = osc_unlink_nic(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkNic: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkLoadBalancerBackendMachines", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_load_balancer_backend_machines_arg a = {0};
		     struct osc_unlink_load_balancer_backend_machines_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_load_balancer_backend_machines_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_load_balancer_backend_machines_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "BackendIps") ) {
				          	 TRY(!aa, "BackendIps argument missing\n");
				             s->backend_ips_str = aa;
				       } else if (!strcmp(str, "BackendIps[]")) {
				             TRY(!aa, "BackendIps[] argument missing\n");
				             SET_NEXT(s->backend_ips, (aa), pa);
				       } else
			      if (!argcmp(next_a, "BackendVmIds") ) {
				          	 TRY(!aa, "BackendVmIds argument missing\n");
				             s->backend_vm_ids_str = aa;
				       } else if (!strcmp(str, "BackendVmIds[]")) {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkLoadBalancerBackendMachines'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_load_balancer_backend_machines_arg;
		     }
		     cret = osc_unlink_load_balancer_backend_machines(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkLoadBalancerBackendMachines: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkInternetService", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_internet_service_arg a = {0};
		     struct osc_unlink_internet_service_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_internet_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_internet_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "InternetServiceId") ) {
				          TRY(!aa, "InternetServiceId argument missing\n");
				          s->internet_service_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkInternetService'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_internet_service_arg;
		     }
		     cret = osc_unlink_internet_service(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkInternetService: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("UnlinkFlexibleGpu", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_flexible_gpu_arg a = {0};
		     struct osc_unlink_flexible_gpu_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto unlink_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "FlexibleGpuId") ) {
				          TRY(!aa, "FlexibleGpuId argument missing\n");
				          s->flexible_gpu_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'UnlinkFlexibleGpu'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto unlink_flexible_gpu_arg;
		     }
		     cret = osc_unlink_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("StopVms", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_stop_vms_arg a = {0};
		     struct osc_stop_vms_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     stop_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto stop_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ForceStop") ) {
				          s->is_set_force_stop = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->force_stop = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->force_stop = 0;
				           } else {
				          		fprintf(stderr, "ForceStop require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VmIds") ) {
				          	 TRY(!aa, "VmIds argument missing\n");
				             s->vm_ids_str = aa;
				       } else if (!strcmp(str, "VmIds[]")) {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'StopVms'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto stop_vms_arg;
		     }
		     cret = osc_stop_vms(&e, &r, &a);
            	     TRY(cret, "fail to call StopVms: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("StartVms", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_start_vms_arg a = {0};
		     struct osc_start_vms_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     start_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto start_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VmIds") ) {
				          	 TRY(!aa, "VmIds argument missing\n");
				             s->vm_ids_str = aa;
				       } else if (!strcmp(str, "VmIds[]")) {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'StartVms'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto start_vms_arg;
		     }
		     cret = osc_start_vms(&e, &r, &a);
            	     TRY(cret, "fail to call StartVms: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("SendResetPasswordEmail", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_send_reset_password_email_arg a = {0};
		     struct osc_send_reset_password_email_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     send_reset_password_email_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto send_reset_password_email_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Email") ) {
				          TRY(!aa, "Email argument missing\n");
				          s->email = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'SendResetPasswordEmail'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto send_reset_password_email_arg;
		     }
		     cret = osc_send_reset_password_email(&e, &r, &a);
            	     TRY(cret, "fail to call SendResetPasswordEmail: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ResetAccountPassword", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_reset_account_password_arg a = {0};
		     struct osc_reset_account_password_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     reset_account_password_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto reset_account_password_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Password") ) {
				          TRY(!aa, "Password argument missing\n");
				          s->password = aa; // string string

				       } else
			      if (!argcmp(next_a, "Token") ) {
				          TRY(!aa, "Token argument missing\n");
				          s->token = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ResetAccountPassword'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto reset_account_password_arg;
		     }
		     cret = osc_reset_account_password(&e, &r, &a);
            	     TRY(cret, "fail to call ResetAccountPassword: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("RejectNetPeering", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_reject_net_peering_arg a = {0};
		     struct osc_reject_net_peering_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     reject_net_peering_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto reject_net_peering_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetPeeringId") ) {
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'RejectNetPeering'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto reject_net_peering_arg;
		     }
		     cret = osc_reject_net_peering(&e, &r, &a);
            	     TRY(cret, "fail to call RejectNetPeering: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("RegisterVmsInLoadBalancer", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_register_vms_in_load_balancer_arg a = {0};
		     struct osc_register_vms_in_load_balancer_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     register_vms_in_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto register_vms_in_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "BackendVmIds") ) {
				          	 TRY(!aa, "BackendVmIds argument missing\n");
				             s->backend_vm_ids_str = aa;
				       } else if (!strcmp(str, "BackendVmIds[]")) {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'RegisterVmsInLoadBalancer'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto register_vms_in_load_balancer_arg;
		     }
		     cret = osc_register_vms_in_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call RegisterVmsInLoadBalancer: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("RebootVms", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_reboot_vms_arg a = {0};
		     struct osc_reboot_vms_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     reboot_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto reboot_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VmIds") ) {
				          	 TRY(!aa, "VmIds argument missing\n");
				             s->vm_ids_str = aa;
				       } else if (!strcmp(str, "VmIds[]")) {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'RebootVms'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto reboot_vms_arg;
		     }
		     cret = osc_reboot_vms(&e, &r, &a);
            	     TRY(cret, "fail to call RebootVms: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadVpnConnections", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vpn_connections_arg a = {0};
		     struct osc_read_vpn_connections_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vpn_connections_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_vpn_connections_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vpn_connection_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_vpn_connection_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadVpnConnections'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_vpn_connections_arg;
		     }
		     cret = osc_read_vpn_connections(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVpnConnections: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadVolumes", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_volumes_arg a = {0};
		     struct osc_read_volumes_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_volumes_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_volumes_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_volume_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_volume_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadVolumes'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_volumes_arg;
		     }
		     cret = osc_read_volumes(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVolumes: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadVmsState", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vms_state_arg a = {0};
		     struct osc_read_vms_state_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vms_state_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_vms_state_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AllVms") ) {
				          s->is_set_all_vms = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->all_vms = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->all_vms = 0;
				           } else {
				          		fprintf(stderr, "AllVms require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vms_state_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_vms_state_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadVmsState'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_vms_state_arg;
		     }
		     cret = osc_read_vms_state(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVmsState: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadVmsHealth", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vms_health_arg a = {0};
		     struct osc_read_vms_health_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vms_health_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_vms_health_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "BackendVmIds") ) {
				          	 TRY(!aa, "BackendVmIds argument missing\n");
				             s->backend_vm_ids_str = aa;
				       } else if (!strcmp(str, "BackendVmIds[]")) {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadVmsHealth'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_vms_health_arg;
		     }
		     cret = osc_read_vms_health(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVmsHealth: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadVms", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vms_arg a = {0};
		     struct osc_read_vms_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vm_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_vm_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadVms'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_vms_arg;
		     }
		     cret = osc_read_vms(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVms: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadVmTypes", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vm_types_arg a = {0};
		     struct osc_read_vm_types_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vm_types_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_vm_types_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vm_type_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_vm_type_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadVmTypes'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_vm_types_arg;
		     }
		     cret = osc_read_vm_types(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVmTypes: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadVirtualGateways", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_virtual_gateways_arg a = {0};
		     struct osc_read_virtual_gateways_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_virtual_gateways_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_virtual_gateways_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_virtual_gateway_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_virtual_gateway_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadVirtualGateways'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_virtual_gateways_arg;
		     }
		     cret = osc_read_virtual_gateways(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVirtualGateways: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadTags", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_tags_arg a = {0};
		     struct osc_read_tags_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_tag_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_tag_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadTags'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_tags_arg;
		     }
		     cret = osc_read_tags(&e, &r, &a);
            	     TRY(cret, "fail to call ReadTags: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadSubregions", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_subregions_arg a = {0};
		     struct osc_read_subregions_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_subregions_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_subregions_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_subregion_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_subregion_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadSubregions'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_subregions_arg;
		     }
		     cret = osc_read_subregions(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSubregions: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadSubnets", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_subnets_arg a = {0};
		     struct osc_read_subnets_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_subnets_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_subnets_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_subnet_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_subnet_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadSubnets'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_subnets_arg;
		     }
		     cret = osc_read_subnets(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSubnets: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadSnapshots", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_snapshots_arg a = {0};
		     struct osc_read_snapshots_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_snapshots_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_snapshots_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_snapshot_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_snapshot_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadSnapshots'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_snapshots_arg;
		     }
		     cret = osc_read_snapshots(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSnapshots: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadSnapshotExportTasks", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_snapshot_export_tasks_arg a = {0};
		     struct osc_read_snapshot_export_tasks_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_snapshot_export_tasks_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_snapshot_export_tasks_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_export_task_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_export_task_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadSnapshotExportTasks'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_snapshot_export_tasks_arg;
		     }
		     cret = osc_read_snapshot_export_tasks(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSnapshotExportTasks: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadServerCertificates", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_server_certificates_arg a = {0};
		     struct osc_read_server_certificates_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_server_certificates_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_server_certificates_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_server_certificate_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_server_certificate_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadServerCertificates'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_server_certificates_arg;
		     }
		     cret = osc_read_server_certificates(&e, &r, &a);
            	     TRY(cret, "fail to call ReadServerCertificates: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadSecurityGroups", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_security_groups_arg a = {0};
		     struct osc_read_security_groups_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_security_groups_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_security_groups_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_security_group_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_security_group_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadSecurityGroups'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_security_groups_arg;
		     }
		     cret = osc_read_security_groups(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSecurityGroups: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadSecretAccessKey", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_secret_access_key_arg a = {0};
		     struct osc_read_secret_access_key_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_secret_access_key_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_secret_access_key_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AccessKeyId") ) {
				          TRY(!aa, "AccessKeyId argument missing\n");
				          s->access_key_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadSecretAccessKey'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_secret_access_key_arg;
		     }
		     cret = osc_read_secret_access_key(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSecretAccessKey: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadRouteTables", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_route_tables_arg a = {0};
		     struct osc_read_route_tables_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_route_tables_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_route_tables_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_route_table_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_route_table_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadRouteTables'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_route_tables_arg;
		     }
		     cret = osc_read_route_tables(&e, &r, &a);
            	     TRY(cret, "fail to call ReadRouteTables: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadRegions", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_regions_arg a = {0};
		     struct osc_read_regions_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_regions_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_regions_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadRegions'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_regions_arg;
		     }
		     cret = osc_read_regions(&e, &r, &a);
            	     TRY(cret, "fail to call ReadRegions: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadQuotas", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_quotas_arg a = {0};
		     struct osc_read_quotas_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_quotas_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_quotas_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_quota_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_quota_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadQuotas'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_quotas_arg;
		     }
		     cret = osc_read_quotas(&e, &r, &a);
            	     TRY(cret, "fail to call ReadQuotas: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadPublicIps", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_public_ips_arg a = {0};
		     struct osc_read_public_ips_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_public_ips_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_public_ips_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_public_ip_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_public_ip_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadPublicIps'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_public_ips_arg;
		     }
		     cret = osc_read_public_ips(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPublicIps: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadPublicIpRanges", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_public_ip_ranges_arg a = {0};
		     struct osc_read_public_ip_ranges_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_public_ip_ranges_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_public_ip_ranges_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadPublicIpRanges'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_public_ip_ranges_arg;
		     }
		     cret = osc_read_public_ip_ranges(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPublicIpRanges: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadPublicCatalog", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_public_catalog_arg a = {0};
		     struct osc_read_public_catalog_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_public_catalog_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_public_catalog_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadPublicCatalog'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_public_catalog_arg;
		     }
		     cret = osc_read_public_catalog(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPublicCatalog: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadProductTypes", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_product_types_arg a = {0};
		     struct osc_read_product_types_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_product_types_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_product_types_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_product_type_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_product_type_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadProductTypes'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_product_types_arg;
		     }
		     cret = osc_read_product_types(&e, &r, &a);
            	     TRY(cret, "fail to call ReadProductTypes: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadNics", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_nics_arg a = {0};
		     struct osc_read_nics_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_nics_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_nics_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_nic_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_nic_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadNics'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_nics_arg;
		     }
		     cret = osc_read_nics(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNics: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadNets", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_nets_arg a = {0};
		     struct osc_read_nets_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_nets_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_nets_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_net_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_net_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadNets'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_nets_arg;
		     }
		     cret = osc_read_nets(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNets: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadNetPeerings", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_net_peerings_arg a = {0};
		     struct osc_read_net_peerings_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_net_peerings_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_net_peerings_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_net_peering_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_net_peering_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadNetPeerings'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_net_peerings_arg;
		     }
		     cret = osc_read_net_peerings(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNetPeerings: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadNetAccessPoints", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_net_access_points_arg a = {0};
		     struct osc_read_net_access_points_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_net_access_points_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_net_access_points_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_net_access_point_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_net_access_point_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadNetAccessPoints'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_net_access_points_arg;
		     }
		     cret = osc_read_net_access_points(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNetAccessPoints: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadNetAccessPointServices", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_net_access_point_services_arg a = {0};
		     struct osc_read_net_access_point_services_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_net_access_point_services_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_net_access_point_services_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_service_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_service_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadNetAccessPointServices'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_net_access_point_services_arg;
		     }
		     cret = osc_read_net_access_point_services(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNetAccessPointServices: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadNatServices", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_nat_services_arg a = {0};
		     struct osc_read_nat_services_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_nat_services_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_nat_services_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_nat_service_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_nat_service_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadNatServices'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_nat_services_arg;
		     }
		     cret = osc_read_nat_services(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNatServices: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadLocations", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_locations_arg a = {0};
		     struct osc_read_locations_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_locations_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_locations_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadLocations'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_locations_arg;
		     }
		     cret = osc_read_locations(&e, &r, &a);
            	     TRY(cret, "fail to call ReadLocations: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadLoadBalancers", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_load_balancers_arg a = {0};
		     struct osc_read_load_balancers_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_load_balancers_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_load_balancers_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_load_balancer_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_load_balancer_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadLoadBalancers'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_load_balancers_arg;
		     }
		     cret = osc_read_load_balancers(&e, &r, &a);
            	     TRY(cret, "fail to call ReadLoadBalancers: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadLoadBalancerTags", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_load_balancer_tags_arg a = {0};
		     struct osc_read_load_balancer_tags_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_load_balancer_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_load_balancer_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerNames") ) {
				          	 TRY(!aa, "LoadBalancerNames argument missing\n");
				             s->load_balancer_names_str = aa;
				       } else if (!strcmp(str, "LoadBalancerNames[]")) {
				             TRY(!aa, "LoadBalancerNames[] argument missing\n");
				             SET_NEXT(s->load_balancer_names, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadLoadBalancerTags'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_load_balancer_tags_arg;
		     }
		     cret = osc_read_load_balancer_tags(&e, &r, &a);
            	     TRY(cret, "fail to call ReadLoadBalancerTags: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadListenerRules", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_listener_rules_arg a = {0};
		     struct osc_read_listener_rules_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_listener_rules_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_listener_rules_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_listener_rule_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_listener_rule_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadListenerRules'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_listener_rules_arg;
		     }
		     cret = osc_read_listener_rules(&e, &r, &a);
            	     TRY(cret, "fail to call ReadListenerRules: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadKeypairs", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_keypairs_arg a = {0};
		     struct osc_read_keypairs_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_keypairs_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_keypairs_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_keypair_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_keypair_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadKeypairs'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_keypairs_arg;
		     }
		     cret = osc_read_keypairs(&e, &r, &a);
            	     TRY(cret, "fail to call ReadKeypairs: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadInternetServices", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_internet_services_arg a = {0};
		     struct osc_read_internet_services_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_internet_services_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_internet_services_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_internet_service_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_internet_service_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadInternetServices'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_internet_services_arg;
		     }
		     cret = osc_read_internet_services(&e, &r, &a);
            	     TRY(cret, "fail to call ReadInternetServices: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadImages", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_images_arg a = {0};
		     struct osc_read_images_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_images_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_images_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_image_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_image_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadImages'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_images_arg;
		     }
		     cret = osc_read_images(&e, &r, &a);
            	     TRY(cret, "fail to call ReadImages: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadImageExportTasks", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_image_export_tasks_arg a = {0};
		     struct osc_read_image_export_tasks_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_image_export_tasks_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_image_export_tasks_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_export_task_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_export_task_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadImageExportTasks'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_image_export_tasks_arg;
		     }
		     cret = osc_read_image_export_tasks(&e, &r, &a);
            	     TRY(cret, "fail to call ReadImageExportTasks: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadFlexibleGpus", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_flexible_gpus_arg a = {0};
		     struct osc_read_flexible_gpus_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_flexible_gpus_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_flexible_gpus_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_flexible_gpu_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_flexible_gpu_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadFlexibleGpus'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_flexible_gpus_arg;
		     }
		     cret = osc_read_flexible_gpus(&e, &r, &a);
            	     TRY(cret, "fail to call ReadFlexibleGpus: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadFlexibleGpuCatalog", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_flexible_gpu_catalog_arg a = {0};
		     struct osc_read_flexible_gpu_catalog_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_flexible_gpu_catalog_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_flexible_gpu_catalog_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadFlexibleGpuCatalog'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_flexible_gpu_catalog_arg;
		     }
		     cret = osc_read_flexible_gpu_catalog(&e, &r, &a);
            	     TRY(cret, "fail to call ReadFlexibleGpuCatalog: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadDirectLinks", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_direct_links_arg a = {0};
		     struct osc_read_direct_links_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_direct_links_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_direct_links_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_direct_link_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_direct_link_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadDirectLinks'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_direct_links_arg;
		     }
		     cret = osc_read_direct_links(&e, &r, &a);
            	     TRY(cret, "fail to call ReadDirectLinks: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadDirectLinkInterfaces", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_direct_link_interfaces_arg a = {0};
		     struct osc_read_direct_link_interfaces_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_direct_link_interfaces_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_direct_link_interfaces_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_direct_link_interface_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_direct_link_interface_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadDirectLinkInterfaces'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_direct_link_interfaces_arg;
		     }
		     cret = osc_read_direct_link_interfaces(&e, &r, &a);
            	     TRY(cret, "fail to call ReadDirectLinkInterfaces: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadDhcpOptions", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_dhcp_options_arg a = {0};
		     struct osc_read_dhcp_options_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_dhcp_options_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_dhcp_options_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_dhcp_options_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_dhcp_options_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadDhcpOptions'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_dhcp_options_arg;
		     }
		     cret = osc_read_dhcp_options(&e, &r, &a);
            	     TRY(cret, "fail to call ReadDhcpOptions: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadConsumptionAccount", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_consumption_account_arg a = {0};
		     struct osc_read_consumption_account_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_consumption_account_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_consumption_account_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "FromDate") ) {
				          TRY(!aa, "FromDate argument missing\n");
				          s->from_date = aa; // string string

				       } else
			      if (!argcmp(next_a, "Overall") ) {
				          s->is_set_overall = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->overall = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->overall = 0;
				           } else {
				          		fprintf(stderr, "Overall require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ToDate") ) {
				          TRY(!aa, "ToDate argument missing\n");
				          s->to_date = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadConsumptionAccount'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_consumption_account_arg;
		     }
		     cret = osc_read_consumption_account(&e, &r, &a);
            	     TRY(cret, "fail to call ReadConsumptionAccount: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadConsoleOutput", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_console_output_arg a = {0};
		     struct osc_read_console_output_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_console_output_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_console_output_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadConsoleOutput'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_console_output_arg;
		     }
		     cret = osc_read_console_output(&e, &r, &a);
            	     TRY(cret, "fail to call ReadConsoleOutput: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadClientGateways", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_client_gateways_arg a = {0};
		     struct osc_read_client_gateways_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_client_gateways_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_client_gateways_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_client_gateway_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_client_gateway_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadClientGateways'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_client_gateways_arg;
		     }
		     cret = osc_read_client_gateways(&e, &r, &a);
            	     TRY(cret, "fail to call ReadClientGateways: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadCatalog", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_catalog_arg a = {0};
		     struct osc_read_catalog_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_catalog_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_catalog_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadCatalog'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_catalog_arg;
		     }
		     cret = osc_read_catalog(&e, &r, &a);
            	     TRY(cret, "fail to call ReadCatalog: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadCas", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_cas_arg a = {0};
		     struct osc_read_cas_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_cas_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_cas_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_ca_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_ca_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadCas'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_cas_arg;
		     }
		     cret = osc_read_cas(&e, &r, &a);
            	     TRY(cret, "fail to call ReadCas: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadApiLogs", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_api_logs_arg a = {0};
		     struct osc_read_api_logs_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_api_logs_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_api_logs_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_api_log_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_api_log_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "NextPageToken") ) {
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if (!argcmp(next_a, "ResultsPerPage") ) {
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			      if (!argcmp(next_a, "With") ) {
				          char *dot_pos;

				          TRY(!aa, "With argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->with;
				          	    cascade_parser = with_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    with_parser(&s->with, dot_pos, aa, pa);
				          	    s->is_set_with = 1;
				           } else {
				                 s->with_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadApiLogs'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_api_logs_arg;
		     }
		     cret = osc_read_api_logs(&e, &r, &a);
            	     TRY(cret, "fail to call ReadApiLogs: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadApiAccessRules", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_api_access_rules_arg a = {0};
		     struct osc_read_api_access_rules_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_api_access_rules_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_api_access_rules_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_api_access_rule_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_api_access_rule_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadApiAccessRules'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_api_access_rules_arg;
		     }
		     cret = osc_read_api_access_rules(&e, &r, &a);
            	     TRY(cret, "fail to call ReadApiAccessRules: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadApiAccessPolicy", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_api_access_policy_arg a = {0};
		     struct osc_read_api_access_policy_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_api_access_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_api_access_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadApiAccessPolicy'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_api_access_policy_arg;
		     }
		     cret = osc_read_api_access_policy(&e, &r, &a);
            	     TRY(cret, "fail to call ReadApiAccessPolicy: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadAdminPassword", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_admin_password_arg a = {0};
		     struct osc_read_admin_password_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_admin_password_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_admin_password_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadAdminPassword'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_admin_password_arg;
		     }
		     cret = osc_read_admin_password(&e, &r, &a);
            	     TRY(cret, "fail to call ReadAdminPassword: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadAccounts", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_accounts_arg a = {0};
		     struct osc_read_accounts_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_accounts_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_accounts_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadAccounts'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_accounts_arg;
		     }
		     cret = osc_read_accounts(&e, &r, &a);
            	     TRY(cret, "fail to call ReadAccounts: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("ReadAccessKeys", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_access_keys_arg a = {0};
		     struct osc_read_access_keys_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_access_keys_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto read_access_keys_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Filters") ) {
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_access_keys_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    filters_access_keys_parser(&s->filters, dot_pos, aa, pa);
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'ReadAccessKeys'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto read_access_keys_arg;
		     }
		     cret = osc_read_access_keys(&e, &r, &a);
            	     TRY(cret, "fail to call ReadAccessKeys: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkVolume", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_volume_arg a = {0};
		     struct osc_link_volume_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DeviceName") ) {
				          TRY(!aa, "DeviceName argument missing\n");
				          s->device_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VolumeId") ) {
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkVolume'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_volume_arg;
		     }
		     cret = osc_link_volume(&e, &r, &a);
            	     TRY(cret, "fail to call LinkVolume: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkVirtualGateway", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_virtual_gateway_arg a = {0};
		     struct osc_link_virtual_gateway_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_virtual_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_virtual_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VirtualGatewayId") ) {
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkVirtualGateway'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_virtual_gateway_arg;
		     }
		     cret = osc_link_virtual_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call LinkVirtualGateway: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkRouteTable", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_route_table_arg a = {0};
		     struct osc_link_route_table_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_route_table_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_route_table_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "RouteTableId") ) {
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SubnetId") ) {
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkRouteTable'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_route_table_arg;
		     }
		     cret = osc_link_route_table(&e, &r, &a);
            	     TRY(cret, "fail to call LinkRouteTable: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkPublicIp", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_public_ip_arg a = {0};
		     struct osc_link_public_ip_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_public_ip_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_public_ip_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AllowRelink") ) {
				          s->is_set_allow_relink = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->allow_relink = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->allow_relink = 0;
				           } else {
				          		fprintf(stderr, "AllowRelink require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NicId") ) {
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "PrivateIp") ) {
				          TRY(!aa, "PrivateIp argument missing\n");
				          s->private_ip = aa; // string string

				       } else
			      if (!argcmp(next_a, "PublicIp") ) {
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			      if (!argcmp(next_a, "PublicIpId") ) {
				          TRY(!aa, "PublicIpId argument missing\n");
				          s->public_ip_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkPublicIp'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_public_ip_arg;
		     }
		     cret = osc_link_public_ip(&e, &r, &a);
            	     TRY(cret, "fail to call LinkPublicIp: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkPrivateIps", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_private_ips_arg a = {0};
		     struct osc_link_private_ips_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_private_ips_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_private_ips_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AllowRelink") ) {
				          s->is_set_allow_relink = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->allow_relink = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->allow_relink = 0;
				           } else {
				          		fprintf(stderr, "AllowRelink require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NicId") ) {
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "PrivateIps") ) {
				          	 TRY(!aa, "PrivateIps argument missing\n");
				             s->private_ips_str = aa;
				       } else if (!strcmp(str, "PrivateIps[]")) {
				             TRY(!aa, "PrivateIps[] argument missing\n");
				             SET_NEXT(s->private_ips, (aa), pa);
				       } else
			      if (!argcmp(next_a, "SecondaryPrivateIpCount") ) {
				          TRY(!aa, "SecondaryPrivateIpCount argument missing\n");
				          s->is_set_secondary_private_ip_count = 1;
				          s->secondary_private_ip_count = atoi(aa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkPrivateIps'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_private_ips_arg;
		     }
		     cret = osc_link_private_ips(&e, &r, &a);
            	     TRY(cret, "fail to call LinkPrivateIps: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkNic", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_nic_arg a = {0};
		     struct osc_link_nic_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DeviceNumber") ) {
				          TRY(!aa, "DeviceNumber argument missing\n");
				          s->is_set_device_number = 1;
				          s->device_number = atoi(aa);
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NicId") ) {
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkNic'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_nic_arg;
		     }
		     cret = osc_link_nic(&e, &r, &a);
            	     TRY(cret, "fail to call LinkNic: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkLoadBalancerBackendMachines", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_load_balancer_backend_machines_arg a = {0};
		     struct osc_link_load_balancer_backend_machines_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_load_balancer_backend_machines_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_load_balancer_backend_machines_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "BackendIps") ) {
				          	 TRY(!aa, "BackendIps argument missing\n");
				             s->backend_ips_str = aa;
				       } else if (!strcmp(str, "BackendIps[]")) {
				             TRY(!aa, "BackendIps[] argument missing\n");
				             SET_NEXT(s->backend_ips, (aa), pa);
				       } else
			      if (!argcmp(next_a, "BackendVmIds") ) {
				          	 TRY(!aa, "BackendVmIds argument missing\n");
				             s->backend_vm_ids_str = aa;
				       } else if (!strcmp(str, "BackendVmIds[]")) {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkLoadBalancerBackendMachines'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_load_balancer_backend_machines_arg;
		     }
		     cret = osc_link_load_balancer_backend_machines(&e, &r, &a);
            	     TRY(cret, "fail to call LinkLoadBalancerBackendMachines: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkInternetService", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_internet_service_arg a = {0};
		     struct osc_link_internet_service_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_internet_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_internet_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "InternetServiceId") ) {
				          TRY(!aa, "InternetServiceId argument missing\n");
				          s->internet_service_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkInternetService'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_internet_service_arg;
		     }
		     cret = osc_link_internet_service(&e, &r, &a);
            	     TRY(cret, "fail to call LinkInternetService: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("LinkFlexibleGpu", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_flexible_gpu_arg a = {0};
		     struct osc_link_flexible_gpu_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto link_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "FlexibleGpuId") ) {
				          TRY(!aa, "FlexibleGpuId argument missing\n");
				          s->flexible_gpu_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'LinkFlexibleGpu'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto link_flexible_gpu_arg;
		     }
		     cret = osc_link_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call LinkFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeregisterVmsInLoadBalancer", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_deregister_vms_in_load_balancer_arg a = {0};
		     struct osc_deregister_vms_in_load_balancer_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     deregister_vms_in_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto deregister_vms_in_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "BackendVmIds") ) {
				          	 TRY(!aa, "BackendVmIds argument missing\n");
				             s->backend_vm_ids_str = aa;
				       } else if (!strcmp(str, "BackendVmIds[]")) {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeregisterVmsInLoadBalancer'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto deregister_vms_in_load_balancer_arg;
		     }
		     cret = osc_deregister_vms_in_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call DeregisterVmsInLoadBalancer: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteVpnConnectionRoute", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_vpn_connection_route_arg a = {0};
		     struct osc_delete_vpn_connection_route_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_vpn_connection_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_vpn_connection_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DestinationIpRange") ) {
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VpnConnectionId") ) {
				          TRY(!aa, "VpnConnectionId argument missing\n");
				          s->vpn_connection_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteVpnConnectionRoute'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_vpn_connection_route_arg;
		     }
		     cret = osc_delete_vpn_connection_route(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVpnConnectionRoute: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteVpnConnection", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_vpn_connection_arg a = {0};
		     struct osc_delete_vpn_connection_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_vpn_connection_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_vpn_connection_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VpnConnectionId") ) {
				          TRY(!aa, "VpnConnectionId argument missing\n");
				          s->vpn_connection_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteVpnConnection'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_vpn_connection_arg;
		     }
		     cret = osc_delete_vpn_connection(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVpnConnection: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteVolume", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_volume_arg a = {0};
		     struct osc_delete_volume_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VolumeId") ) {
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteVolume'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_volume_arg;
		     }
		     cret = osc_delete_volume(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVolume: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteVms", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_vms_arg a = {0};
		     struct osc_delete_vms_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VmIds") ) {
				          	 TRY(!aa, "VmIds argument missing\n");
				             s->vm_ids_str = aa;
				       } else if (!strcmp(str, "VmIds[]")) {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteVms'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_vms_arg;
		     }
		     cret = osc_delete_vms(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVms: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteVirtualGateway", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_virtual_gateway_arg a = {0};
		     struct osc_delete_virtual_gateway_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_virtual_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_virtual_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VirtualGatewayId") ) {
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteVirtualGateway'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_virtual_gateway_arg;
		     }
		     cret = osc_delete_virtual_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVirtualGateway: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteTags", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_tags_arg a = {0};
		     struct osc_delete_tags_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ResourceIds") ) {
				          	 TRY(!aa, "ResourceIds argument missing\n");
				             s->resource_ids_str = aa;
				       } else if (!strcmp(str, "ResourceIds[]")) {
				             TRY(!aa, "ResourceIds[] argument missing\n");
				             SET_NEXT(s->resource_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Tags") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Tags' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteTags'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_tags_arg;
		     }
		     cret = osc_delete_tags(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteTags: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteSubnet", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_subnet_arg a = {0};
		     struct osc_delete_subnet_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_subnet_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_subnet_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "SubnetId") ) {
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteSubnet'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_subnet_arg;
		     }
		     cret = osc_delete_subnet(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteSubnet: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteSnapshot", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_snapshot_arg a = {0};
		     struct osc_delete_snapshot_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_snapshot_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_snapshot_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "SnapshotId") ) {
				          TRY(!aa, "SnapshotId argument missing\n");
				          s->snapshot_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteSnapshot'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_snapshot_arg;
		     }
		     cret = osc_delete_snapshot(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteSnapshot: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteServerCertificate", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_server_certificate_arg a = {0};
		     struct osc_delete_server_certificate_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_server_certificate_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_server_certificate_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Name") ) {
				          TRY(!aa, "Name argument missing\n");
				          s->name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteServerCertificate'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_server_certificate_arg;
		     }
		     cret = osc_delete_server_certificate(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteServerCertificate: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteSecurityGroupRule", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_security_group_rule_arg a = {0};
		     struct osc_delete_security_group_rule_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_security_group_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_security_group_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Flow") ) {
				          TRY(!aa, "Flow argument missing\n");
				          s->flow = aa; // string string

				       } else
			      if (!argcmp(next_a, "FromPortRange") ) {
				          TRY(!aa, "FromPortRange argument missing\n");
				          s->is_set_from_port_range = 1;
				          s->from_port_range = atoi(aa);
				       } else
			      if (!argcmp(next_a, "IpProtocol") ) {
				          TRY(!aa, "IpProtocol argument missing\n");
				          s->ip_protocol = aa; // string string

				       } else
			      if (!argcmp(next_a, "IpRange") ) {
				          TRY(!aa, "IpRange argument missing\n");
				          s->ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "Rules") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Rules' require an index (example array ref SecurityGroupRule.Rules.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Rules' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,rules, pa, pos, sizeof(*s->rules));
				          	      cascade_struct = &s->rules[pos];
				          	      cascade_parser = security_group_rule_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      security_group_rule_parser(&s->rules[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Rules argument missing\n");
				          	s->rules_str = aa; // array ref SecurityGroupRule ref
				          }
				       } else
			      if (!argcmp(next_a, "SecurityGroupAccountIdToUnlink") ) {
				          TRY(!aa, "SecurityGroupAccountIdToUnlink argument missing\n");
				          s->security_group_account_id_to_unlink = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroupId") ) {
				          TRY(!aa, "SecurityGroupId argument missing\n");
				          s->security_group_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroupNameToUnlink") ) {
				          TRY(!aa, "SecurityGroupNameToUnlink argument missing\n");
				          s->security_group_name_to_unlink = aa; // string string

				       } else
			      if (!argcmp(next_a, "ToPortRange") ) {
				          TRY(!aa, "ToPortRange argument missing\n");
				          s->is_set_to_port_range = 1;
				          s->to_port_range = atoi(aa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteSecurityGroupRule'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_security_group_rule_arg;
		     }
		     cret = osc_delete_security_group_rule(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteSecurityGroupRule: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteSecurityGroup", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_security_group_arg a = {0};
		     struct osc_delete_security_group_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_security_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_security_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "SecurityGroupId") ) {
				          TRY(!aa, "SecurityGroupId argument missing\n");
				          s->security_group_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroupName") ) {
				          TRY(!aa, "SecurityGroupName argument missing\n");
				          s->security_group_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteSecurityGroup'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_security_group_arg;
		     }
		     cret = osc_delete_security_group(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteSecurityGroup: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteRouteTable", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_route_table_arg a = {0};
		     struct osc_delete_route_table_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_route_table_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_route_table_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "RouteTableId") ) {
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteRouteTable'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_route_table_arg;
		     }
		     cret = osc_delete_route_table(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteRouteTable: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteRoute", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_route_arg a = {0};
		     struct osc_delete_route_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DestinationIpRange") ) {
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "RouteTableId") ) {
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteRoute'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_route_arg;
		     }
		     cret = osc_delete_route(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteRoute: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeletePublicIp", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_public_ip_arg a = {0};
		     struct osc_delete_public_ip_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_public_ip_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_public_ip_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "PublicIp") ) {
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			      if (!argcmp(next_a, "PublicIpId") ) {
				          TRY(!aa, "PublicIpId argument missing\n");
				          s->public_ip_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeletePublicIp'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_public_ip_arg;
		     }
		     cret = osc_delete_public_ip(&e, &r, &a);
            	     TRY(cret, "fail to call DeletePublicIp: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteNic", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_nic_arg a = {0};
		     struct osc_delete_nic_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NicId") ) {
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteNic'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_nic_arg;
		     }
		     cret = osc_delete_nic(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNic: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteNetPeering", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_net_peering_arg a = {0};
		     struct osc_delete_net_peering_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_net_peering_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_net_peering_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetPeeringId") ) {
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteNetPeering'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_net_peering_arg;
		     }
		     cret = osc_delete_net_peering(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNetPeering: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteNetAccessPoint", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_net_access_point_arg a = {0};
		     struct osc_delete_net_access_point_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_net_access_point_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_net_access_point_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetAccessPointId") ) {
				          TRY(!aa, "NetAccessPointId argument missing\n");
				          s->net_access_point_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteNetAccessPoint'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_net_access_point_arg;
		     }
		     cret = osc_delete_net_access_point(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNetAccessPoint: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteNet", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_net_arg a = {0};
		     struct osc_delete_net_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_net_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_net_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteNet'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_net_arg;
		     }
		     cret = osc_delete_net(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNet: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteNatService", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_nat_service_arg a = {0};
		     struct osc_delete_nat_service_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_nat_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_nat_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NatServiceId") ) {
				          TRY(!aa, "NatServiceId argument missing\n");
				          s->nat_service_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteNatService'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_nat_service_arg;
		     }
		     cret = osc_delete_nat_service(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNatService: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteLoadBalancerTags", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_load_balancer_tags_arg a = {0};
		     struct osc_delete_load_balancer_tags_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_load_balancer_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_load_balancer_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerNames") ) {
				          	 TRY(!aa, "LoadBalancerNames argument missing\n");
				             s->load_balancer_names_str = aa;
				       } else if (!strcmp(str, "LoadBalancerNames[]")) {
				             TRY(!aa, "LoadBalancerNames[] argument missing\n");
				             SET_NEXT(s->load_balancer_names, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Tags") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Tags' require an index (example array ref ResourceLoadBalancerTag.Tags.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Tags' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_load_balancer_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      resource_load_balancer_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceLoadBalancerTag ref
				          }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteLoadBalancerTags'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_load_balancer_tags_arg;
		     }
		     cret = osc_delete_load_balancer_tags(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteLoadBalancerTags: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteLoadBalancerPolicy", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_load_balancer_policy_arg a = {0};
		     struct osc_delete_load_balancer_policy_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_load_balancer_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_load_balancer_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "PolicyName") ) {
				          TRY(!aa, "PolicyName argument missing\n");
				          s->policy_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteLoadBalancerPolicy'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_load_balancer_policy_arg;
		     }
		     cret = osc_delete_load_balancer_policy(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteLoadBalancerPolicy: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteLoadBalancerListeners", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_load_balancer_listeners_arg a = {0};
		     struct osc_delete_load_balancer_listeners_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_load_balancer_listeners_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_load_balancer_listeners_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "LoadBalancerPorts") ) {
				          	 TRY(!aa, "LoadBalancerPorts argument missing\n");
				             s->load_balancer_ports_str = aa;
				       } else if (!strcmp(str, "LoadBalancerPorts[]")) {
				             TRY(!aa, "LoadBalancerPorts[] argument missing\n");
				             SET_NEXT(s->load_balancer_ports, atoi(aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteLoadBalancerListeners'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_load_balancer_listeners_arg;
		     }
		     cret = osc_delete_load_balancer_listeners(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteLoadBalancerListeners: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteLoadBalancer", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_load_balancer_arg a = {0};
		     struct osc_delete_load_balancer_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteLoadBalancer'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_load_balancer_arg;
		     }
		     cret = osc_delete_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteLoadBalancer: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteListenerRule", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_listener_rule_arg a = {0};
		     struct osc_delete_listener_rule_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_listener_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_listener_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ListenerRuleName") ) {
				          TRY(!aa, "ListenerRuleName argument missing\n");
				          s->listener_rule_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteListenerRule'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_listener_rule_arg;
		     }
		     cret = osc_delete_listener_rule(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteListenerRule: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteKeypair", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_keypair_arg a = {0};
		     struct osc_delete_keypair_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_keypair_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_keypair_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "KeypairName") ) {
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteKeypair'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_keypair_arg;
		     }
		     cret = osc_delete_keypair(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteKeypair: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteInternetService", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_internet_service_arg a = {0};
		     struct osc_delete_internet_service_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_internet_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_internet_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "InternetServiceId") ) {
				          TRY(!aa, "InternetServiceId argument missing\n");
				          s->internet_service_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteInternetService'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_internet_service_arg;
		     }
		     cret = osc_delete_internet_service(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteInternetService: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteImage", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_image_arg a = {0};
		     struct osc_delete_image_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_image_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_image_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ImageId") ) {
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteImage'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_image_arg;
		     }
		     cret = osc_delete_image(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteImage: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteFlexibleGpu", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_flexible_gpu_arg a = {0};
		     struct osc_delete_flexible_gpu_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "FlexibleGpuId") ) {
				          TRY(!aa, "FlexibleGpuId argument missing\n");
				          s->flexible_gpu_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteFlexibleGpu'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_flexible_gpu_arg;
		     }
		     cret = osc_delete_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteExportTask", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_export_task_arg a = {0};
		     struct osc_delete_export_task_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_export_task_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_export_task_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ExportTaskId") ) {
				          TRY(!aa, "ExportTaskId argument missing\n");
				          s->export_task_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteExportTask'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_export_task_arg;
		     }
		     cret = osc_delete_export_task(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteExportTask: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteDirectLinkInterface", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_direct_link_interface_arg a = {0};
		     struct osc_delete_direct_link_interface_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_direct_link_interface_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_direct_link_interface_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DirectLinkInterfaceId") ) {
				          TRY(!aa, "DirectLinkInterfaceId argument missing\n");
				          s->direct_link_interface_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteDirectLinkInterface'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_direct_link_interface_arg;
		     }
		     cret = osc_delete_direct_link_interface(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteDirectLinkInterface: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteDirectLink", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_direct_link_arg a = {0};
		     struct osc_delete_direct_link_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_direct_link_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_direct_link_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DirectLinkId") ) {
				          TRY(!aa, "DirectLinkId argument missing\n");
				          s->direct_link_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteDirectLink'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_direct_link_arg;
		     }
		     cret = osc_delete_direct_link(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteDirectLink: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteDhcpOptions", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_dhcp_options_arg a = {0};
		     struct osc_delete_dhcp_options_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_dhcp_options_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_dhcp_options_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DhcpOptionsSetId") ) {
				          TRY(!aa, "DhcpOptionsSetId argument missing\n");
				          s->dhcp_options_set_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteDhcpOptions'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_dhcp_options_arg;
		     }
		     cret = osc_delete_dhcp_options(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteDhcpOptions: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteClientGateway", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_client_gateway_arg a = {0};
		     struct osc_delete_client_gateway_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_client_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_client_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "ClientGatewayId") ) {
				          TRY(!aa, "ClientGatewayId argument missing\n");
				          s->client_gateway_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteClientGateway'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_client_gateway_arg;
		     }
		     cret = osc_delete_client_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteClientGateway: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteCa", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_ca_arg a = {0};
		     struct osc_delete_ca_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_ca_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_ca_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "CaId") ) {
				          TRY(!aa, "CaId argument missing\n");
				          s->ca_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteCa'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_ca_arg;
		     }
		     cret = osc_delete_ca(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteCa: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteApiAccessRule", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_api_access_rule_arg a = {0};
		     struct osc_delete_api_access_rule_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_api_access_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_api_access_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "ApiAccessRuleId") ) {
				          TRY(!aa, "ApiAccessRuleId argument missing\n");
				          s->api_access_rule_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteApiAccessRule'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_api_access_rule_arg;
		     }
		     cret = osc_delete_api_access_rule(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteApiAccessRule: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("DeleteAccessKey", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_access_key_arg a = {0};
		     struct osc_delete_access_key_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_access_key_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto delete_access_key_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AccessKeyId") ) {
				          TRY(!aa, "AccessKeyId argument missing\n");
				          s->access_key_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'DeleteAccessKey'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto delete_access_key_arg;
		     }
		     cret = osc_delete_access_key(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteAccessKey: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateVpnConnectionRoute", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_vpn_connection_route_arg a = {0};
		     struct osc_create_vpn_connection_route_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_vpn_connection_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_vpn_connection_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DestinationIpRange") ) {
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VpnConnectionId") ) {
				          TRY(!aa, "VpnConnectionId argument missing\n");
				          s->vpn_connection_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateVpnConnectionRoute'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_vpn_connection_route_arg;
		     }
		     cret = osc_create_vpn_connection_route(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVpnConnectionRoute: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateVpnConnection", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_vpn_connection_arg a = {0};
		     struct osc_create_vpn_connection_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_vpn_connection_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_vpn_connection_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "ClientGatewayId") ) {
				          TRY(!aa, "ClientGatewayId argument missing\n");
				          s->client_gateway_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "ConnectionType") ) {
				          TRY(!aa, "ConnectionType argument missing\n");
				          s->connection_type = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "StaticRoutesOnly") ) {
				          s->is_set_static_routes_only = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->static_routes_only = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->static_routes_only = 0;
				           } else {
				          		fprintf(stderr, "StaticRoutesOnly require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "VirtualGatewayId") ) {
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateVpnConnection'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_vpn_connection_arg;
		     }
		     cret = osc_create_vpn_connection(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVpnConnection: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateVolume", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_volume_arg a = {0};
		     struct osc_create_volume_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Iops") ) {
				          TRY(!aa, "Iops argument missing\n");
				          s->is_set_iops = 1;
				          s->iops = atoi(aa);
				       } else
			      if (!argcmp(next_a, "Size") ) {
				          TRY(!aa, "Size argument missing\n");
				          s->is_set_size = 1;
				          s->size = atoi(aa);
				       } else
			      if (!argcmp(next_a, "SnapshotId") ) {
				          TRY(!aa, "SnapshotId argument missing\n");
				          s->snapshot_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SubregionName") ) {
				          TRY(!aa, "SubregionName argument missing\n");
				          s->subregion_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "VolumeType") ) {
				          TRY(!aa, "VolumeType argument missing\n");
				          s->volume_type = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateVolume'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_volume_arg;
		     }
		     cret = osc_create_volume(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVolume: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateVms", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_vms_arg a = {0};
		     struct osc_create_vms_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "BlockDeviceMappings") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingVmCreation.BlockDeviceMappings.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'BlockDeviceMappings' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
				          	      cascade_struct = &s->block_device_mappings[pos];
				          	      cascade_parser = block_device_mapping_vm_creation_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      block_device_mapping_vm_creation_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "BlockDeviceMappings argument missing\n");
				          	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingVmCreation ref
				          }
				       } else
			      if (!argcmp(next_a, "BootOnCreation") ) {
				          s->is_set_boot_on_creation = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->boot_on_creation = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->boot_on_creation = 0;
				           } else {
				          		fprintf(stderr, "BootOnCreation require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "BsuOptimized") ) {
				          s->is_set_bsu_optimized = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->bsu_optimized = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->bsu_optimized = 0;
				           } else {
				          		fprintf(stderr, "BsuOptimized require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ClientToken") ) {
				          TRY(!aa, "ClientToken argument missing\n");
				          s->client_token = aa; // string string

				       } else
			      if (!argcmp(next_a, "DeletionProtection") ) {
				          s->is_set_deletion_protection = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->deletion_protection = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->deletion_protection = 0;
				           } else {
				          		fprintf(stderr, "DeletionProtection require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ImageId") ) {
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "KeypairName") ) {
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "MaxVmsCount") ) {
				          TRY(!aa, "MaxVmsCount argument missing\n");
				          s->is_set_max_vms_count = 1;
				          s->max_vms_count = atoi(aa);
				       } else
			      if (!argcmp(next_a, "MinVmsCount") ) {
				          TRY(!aa, "MinVmsCount argument missing\n");
				          s->is_set_min_vms_count = 1;
				          s->min_vms_count = atoi(aa);
				       } else
			      if (!argcmp(next_a, "NestedVirtualization") ) {
				          s->is_set_nested_virtualization = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->nested_virtualization = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->nested_virtualization = 0;
				           } else {
				          		fprintf(stderr, "NestedVirtualization require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Nics") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Nics' require an index (example array ref NicForVmCreation.Nics.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Nics' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,nics, pa, pos, sizeof(*s->nics));
				          	      cascade_struct = &s->nics[pos];
				          	      cascade_parser = nic_for_vm_creation_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      nic_for_vm_creation_parser(&s->nics[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Nics argument missing\n");
				          	s->nics_str = aa; // array ref NicForVmCreation ref
				          }
				       } else
			      if (!argcmp(next_a, "Performance") ) {
				          TRY(!aa, "Performance argument missing\n");
				          s->performance = aa; // string string

				       } else
			      if (!argcmp(next_a, "Placement") ) {
				          char *dot_pos;

				          TRY(!aa, "Placement argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->placement;
				          	    cascade_parser = placement_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    placement_parser(&s->placement, dot_pos, aa, pa);
				          	    s->is_set_placement = 1;
				           } else {
				                 s->placement_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "PrivateIps") ) {
				          	 TRY(!aa, "PrivateIps argument missing\n");
				             s->private_ips_str = aa;
				       } else if (!strcmp(str, "PrivateIps[]")) {
				             TRY(!aa, "PrivateIps[] argument missing\n");
				             SET_NEXT(s->private_ips, (aa), pa);
				       } else
			      if (!argcmp(next_a, "SecurityGroupIds") ) {
				          	 TRY(!aa, "SecurityGroupIds argument missing\n");
				             s->security_group_ids_str = aa;
				       } else if (!strcmp(str, "SecurityGroupIds[]")) {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "SecurityGroups") ) {
				          	 TRY(!aa, "SecurityGroups argument missing\n");
				             s->security_groups_str = aa;
				       } else if (!strcmp(str, "SecurityGroups[]")) {
				             TRY(!aa, "SecurityGroups[] argument missing\n");
				             SET_NEXT(s->security_groups, (aa), pa);
				       } else
			      if (!argcmp(next_a, "SubnetId") ) {
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "UserData") ) {
				          TRY(!aa, "UserData argument missing\n");
				          s->user_data = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmInitiatedShutdownBehavior") ) {
				          TRY(!aa, "VmInitiatedShutdownBehavior argument missing\n");
				          s->vm_initiated_shutdown_behavior = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmType") ) {
				          TRY(!aa, "VmType argument missing\n");
				          s->vm_type = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateVms'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_vms_arg;
		     }
		     cret = osc_create_vms(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVms: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateVirtualGateway", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_virtual_gateway_arg a = {0};
		     struct osc_create_virtual_gateway_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_virtual_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_virtual_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "ConnectionType") ) {
				          TRY(!aa, "ConnectionType argument missing\n");
				          s->connection_type = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateVirtualGateway'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_virtual_gateway_arg;
		     }
		     cret = osc_create_virtual_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVirtualGateway: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateTags", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_tags_arg a = {0};
		     struct osc_create_tags_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ResourceIds") ) {
				          	 TRY(!aa, "ResourceIds argument missing\n");
				             s->resource_ids_str = aa;
				       } else if (!strcmp(str, "ResourceIds[]")) {
				             TRY(!aa, "ResourceIds[] argument missing\n");
				             SET_NEXT(s->resource_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Tags") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Tags' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateTags'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_tags_arg;
		     }
		     cret = osc_create_tags(&e, &r, &a);
            	     TRY(cret, "fail to call CreateTags: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateSubnet", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_subnet_arg a = {0};
		     struct osc_create_subnet_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_subnet_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_subnet_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "IpRange") ) {
				          TRY(!aa, "IpRange argument missing\n");
				          s->ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SubregionName") ) {
				          TRY(!aa, "SubregionName argument missing\n");
				          s->subregion_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateSubnet'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_subnet_arg;
		     }
		     cret = osc_create_subnet(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSubnet: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateSnapshotExportTask", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_snapshot_export_task_arg a = {0};
		     struct osc_create_snapshot_export_task_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_snapshot_export_task_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_snapshot_export_task_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "OsuExport") ) {
				          char *dot_pos;

				          TRY(!aa, "OsuExport argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->osu_export;
				          	    cascade_parser = osu_export_to_create_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    osu_export_to_create_parser(&s->osu_export, dot_pos, aa, pa);
				          	    s->is_set_osu_export = 1;
				           } else {
				                 s->osu_export_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "SnapshotId") ) {
				          TRY(!aa, "SnapshotId argument missing\n");
				          s->snapshot_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateSnapshotExportTask'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_snapshot_export_task_arg;
		     }
		     cret = osc_create_snapshot_export_task(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSnapshotExportTask: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateSnapshot", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_snapshot_arg a = {0};
		     struct osc_create_snapshot_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_snapshot_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_snapshot_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "FileLocation") ) {
				          TRY(!aa, "FileLocation argument missing\n");
				          s->file_location = aa; // string string

				       } else
			      if (!argcmp(next_a, "SnapshotSize") ) {
				          TRY(!aa, "SnapshotSize argument missing\n");
				          s->is_set_snapshot_size = 1;
				          s->snapshot_size = atoi(aa);
				       } else
			      if (!argcmp(next_a, "SourceRegionName") ) {
				          TRY(!aa, "SourceRegionName argument missing\n");
				          s->source_region_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "SourceSnapshotId") ) {
				          TRY(!aa, "SourceSnapshotId argument missing\n");
				          s->source_snapshot_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VolumeId") ) {
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateSnapshot'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_snapshot_arg;
		     }
		     cret = osc_create_snapshot(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSnapshot: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateServerCertificate", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_server_certificate_arg a = {0};
		     struct osc_create_server_certificate_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_server_certificate_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_server_certificate_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "Body") ) {
				          TRY(!aa, "Body argument missing\n");
				          s->body = aa; // string string

				       } else
			      if (!argcmp(next_a, "Chain") ) {
				          TRY(!aa, "Chain argument missing\n");
				          s->chain = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Name") ) {
				          TRY(!aa, "Name argument missing\n");
				          s->name = aa; // string string

				       } else
			      if (!argcmp(next_a, "Path") ) {
				          TRY(!aa, "Path argument missing\n");
				          s->path = aa; // string string

				       } else
			      if (!argcmp(next_a, "PrivateKey") ) {
				          TRY(!aa, "PrivateKey argument missing\n");
				          s->private_key = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateServerCertificate'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_server_certificate_arg;
		     }
		     cret = osc_create_server_certificate(&e, &r, &a);
            	     TRY(cret, "fail to call CreateServerCertificate: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateSecurityGroupRule", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_security_group_rule_arg a = {0};
		     struct osc_create_security_group_rule_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_security_group_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_security_group_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Flow") ) {
				          TRY(!aa, "Flow argument missing\n");
				          s->flow = aa; // string string

				       } else
			      if (!argcmp(next_a, "FromPortRange") ) {
				          TRY(!aa, "FromPortRange argument missing\n");
				          s->is_set_from_port_range = 1;
				          s->from_port_range = atoi(aa);
				       } else
			      if (!argcmp(next_a, "IpProtocol") ) {
				          TRY(!aa, "IpProtocol argument missing\n");
				          s->ip_protocol = aa; // string string

				       } else
			      if (!argcmp(next_a, "IpRange") ) {
				          TRY(!aa, "IpRange argument missing\n");
				          s->ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "Rules") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Rules' require an index (example array ref SecurityGroupRule.Rules.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Rules' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,rules, pa, pos, sizeof(*s->rules));
				          	      cascade_struct = &s->rules[pos];
				          	      cascade_parser = security_group_rule_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      security_group_rule_parser(&s->rules[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Rules argument missing\n");
				          	s->rules_str = aa; // array ref SecurityGroupRule ref
				          }
				       } else
			      if (!argcmp(next_a, "SecurityGroupAccountIdToLink") ) {
				          TRY(!aa, "SecurityGroupAccountIdToLink argument missing\n");
				          s->security_group_account_id_to_link = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroupId") ) {
				          TRY(!aa, "SecurityGroupId argument missing\n");
				          s->security_group_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroupNameToLink") ) {
				          TRY(!aa, "SecurityGroupNameToLink argument missing\n");
				          s->security_group_name_to_link = aa; // string string

				       } else
			      if (!argcmp(next_a, "ToPortRange") ) {
				          TRY(!aa, "ToPortRange argument missing\n");
				          s->is_set_to_port_range = 1;
				          s->to_port_range = atoi(aa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateSecurityGroupRule'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_security_group_rule_arg;
		     }
		     cret = osc_create_security_group_rule(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSecurityGroupRule: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateSecurityGroup", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_security_group_arg a = {0};
		     struct osc_create_security_group_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_security_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_security_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroupName") ) {
				          TRY(!aa, "SecurityGroupName argument missing\n");
				          s->security_group_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateSecurityGroup'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_security_group_arg;
		     }
		     cret = osc_create_security_group(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSecurityGroup: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateRouteTable", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_route_table_arg a = {0};
		     struct osc_create_route_table_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_route_table_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_route_table_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateRouteTable'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_route_table_arg;
		     }
		     cret = osc_create_route_table(&e, &r, &a);
            	     TRY(cret, "fail to call CreateRouteTable: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateRoute", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_route_arg a = {0};
		     struct osc_create_route_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DestinationIpRange") ) {
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "GatewayId") ) {
				          TRY(!aa, "GatewayId argument missing\n");
				          s->gateway_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "NatServiceId") ) {
				          TRY(!aa, "NatServiceId argument missing\n");
				          s->nat_service_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "NetPeeringId") ) {
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "NicId") ) {
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "RouteTableId") ) {
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateRoute'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_route_arg;
		     }
		     cret = osc_create_route(&e, &r, &a);
            	     TRY(cret, "fail to call CreateRoute: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreatePublicIp", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_public_ip_arg a = {0};
		     struct osc_create_public_ip_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_public_ip_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_public_ip_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreatePublicIp'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_public_ip_arg;
		     }
		     cret = osc_create_public_ip(&e, &r, &a);
            	     TRY(cret, "fail to call CreatePublicIp: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateNic", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_nic_arg a = {0};
		     struct osc_create_nic_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "PrivateIps") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'PrivateIps' require an index (example array ref PrivateIpLight.PrivateIps.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'PrivateIps' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,private_ips, pa, pos, sizeof(*s->private_ips));
				          	      cascade_struct = &s->private_ips[pos];
				          	      cascade_parser = private_ip_light_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      private_ip_light_parser(&s->private_ips[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "PrivateIps argument missing\n");
				          	s->private_ips_str = aa; // array ref PrivateIpLight ref
				          }
				       } else
			      if (!argcmp(next_a, "SecurityGroupIds") ) {
				          	 TRY(!aa, "SecurityGroupIds argument missing\n");
				             s->security_group_ids_str = aa;
				       } else if (!strcmp(str, "SecurityGroupIds[]")) {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "SubnetId") ) {
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateNic'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_nic_arg;
		     }
		     cret = osc_create_nic(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNic: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateNetPeering", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_net_peering_arg a = {0};
		     struct osc_create_net_peering_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_net_peering_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_net_peering_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AccepterNetId") ) {
				          TRY(!aa, "AccepterNetId argument missing\n");
				          s->accepter_net_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "SourceNetId") ) {
				          TRY(!aa, "SourceNetId argument missing\n");
				          s->source_net_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateNetPeering'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_net_peering_arg;
		     }
		     cret = osc_create_net_peering(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNetPeering: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateNetAccessPoint", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_net_access_point_arg a = {0};
		     struct osc_create_net_access_point_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_net_access_point_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_net_access_point_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetId") ) {
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "RouteTableIds") ) {
				          	 TRY(!aa, "RouteTableIds argument missing\n");
				             s->route_table_ids_str = aa;
				       } else if (!strcmp(str, "RouteTableIds[]")) {
				             TRY(!aa, "RouteTableIds[] argument missing\n");
				             SET_NEXT(s->route_table_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "ServiceName") ) {
				          TRY(!aa, "ServiceName argument missing\n");
				          s->service_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateNetAccessPoint'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_net_access_point_arg;
		     }
		     cret = osc_create_net_access_point(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNetAccessPoint: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateNet", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_net_arg a = {0};
		     struct osc_create_net_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_net_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_net_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "IpRange") ) {
				          TRY(!aa, "IpRange argument missing\n");
				          s->ip_range = aa; // string string

				       } else
			      if (!argcmp(next_a, "Tenancy") ) {
				          TRY(!aa, "Tenancy argument missing\n");
				          s->tenancy = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateNet'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_net_arg;
		     }
		     cret = osc_create_net(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNet: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateNatService", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_nat_service_arg a = {0};
		     struct osc_create_nat_service_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_nat_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_nat_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "PublicIpId") ) {
				          TRY(!aa, "PublicIpId argument missing\n");
				          s->public_ip_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SubnetId") ) {
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateNatService'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_nat_service_arg;
		     }
		     cret = osc_create_nat_service(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNatService: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateLoadBalancerTags", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_load_balancer_tags_arg a = {0};
		     struct osc_create_load_balancer_tags_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_load_balancer_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_load_balancer_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerNames") ) {
				          	 TRY(!aa, "LoadBalancerNames argument missing\n");
				             s->load_balancer_names_str = aa;
				       } else if (!strcmp(str, "LoadBalancerNames[]")) {
				             TRY(!aa, "LoadBalancerNames[] argument missing\n");
				             SET_NEXT(s->load_balancer_names, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Tags") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Tags' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateLoadBalancerTags'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_load_balancer_tags_arg;
		     }
		     cret = osc_create_load_balancer_tags(&e, &r, &a);
            	     TRY(cret, "fail to call CreateLoadBalancerTags: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateLoadBalancerPolicy", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_load_balancer_policy_arg a = {0};
		     struct osc_create_load_balancer_policy_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_load_balancer_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_load_balancer_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "CookieExpirationPeriod") ) {
				          TRY(!aa, "CookieExpirationPeriod argument missing\n");
				          s->is_set_cookie_expiration_period = 1;
				          s->cookie_expiration_period = atoi(aa);
				       } else
			      if (!argcmp(next_a, "CookieName") ) {
				          TRY(!aa, "CookieName argument missing\n");
				          s->cookie_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "PolicyName") ) {
				          TRY(!aa, "PolicyName argument missing\n");
				          s->policy_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "PolicyType") ) {
				          TRY(!aa, "PolicyType argument missing\n");
				          s->policy_type = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateLoadBalancerPolicy'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_load_balancer_policy_arg;
		     }
		     cret = osc_create_load_balancer_policy(&e, &r, &a);
            	     TRY(cret, "fail to call CreateLoadBalancerPolicy: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateLoadBalancerListeners", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_load_balancer_listeners_arg a = {0};
		     struct osc_create_load_balancer_listeners_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_load_balancer_listeners_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_load_balancer_listeners_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Listeners") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Listeners' require an index (example array ref ListenerForCreation.Listeners.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Listeners' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,listeners, pa, pos, sizeof(*s->listeners));
				          	      cascade_struct = &s->listeners[pos];
				          	      cascade_parser = listener_for_creation_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      listener_for_creation_parser(&s->listeners[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Listeners argument missing\n");
				          	s->listeners_str = aa; // array ref ListenerForCreation ref
				          }
				       } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateLoadBalancerListeners'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_load_balancer_listeners_arg;
		     }
		     cret = osc_create_load_balancer_listeners(&e, &r, &a);
            	     TRY(cret, "fail to call CreateLoadBalancerListeners: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateLoadBalancer", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_load_balancer_arg a = {0};
		     struct osc_create_load_balancer_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Listeners") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Listeners' require an index (example array ref ListenerForCreation.Listeners.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Listeners' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,listeners, pa, pos, sizeof(*s->listeners));
				          	      cascade_struct = &s->listeners[pos];
				          	      cascade_parser = listener_for_creation_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      listener_for_creation_parser(&s->listeners[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Listeners argument missing\n");
				          	s->listeners_str = aa; // array ref ListenerForCreation ref
				          }
				       } else
			      if (!argcmp(next_a, "LoadBalancerName") ) {
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "LoadBalancerType") ) {
				          TRY(!aa, "LoadBalancerType argument missing\n");
				          s->load_balancer_type = aa; // string string

				       } else
			      if (!argcmp(next_a, "PublicIp") ) {
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			      if (!argcmp(next_a, "SecurityGroups") ) {
				          	 TRY(!aa, "SecurityGroups argument missing\n");
				             s->security_groups_str = aa;
				       } else if (!strcmp(str, "SecurityGroups[]")) {
				             TRY(!aa, "SecurityGroups[] argument missing\n");
				             SET_NEXT(s->security_groups, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Subnets") ) {
				          	 TRY(!aa, "Subnets argument missing\n");
				             s->subnets_str = aa;
				       } else if (!strcmp(str, "Subnets[]")) {
				             TRY(!aa, "Subnets[] argument missing\n");
				             SET_NEXT(s->subnets, (aa), pa);
				       } else
			      if (!argcmp(next_a, "SubregionNames") ) {
				          	 TRY(!aa, "SubregionNames argument missing\n");
				             s->subregion_names_str = aa;
				       } else if (!strcmp(str, "SubregionNames[]")) {
				             TRY(!aa, "SubregionNames[] argument missing\n");
				             SET_NEXT(s->subregion_names, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Tags") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'Tags' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateLoadBalancer'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_load_balancer_arg;
		     }
		     cret = osc_create_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call CreateLoadBalancer: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateListenerRule", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_listener_rule_arg a = {0};
		     struct osc_create_listener_rule_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_listener_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_listener_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Listener") ) {
				          char *dot_pos;

				          TRY(!aa, "Listener argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->listener;
				          	    cascade_parser = load_balancer_light_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    load_balancer_light_parser(&s->listener, dot_pos, aa, pa);
				          	    s->is_set_listener = 1;
				           } else {
				                 s->listener_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "ListenerRule") ) {
				          char *dot_pos;

				          TRY(!aa, "ListenerRule argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->listener_rule;
				          	    cascade_parser = listener_rule_for_creation_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    listener_rule_for_creation_parser(&s->listener_rule, dot_pos, aa, pa);
				          	    s->is_set_listener_rule = 1;
				           } else {
				                 s->listener_rule_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "VmIds") ) {
				          	 TRY(!aa, "VmIds argument missing\n");
				             s->vm_ids_str = aa;
				       } else if (!strcmp(str, "VmIds[]")) {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateListenerRule'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_listener_rule_arg;
		     }
		     cret = osc_create_listener_rule(&e, &r, &a);
            	     TRY(cret, "fail to call CreateListenerRule: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateKeypair", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_keypair_arg a = {0};
		     struct osc_create_keypair_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_keypair_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_keypair_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "KeypairName") ) {
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "PublicKey") ) {
				          TRY(!aa, "PublicKey argument missing\n");
				          s->public_key = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateKeypair'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_keypair_arg;
		     }
		     cret = osc_create_keypair(&e, &r, &a);
            	     TRY(cret, "fail to call CreateKeypair: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateInternetService", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_internet_service_arg a = {0};
		     struct osc_create_internet_service_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_internet_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_internet_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateInternetService'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_internet_service_arg;
		     }
		     cret = osc_create_internet_service(&e, &r, &a);
            	     TRY(cret, "fail to call CreateInternetService: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateImageExportTask", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_image_export_task_arg a = {0};
		     struct osc_create_image_export_task_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_image_export_task_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_image_export_task_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ImageId") ) {
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "OsuExport") ) {
				          char *dot_pos;

				          TRY(!aa, "OsuExport argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->osu_export;
				          	    cascade_parser = osu_export_to_create_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    osu_export_to_create_parser(&s->osu_export, dot_pos, aa, pa);
				          	    s->is_set_osu_export = 1;
				           } else {
				                 s->osu_export_str = aa;
				           }
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateImageExportTask'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_image_export_task_arg;
		     }
		     cret = osc_create_image_export_task(&e, &r, &a);
            	     TRY(cret, "fail to call CreateImageExportTask: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateImage", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_image_arg a = {0};
		     struct osc_create_image_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_image_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_image_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "Architecture") ) {
				          TRY(!aa, "Architecture argument missing\n");
				          s->architecture = aa; // string string

				       } else
			      if (!argcmp(next_a, "BlockDeviceMappings") ) {
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos) {
				          		      fprintf(stderr, "'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingImage.BlockDeviceMappings.0)\n");
				          		      return -1;
				          	      } else if (*endptr != '.') {
				          		      fprintf(stderr, "'BlockDeviceMappings' require a .\n");
				          		      return -1;
				          	      }
				          	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
				          	      cascade_struct = &s->block_device_mappings[pos];
				          	      cascade_parser = block_device_mapping_image_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      block_device_mapping_image_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa);
				           } else {
				          	TRY(!aa, "BlockDeviceMappings argument missing\n");
				          	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingImage ref
				          }
				       } else
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "FileLocation") ) {
				          TRY(!aa, "FileLocation argument missing\n");
				          s->file_location = aa; // string string

				       } else
			      if (!argcmp(next_a, "ImageName") ) {
				          TRY(!aa, "ImageName argument missing\n");
				          s->image_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "NoReboot") ) {
				          s->is_set_no_reboot = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->no_reboot = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->no_reboot = 0;
				           } else {
				          		fprintf(stderr, "NoReboot require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "RootDeviceName") ) {
				          TRY(!aa, "RootDeviceName argument missing\n");
				          s->root_device_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "SourceImageId") ) {
				          TRY(!aa, "SourceImageId argument missing\n");
				          s->source_image_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "SourceRegionName") ) {
				          TRY(!aa, "SourceRegionName argument missing\n");
				          s->source_region_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "VmId") ) {
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateImage'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_image_arg;
		     }
		     cret = osc_create_image(&e, &r, &a);
            	     TRY(cret, "fail to call CreateImage: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateFlexibleGpu", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_flexible_gpu_arg a = {0};
		     struct osc_create_flexible_gpu_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DeleteOnVmDeletion") ) {
				          s->is_set_delete_on_vm_deletion = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->delete_on_vm_deletion = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->delete_on_vm_deletion = 0;
				           } else {
				          		fprintf(stderr, "DeleteOnVmDeletion require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Generation") ) {
				          TRY(!aa, "Generation argument missing\n");
				          s->generation = aa; // string string

				       } else
			      if (!argcmp(next_a, "ModelName") ) {
				          TRY(!aa, "ModelName argument missing\n");
				          s->model_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "SubregionName") ) {
				          TRY(!aa, "SubregionName argument missing\n");
				          s->subregion_name = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateFlexibleGpu'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_flexible_gpu_arg;
		     }
		     cret = osc_create_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call CreateFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateDirectLinkInterface", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_direct_link_interface_arg a = {0};
		     struct osc_create_direct_link_interface_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_direct_link_interface_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_direct_link_interface_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DirectLinkId") ) {
				          TRY(!aa, "DirectLinkId argument missing\n");
				          s->direct_link_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DirectLinkInterface") ) {
				          char *dot_pos;

				          TRY(!aa, "DirectLinkInterface argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->direct_link_interface;
				          	    cascade_parser = direct_link_interface_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    direct_link_interface_parser(&s->direct_link_interface, dot_pos, aa, pa);
				          	    s->is_set_direct_link_interface = 1;
				           } else {
				                 s->direct_link_interface_str = aa;
				           }
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateDirectLinkInterface'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_direct_link_interface_arg;
		     }
		     cret = osc_create_direct_link_interface(&e, &r, &a);
            	     TRY(cret, "fail to call CreateDirectLinkInterface: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateDirectLink", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_direct_link_arg a = {0};
		     struct osc_create_direct_link_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_direct_link_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_direct_link_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "Bandwidth") ) {
				          TRY(!aa, "Bandwidth argument missing\n");
				          s->bandwidth = aa; // string string

				       } else
			      if (!argcmp(next_a, "DirectLinkName") ) {
				          TRY(!aa, "DirectLinkName argument missing\n");
				          s->direct_link_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Location") ) {
				          TRY(!aa, "Location argument missing\n");
				          s->location = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateDirectLink'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_direct_link_arg;
		     }
		     cret = osc_create_direct_link(&e, &r, &a);
            	     TRY(cret, "fail to call CreateDirectLink: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateDhcpOptions", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_dhcp_options_arg a = {0};
		     struct osc_create_dhcp_options_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_dhcp_options_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_dhcp_options_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DomainName") ) {
				          TRY(!aa, "DomainName argument missing\n");
				          s->domain_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "DomainNameServers") ) {
				          	 TRY(!aa, "DomainNameServers argument missing\n");
				             s->domain_name_servers_str = aa;
				       } else if (!strcmp(str, "DomainNameServers[]")) {
				             TRY(!aa, "DomainNameServers[] argument missing\n");
				             SET_NEXT(s->domain_name_servers, (aa), pa);
				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "LogServers") ) {
				          	 TRY(!aa, "LogServers argument missing\n");
				             s->log_servers_str = aa;
				       } else if (!strcmp(str, "LogServers[]")) {
				             TRY(!aa, "LogServers[] argument missing\n");
				             SET_NEXT(s->log_servers, (aa), pa);
				       } else
			      if (!argcmp(next_a, "NtpServers") ) {
				          	 TRY(!aa, "NtpServers argument missing\n");
				             s->ntp_servers_str = aa;
				       } else if (!strcmp(str, "NtpServers[]")) {
				             TRY(!aa, "NtpServers[] argument missing\n");
				             SET_NEXT(s->ntp_servers, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateDhcpOptions'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_dhcp_options_arg;
		     }
		     cret = osc_create_dhcp_options(&e, &r, &a);
            	     TRY(cret, "fail to call CreateDhcpOptions: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateClientGateway", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_client_gateway_arg a = {0};
		     struct osc_create_client_gateway_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_client_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_client_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "BgpAsn") ) {
				          TRY(!aa, "BgpAsn argument missing\n");
				          s->is_set_bgp_asn = 1;
				          s->bgp_asn = atoi(aa);
				       } else
			      if (!argcmp(next_a, "ConnectionType") ) {
				          TRY(!aa, "ConnectionType argument missing\n");
				          s->connection_type = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "PublicIp") ) {
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateClientGateway'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_client_gateway_arg;
		     }
		     cret = osc_create_client_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call CreateClientGateway: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateCa", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_ca_arg a = {0};
		     struct osc_create_ca_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_ca_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_ca_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "CaPem") ) {
				          TRY(!aa, "CaPem argument missing\n");
				          s->ca_pem = aa; // string string

				       } else
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateCa'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_ca_arg;
		     }
		     cret = osc_create_ca(&e, &r, &a);
            	     TRY(cret, "fail to call CreateCa: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateApiAccessRule", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_api_access_rule_arg a = {0};
		     struct osc_create_api_access_rule_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_api_access_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_api_access_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "CaIds") ) {
				          	 TRY(!aa, "CaIds argument missing\n");
				             s->ca_ids_str = aa;
				       } else if (!strcmp(str, "CaIds[]")) {
				             TRY(!aa, "CaIds[] argument missing\n");
				             SET_NEXT(s->ca_ids, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Cns") ) {
				          	 TRY(!aa, "Cns argument missing\n");
				             s->cns_str = aa;
				       } else if (!strcmp(str, "Cns[]")) {
				             TRY(!aa, "Cns[] argument missing\n");
				             SET_NEXT(s->cns, (aa), pa);
				       } else
			      if (!argcmp(next_a, "Description") ) {
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "IpRanges") ) {
				          	 TRY(!aa, "IpRanges argument missing\n");
				             s->ip_ranges_str = aa;
				       } else if (!strcmp(str, "IpRanges[]")) {
				             TRY(!aa, "IpRanges[] argument missing\n");
				             SET_NEXT(s->ip_ranges, (aa), pa);
				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateApiAccessRule'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_api_access_rule_arg;
		     }
		     cret = osc_create_api_access_rule(&e, &r, &a);
            	     TRY(cret, "fail to call CreateApiAccessRule: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateAccount", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_account_arg a = {0};
		     struct osc_create_account_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_account_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_account_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "AdditionalEmails") ) {
				          	 TRY(!aa, "AdditionalEmails argument missing\n");
				             s->additional_emails_str = aa;
				       } else if (!strcmp(str, "AdditionalEmails[]")) {
				             TRY(!aa, "AdditionalEmails[] argument missing\n");
				             SET_NEXT(s->additional_emails, (aa), pa);
				       } else
			      if (!argcmp(next_a, "City") ) {
				          TRY(!aa, "City argument missing\n");
				          s->city = aa; // string string

				       } else
			      if (!argcmp(next_a, "CompanyName") ) {
				          TRY(!aa, "CompanyName argument missing\n");
				          s->company_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "Country") ) {
				          TRY(!aa, "Country argument missing\n");
				          s->country = aa; // string string

				       } else
			      if (!argcmp(next_a, "CustomerId") ) {
				          TRY(!aa, "CustomerId argument missing\n");
				          s->customer_id = aa; // string string

				       } else
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Email") ) {
				          TRY(!aa, "Email argument missing\n");
				          s->email = aa; // string string

				       } else
			      if (!argcmp(next_a, "FirstName") ) {
				          TRY(!aa, "FirstName argument missing\n");
				          s->first_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "JobTitle") ) {
				          TRY(!aa, "JobTitle argument missing\n");
				          s->job_title = aa; // string string

				       } else
			      if (!argcmp(next_a, "LastName") ) {
				          TRY(!aa, "LastName argument missing\n");
				          s->last_name = aa; // string string

				       } else
			      if (!argcmp(next_a, "MobileNumber") ) {
				          TRY(!aa, "MobileNumber argument missing\n");
				          s->mobile_number = aa; // string string

				       } else
			      if (!argcmp(next_a, "PhoneNumber") ) {
				          TRY(!aa, "PhoneNumber argument missing\n");
				          s->phone_number = aa; // string string

				       } else
			      if (!argcmp(next_a, "StateProvince") ) {
				          TRY(!aa, "StateProvince argument missing\n");
				          s->state_province = aa; // string string

				       } else
			      if (!argcmp(next_a, "VatNumber") ) {
				          TRY(!aa, "VatNumber argument missing\n");
				          s->vat_number = aa; // string string

				       } else
			      if (!argcmp(next_a, "ZipCode") ) {
				          TRY(!aa, "ZipCode argument missing\n");
				          s->zip_code = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateAccount'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_account_arg;
		     }
		     cret = osc_create_account(&e, &r, &a);
            	     TRY(cret, "fail to call CreateAccount: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CreateAccessKey", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_access_key_arg a = {0};
		     struct osc_create_access_key_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_access_key_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto create_access_key_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "ExpirationDate") ) {
				          TRY(!aa, "ExpirationDate argument missing\n");
				          s->expiration_date = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CreateAccessKey'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto create_access_key_arg;
		     }
		     cret = osc_create_access_key(&e, &r, &a);
            	     TRY(cret, "fail to call CreateAccessKey: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("CheckAuthentication", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_check_authentication_arg a = {0};
		     struct osc_check_authentication_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     check_authentication_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto check_authentication_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "Login") ) {
				          TRY(!aa, "Login argument missing\n");
				          s->login = aa; // string string

				       } else
			      if (!argcmp(next_a, "Password") ) {
				          TRY(!aa, "Password argument missing\n");
				          s->password = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'CheckAuthentication'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto check_authentication_arg;
		     }
		     cret = osc_check_authentication(&e, &r, &a);
            	     TRY(cret, "fail to call CheckAuthentication: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
              if (!strcmp("AcceptNetPeering", av[i])) {
		     json_object *jobj;
		     struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_accept_net_peering_arg a = {0};
		     struct osc_accept_net_peering_arg *s = &a;
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     accept_net_peering_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;

		      	   if (!cascade_struct) {
		      	          fprintf(stderr, "cascade need to be se first\n");
		      	      	  return 1;
		      	   }
			   if (!aa || aa[0] == '-') {
			      	  fprintf(stderr, "cascade need an argument\n");
		      	      	  return 1;
			   }
		      	   cascade_parser(cascade_struct, next_a, aa, pa);
			   i += 2;
		       	   goto accept_net_peering_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-') {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int incr = aa ? 2 : 1;

			     if (aa && aa[0] == '-' && aa[1] == '-') {
				aa = 0;
				incr = 1;
			     }
			      if (!argcmp(next_a, "DryRun") ) {
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		fprintf(stderr, "DryRun require true/false\n");
				          		return 1;
				           }
				      } else
			      if (!argcmp(next_a, "NetPeeringId") ) {
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			    {
				fprintf(stderr, "'%s' is not a valide argument for 'AcceptNetPeering'\n", next_a);
				return 1;
			    }
		            i += incr;
			    goto accept_net_peering_arg;
		     }
		     cret = osc_accept_net_peering(&e, &r, &a);
            	     TRY(cret, "fail to call AcceptNetPeering: %s\n", curl_easy_strerror(cret));
		     if (!r.buf) {
			    fprintf(stderr, "connection sucessful, but empty responce\n");
			    return 1;
		     }
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
			     json_object_put(jobj);
		      }
		     osc_deinit_str(&r);
		     ptr_array_free_all(pa);
	      } else
		{
			printf("Unknow Call %s\n", av[i]);
			ret = 1;
			goto out;
		}
	}
good:
	ret = 0;
out:
	return ret;
}
