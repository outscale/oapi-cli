/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, Outscale SAS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

 /*
  * This code is autogenerated, don't edit it directely
  */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "json.h"
#include "osc_sdk.h"
#include "main-helper.h"

#ifndef JSON_C_TO_STRING_COLOR
#define JSON_C_TO_STRING_COLOR 0
#endif

#define OAPI_RAW_OUTPUT 1

#define OAPI_CLI_VERSION "0.4.0"

#define OAPI_CLI_UAGENT "oapi-cli/"OAPI_CLI_VERSION"; osc-sdk-c/"

#define STRY(f, args...)					\
	do {							\
		if (f) {return 1;}				\
	} while(0)

#define TRY(f, args...)						\
	do {							\
		if (f) {fprintf(stderr, args);  return -1;}	\
	} while(0)

#define META_ARGS(else_cnd)                                                     \
	if (!strcmp(aa, "--file")) {                                        \
		TRY(i + 3 >= ac, "file name require");                          \
		++incr;                                                         \
		aa = read_file(files_cnt, av[i + 3], 0);                        \
		STRY(!aa);                                                      \
	} else if (!strcmp(aa, "--jsonstr-file")) {                         \
		TRY(i + 3 >= ac, "file name require");                          \
		++incr;                                                         \
		aa = read_file(files_cnt, av[i + 3], 1);                        \
		STRY(!aa);                                                      \
	} else if (!strcmp(aa, "--var")) {                                  \
		TRY(i + 3 >= ac, "var name require");                           \
		int var_found = 0;                                              \
		for (int j = 0; j < nb_cli_vars; ++j) {                         \
			if (!strcmp(cli_vars[j].name, av[i + 3])) {                 \
				var_found = 1;                                          \
				aa = cli_vars[j].val;                                   \
			}                                                           \
		}                                                               \
		TRY(!var_found, "--var could not find osc variable '%s'", av[i + 3]); \
		++incr;                                                         \
		STRY(!aa);                                                      \
	} else \
		else_cnd


#define VAR_NAME_SIZE 128
#define VAR_VAL_SIZE 512
#define VAR_ARRAY_SIZE 128

static int nb_cli_vars;

struct cli_var {
	char name[VAR_NAME_SIZE];
	char val[VAR_VAL_SIZE];
} cli_vars[VAR_ARRAY_SIZE];

static void *cascade_struct;
static int (*cascade_parser)(void *, char *, char *, struct ptr_array *);

static int argcmp2(const char *s1, const char *s2, char dst)
{
	while (*s1 == *s2 && *s1 && *s2) {
		s1++;
		s2++;
	}
	if ((*s2 == dst && *s1 == '\0') ||
	    (*s1 == dst && *s2 == '\0'))
		return 0;
	return *s1 - *s2;
}

static int argcmp(const char *s1, const char *s2)
{
	return argcmp2(s1, s2, '.');
}

#define MAX_FILES_PER_CMD 64

static void files_cnt_cleanup(char * (*files_cnt_ptr)[64])
{
	for (int i = 0; i < MAX_FILES_PER_CMD && (*files_cnt_ptr)[i]; ++i) {
		free((*files_cnt_ptr)[i]);
	}
}

char *string_to_jsonstr(char **file_str_p)
{
	/* no auto free, as we steal s.buf */
	struct osc_str s;
	char *in = *file_str_p;
	char *double_quote;
	char *tmp = in;

	osc_init_str(&s);
	while((double_quote = strchr(tmp, '"')) != NULL) {
		int l = double_quote - tmp;

		osc_str_append_n_string(&s, tmp, l);
		osc_str_append_string(&s, "\\\"");
		tmp = double_quote + 1;
	}
	osc_str_append_string(&s, tmp);

	free(in);
	*file_str_p = s.buf;
	return *file_str_p;
}

static int parse_variable(json_object *jobj, char **av, int ac, int i)
{
	const char *tmp = av[i + 1];
	const char *tmp2;
	TRY(nb_cli_vars >= VAR_ARRAY_SIZE, "variable asignement fail: too much variables");
	struct cli_var *var = &cli_vars[nb_cli_vars++];
	json_object *j = jobj;
	char buf[512];

	tmp2 = strchr(tmp, '=');
	TRY(!tmp2, "variable asignement fail (missing '='))\n");
	TRY((uintptr_t)(tmp2 - tmp) >= VAR_NAME_SIZE, "var name too long");
	strncpy(var->name, tmp, tmp2 - tmp);
	var->name[tmp2 - tmp] = 0;
	tmp = tmp2 + 1;

	while ((tmp2 = strchr(tmp, '.')) != NULL) {
		char *end = NULL;
		// get json
		int idx = strtoul(tmp, &end, 0);
		if (end != tmp) {
			j = json_object_array_get_idx(j, idx);
		} else {
			TRY((uintptr_t)(tmp2 - tmp) >= sizeof buf - 1,
			    "variable asignement fail");
			strncpy(buf, tmp, tmp2 - tmp);
			buf[tmp2 - tmp] = 0;
			j = json_object_object_get(j, buf);
		}
		TRY(!j, "variable asignement fail (not found)");
		tmp = tmp2 + 1;
	}
	tmp2 = tmp + strlen(tmp);
	TRY((uintptr_t)(tmp2 - tmp) >= sizeof buf - 1,
	    "variable asignement fail");
	strncpy(buf, tmp, tmp2 - tmp);
	buf[tmp2 - tmp] = 0;
	j = json_object_object_get(j, buf);
	if (json_object_is_type(j, json_type_string)) {
		tmp = json_object_get_string(j);
	} else {
		tmp = json_object_to_json_string_ext(j, JSON_C_TO_STRING_PLAIN);
	}
	TRY(strlen(tmp) >= VAR_VAL_SIZE, "variable asignement fail: value too big");
	strcpy(var->val, tmp);
	return 0;

}

char *read_file(char *files_cnt[static MAX_FILES_PER_CMD], char *file_name,
		int is_json)
{
	int dest = -1;
	const char *call_name = is_json ? "--jsonstr-file" : "--file";
	for (int i = 0; i < MAX_FILES_PER_CMD; ++i) {
		if (!files_cnt[i]) {
			dest = i;
			break;
		}
	}
	if (dest < 0) {
		fprintf(stderr, "%s option used too much", call_name);
		return NULL;
	}
	FILE *f = fopen(file_name, "rb");
	if (!f) {
		fprintf(stderr, "%s fail to open %s", call_name, file_name);
		return NULL;
	}
	if (fseek(f, 0, SEEK_END) < 0) {
		fprintf(stderr, "%s fseek fail for %s", call_name, file_name);
		goto error;
	}
	long fsize = ftell(f);
	if (fseek(f, 0, SEEK_SET) < 0) {
		fprintf(stderr, "%s fseek fail for %s", call_name, file_name);
		goto error;
	}

	files_cnt[dest] = malloc(fsize + 1);
	if (!files_cnt[dest]) {
		fprintf(stderr, "%s malloc fail for %s", call_name, file_name);
		goto error;
	}
	fread(files_cnt[dest], fsize, 1, f);
	if (ferror(f)) {
		fprintf(stderr, "%s fread fail for %s", call_name, file_name);
		goto error;
	}
	fclose(f);
	files_cnt[dest][fsize] = 0;
	if (is_json)
		return string_to_jsonstr(&files_cnt[dest]);
	return files_cnt[dest];
error:
	fclose(f);
	return NULL;
}

int accepter_net_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int access_key_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int access_key_secret_key_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int access_log_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int account_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int api_access_policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int api_access_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int application_sticky_cookie_policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int backend_vm_health_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int block_device_mapping_created_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int block_device_mapping_image_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int block_device_mapping_vm_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int block_device_mapping_vm_update_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int bsu_created_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int bsu_to_create_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int bsu_to_update_vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int ca_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int catalog_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int catalog_entry_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int catalogs_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int client_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int consumption_entry_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int dedicated_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int dhcp_options_set_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int direct_link_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int direct_link_interface_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int direct_link_interfaces_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int errors_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_access_keys_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_api_access_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_api_log_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_ca_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_catalogs_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_client_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_dedicated_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_dhcp_options_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_direct_link_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_direct_link_interface_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_flexible_gpu_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_image_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_internet_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_keypair_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_listener_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_load_balancer_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_nat_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_net_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_net_access_point_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_net_peering_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_nic_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_product_type_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_public_ip_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_quota_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_route_table_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_security_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_server_certificate_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_snapshot_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_subnet_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_subregion_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_user_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_virtual_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vm_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vm_template_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vm_type_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vms_state_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_volume_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int filters_vpn_connection_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int flexible_gpu_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int flexible_gpu_catalog_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int health_check_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int image_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int image_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int inline_policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int internet_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int keypair_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int keypair_created_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_nic_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_nic_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_nic_to_update_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_public_ip_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_public_ip_light_for_vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int link_route_table_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int linked_policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int linked_volume_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int listener_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int listener_for_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int listener_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int listener_rule_for_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int load_balancer_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int load_balancer_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int load_balancer_sticky_cookie_policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int load_balancer_tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int location_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int log_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int maintenance_event_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int nat_service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_access_point_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_peering_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_peering_state_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int net_to_virtual_gateway_link_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int nic_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int nic_for_vm_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int nic_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int osu_api_key_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int osu_export_image_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int osu_export_snapshot_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int osu_export_to_create_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int permissions_on_resource_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int permissions_on_resource_creation_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int phase1_options_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int phase2_options_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int placement_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int policy_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int policy_version_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int private_ip_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int private_ip_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int private_ip_light_for_vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int product_type_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int public_ip_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int public_ip_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int quota_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int quota_types_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int read_linked_policies_filters_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int read_policies_filters_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int region_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int resource_load_balancer_tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int resource_tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int route_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int route_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int route_propagating_virtual_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int route_table_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int security_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int security_group_light_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int security_group_rule_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int security_groups_member_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int server_certificate_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int service_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int snapshot_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int snapshot_export_task_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int source_net_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int source_security_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int state_comment_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int subnet_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int subregion_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int tag_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int user_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int user_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vgw_telemetry_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int virtual_gateway_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_group_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_state_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_states_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_template_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vm_type_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int volume_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vpn_connection_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int vpn_options_parser(void *s, char *str, char *aa, struct ptr_array *pa);
int with_parser(void *s, char *str, char *aa, struct ptr_array *pa);

int accepter_net_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct accepter_net *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "IpRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "IpRange argument missing\n");
            s->ip_range = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'AccepterNet'\n", str);
		return -1;
	}
	return 0;
}

int access_key_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct access_key *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccessKeyId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccessKeyId argument missing\n");
            s->access_key_id = aa; // string string

         } else
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "ExpirationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ExpirationDate argument missing\n");
            s->expiration_date = aa; // string string

         } else
	if ((aret = strcmp(str, "LastModificationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LastModificationDate argument missing\n");
            s->last_modification_date = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'AccessKey'\n", str);
		return -1;
	}
	return 0;
}

int access_key_secret_key_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct access_key_secret_key *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccessKeyId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccessKeyId argument missing\n");
            s->access_key_id = aa; // string string

         } else
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "ExpirationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ExpirationDate argument missing\n");
            s->expiration_date = aa; // string string

         } else
	if ((aret = strcmp(str, "LastModificationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LastModificationDate argument missing\n");
            s->last_modification_date = aa; // string string

         } else
	if ((aret = strcmp(str, "SecretKey")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecretKey argument missing\n");
            s->secret_key = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'AccessKeySecretKey'\n", str);
		return -1;
	}
	return 0;
}

int access_log_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct access_log *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "IsEnabled")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_enabled = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_enabled = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_enabled = 0;
             } else {
            		BAD_RET("IsEnabled require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "OsuBucketName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuBucketName argument missing\n");
            s->osu_bucket_name = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuBucketPrefix")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuBucketPrefix argument missing\n");
            s->osu_bucket_prefix = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicationInterval")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicationInterval argument missing\n");
            s->is_set_publication_interval = 1;
            s->publication_interval = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'AccessLog'\n", str);
		return -1;
	}
	return 0;
}

int account_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct account *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "AdditionalEmails")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AdditionalEmails argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AdditionalEmails require an index\n");
                      if (s->additional_emails) {
                              for (; s->additional_emails[last]; ++last);
                      }
                      if (pos < last) {
                              s->additional_emails[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->additional_emails, "", pa);
                              SET_NEXT(s->additional_emails, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AdditionalEmails argument missing\n");
                     s->additional_emails_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AdditionalEmails[]")) || aret == '=') {
               TRY(!aa, "AdditionalEmails[] argument missing\n");
               SET_NEXT(s->additional_emails, (aa), pa);
         } else
	if ((aret = strcmp(str, "City")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "City argument missing\n");
            s->city = aa; // string string

         } else
	if ((aret = strcmp(str, "CompanyName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CompanyName argument missing\n");
            s->company_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Country")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Country argument missing\n");
            s->country = aa; // string string

         } else
	if ((aret = strcmp(str, "CustomerId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CustomerId argument missing\n");
            s->customer_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Email")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Email argument missing\n");
            s->email = aa; // string string

         } else
	if ((aret = strcmp(str, "FirstName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "FirstName argument missing\n");
            s->first_name = aa; // string string

         } else
	if ((aret = strcmp(str, "JobTitle")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "JobTitle argument missing\n");
            s->job_title = aa; // string string

         } else
	if ((aret = strcmp(str, "LastName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LastName argument missing\n");
            s->last_name = aa; // string string

         } else
	if ((aret = strcmp(str, "MobileNumber")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MobileNumber argument missing\n");
            s->mobile_number = aa; // string string

         } else
	if ((aret = strcmp(str, "PhoneNumber")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PhoneNumber argument missing\n");
            s->phone_number = aa; // string string

         } else
	if ((aret = strcmp(str, "StateProvince")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "StateProvince argument missing\n");
            s->state_province = aa; // string string

         } else
	if ((aret = strcmp(str, "VatNumber")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VatNumber argument missing\n");
            s->vat_number = aa; // string string

         } else
	if ((aret = strcmp(str, "ZipCode")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ZipCode argument missing\n");
            s->zip_code = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Account'\n", str);
		return -1;
	}
	return 0;
}

int api_access_policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct api_access_policy *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "MaxAccessKeyExpirationSeconds")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MaxAccessKeyExpirationSeconds argument missing\n");
            s->is_set_max_access_key_expiration_seconds = 1;
            s->max_access_key_expiration_seconds = atoi(aa);
         } else
	if ((aret = strcmp(str, "RequireTrustedEnv")) == 0 || aret == '=' || aret == '.') {
            s->is_set_require_trusted_env = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->require_trusted_env = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->require_trusted_env = 0;
             } else {
            		BAD_RET("RequireTrustedEnv require true/false\n");
             }
        } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ApiAccessPolicy'\n", str);
		return -1;
	}
	return 0;
}

int api_access_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct api_access_rule *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ApiAccessRuleId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ApiAccessRuleId argument missing\n");
            s->api_access_rule_id = aa; // string string

         } else
	if ((aret = strcmp(str, "CaIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CaIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CaIds require an index\n");
                      if (s->ca_ids) {
                              for (; s->ca_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->ca_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ca_ids, "", pa);
                              SET_NEXT(s->ca_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CaIds argument missing\n");
                     s->ca_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CaIds[]")) || aret == '=') {
               TRY(!aa, "CaIds[] argument missing\n");
               SET_NEXT(s->ca_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "Cns")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Cns argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Cns require an index\n");
                      if (s->cns) {
                              for (; s->cns[last]; ++last);
                      }
                      if (pos < last) {
                              s->cns[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->cns, "", pa);
                              SET_NEXT(s->cns, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Cns argument missing\n");
                     s->cns_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Cns[]")) || aret == '=') {
               TRY(!aa, "Cns[] argument missing\n");
               SET_NEXT(s->cns, (aa), pa);
         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "IpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "IpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "IpRanges require an index\n");
                      if (s->ip_ranges) {
                              for (; s->ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ip_ranges, "", pa);
                              SET_NEXT(s->ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "IpRanges argument missing\n");
                     s->ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "IpRanges[]")) || aret == '=') {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ApiAccessRule'\n", str);
		return -1;
	}
	return 0;
}

int application_sticky_cookie_policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct application_sticky_cookie_policy *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CookieName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CookieName argument missing\n");
            s->cookie_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PolicyName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PolicyName argument missing\n");
            s->policy_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ApplicationStickyCookiePolicy'\n", str);
		return -1;
	}
	return 0;
}

int backend_vm_health_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct backend_vm_health *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "StateReason")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "StateReason argument missing\n");
            s->state_reason = aa; // string string

         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BackendVmHealth'\n", str);
		return -1;
	}
	return 0;
}

int block_device_mapping_created_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct block_device_mapping_created *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Bsu")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Bsu argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->bsu;
            	    cascade_parser = bsu_created_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(bsu_created_parser(&s->bsu, dot_pos, aa, pa));
            	    s->is_set_bsu = 1;
             } else {
                   s->bsu_str = aa;
             }
         } else
	if ((aret = strcmp(str, "DeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BlockDeviceMappingCreated'\n", str);
		return -1;
	}
	return 0;
}

int block_device_mapping_image_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct block_device_mapping_image *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Bsu")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Bsu argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->bsu;
            	    cascade_parser = bsu_to_create_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(bsu_to_create_parser(&s->bsu, dot_pos, aa, pa));
            	    s->is_set_bsu = 1;
             } else {
                   s->bsu_str = aa;
             }
         } else
	if ((aret = strcmp(str, "DeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	if ((aret = strcmp(str, "VirtualDeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VirtualDeviceName argument missing\n");
            s->virtual_device_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BlockDeviceMappingImage'\n", str);
		return -1;
	}
	return 0;
}

int block_device_mapping_vm_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct block_device_mapping_vm_creation *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Bsu")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Bsu argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->bsu;
            	    cascade_parser = bsu_to_create_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(bsu_to_create_parser(&s->bsu, dot_pos, aa, pa));
            	    s->is_set_bsu = 1;
             } else {
                   s->bsu_str = aa;
             }
         } else
	if ((aret = strcmp(str, "DeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	if ((aret = strcmp(str, "NoDevice")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NoDevice argument missing\n");
            s->no_device = aa; // string string

         } else
	if ((aret = strcmp(str, "VirtualDeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VirtualDeviceName argument missing\n");
            s->virtual_device_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BlockDeviceMappingVmCreation'\n", str);
		return -1;
	}
	return 0;
}

int block_device_mapping_vm_update_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct block_device_mapping_vm_update *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Bsu")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Bsu argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->bsu;
            	    cascade_parser = bsu_to_update_vm_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(bsu_to_update_vm_parser(&s->bsu, dot_pos, aa, pa));
            	    s->is_set_bsu = 1;
             } else {
                   s->bsu_str = aa;
             }
         } else
	if ((aret = strcmp(str, "DeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	if ((aret = strcmp(str, "NoDevice")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NoDevice argument missing\n");
            s->no_device = aa; // string string

         } else
	if ((aret = strcmp(str, "VirtualDeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VirtualDeviceName argument missing\n");
            s->virtual_device_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BlockDeviceMappingVmUpdate'\n", str);
		return -1;
	}
	return 0;
}

int bsu_created_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct bsu_created *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LinkDate argument missing\n");
            s->link_date = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "VolumeId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BsuCreated'\n", str);
		return -1;
	}
	return 0;
}

int bsu_to_create_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct bsu_to_create *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "Iops")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Iops argument missing\n");
            s->is_set_iops = 1;
            s->iops = atoi(aa);
         } else
	if ((aret = strcmp(str, "SnapshotId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SnapshotId argument missing\n");
            s->snapshot_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VolumeSize")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeSize argument missing\n");
            s->is_set_volume_size = 1;
            s->volume_size = atoi(aa);
         } else
	if ((aret = strcmp(str, "VolumeType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeType argument missing\n");
            s->volume_type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BsuToCreate'\n", str);
		return -1;
	}
	return 0;
}

int bsu_to_update_vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct bsu_to_update_vm *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "VolumeId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'BsuToUpdateVm'\n", str);
		return -1;
	}
	return 0;
}

int ca_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct ca *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CaFingerprint")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CaFingerprint argument missing\n");
            s->ca_fingerprint = aa; // string string

         } else
	if ((aret = strcmp(str, "CaId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CaId argument missing\n");
            s->ca_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Ca'\n", str);
		return -1;
	}
	return 0;
}

int catalog_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct catalog *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Entries")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Entries' require an index (example array ref CatalogEntry.Entries.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Entries' require a .\n");
            	      TRY_ALLOC_AT(s,entries, pa, pos, sizeof(*s->entries));
            	      cascade_struct = &s->entries[pos];
            	      cascade_parser = catalog_entry_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(catalog_entry_parser(&s->entries[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Entries argument missing\n");
            	s->entries_str = aa; // array ref CatalogEntry ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Catalog'\n", str);
		return -1;
	}
	return 0;
}

int catalog_entry_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct catalog_entry *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Category")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Category argument missing\n");
            s->category = aa; // string string

         } else
	if ((aret = strcmp(str, "Flags")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Flags argument missing\n");
            s->flags = aa; // string string

         } else
	if ((aret = strcmp(str, "Operation")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Operation argument missing\n");
            s->operation = aa; // string string

         } else
	if ((aret = strcmp(str, "Service")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Service argument missing\n");
            s->service = aa; // string string

         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Title")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Title argument missing\n");
            s->title = aa; // string string

         } else
	if ((aret = strcmp(str, "Type")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Type argument missing\n");
            s->type = aa; // string string

         } else
	if ((aret = strcmp(str, "UnitPrice")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UnitPrice argument missing\n");
            s->is_set_unit_price = 1;
            s->unit_price = atof(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'CatalogEntry'\n", str);
		return -1;
	}
	return 0;
}

int catalogs_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct catalogs *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Entries")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Entries' require an index (example array ref CatalogEntry.Entries.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Entries' require a .\n");
            	      TRY_ALLOC_AT(s,entries, pa, pos, sizeof(*s->entries));
            	      cascade_struct = &s->entries[pos];
            	      cascade_parser = catalog_entry_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(catalog_entry_parser(&s->entries[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Entries argument missing\n");
            	s->entries_str = aa; // array ref CatalogEntry ref
            }
         } else
	if ((aret = strcmp(str, "FromDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "FromDate argument missing\n");
            s->from_date = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "ToDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ToDate argument missing\n");
            s->to_date = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Catalogs'\n", str);
		return -1;
	}
	return 0;
}

int client_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct client_gateway *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "BgpAsn")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BgpAsn argument missing\n");
            s->is_set_bgp_asn = 1;
            s->bgp_asn = atoi(aa);
         } else
	if ((aret = strcmp(str, "ClientGatewayId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ClientGatewayId argument missing\n");
            s->client_gateway_id = aa; // string string

         } else
	if ((aret = strcmp(str, "ConnectionType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ConnectionType argument missing\n");
            s->connection_type = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ClientGateway'\n", str);
		return -1;
	}
	return 0;
}

int consumption_entry_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct consumption_entry *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Category")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Category argument missing\n");
            s->category = aa; // string string

         } else
	if ((aret = strcmp(str, "FromDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "FromDate argument missing\n");
            s->from_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Operation")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Operation argument missing\n");
            s->operation = aa; // string string

         } else
	if ((aret = strcmp(str, "PayingAccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PayingAccountId argument missing\n");
            s->paying_account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Price")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Price argument missing\n");
            s->is_set_price = 1;
            s->price = atof(aa);
         } else
	if ((aret = strcmp(str, "Service")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Service argument missing\n");
            s->service = aa; // string string

         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Title")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Title argument missing\n");
            s->title = aa; // string string

         } else
	if ((aret = strcmp(str, "ToDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ToDate argument missing\n");
            s->to_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Type")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Type argument missing\n");
            s->type = aa; // string string

         } else
	if ((aret = strcmp(str, "UnitPrice")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UnitPrice argument missing\n");
            s->is_set_unit_price = 1;
            s->unit_price = atof(aa);
         } else
	if ((aret = strcmp(str, "Value")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Value argument missing\n");
            s->is_set_value = 1;
            s->value = atof(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ConsumptionEntry'\n", str);
		return -1;
	}
	return 0;
}

int dedicated_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct dedicated_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "CpuGeneration")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CpuGeneration argument missing\n");
            s->is_set_cpu_generation = 1;
            s->cpu_generation = atoi(aa);
         } else
	if ((aret = strcmp(str, "DedicatedGroupId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DedicatedGroupId argument missing\n");
            s->dedicated_group_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Name")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "VmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmIds require an index\n");
                      if (s->vm_ids) {
                              for (; s->vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_ids, "", pa);
                              SET_NEXT(s->vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmIds argument missing\n");
                     s->vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DedicatedGroup'\n", str);
		return -1;
	}
	return 0;
}

int dhcp_options_set_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct dhcp_options_set *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Default")) == 0 || aret == '=' || aret == '.') {
            s->is_set_default_arg = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->default_arg = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->default_arg = 0;
             } else {
            		BAD_RET("Default require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "DhcpOptionsSetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DhcpOptionsSetId argument missing\n");
            s->dhcp_options_set_id = aa; // string string

         } else
	if ((aret = strcmp(str, "DomainName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DomainName argument missing\n");
            s->domain_name = aa; // string string

         } else
	if ((aret = strcmp(str, "DomainNameServers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DomainNameServers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DomainNameServers require an index\n");
                      if (s->domain_name_servers) {
                              for (; s->domain_name_servers[last]; ++last);
                      }
                      if (pos < last) {
                              s->domain_name_servers[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->domain_name_servers, "", pa);
                              SET_NEXT(s->domain_name_servers, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DomainNameServers argument missing\n");
                     s->domain_name_servers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DomainNameServers[]")) || aret == '=') {
               TRY(!aa, "DomainNameServers[] argument missing\n");
               SET_NEXT(s->domain_name_servers, (aa), pa);
         } else
	if ((aret = strcmp(str, "LogServers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LogServers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LogServers require an index\n");
                      if (s->log_servers) {
                              for (; s->log_servers[last]; ++last);
                      }
                      if (pos < last) {
                              s->log_servers[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->log_servers, "", pa);
                              SET_NEXT(s->log_servers, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LogServers argument missing\n");
                     s->log_servers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LogServers[]")) || aret == '=') {
               TRY(!aa, "LogServers[] argument missing\n");
               SET_NEXT(s->log_servers, (aa), pa);
         } else
	if ((aret = strcmp(str, "NtpServers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NtpServers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NtpServers require an index\n");
                      if (s->ntp_servers) {
                              for (; s->ntp_servers[last]; ++last);
                      }
                      if (pos < last) {
                              s->ntp_servers[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ntp_servers, "", pa);
                              SET_NEXT(s->ntp_servers, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NtpServers argument missing\n");
                     s->ntp_servers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NtpServers[]")) || aret == '=') {
               TRY(!aa, "NtpServers[] argument missing\n");
               SET_NEXT(s->ntp_servers, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DhcpOptionsSet'\n", str);
		return -1;
	}
	return 0;
}

int direct_link_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct direct_link *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Bandwidth")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Bandwidth argument missing\n");
            s->bandwidth = aa; // string string

         } else
	if ((aret = strcmp(str, "DirectLinkId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DirectLinkId argument missing\n");
            s->direct_link_id = aa; // string string

         } else
	if ((aret = strcmp(str, "DirectLinkName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DirectLinkName argument missing\n");
            s->direct_link_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Location")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Location argument missing\n");
            s->location = aa; // string string

         } else
	if ((aret = strcmp(str, "RegionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RegionName argument missing\n");
            s->region_name = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DirectLink'\n", str);
		return -1;
	}
	return 0;
}

int direct_link_interface_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct direct_link_interface *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "BgpAsn")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BgpAsn argument missing\n");
            s->is_set_bgp_asn = 1;
            s->bgp_asn = atoi(aa);
         } else
	if ((aret = strcmp(str, "BgpKey")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BgpKey argument missing\n");
            s->bgp_key = aa; // string string

         } else
	if ((aret = strcmp(str, "ClientPrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ClientPrivateIp argument missing\n");
            s->client_private_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "DirectLinkInterfaceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DirectLinkInterfaceName argument missing\n");
            s->direct_link_interface_name = aa; // string string

         } else
	if ((aret = strcmp(str, "OutscalePrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OutscalePrivateIp argument missing\n");
            s->outscale_private_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "VirtualGatewayId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Vlan")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Vlan argument missing\n");
            s->is_set_vlan = 1;
            s->vlan = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DirectLinkInterface'\n", str);
		return -1;
	}
	return 0;
}

int direct_link_interfaces_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct direct_link_interfaces *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "BgpAsn")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BgpAsn argument missing\n");
            s->is_set_bgp_asn = 1;
            s->bgp_asn = atoi(aa);
         } else
	if ((aret = strcmp(str, "BgpKey")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BgpKey argument missing\n");
            s->bgp_key = aa; // string string

         } else
	if ((aret = strcmp(str, "ClientPrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ClientPrivateIp argument missing\n");
            s->client_private_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "DirectLinkId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DirectLinkId argument missing\n");
            s->direct_link_id = aa; // string string

         } else
	if ((aret = strcmp(str, "DirectLinkInterfaceId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DirectLinkInterfaceId argument missing\n");
            s->direct_link_interface_id = aa; // string string

         } else
	if ((aret = strcmp(str, "DirectLinkInterfaceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DirectLinkInterfaceName argument missing\n");
            s->direct_link_interface_name = aa; // string string

         } else
	if ((aret = strcmp(str, "InterfaceType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "InterfaceType argument missing\n");
            s->interface_type = aa; // string string

         } else
	if ((aret = strcmp(str, "Location")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Location argument missing\n");
            s->location = aa; // string string

         } else
	if ((aret = strcmp(str, "Mtu")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Mtu argument missing\n");
            s->is_set_mtu = 1;
            s->mtu = atoi(aa);
         } else
	if ((aret = strcmp(str, "OutscalePrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OutscalePrivateIp argument missing\n");
            s->outscale_private_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "VirtualGatewayId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Vlan")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Vlan argument missing\n");
            s->is_set_vlan = 1;
            s->vlan = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'DirectLinkInterfaces'\n", str);
		return -1;
	}
	return 0;
}

int errors_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct errors *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Code")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Code argument missing\n");
            s->code = aa; // string string

         } else
	if ((aret = strcmp(str, "Details")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Details argument missing\n");
            s->details = aa; // string string

         } else
	if ((aret = strcmp(str, "Type")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Type argument missing\n");
            s->type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Errors'\n", str);
		return -1;
	}
	return 0;
}

int filters_access_keys_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_access_keys *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccessKeyIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AccessKeyIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AccessKeyIds require an index\n");
                      if (s->access_key_ids) {
                              for (; s->access_key_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->access_key_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->access_key_ids, "", pa);
                              SET_NEXT(s->access_key_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AccessKeyIds argument missing\n");
                     s->access_key_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AccessKeyIds[]")) || aret == '=') {
               TRY(!aa, "AccessKeyIds[] argument missing\n");
               SET_NEXT(s->access_key_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersAccessKeys'\n", str);
		return -1;
	}
	return 0;
}

int filters_api_access_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_api_access_rule *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ApiAccessRuleIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ApiAccessRuleIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ApiAccessRuleIds require an index\n");
                      if (s->api_access_rule_ids) {
                              for (; s->api_access_rule_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->api_access_rule_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->api_access_rule_ids, "", pa);
                              SET_NEXT(s->api_access_rule_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ApiAccessRuleIds argument missing\n");
                     s->api_access_rule_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ApiAccessRuleIds[]")) || aret == '=') {
               TRY(!aa, "ApiAccessRuleIds[] argument missing\n");
               SET_NEXT(s->api_access_rule_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "CaIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CaIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CaIds require an index\n");
                      if (s->ca_ids) {
                              for (; s->ca_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->ca_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ca_ids, "", pa);
                              SET_NEXT(s->ca_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CaIds argument missing\n");
                     s->ca_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CaIds[]")) || aret == '=') {
               TRY(!aa, "CaIds[] argument missing\n");
               SET_NEXT(s->ca_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "Cns")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Cns argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Cns require an index\n");
                      if (s->cns) {
                              for (; s->cns[last]; ++last);
                      }
                      if (pos < last) {
                              s->cns[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->cns, "", pa);
                              SET_NEXT(s->cns, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Cns argument missing\n");
                     s->cns_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Cns[]")) || aret == '=') {
               TRY(!aa, "Cns[] argument missing\n");
               SET_NEXT(s->cns, (aa), pa);
         } else
	if ((aret = strcmp(str, "Descriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Descriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Descriptions require an index\n");
                      if (s->descriptions) {
                              for (; s->descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->descriptions, "", pa);
                              SET_NEXT(s->descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Descriptions argument missing\n");
                     s->descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Descriptions[]")) || aret == '=') {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "IpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "IpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "IpRanges require an index\n");
                      if (s->ip_ranges) {
                              for (; s->ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ip_ranges, "", pa);
                              SET_NEXT(s->ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "IpRanges argument missing\n");
                     s->ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "IpRanges[]")) || aret == '=') {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersApiAccessRule'\n", str);
		return -1;
	}
	return 0;
}

int filters_api_log_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_api_log *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "QueryAccessKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "QueryAccessKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "QueryAccessKeys require an index\n");
                      if (s->query_access_keys) {
                              for (; s->query_access_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->query_access_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->query_access_keys, "", pa);
                              SET_NEXT(s->query_access_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "QueryAccessKeys argument missing\n");
                     s->query_access_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "QueryAccessKeys[]")) || aret == '=') {
               TRY(!aa, "QueryAccessKeys[] argument missing\n");
               SET_NEXT(s->query_access_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "QueryApiNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "QueryApiNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "QueryApiNames require an index\n");
                      if (s->query_api_names) {
                              for (; s->query_api_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->query_api_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->query_api_names, "", pa);
                              SET_NEXT(s->query_api_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "QueryApiNames argument missing\n");
                     s->query_api_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "QueryApiNames[]")) || aret == '=') {
               TRY(!aa, "QueryApiNames[] argument missing\n");
               SET_NEXT(s->query_api_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "QueryCallNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "QueryCallNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "QueryCallNames require an index\n");
                      if (s->query_call_names) {
                              for (; s->query_call_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->query_call_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->query_call_names, "", pa);
                              SET_NEXT(s->query_call_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "QueryCallNames argument missing\n");
                     s->query_call_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "QueryCallNames[]")) || aret == '=') {
               TRY(!aa, "QueryCallNames[] argument missing\n");
               SET_NEXT(s->query_call_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "QueryDateAfter")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryDateAfter argument missing\n");
            s->query_date_after = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryDateBefore")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryDateBefore argument missing\n");
            s->query_date_before = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryIpAddresses")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "QueryIpAddresses argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "QueryIpAddresses require an index\n");
                      if (s->query_ip_addresses) {
                              for (; s->query_ip_addresses[last]; ++last);
                      }
                      if (pos < last) {
                              s->query_ip_addresses[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->query_ip_addresses, "", pa);
                              SET_NEXT(s->query_ip_addresses, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "QueryIpAddresses argument missing\n");
                     s->query_ip_addresses_str = aa;
                 }
         } else if (!(aret = strcmp(str, "QueryIpAddresses[]")) || aret == '=') {
               TRY(!aa, "QueryIpAddresses[] argument missing\n");
               SET_NEXT(s->query_ip_addresses, (aa), pa);
         } else
	if ((aret = strcmp(str, "QueryUserAgents")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "QueryUserAgents argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "QueryUserAgents require an index\n");
                      if (s->query_user_agents) {
                              for (; s->query_user_agents[last]; ++last);
                      }
                      if (pos < last) {
                              s->query_user_agents[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->query_user_agents, "", pa);
                              SET_NEXT(s->query_user_agents, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "QueryUserAgents argument missing\n");
                     s->query_user_agents_str = aa;
                 }
         } else if (!(aret = strcmp(str, "QueryUserAgents[]")) || aret == '=') {
               TRY(!aa, "QueryUserAgents[] argument missing\n");
               SET_NEXT(s->query_user_agents, (aa), pa);
         } else
	if ((aret = strcmp(str, "RequestIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RequestIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RequestIds require an index\n");
                      if (s->request_ids) {
                              for (; s->request_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->request_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->request_ids, "", pa);
                              SET_NEXT(s->request_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RequestIds argument missing\n");
                     s->request_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RequestIds[]")) || aret == '=') {
               TRY(!aa, "RequestIds[] argument missing\n");
               SET_NEXT(s->request_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ResponseStatusCodes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ResponseStatusCodes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ResponseStatusCodes require an index\n");
                      if (s->response_status_codes) {
                              for (; s->response_status_codes[last]; ++last);
                      }
                      if (pos < last) {
                              s->response_status_codes[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->response_status_codes, 0, pa);
                              SET_NEXT(s->response_status_codes, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ResponseStatusCodes argument missing\n");
                     s->response_status_codes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ResponseStatusCodes[]")) || aret == '=') {
               TRY(!aa, "ResponseStatusCodes[] argument missing\n");
               SET_NEXT(s->response_status_codes, atoi(aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersApiLog'\n", str);
		return -1;
	}
	return 0;
}

int filters_ca_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_ca *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CaFingerprints")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CaFingerprints argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CaFingerprints require an index\n");
                      if (s->ca_fingerprints) {
                              for (; s->ca_fingerprints[last]; ++last);
                      }
                      if (pos < last) {
                              s->ca_fingerprints[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ca_fingerprints, "", pa);
                              SET_NEXT(s->ca_fingerprints, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CaFingerprints argument missing\n");
                     s->ca_fingerprints_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CaFingerprints[]")) || aret == '=') {
               TRY(!aa, "CaFingerprints[] argument missing\n");
               SET_NEXT(s->ca_fingerprints, (aa), pa);
         } else
	if ((aret = strcmp(str, "CaIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CaIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CaIds require an index\n");
                      if (s->ca_ids) {
                              for (; s->ca_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->ca_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ca_ids, "", pa);
                              SET_NEXT(s->ca_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CaIds argument missing\n");
                     s->ca_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CaIds[]")) || aret == '=') {
               TRY(!aa, "CaIds[] argument missing\n");
               SET_NEXT(s->ca_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "Descriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Descriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Descriptions require an index\n");
                      if (s->descriptions) {
                              for (; s->descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->descriptions, "", pa);
                              SET_NEXT(s->descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Descriptions argument missing\n");
                     s->descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Descriptions[]")) || aret == '=') {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersCa'\n", str);
		return -1;
	}
	return 0;
}

int filters_catalogs_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_catalogs *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CurrentCatalogOnly")) == 0 || aret == '=' || aret == '.') {
            s->is_set_current_catalog_only = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->current_catalog_only = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->current_catalog_only = 0;
             } else {
            		BAD_RET("CurrentCatalogOnly require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "FromDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "FromDate argument missing\n");
            s->from_date = aa; // string string

         } else
	if ((aret = strcmp(str, "ToDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ToDate argument missing\n");
            s->to_date = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersCatalogs'\n", str);
		return -1;
	}
	return 0;
}

int filters_client_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_client_gateway *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "BgpAsns")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BgpAsns argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BgpAsns require an index\n");
                      if (s->bgp_asns) {
                              for (; s->bgp_asns[last]; ++last);
                      }
                      if (pos < last) {
                              s->bgp_asns[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->bgp_asns, 0, pa);
                              SET_NEXT(s->bgp_asns, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BgpAsns argument missing\n");
                     s->bgp_asns_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BgpAsns[]")) || aret == '=') {
               TRY(!aa, "BgpAsns[] argument missing\n");
               SET_NEXT(s->bgp_asns, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "ClientGatewayIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ClientGatewayIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ClientGatewayIds require an index\n");
                      if (s->client_gateway_ids) {
                              for (; s->client_gateway_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->client_gateway_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->client_gateway_ids, "", pa);
                              SET_NEXT(s->client_gateway_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ClientGatewayIds argument missing\n");
                     s->client_gateway_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ClientGatewayIds[]")) || aret == '=') {
               TRY(!aa, "ClientGatewayIds[] argument missing\n");
               SET_NEXT(s->client_gateway_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ConnectionTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ConnectionTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ConnectionTypes require an index\n");
                      if (s->connection_types) {
                              for (; s->connection_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->connection_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->connection_types, "", pa);
                              SET_NEXT(s->connection_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ConnectionTypes argument missing\n");
                     s->connection_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ConnectionTypes[]")) || aret == '=') {
               TRY(!aa, "ConnectionTypes[] argument missing\n");
               SET_NEXT(s->connection_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "PublicIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PublicIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PublicIps require an index\n");
                      if (s->public_ips) {
                              for (; s->public_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->public_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->public_ips, "", pa);
                              SET_NEXT(s->public_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PublicIps argument missing\n");
                     s->public_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PublicIps[]")) || aret == '=') {
               TRY(!aa, "PublicIps[] argument missing\n");
               SET_NEXT(s->public_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersClientGateway'\n", str);
		return -1;
	}
	return 0;
}

int filters_dedicated_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_dedicated_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CpuGenerations")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CpuGenerations argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CpuGenerations require an index\n");
                      if (s->cpu_generations) {
                              for (; s->cpu_generations[last]; ++last);
                      }
                      if (pos < last) {
                              s->cpu_generations[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->cpu_generations, 0, pa);
                              SET_NEXT(s->cpu_generations, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CpuGenerations argument missing\n");
                     s->cpu_generations_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CpuGenerations[]")) || aret == '=') {
               TRY(!aa, "CpuGenerations[] argument missing\n");
               SET_NEXT(s->cpu_generations, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "DedicatedGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DedicatedGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DedicatedGroupIds require an index\n");
                      if (s->dedicated_group_ids) {
                              for (; s->dedicated_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->dedicated_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->dedicated_group_ids, "", pa);
                              SET_NEXT(s->dedicated_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DedicatedGroupIds argument missing\n");
                     s->dedicated_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DedicatedGroupIds[]")) || aret == '=') {
               TRY(!aa, "DedicatedGroupIds[] argument missing\n");
               SET_NEXT(s->dedicated_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "Names")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Names argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Names require an index\n");
                      if (s->names) {
                              for (; s->names[last]; ++last);
                      }
                      if (pos < last) {
                              s->names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->names, "", pa);
                              SET_NEXT(s->names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Names argument missing\n");
                     s->names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Names[]")) || aret == '=') {
               TRY(!aa, "Names[] argument missing\n");
               SET_NEXT(s->names, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersDedicatedGroup'\n", str);
		return -1;
	}
	return 0;
}

int filters_dhcp_options_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_dhcp_options *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Default")) == 0 || aret == '=' || aret == '.') {
            s->is_set_default_arg = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->default_arg = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->default_arg = 0;
             } else {
            		BAD_RET("Default require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "DhcpOptionsSetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DhcpOptionsSetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DhcpOptionsSetIds require an index\n");
                      if (s->dhcp_options_set_ids) {
                              for (; s->dhcp_options_set_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->dhcp_options_set_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->dhcp_options_set_ids, "", pa);
                              SET_NEXT(s->dhcp_options_set_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DhcpOptionsSetIds argument missing\n");
                     s->dhcp_options_set_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DhcpOptionsSetIds[]")) || aret == '=') {
               TRY(!aa, "DhcpOptionsSetIds[] argument missing\n");
               SET_NEXT(s->dhcp_options_set_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "DomainNameServers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DomainNameServers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DomainNameServers require an index\n");
                      if (s->domain_name_servers) {
                              for (; s->domain_name_servers[last]; ++last);
                      }
                      if (pos < last) {
                              s->domain_name_servers[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->domain_name_servers, "", pa);
                              SET_NEXT(s->domain_name_servers, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DomainNameServers argument missing\n");
                     s->domain_name_servers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DomainNameServers[]")) || aret == '=') {
               TRY(!aa, "DomainNameServers[] argument missing\n");
               SET_NEXT(s->domain_name_servers, (aa), pa);
         } else
	if ((aret = strcmp(str, "DomainNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DomainNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DomainNames require an index\n");
                      if (s->domain_names) {
                              for (; s->domain_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->domain_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->domain_names, "", pa);
                              SET_NEXT(s->domain_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DomainNames argument missing\n");
                     s->domain_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DomainNames[]")) || aret == '=') {
               TRY(!aa, "DomainNames[] argument missing\n");
               SET_NEXT(s->domain_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "LogServers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LogServers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LogServers require an index\n");
                      if (s->log_servers) {
                              for (; s->log_servers[last]; ++last);
                      }
                      if (pos < last) {
                              s->log_servers[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->log_servers, "", pa);
                              SET_NEXT(s->log_servers, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LogServers argument missing\n");
                     s->log_servers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LogServers[]")) || aret == '=') {
               TRY(!aa, "LogServers[] argument missing\n");
               SET_NEXT(s->log_servers, (aa), pa);
         } else
	if ((aret = strcmp(str, "NtpServers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NtpServers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NtpServers require an index\n");
                      if (s->ntp_servers) {
                              for (; s->ntp_servers[last]; ++last);
                      }
                      if (pos < last) {
                              s->ntp_servers[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ntp_servers, "", pa);
                              SET_NEXT(s->ntp_servers, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NtpServers argument missing\n");
                     s->ntp_servers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NtpServers[]")) || aret == '=') {
               TRY(!aa, "NtpServers[] argument missing\n");
               SET_NEXT(s->ntp_servers, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersDhcpOptions'\n", str);
		return -1;
	}
	return 0;
}

int filters_direct_link_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_direct_link *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DirectLinkIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DirectLinkIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DirectLinkIds require an index\n");
                      if (s->direct_link_ids) {
                              for (; s->direct_link_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->direct_link_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->direct_link_ids, "", pa);
                              SET_NEXT(s->direct_link_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DirectLinkIds argument missing\n");
                     s->direct_link_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DirectLinkIds[]")) || aret == '=') {
               TRY(!aa, "DirectLinkIds[] argument missing\n");
               SET_NEXT(s->direct_link_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersDirectLink'\n", str);
		return -1;
	}
	return 0;
}

int filters_direct_link_interface_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_direct_link_interface *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DirectLinkIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DirectLinkIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DirectLinkIds require an index\n");
                      if (s->direct_link_ids) {
                              for (; s->direct_link_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->direct_link_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->direct_link_ids, "", pa);
                              SET_NEXT(s->direct_link_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DirectLinkIds argument missing\n");
                     s->direct_link_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DirectLinkIds[]")) || aret == '=') {
               TRY(!aa, "DirectLinkIds[] argument missing\n");
               SET_NEXT(s->direct_link_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "DirectLinkInterfaceIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DirectLinkInterfaceIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DirectLinkInterfaceIds require an index\n");
                      if (s->direct_link_interface_ids) {
                              for (; s->direct_link_interface_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->direct_link_interface_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->direct_link_interface_ids, "", pa);
                              SET_NEXT(s->direct_link_interface_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DirectLinkInterfaceIds argument missing\n");
                     s->direct_link_interface_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DirectLinkInterfaceIds[]")) || aret == '=') {
               TRY(!aa, "DirectLinkInterfaceIds[] argument missing\n");
               SET_NEXT(s->direct_link_interface_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersDirectLinkInterface'\n", str);
		return -1;
	}
	return 0;
}

int filters_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_export_task *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "TaskIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TaskIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TaskIds require an index\n");
                      if (s->task_ids) {
                              for (; s->task_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->task_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->task_ids, "", pa);
                              SET_NEXT(s->task_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TaskIds argument missing\n");
                     s->task_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TaskIds[]")) || aret == '=') {
               TRY(!aa, "TaskIds[] argument missing\n");
               SET_NEXT(s->task_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersExportTask'\n", str);
		return -1;
	}
	return 0;
}

int filters_flexible_gpu_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_flexible_gpu *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "FlexibleGpuIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "FlexibleGpuIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "FlexibleGpuIds require an index\n");
                      if (s->flexible_gpu_ids) {
                              for (; s->flexible_gpu_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->flexible_gpu_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->flexible_gpu_ids, "", pa);
                              SET_NEXT(s->flexible_gpu_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "FlexibleGpuIds argument missing\n");
                     s->flexible_gpu_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "FlexibleGpuIds[]")) || aret == '=') {
               TRY(!aa, "FlexibleGpuIds[] argument missing\n");
               SET_NEXT(s->flexible_gpu_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "Generations")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Generations argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Generations require an index\n");
                      if (s->generations) {
                              for (; s->generations[last]; ++last);
                      }
                      if (pos < last) {
                              s->generations[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->generations, "", pa);
                              SET_NEXT(s->generations, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Generations argument missing\n");
                     s->generations_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Generations[]")) || aret == '=') {
               TRY(!aa, "Generations[] argument missing\n");
               SET_NEXT(s->generations, (aa), pa);
         } else
	if ((aret = strcmp(str, "ModelNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ModelNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ModelNames require an index\n");
                      if (s->model_names) {
                              for (; s->model_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->model_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->model_names, "", pa);
                              SET_NEXT(s->model_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ModelNames argument missing\n");
                     s->model_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ModelNames[]")) || aret == '=') {
               TRY(!aa, "ModelNames[] argument missing\n");
               SET_NEXT(s->model_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmIds require an index\n");
                      if (s->vm_ids) {
                              for (; s->vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_ids, "", pa);
                              SET_NEXT(s->vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmIds argument missing\n");
                     s->vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersFlexibleGpu'\n", str);
		return -1;
	}
	return 0;
}

int filters_image_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_image *s = v_s;
	    int aret = 0;
	if ((aret = argcmp(str, "AccountAliases")) == 0 || aret == '=') {
		TRY(!aa, "AccountAliases argument missing\n");
		s->account_aliases_str = aa;
         } else if (!(aret = strcmp(str, "AccountAliases[]")) || aret == '=') {
               TRY(!aa, "AccountAliases[] argument missing\n");
               SET_NEXT(s->account_aliases, (aa), pa);
         } else
	if ((aret = strcmp(str, "AccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AccountIds require an index\n");
                      if (s->account_ids) {
                              for (; s->account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->account_ids, "", pa);
                              SET_NEXT(s->account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AccountIds argument missing\n");
                     s->account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AccountIds[]")) || aret == '=') {
               TRY(!aa, "AccountIds[] argument missing\n");
               SET_NEXT(s->account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "Architectures")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Architectures argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Architectures require an index\n");
                      if (s->architectures) {
                              for (; s->architectures[last]; ++last);
                      }
                      if (pos < last) {
                              s->architectures[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->architectures, "", pa);
                              SET_NEXT(s->architectures, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Architectures argument missing\n");
                     s->architectures_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Architectures[]")) || aret == '=') {
               TRY(!aa, "Architectures[] argument missing\n");
               SET_NEXT(s->architectures, (aa), pa);
         } else
	if ((aret = strcmp(str, "BlockDeviceMappingDeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_block_device_mapping_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->block_device_mapping_delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->block_device_mapping_delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("BlockDeviceMappingDeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "BlockDeviceMappingDeviceNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BlockDeviceMappingDeviceNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BlockDeviceMappingDeviceNames require an index\n");
                      if (s->block_device_mapping_device_names) {
                              for (; s->block_device_mapping_device_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->block_device_mapping_device_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->block_device_mapping_device_names, "", pa);
                              SET_NEXT(s->block_device_mapping_device_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BlockDeviceMappingDeviceNames argument missing\n");
                     s->block_device_mapping_device_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BlockDeviceMappingDeviceNames[]")) || aret == '=') {
               TRY(!aa, "BlockDeviceMappingDeviceNames[] argument missing\n");
               SET_NEXT(s->block_device_mapping_device_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "BlockDeviceMappingSnapshotIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BlockDeviceMappingSnapshotIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BlockDeviceMappingSnapshotIds require an index\n");
                      if (s->block_device_mapping_snapshot_ids) {
                              for (; s->block_device_mapping_snapshot_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->block_device_mapping_snapshot_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->block_device_mapping_snapshot_ids, "", pa);
                              SET_NEXT(s->block_device_mapping_snapshot_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BlockDeviceMappingSnapshotIds argument missing\n");
                     s->block_device_mapping_snapshot_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BlockDeviceMappingSnapshotIds[]")) || aret == '=') {
               TRY(!aa, "BlockDeviceMappingSnapshotIds[] argument missing\n");
               SET_NEXT(s->block_device_mapping_snapshot_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "BlockDeviceMappingVolumeSizes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BlockDeviceMappingVolumeSizes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BlockDeviceMappingVolumeSizes require an index\n");
                      if (s->block_device_mapping_volume_sizes) {
                              for (; s->block_device_mapping_volume_sizes[last]; ++last);
                      }
                      if (pos < last) {
                              s->block_device_mapping_volume_sizes[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->block_device_mapping_volume_sizes, 0, pa);
                              SET_NEXT(s->block_device_mapping_volume_sizes, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BlockDeviceMappingVolumeSizes argument missing\n");
                     s->block_device_mapping_volume_sizes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BlockDeviceMappingVolumeSizes[]")) || aret == '=') {
               TRY(!aa, "BlockDeviceMappingVolumeSizes[] argument missing\n");
               SET_NEXT(s->block_device_mapping_volume_sizes, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "BlockDeviceMappingVolumeTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BlockDeviceMappingVolumeTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BlockDeviceMappingVolumeTypes require an index\n");
                      if (s->block_device_mapping_volume_types) {
                              for (; s->block_device_mapping_volume_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->block_device_mapping_volume_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->block_device_mapping_volume_types, "", pa);
                              SET_NEXT(s->block_device_mapping_volume_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BlockDeviceMappingVolumeTypes argument missing\n");
                     s->block_device_mapping_volume_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BlockDeviceMappingVolumeTypes[]")) || aret == '=') {
               TRY(!aa, "BlockDeviceMappingVolumeTypes[] argument missing\n");
               SET_NEXT(s->block_device_mapping_volume_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "Descriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Descriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Descriptions require an index\n");
                      if (s->descriptions) {
                              for (; s->descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->descriptions, "", pa);
                              SET_NEXT(s->descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Descriptions argument missing\n");
                     s->descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Descriptions[]")) || aret == '=') {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "FileLocations")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "FileLocations argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "FileLocations require an index\n");
                      if (s->file_locations) {
                              for (; s->file_locations[last]; ++last);
                      }
                      if (pos < last) {
                              s->file_locations[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->file_locations, "", pa);
                              SET_NEXT(s->file_locations, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "FileLocations argument missing\n");
                     s->file_locations_str = aa;
                 }
         } else if (!(aret = strcmp(str, "FileLocations[]")) || aret == '=') {
               TRY(!aa, "FileLocations[] argument missing\n");
               SET_NEXT(s->file_locations, (aa), pa);
         } else
	if ((aret = strcmp(str, "Hypervisors")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Hypervisors argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Hypervisors require an index\n");
                      if (s->hypervisors) {
                              for (; s->hypervisors[last]; ++last);
                      }
                      if (pos < last) {
                              s->hypervisors[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->hypervisors, "", pa);
                              SET_NEXT(s->hypervisors, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Hypervisors argument missing\n");
                     s->hypervisors_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Hypervisors[]")) || aret == '=') {
               TRY(!aa, "Hypervisors[] argument missing\n");
               SET_NEXT(s->hypervisors, (aa), pa);
         } else
	if ((aret = strcmp(str, "ImageIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ImageIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ImageIds require an index\n");
                      if (s->image_ids) {
                              for (; s->image_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->image_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->image_ids, "", pa);
                              SET_NEXT(s->image_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ImageIds argument missing\n");
                     s->image_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ImageIds[]")) || aret == '=') {
               TRY(!aa, "ImageIds[] argument missing\n");
               SET_NEXT(s->image_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ImageNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ImageNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ImageNames require an index\n");
                      if (s->image_names) {
                              for (; s->image_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->image_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->image_names, "", pa);
                              SET_NEXT(s->image_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ImageNames argument missing\n");
                     s->image_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ImageNames[]")) || aret == '=') {
               TRY(!aa, "ImageNames[] argument missing\n");
               SET_NEXT(s->image_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "PermissionsToLaunchAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PermissionsToLaunchAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PermissionsToLaunchAccountIds require an index\n");
                      if (s->permissions_to_launch_account_ids) {
                              for (; s->permissions_to_launch_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->permissions_to_launch_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->permissions_to_launch_account_ids, "", pa);
                              SET_NEXT(s->permissions_to_launch_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PermissionsToLaunchAccountIds argument missing\n");
                     s->permissions_to_launch_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PermissionsToLaunchAccountIds[]")) || aret == '=') {
               TRY(!aa, "PermissionsToLaunchAccountIds[] argument missing\n");
               SET_NEXT(s->permissions_to_launch_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "PermissionsToLaunchGlobalPermission")) == 0 || aret == '=' || aret == '.') {
            s->is_set_permissions_to_launch_global_permission = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->permissions_to_launch_global_permission = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->permissions_to_launch_global_permission = 0;
             } else {
            		BAD_RET("PermissionsToLaunchGlobalPermission require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "ProductCodeNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ProductCodeNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ProductCodeNames require an index\n");
                      if (s->product_code_names) {
                              for (; s->product_code_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->product_code_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->product_code_names, "", pa);
                              SET_NEXT(s->product_code_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ProductCodeNames argument missing\n");
                     s->product_code_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ProductCodeNames[]")) || aret == '=') {
               TRY(!aa, "ProductCodeNames[] argument missing\n");
               SET_NEXT(s->product_code_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "ProductCodes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ProductCodes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ProductCodes require an index\n");
                      if (s->product_codes) {
                              for (; s->product_codes[last]; ++last);
                      }
                      if (pos < last) {
                              s->product_codes[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->product_codes, "", pa);
                              SET_NEXT(s->product_codes, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ProductCodes argument missing\n");
                     s->product_codes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ProductCodes[]")) || aret == '=') {
               TRY(!aa, "ProductCodes[] argument missing\n");
               SET_NEXT(s->product_codes, (aa), pa);
         } else
	if ((aret = strcmp(str, "RootDeviceNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RootDeviceNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RootDeviceNames require an index\n");
                      if (s->root_device_names) {
                              for (; s->root_device_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->root_device_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->root_device_names, "", pa);
                              SET_NEXT(s->root_device_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RootDeviceNames argument missing\n");
                     s->root_device_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RootDeviceNames[]")) || aret == '=') {
               TRY(!aa, "RootDeviceNames[] argument missing\n");
               SET_NEXT(s->root_device_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "RootDeviceTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RootDeviceTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RootDeviceTypes require an index\n");
                      if (s->root_device_types) {
                              for (; s->root_device_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->root_device_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->root_device_types, "", pa);
                              SET_NEXT(s->root_device_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RootDeviceTypes argument missing\n");
                     s->root_device_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RootDeviceTypes[]")) || aret == '=') {
               TRY(!aa, "RootDeviceTypes[] argument missing\n");
               SET_NEXT(s->root_device_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "VirtualizationTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VirtualizationTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VirtualizationTypes require an index\n");
                      if (s->virtualization_types) {
                              for (; s->virtualization_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->virtualization_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->virtualization_types, "", pa);
                              SET_NEXT(s->virtualization_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VirtualizationTypes argument missing\n");
                     s->virtualization_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VirtualizationTypes[]")) || aret == '=') {
               TRY(!aa, "VirtualizationTypes[] argument missing\n");
               SET_NEXT(s->virtualization_types, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersImage'\n", str);
		return -1;
	}
	return 0;
}

int filters_internet_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_internet_service *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "InternetServiceIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "InternetServiceIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "InternetServiceIds require an index\n");
                      if (s->internet_service_ids) {
                              for (; s->internet_service_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->internet_service_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->internet_service_ids, "", pa);
                              SET_NEXT(s->internet_service_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "InternetServiceIds argument missing\n");
                     s->internet_service_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "InternetServiceIds[]")) || aret == '=') {
               TRY(!aa, "InternetServiceIds[] argument missing\n");
               SET_NEXT(s->internet_service_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkNetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkNetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkNetIds require an index\n");
                      if (s->link_net_ids) {
                              for (; s->link_net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_net_ids, "", pa);
                              SET_NEXT(s->link_net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkNetIds argument missing\n");
                     s->link_net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkNetIds[]")) || aret == '=') {
               TRY(!aa, "LinkNetIds[] argument missing\n");
               SET_NEXT(s->link_net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkStates require an index\n");
                      if (s->link_states) {
                              for (; s->link_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_states, "", pa);
                              SET_NEXT(s->link_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkStates argument missing\n");
                     s->link_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkStates[]")) || aret == '=') {
               TRY(!aa, "LinkStates[] argument missing\n");
               SET_NEXT(s->link_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersInternetService'\n", str);
		return -1;
	}
	return 0;
}

int filters_keypair_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_keypair *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "KeypairFingerprints")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "KeypairFingerprints argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "KeypairFingerprints require an index\n");
                      if (s->keypair_fingerprints) {
                              for (; s->keypair_fingerprints[last]; ++last);
                      }
                      if (pos < last) {
                              s->keypair_fingerprints[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->keypair_fingerprints, "", pa);
                              SET_NEXT(s->keypair_fingerprints, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "KeypairFingerprints argument missing\n");
                     s->keypair_fingerprints_str = aa;
                 }
         } else if (!(aret = strcmp(str, "KeypairFingerprints[]")) || aret == '=') {
               TRY(!aa, "KeypairFingerprints[] argument missing\n");
               SET_NEXT(s->keypair_fingerprints, (aa), pa);
         } else
	if ((aret = strcmp(str, "KeypairNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "KeypairNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "KeypairNames require an index\n");
                      if (s->keypair_names) {
                              for (; s->keypair_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->keypair_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->keypair_names, "", pa);
                              SET_NEXT(s->keypair_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "KeypairNames argument missing\n");
                     s->keypair_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "KeypairNames[]")) || aret == '=') {
               TRY(!aa, "KeypairNames[] argument missing\n");
               SET_NEXT(s->keypair_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "KeypairTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "KeypairTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "KeypairTypes require an index\n");
                      if (s->keypair_types) {
                              for (; s->keypair_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->keypair_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->keypair_types, "", pa);
                              SET_NEXT(s->keypair_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "KeypairTypes argument missing\n");
                     s->keypair_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "KeypairTypes[]")) || aret == '=') {
               TRY(!aa, "KeypairTypes[] argument missing\n");
               SET_NEXT(s->keypair_types, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersKeypair'\n", str);
		return -1;
	}
	return 0;
}

int filters_listener_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_listener_rule *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ListenerRuleNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ListenerRuleNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ListenerRuleNames require an index\n");
                      if (s->listener_rule_names) {
                              for (; s->listener_rule_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->listener_rule_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->listener_rule_names, "", pa);
                              SET_NEXT(s->listener_rule_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ListenerRuleNames argument missing\n");
                     s->listener_rule_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ListenerRuleNames[]")) || aret == '=') {
               TRY(!aa, "ListenerRuleNames[] argument missing\n");
               SET_NEXT(s->listener_rule_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersListenerRule'\n", str);
		return -1;
	}
	return 0;
}

int filters_load_balancer_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_load_balancer *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LoadBalancerNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LoadBalancerNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LoadBalancerNames require an index\n");
                      if (s->load_balancer_names) {
                              for (; s->load_balancer_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->load_balancer_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->load_balancer_names, "", pa);
                              SET_NEXT(s->load_balancer_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LoadBalancerNames argument missing\n");
                     s->load_balancer_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LoadBalancerNames[]")) || aret == '=') {
               TRY(!aa, "LoadBalancerNames[] argument missing\n");
               SET_NEXT(s->load_balancer_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersLoadBalancer'\n", str);
		return -1;
	}
	return 0;
}

int filters_nat_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_nat_service *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ClientTokens")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ClientTokens argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ClientTokens require an index\n");
                      if (s->client_tokens) {
                              for (; s->client_tokens[last]; ++last);
                      }
                      if (pos < last) {
                              s->client_tokens[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->client_tokens, "", pa);
                              SET_NEXT(s->client_tokens, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ClientTokens argument missing\n");
                     s->client_tokens_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ClientTokens[]")) || aret == '=') {
               TRY(!aa, "ClientTokens[] argument missing\n");
               SET_NEXT(s->client_tokens, (aa), pa);
         } else
	if ((aret = strcmp(str, "NatServiceIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NatServiceIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NatServiceIds require an index\n");
                      if (s->nat_service_ids) {
                              for (; s->nat_service_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nat_service_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nat_service_ids, "", pa);
                              SET_NEXT(s->nat_service_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NatServiceIds argument missing\n");
                     s->nat_service_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NatServiceIds[]")) || aret == '=') {
               TRY(!aa, "NatServiceIds[] argument missing\n");
               SET_NEXT(s->nat_service_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubnetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubnetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubnetIds require an index\n");
                      if (s->subnet_ids) {
                              for (; s->subnet_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->subnet_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subnet_ids, "", pa);
                              SET_NEXT(s->subnet_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubnetIds argument missing\n");
                     s->subnet_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubnetIds[]")) || aret == '=') {
               TRY(!aa, "SubnetIds[] argument missing\n");
               SET_NEXT(s->subnet_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNatService'\n", str);
		return -1;
	}
	return 0;
}

int filters_net_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_net *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DhcpOptionsSetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "DhcpOptionsSetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "DhcpOptionsSetIds require an index\n");
                      if (s->dhcp_options_set_ids) {
                              for (; s->dhcp_options_set_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->dhcp_options_set_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->dhcp_options_set_ids, "", pa);
                              SET_NEXT(s->dhcp_options_set_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "DhcpOptionsSetIds argument missing\n");
                     s->dhcp_options_set_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "DhcpOptionsSetIds[]")) || aret == '=') {
               TRY(!aa, "DhcpOptionsSetIds[] argument missing\n");
               SET_NEXT(s->dhcp_options_set_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "IpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "IpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "IpRanges require an index\n");
                      if (s->ip_ranges) {
                              for (; s->ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ip_ranges, "", pa);
                              SET_NEXT(s->ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "IpRanges argument missing\n");
                     s->ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "IpRanges[]")) || aret == '=') {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "IsDefault")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_default = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_default = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_default = 0;
             } else {
            		BAD_RET("IsDefault require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNet'\n", str);
		return -1;
	}
	return 0;
}

int filters_net_access_point_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_net_access_point *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "NetAccessPointIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetAccessPointIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetAccessPointIds require an index\n");
                      if (s->net_access_point_ids) {
                              for (; s->net_access_point_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_access_point_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_access_point_ids, "", pa);
                              SET_NEXT(s->net_access_point_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetAccessPointIds argument missing\n");
                     s->net_access_point_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetAccessPointIds[]")) || aret == '=') {
               TRY(!aa, "NetAccessPointIds[] argument missing\n");
               SET_NEXT(s->net_access_point_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ServiceNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ServiceNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ServiceNames require an index\n");
                      if (s->service_names) {
                              for (; s->service_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->service_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->service_names, "", pa);
                              SET_NEXT(s->service_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ServiceNames argument missing\n");
                     s->service_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ServiceNames[]")) || aret == '=') {
               TRY(!aa, "ServiceNames[] argument missing\n");
               SET_NEXT(s->service_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNetAccessPoint'\n", str);
		return -1;
	}
	return 0;
}

int filters_net_peering_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_net_peering *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccepterNetAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AccepterNetAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AccepterNetAccountIds require an index\n");
                      if (s->accepter_net_account_ids) {
                              for (; s->accepter_net_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->accepter_net_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->accepter_net_account_ids, "", pa);
                              SET_NEXT(s->accepter_net_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AccepterNetAccountIds argument missing\n");
                     s->accepter_net_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AccepterNetAccountIds[]")) || aret == '=') {
               TRY(!aa, "AccepterNetAccountIds[] argument missing\n");
               SET_NEXT(s->accepter_net_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "AccepterNetIpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AccepterNetIpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AccepterNetIpRanges require an index\n");
                      if (s->accepter_net_ip_ranges) {
                              for (; s->accepter_net_ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->accepter_net_ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->accepter_net_ip_ranges, "", pa);
                              SET_NEXT(s->accepter_net_ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AccepterNetIpRanges argument missing\n");
                     s->accepter_net_ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AccepterNetIpRanges[]")) || aret == '=') {
               TRY(!aa, "AccepterNetIpRanges[] argument missing\n");
               SET_NEXT(s->accepter_net_ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "AccepterNetNetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AccepterNetNetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AccepterNetNetIds require an index\n");
                      if (s->accepter_net_net_ids) {
                              for (; s->accepter_net_net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->accepter_net_net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->accepter_net_net_ids, "", pa);
                              SET_NEXT(s->accepter_net_net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AccepterNetNetIds argument missing\n");
                     s->accepter_net_net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AccepterNetNetIds[]")) || aret == '=') {
               TRY(!aa, "AccepterNetNetIds[] argument missing\n");
               SET_NEXT(s->accepter_net_net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ExpirationDates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ExpirationDates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ExpirationDates require an index\n");
                      if (s->expiration_dates) {
                              for (; s->expiration_dates[last]; ++last);
                      }
                      if (pos < last) {
                              s->expiration_dates[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->expiration_dates, "", pa);
                              SET_NEXT(s->expiration_dates, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ExpirationDates argument missing\n");
                     s->expiration_dates_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ExpirationDates[]")) || aret == '=') {
               TRY(!aa, "ExpirationDates[] argument missing\n");
               SET_NEXT(s->expiration_dates, (aa), pa);
         } else
	if ((aret = strcmp(str, "NetPeeringIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetPeeringIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetPeeringIds require an index\n");
                      if (s->net_peering_ids) {
                              for (; s->net_peering_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_peering_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_peering_ids, "", pa);
                              SET_NEXT(s->net_peering_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetPeeringIds argument missing\n");
                     s->net_peering_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetPeeringIds[]")) || aret == '=') {
               TRY(!aa, "NetPeeringIds[] argument missing\n");
               SET_NEXT(s->net_peering_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SourceNetAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SourceNetAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SourceNetAccountIds require an index\n");
                      if (s->source_net_account_ids) {
                              for (; s->source_net_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->source_net_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->source_net_account_ids, "", pa);
                              SET_NEXT(s->source_net_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SourceNetAccountIds argument missing\n");
                     s->source_net_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SourceNetAccountIds[]")) || aret == '=') {
               TRY(!aa, "SourceNetAccountIds[] argument missing\n");
               SET_NEXT(s->source_net_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SourceNetIpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SourceNetIpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SourceNetIpRanges require an index\n");
                      if (s->source_net_ip_ranges) {
                              for (; s->source_net_ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->source_net_ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->source_net_ip_ranges, "", pa);
                              SET_NEXT(s->source_net_ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SourceNetIpRanges argument missing\n");
                     s->source_net_ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SourceNetIpRanges[]")) || aret == '=') {
               TRY(!aa, "SourceNetIpRanges[] argument missing\n");
               SET_NEXT(s->source_net_ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "SourceNetNetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SourceNetNetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SourceNetNetIds require an index\n");
                      if (s->source_net_net_ids) {
                              for (; s->source_net_net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->source_net_net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->source_net_net_ids, "", pa);
                              SET_NEXT(s->source_net_net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SourceNetNetIds argument missing\n");
                     s->source_net_net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SourceNetNetIds[]")) || aret == '=') {
               TRY(!aa, "SourceNetNetIds[] argument missing\n");
               SET_NEXT(s->source_net_net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "StateMessages")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "StateMessages argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "StateMessages require an index\n");
                      if (s->state_messages) {
                              for (; s->state_messages[last]; ++last);
                      }
                      if (pos < last) {
                              s->state_messages[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->state_messages, "", pa);
                              SET_NEXT(s->state_messages, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "StateMessages argument missing\n");
                     s->state_messages_str = aa;
                 }
         } else if (!(aret = strcmp(str, "StateMessages[]")) || aret == '=') {
               TRY(!aa, "StateMessages[] argument missing\n");
               SET_NEXT(s->state_messages, (aa), pa);
         } else
	if ((aret = strcmp(str, "StateNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "StateNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "StateNames require an index\n");
                      if (s->state_names) {
                              for (; s->state_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->state_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->state_names, "", pa);
                              SET_NEXT(s->state_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "StateNames argument missing\n");
                     s->state_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "StateNames[]")) || aret == '=') {
               TRY(!aa, "StateNames[] argument missing\n");
               SET_NEXT(s->state_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNetPeering'\n", str);
		return -1;
	}
	return 0;
}

int filters_nic_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_nic *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Descriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Descriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Descriptions require an index\n");
                      if (s->descriptions) {
                              for (; s->descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->descriptions, "", pa);
                              SET_NEXT(s->descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Descriptions argument missing\n");
                     s->descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Descriptions[]")) || aret == '=') {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "IsSourceDestCheck")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_source_dest_check = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_check = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_check = 0;
             } else {
            		BAD_RET("IsSourceDestCheck require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkNicDeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_link_nic_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->link_nic_delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->link_nic_delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("LinkNicDeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkNicDeviceNumbers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkNicDeviceNumbers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkNicDeviceNumbers require an index\n");
                      if (s->link_nic_device_numbers) {
                              for (; s->link_nic_device_numbers[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_nic_device_numbers[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_nic_device_numbers, 0, pa);
                              SET_NEXT(s->link_nic_device_numbers, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkNicDeviceNumbers argument missing\n");
                     s->link_nic_device_numbers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkNicDeviceNumbers[]")) || aret == '=') {
               TRY(!aa, "LinkNicDeviceNumbers[] argument missing\n");
               SET_NEXT(s->link_nic_device_numbers, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "LinkNicLinkNicIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkNicLinkNicIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkNicLinkNicIds require an index\n");
                      if (s->link_nic_link_nic_ids) {
                              for (; s->link_nic_link_nic_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_nic_link_nic_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_nic_link_nic_ids, "", pa);
                              SET_NEXT(s->link_nic_link_nic_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkNicLinkNicIds argument missing\n");
                     s->link_nic_link_nic_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkNicLinkNicIds[]")) || aret == '=') {
               TRY(!aa, "LinkNicLinkNicIds[] argument missing\n");
               SET_NEXT(s->link_nic_link_nic_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkNicStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkNicStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkNicStates require an index\n");
                      if (s->link_nic_states) {
                              for (; s->link_nic_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_nic_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_nic_states, "", pa);
                              SET_NEXT(s->link_nic_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkNicStates argument missing\n");
                     s->link_nic_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkNicStates[]")) || aret == '=') {
               TRY(!aa, "LinkNicStates[] argument missing\n");
               SET_NEXT(s->link_nic_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkNicVmAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkNicVmAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkNicVmAccountIds require an index\n");
                      if (s->link_nic_vm_account_ids) {
                              for (; s->link_nic_vm_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_nic_vm_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_nic_vm_account_ids, "", pa);
                              SET_NEXT(s->link_nic_vm_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkNicVmAccountIds argument missing\n");
                     s->link_nic_vm_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkNicVmAccountIds[]")) || aret == '=') {
               TRY(!aa, "LinkNicVmAccountIds[] argument missing\n");
               SET_NEXT(s->link_nic_vm_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkNicVmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkNicVmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkNicVmIds require an index\n");
                      if (s->link_nic_vm_ids) {
                              for (; s->link_nic_vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_nic_vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_nic_vm_ids, "", pa);
                              SET_NEXT(s->link_nic_vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkNicVmIds argument missing\n");
                     s->link_nic_vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkNicVmIds[]")) || aret == '=') {
               TRY(!aa, "LinkNicVmIds[] argument missing\n");
               SET_NEXT(s->link_nic_vm_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkPublicIpAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkPublicIpAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkPublicIpAccountIds require an index\n");
                      if (s->link_public_ip_account_ids) {
                              for (; s->link_public_ip_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_public_ip_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_public_ip_account_ids, "", pa);
                              SET_NEXT(s->link_public_ip_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkPublicIpAccountIds argument missing\n");
                     s->link_public_ip_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkPublicIpAccountIds[]")) || aret == '=') {
               TRY(!aa, "LinkPublicIpAccountIds[] argument missing\n");
               SET_NEXT(s->link_public_ip_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkPublicIpLinkPublicIpIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkPublicIpLinkPublicIpIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkPublicIpLinkPublicIpIds require an index\n");
                      if (s->link_public_ip_link_public_ip_ids) {
                              for (; s->link_public_ip_link_public_ip_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_public_ip_link_public_ip_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_public_ip_link_public_ip_ids, "", pa);
                              SET_NEXT(s->link_public_ip_link_public_ip_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkPublicIpLinkPublicIpIds argument missing\n");
                     s->link_public_ip_link_public_ip_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkPublicIpLinkPublicIpIds[]")) || aret == '=') {
               TRY(!aa, "LinkPublicIpLinkPublicIpIds[] argument missing\n");
               SET_NEXT(s->link_public_ip_link_public_ip_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkPublicIpPublicDnsNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkPublicIpPublicDnsNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkPublicIpPublicDnsNames require an index\n");
                      if (s->link_public_ip_public_dns_names) {
                              for (; s->link_public_ip_public_dns_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_public_ip_public_dns_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_public_ip_public_dns_names, "", pa);
                              SET_NEXT(s->link_public_ip_public_dns_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkPublicIpPublicDnsNames argument missing\n");
                     s->link_public_ip_public_dns_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkPublicIpPublicDnsNames[]")) || aret == '=') {
               TRY(!aa, "LinkPublicIpPublicDnsNames[] argument missing\n");
               SET_NEXT(s->link_public_ip_public_dns_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkPublicIpPublicIpIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkPublicIpPublicIpIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkPublicIpPublicIpIds require an index\n");
                      if (s->link_public_ip_public_ip_ids) {
                              for (; s->link_public_ip_public_ip_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_public_ip_public_ip_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_public_ip_public_ip_ids, "", pa);
                              SET_NEXT(s->link_public_ip_public_ip_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkPublicIpPublicIpIds argument missing\n");
                     s->link_public_ip_public_ip_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkPublicIpPublicIpIds[]")) || aret == '=') {
               TRY(!aa, "LinkPublicIpPublicIpIds[] argument missing\n");
               SET_NEXT(s->link_public_ip_public_ip_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkPublicIpPublicIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkPublicIpPublicIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkPublicIpPublicIps require an index\n");
                      if (s->link_public_ip_public_ips) {
                              for (; s->link_public_ip_public_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_public_ip_public_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_public_ip_public_ips, "", pa);
                              SET_NEXT(s->link_public_ip_public_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkPublicIpPublicIps argument missing\n");
                     s->link_public_ip_public_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkPublicIpPublicIps[]")) || aret == '=') {
               TRY(!aa, "LinkPublicIpPublicIps[] argument missing\n");
               SET_NEXT(s->link_public_ip_public_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "MacAddresses")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "MacAddresses argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "MacAddresses require an index\n");
                      if (s->mac_addresses) {
                              for (; s->mac_addresses[last]; ++last);
                      }
                      if (pos < last) {
                              s->mac_addresses[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->mac_addresses, "", pa);
                              SET_NEXT(s->mac_addresses, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "MacAddresses argument missing\n");
                     s->mac_addresses_str = aa;
                 }
         } else if (!(aret = strcmp(str, "MacAddresses[]")) || aret == '=') {
               TRY(!aa, "MacAddresses[] argument missing\n");
               SET_NEXT(s->mac_addresses, (aa), pa);
         } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicIds require an index\n");
                      if (s->nic_ids) {
                              for (; s->nic_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_ids, "", pa);
                              SET_NEXT(s->nic_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicIds argument missing\n");
                     s->nic_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicIds[]")) || aret == '=') {
               TRY(!aa, "NicIds[] argument missing\n");
               SET_NEXT(s->nic_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "PrivateDnsNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PrivateDnsNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PrivateDnsNames require an index\n");
                      if (s->private_dns_names) {
                              for (; s->private_dns_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->private_dns_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->private_dns_names, "", pa);
                              SET_NEXT(s->private_dns_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PrivateDnsNames argument missing\n");
                     s->private_dns_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PrivateDnsNames[]")) || aret == '=') {
               TRY(!aa, "PrivateDnsNames[] argument missing\n");
               SET_NEXT(s->private_dns_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "PrivateIpsLinkPublicIpAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PrivateIpsLinkPublicIpAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PrivateIpsLinkPublicIpAccountIds require an index\n");
                      if (s->private_ips_link_public_ip_account_ids) {
                              for (; s->private_ips_link_public_ip_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->private_ips_link_public_ip_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->private_ips_link_public_ip_account_ids, "", pa);
                              SET_NEXT(s->private_ips_link_public_ip_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PrivateIpsLinkPublicIpAccountIds argument missing\n");
                     s->private_ips_link_public_ip_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PrivateIpsLinkPublicIpAccountIds[]")) || aret == '=') {
               TRY(!aa, "PrivateIpsLinkPublicIpAccountIds[] argument missing\n");
               SET_NEXT(s->private_ips_link_public_ip_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "PrivateIpsLinkPublicIpPublicIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PrivateIpsLinkPublicIpPublicIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PrivateIpsLinkPublicIpPublicIps require an index\n");
                      if (s->private_ips_link_public_ip_public_ips) {
                              for (; s->private_ips_link_public_ip_public_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->private_ips_link_public_ip_public_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->private_ips_link_public_ip_public_ips, "", pa);
                              SET_NEXT(s->private_ips_link_public_ip_public_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PrivateIpsLinkPublicIpPublicIps argument missing\n");
                     s->private_ips_link_public_ip_public_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PrivateIpsLinkPublicIpPublicIps[]")) || aret == '=') {
               TRY(!aa, "PrivateIpsLinkPublicIpPublicIps[] argument missing\n");
               SET_NEXT(s->private_ips_link_public_ip_public_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "PrivateIpsPrimaryIp")) == 0 || aret == '=' || aret == '.') {
            s->is_set_private_ips_primary_ip = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->private_ips_primary_ip = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->private_ips_primary_ip = 0;
             } else {
            		BAD_RET("PrivateIpsPrimaryIp require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "PrivateIpsPrivateIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PrivateIpsPrivateIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PrivateIpsPrivateIps require an index\n");
                      if (s->private_ips_private_ips) {
                              for (; s->private_ips_private_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->private_ips_private_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->private_ips_private_ips, "", pa);
                              SET_NEXT(s->private_ips_private_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PrivateIpsPrivateIps argument missing\n");
                     s->private_ips_private_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PrivateIpsPrivateIps[]")) || aret == '=') {
               TRY(!aa, "PrivateIpsPrivateIps[] argument missing\n");
               SET_NEXT(s->private_ips_private_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "SecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
                      if (s->security_group_ids) {
                              for (; s->security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_ids, "", pa);
                              SET_NEXT(s->security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupIds argument missing\n");
                     s->security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SecurityGroupNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupNames require an index\n");
                      if (s->security_group_names) {
                              for (; s->security_group_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_names, "", pa);
                              SET_NEXT(s->security_group_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupNames argument missing\n");
                     s->security_group_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupNames[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupNames[] argument missing\n");
               SET_NEXT(s->security_group_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubnetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubnetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubnetIds require an index\n");
                      if (s->subnet_ids) {
                              for (; s->subnet_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->subnet_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subnet_ids, "", pa);
                              SET_NEXT(s->subnet_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubnetIds argument missing\n");
                     s->subnet_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubnetIds[]")) || aret == '=') {
               TRY(!aa, "SubnetIds[] argument missing\n");
               SET_NEXT(s->subnet_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersNic'\n", str);
		return -1;
	}
	return 0;
}

int filters_product_type_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_product_type *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ProductTypeIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ProductTypeIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ProductTypeIds require an index\n");
                      if (s->product_type_ids) {
                              for (; s->product_type_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->product_type_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->product_type_ids, "", pa);
                              SET_NEXT(s->product_type_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ProductTypeIds argument missing\n");
                     s->product_type_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ProductTypeIds[]")) || aret == '=') {
               TRY(!aa, "ProductTypeIds[] argument missing\n");
               SET_NEXT(s->product_type_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersProductType'\n", str);
		return -1;
	}
	return 0;
}

int filters_public_ip_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_public_ip *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LinkPublicIpIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkPublicIpIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkPublicIpIds require an index\n");
                      if (s->link_public_ip_ids) {
                              for (; s->link_public_ip_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_public_ip_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_public_ip_ids, "", pa);
                              SET_NEXT(s->link_public_ip_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkPublicIpIds argument missing\n");
                     s->link_public_ip_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkPublicIpIds[]")) || aret == '=') {
               TRY(!aa, "LinkPublicIpIds[] argument missing\n");
               SET_NEXT(s->link_public_ip_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicAccountIds require an index\n");
                      if (s->nic_account_ids) {
                              for (; s->nic_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_account_ids, "", pa);
                              SET_NEXT(s->nic_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicAccountIds argument missing\n");
                     s->nic_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicAccountIds[]")) || aret == '=') {
               TRY(!aa, "NicAccountIds[] argument missing\n");
               SET_NEXT(s->nic_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicIds require an index\n");
                      if (s->nic_ids) {
                              for (; s->nic_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_ids, "", pa);
                              SET_NEXT(s->nic_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicIds argument missing\n");
                     s->nic_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicIds[]")) || aret == '=') {
               TRY(!aa, "NicIds[] argument missing\n");
               SET_NEXT(s->nic_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "Placements")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Placements argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Placements require an index\n");
                      if (s->placements) {
                              for (; s->placements[last]; ++last);
                      }
                      if (pos < last) {
                              s->placements[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->placements, "", pa);
                              SET_NEXT(s->placements, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Placements argument missing\n");
                     s->placements_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Placements[]")) || aret == '=') {
               TRY(!aa, "Placements[] argument missing\n");
               SET_NEXT(s->placements, (aa), pa);
         } else
	if ((aret = strcmp(str, "PrivateIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PrivateIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PrivateIps require an index\n");
                      if (s->private_ips) {
                              for (; s->private_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->private_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->private_ips, "", pa);
                              SET_NEXT(s->private_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PrivateIps argument missing\n");
                     s->private_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PrivateIps[]")) || aret == '=') {
               TRY(!aa, "PrivateIps[] argument missing\n");
               SET_NEXT(s->private_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "PublicIpIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PublicIpIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PublicIpIds require an index\n");
                      if (s->public_ip_ids) {
                              for (; s->public_ip_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->public_ip_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->public_ip_ids, "", pa);
                              SET_NEXT(s->public_ip_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PublicIpIds argument missing\n");
                     s->public_ip_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PublicIpIds[]")) || aret == '=') {
               TRY(!aa, "PublicIpIds[] argument missing\n");
               SET_NEXT(s->public_ip_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "PublicIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PublicIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PublicIps require an index\n");
                      if (s->public_ips) {
                              for (; s->public_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->public_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->public_ips, "", pa);
                              SET_NEXT(s->public_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PublicIps argument missing\n");
                     s->public_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PublicIps[]")) || aret == '=') {
               TRY(!aa, "PublicIps[] argument missing\n");
               SET_NEXT(s->public_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmIds require an index\n");
                      if (s->vm_ids) {
                              for (; s->vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_ids, "", pa);
                              SET_NEXT(s->vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmIds argument missing\n");
                     s->vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersPublicIp'\n", str);
		return -1;
	}
	return 0;
}

int filters_quota_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_quota *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Collections")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Collections argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Collections require an index\n");
                      if (s->collections) {
                              for (; s->collections[last]; ++last);
                      }
                      if (pos < last) {
                              s->collections[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->collections, "", pa);
                              SET_NEXT(s->collections, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Collections argument missing\n");
                     s->collections_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Collections[]")) || aret == '=') {
               TRY(!aa, "Collections[] argument missing\n");
               SET_NEXT(s->collections, (aa), pa);
         } else
	if ((aret = strcmp(str, "QuotaNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "QuotaNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "QuotaNames require an index\n");
                      if (s->quota_names) {
                              for (; s->quota_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->quota_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->quota_names, "", pa);
                              SET_NEXT(s->quota_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "QuotaNames argument missing\n");
                     s->quota_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "QuotaNames[]")) || aret == '=') {
               TRY(!aa, "QuotaNames[] argument missing\n");
               SET_NEXT(s->quota_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "QuotaTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "QuotaTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "QuotaTypes require an index\n");
                      if (s->quota_types) {
                              for (; s->quota_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->quota_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->quota_types, "", pa);
                              SET_NEXT(s->quota_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "QuotaTypes argument missing\n");
                     s->quota_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "QuotaTypes[]")) || aret == '=') {
               TRY(!aa, "QuotaTypes[] argument missing\n");
               SET_NEXT(s->quota_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "ShortDescriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ShortDescriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ShortDescriptions require an index\n");
                      if (s->short_descriptions) {
                              for (; s->short_descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->short_descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->short_descriptions, "", pa);
                              SET_NEXT(s->short_descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ShortDescriptions argument missing\n");
                     s->short_descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ShortDescriptions[]")) || aret == '=') {
               TRY(!aa, "ShortDescriptions[] argument missing\n");
               SET_NEXT(s->short_descriptions, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersQuota'\n", str);
		return -1;
	}
	return 0;
}

int filters_route_table_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_route_table *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LinkRouteTableIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkRouteTableIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkRouteTableIds require an index\n");
                      if (s->link_route_table_ids) {
                              for (; s->link_route_table_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_route_table_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_route_table_ids, "", pa);
                              SET_NEXT(s->link_route_table_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkRouteTableIds argument missing\n");
                     s->link_route_table_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkRouteTableIds[]")) || aret == '=') {
               TRY(!aa, "LinkRouteTableIds[] argument missing\n");
               SET_NEXT(s->link_route_table_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkRouteTableLinkRouteTableIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkRouteTableLinkRouteTableIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkRouteTableLinkRouteTableIds require an index\n");
                      if (s->link_route_table_link_route_table_ids) {
                              for (; s->link_route_table_link_route_table_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_route_table_link_route_table_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_route_table_link_route_table_ids, "", pa);
                              SET_NEXT(s->link_route_table_link_route_table_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkRouteTableLinkRouteTableIds argument missing\n");
                     s->link_route_table_link_route_table_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkRouteTableLinkRouteTableIds[]")) || aret == '=') {
               TRY(!aa, "LinkRouteTableLinkRouteTableIds[] argument missing\n");
               SET_NEXT(s->link_route_table_link_route_table_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkRouteTableMain")) == 0 || aret == '=' || aret == '.') {
            s->is_set_link_route_table_main = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->link_route_table_main = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->link_route_table_main = 0;
             } else {
            		BAD_RET("LinkRouteTableMain require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkSubnetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkSubnetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkSubnetIds require an index\n");
                      if (s->link_subnet_ids) {
                              for (; s->link_subnet_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_subnet_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_subnet_ids, "", pa);
                              SET_NEXT(s->link_subnet_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkSubnetIds argument missing\n");
                     s->link_subnet_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkSubnetIds[]")) || aret == '=') {
               TRY(!aa, "LinkSubnetIds[] argument missing\n");
               SET_NEXT(s->link_subnet_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteCreationMethods")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteCreationMethods argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteCreationMethods require an index\n");
                      if (s->route_creation_methods) {
                              for (; s->route_creation_methods[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_creation_methods[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_creation_methods, "", pa);
                              SET_NEXT(s->route_creation_methods, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteCreationMethods argument missing\n");
                     s->route_creation_methods_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteCreationMethods[]")) || aret == '=') {
               TRY(!aa, "RouteCreationMethods[] argument missing\n");
               SET_NEXT(s->route_creation_methods, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteDestinationIpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteDestinationIpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteDestinationIpRanges require an index\n");
                      if (s->route_destination_ip_ranges) {
                              for (; s->route_destination_ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_destination_ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_destination_ip_ranges, "", pa);
                              SET_NEXT(s->route_destination_ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteDestinationIpRanges argument missing\n");
                     s->route_destination_ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteDestinationIpRanges[]")) || aret == '=') {
               TRY(!aa, "RouteDestinationIpRanges[] argument missing\n");
               SET_NEXT(s->route_destination_ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteDestinationServiceIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteDestinationServiceIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteDestinationServiceIds require an index\n");
                      if (s->route_destination_service_ids) {
                              for (; s->route_destination_service_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_destination_service_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_destination_service_ids, "", pa);
                              SET_NEXT(s->route_destination_service_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteDestinationServiceIds argument missing\n");
                     s->route_destination_service_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteDestinationServiceIds[]")) || aret == '=') {
               TRY(!aa, "RouteDestinationServiceIds[] argument missing\n");
               SET_NEXT(s->route_destination_service_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteGatewayIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteGatewayIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteGatewayIds require an index\n");
                      if (s->route_gateway_ids) {
                              for (; s->route_gateway_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_gateway_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_gateway_ids, "", pa);
                              SET_NEXT(s->route_gateway_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteGatewayIds argument missing\n");
                     s->route_gateway_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteGatewayIds[]")) || aret == '=') {
               TRY(!aa, "RouteGatewayIds[] argument missing\n");
               SET_NEXT(s->route_gateway_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteNatServiceIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteNatServiceIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteNatServiceIds require an index\n");
                      if (s->route_nat_service_ids) {
                              for (; s->route_nat_service_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_nat_service_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_nat_service_ids, "", pa);
                              SET_NEXT(s->route_nat_service_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteNatServiceIds argument missing\n");
                     s->route_nat_service_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteNatServiceIds[]")) || aret == '=') {
               TRY(!aa, "RouteNatServiceIds[] argument missing\n");
               SET_NEXT(s->route_nat_service_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteNetPeeringIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteNetPeeringIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteNetPeeringIds require an index\n");
                      if (s->route_net_peering_ids) {
                              for (; s->route_net_peering_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_net_peering_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_net_peering_ids, "", pa);
                              SET_NEXT(s->route_net_peering_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteNetPeeringIds argument missing\n");
                     s->route_net_peering_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteNetPeeringIds[]")) || aret == '=') {
               TRY(!aa, "RouteNetPeeringIds[] argument missing\n");
               SET_NEXT(s->route_net_peering_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteStates require an index\n");
                      if (s->route_states) {
                              for (; s->route_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_states, "", pa);
                              SET_NEXT(s->route_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteStates argument missing\n");
                     s->route_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteStates[]")) || aret == '=') {
               TRY(!aa, "RouteStates[] argument missing\n");
               SET_NEXT(s->route_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteTableIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteTableIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteTableIds require an index\n");
                      if (s->route_table_ids) {
                              for (; s->route_table_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_table_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_table_ids, "", pa);
                              SET_NEXT(s->route_table_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteTableIds argument missing\n");
                     s->route_table_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteTableIds[]")) || aret == '=') {
               TRY(!aa, "RouteTableIds[] argument missing\n");
               SET_NEXT(s->route_table_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteVmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteVmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteVmIds require an index\n");
                      if (s->route_vm_ids) {
                              for (; s->route_vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_vm_ids, "", pa);
                              SET_NEXT(s->route_vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteVmIds argument missing\n");
                     s->route_vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteVmIds[]")) || aret == '=') {
               TRY(!aa, "RouteVmIds[] argument missing\n");
               SET_NEXT(s->route_vm_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersRouteTable'\n", str);
		return -1;
	}
	return 0;
}

int filters_security_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_security_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Descriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Descriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Descriptions require an index\n");
                      if (s->descriptions) {
                              for (; s->descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->descriptions, "", pa);
                              SET_NEXT(s->descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Descriptions argument missing\n");
                     s->descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Descriptions[]")) || aret == '=') {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "InboundRuleAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "InboundRuleAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "InboundRuleAccountIds require an index\n");
                      if (s->inbound_rule_account_ids) {
                              for (; s->inbound_rule_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->inbound_rule_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->inbound_rule_account_ids, "", pa);
                              SET_NEXT(s->inbound_rule_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "InboundRuleAccountIds argument missing\n");
                     s->inbound_rule_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "InboundRuleAccountIds[]")) || aret == '=') {
               TRY(!aa, "InboundRuleAccountIds[] argument missing\n");
               SET_NEXT(s->inbound_rule_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "InboundRuleFromPortRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "InboundRuleFromPortRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "InboundRuleFromPortRanges require an index\n");
                      if (s->inbound_rule_from_port_ranges) {
                              for (; s->inbound_rule_from_port_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->inbound_rule_from_port_ranges[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->inbound_rule_from_port_ranges, 0, pa);
                              SET_NEXT(s->inbound_rule_from_port_ranges, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "InboundRuleFromPortRanges argument missing\n");
                     s->inbound_rule_from_port_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "InboundRuleFromPortRanges[]")) || aret == '=') {
               TRY(!aa, "InboundRuleFromPortRanges[] argument missing\n");
               SET_NEXT(s->inbound_rule_from_port_ranges, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "InboundRuleIpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "InboundRuleIpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "InboundRuleIpRanges require an index\n");
                      if (s->inbound_rule_ip_ranges) {
                              for (; s->inbound_rule_ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->inbound_rule_ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->inbound_rule_ip_ranges, "", pa);
                              SET_NEXT(s->inbound_rule_ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "InboundRuleIpRanges argument missing\n");
                     s->inbound_rule_ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "InboundRuleIpRanges[]")) || aret == '=') {
               TRY(!aa, "InboundRuleIpRanges[] argument missing\n");
               SET_NEXT(s->inbound_rule_ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "InboundRuleProtocols")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "InboundRuleProtocols argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "InboundRuleProtocols require an index\n");
                      if (s->inbound_rule_protocols) {
                              for (; s->inbound_rule_protocols[last]; ++last);
                      }
                      if (pos < last) {
                              s->inbound_rule_protocols[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->inbound_rule_protocols, "", pa);
                              SET_NEXT(s->inbound_rule_protocols, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "InboundRuleProtocols argument missing\n");
                     s->inbound_rule_protocols_str = aa;
                 }
         } else if (!(aret = strcmp(str, "InboundRuleProtocols[]")) || aret == '=') {
               TRY(!aa, "InboundRuleProtocols[] argument missing\n");
               SET_NEXT(s->inbound_rule_protocols, (aa), pa);
         } else
	if ((aret = strcmp(str, "InboundRuleSecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "InboundRuleSecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "InboundRuleSecurityGroupIds require an index\n");
                      if (s->inbound_rule_security_group_ids) {
                              for (; s->inbound_rule_security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->inbound_rule_security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->inbound_rule_security_group_ids, "", pa);
                              SET_NEXT(s->inbound_rule_security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "InboundRuleSecurityGroupIds argument missing\n");
                     s->inbound_rule_security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "InboundRuleSecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "InboundRuleSecurityGroupIds[] argument missing\n");
               SET_NEXT(s->inbound_rule_security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "InboundRuleSecurityGroupNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "InboundRuleSecurityGroupNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "InboundRuleSecurityGroupNames require an index\n");
                      if (s->inbound_rule_security_group_names) {
                              for (; s->inbound_rule_security_group_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->inbound_rule_security_group_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->inbound_rule_security_group_names, "", pa);
                              SET_NEXT(s->inbound_rule_security_group_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "InboundRuleSecurityGroupNames argument missing\n");
                     s->inbound_rule_security_group_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "InboundRuleSecurityGroupNames[]")) || aret == '=') {
               TRY(!aa, "InboundRuleSecurityGroupNames[] argument missing\n");
               SET_NEXT(s->inbound_rule_security_group_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "InboundRuleToPortRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "InboundRuleToPortRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "InboundRuleToPortRanges require an index\n");
                      if (s->inbound_rule_to_port_ranges) {
                              for (; s->inbound_rule_to_port_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->inbound_rule_to_port_ranges[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->inbound_rule_to_port_ranges, 0, pa);
                              SET_NEXT(s->inbound_rule_to_port_ranges, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "InboundRuleToPortRanges argument missing\n");
                     s->inbound_rule_to_port_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "InboundRuleToPortRanges[]")) || aret == '=') {
               TRY(!aa, "InboundRuleToPortRanges[] argument missing\n");
               SET_NEXT(s->inbound_rule_to_port_ranges, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "OutboundRuleAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "OutboundRuleAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "OutboundRuleAccountIds require an index\n");
                      if (s->outbound_rule_account_ids) {
                              for (; s->outbound_rule_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->outbound_rule_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->outbound_rule_account_ids, "", pa);
                              SET_NEXT(s->outbound_rule_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "OutboundRuleAccountIds argument missing\n");
                     s->outbound_rule_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "OutboundRuleAccountIds[]")) || aret == '=') {
               TRY(!aa, "OutboundRuleAccountIds[] argument missing\n");
               SET_NEXT(s->outbound_rule_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "OutboundRuleFromPortRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "OutboundRuleFromPortRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "OutboundRuleFromPortRanges require an index\n");
                      if (s->outbound_rule_from_port_ranges) {
                              for (; s->outbound_rule_from_port_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->outbound_rule_from_port_ranges[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->outbound_rule_from_port_ranges, 0, pa);
                              SET_NEXT(s->outbound_rule_from_port_ranges, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "OutboundRuleFromPortRanges argument missing\n");
                     s->outbound_rule_from_port_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "OutboundRuleFromPortRanges[]")) || aret == '=') {
               TRY(!aa, "OutboundRuleFromPortRanges[] argument missing\n");
               SET_NEXT(s->outbound_rule_from_port_ranges, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "OutboundRuleIpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "OutboundRuleIpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "OutboundRuleIpRanges require an index\n");
                      if (s->outbound_rule_ip_ranges) {
                              for (; s->outbound_rule_ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->outbound_rule_ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->outbound_rule_ip_ranges, "", pa);
                              SET_NEXT(s->outbound_rule_ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "OutboundRuleIpRanges argument missing\n");
                     s->outbound_rule_ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "OutboundRuleIpRanges[]")) || aret == '=') {
               TRY(!aa, "OutboundRuleIpRanges[] argument missing\n");
               SET_NEXT(s->outbound_rule_ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "OutboundRuleProtocols")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "OutboundRuleProtocols argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "OutboundRuleProtocols require an index\n");
                      if (s->outbound_rule_protocols) {
                              for (; s->outbound_rule_protocols[last]; ++last);
                      }
                      if (pos < last) {
                              s->outbound_rule_protocols[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->outbound_rule_protocols, "", pa);
                              SET_NEXT(s->outbound_rule_protocols, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "OutboundRuleProtocols argument missing\n");
                     s->outbound_rule_protocols_str = aa;
                 }
         } else if (!(aret = strcmp(str, "OutboundRuleProtocols[]")) || aret == '=') {
               TRY(!aa, "OutboundRuleProtocols[] argument missing\n");
               SET_NEXT(s->outbound_rule_protocols, (aa), pa);
         } else
	if ((aret = strcmp(str, "OutboundRuleSecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "OutboundRuleSecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "OutboundRuleSecurityGroupIds require an index\n");
                      if (s->outbound_rule_security_group_ids) {
                              for (; s->outbound_rule_security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->outbound_rule_security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->outbound_rule_security_group_ids, "", pa);
                              SET_NEXT(s->outbound_rule_security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "OutboundRuleSecurityGroupIds argument missing\n");
                     s->outbound_rule_security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "OutboundRuleSecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "OutboundRuleSecurityGroupIds[] argument missing\n");
               SET_NEXT(s->outbound_rule_security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "OutboundRuleSecurityGroupNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "OutboundRuleSecurityGroupNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "OutboundRuleSecurityGroupNames require an index\n");
                      if (s->outbound_rule_security_group_names) {
                              for (; s->outbound_rule_security_group_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->outbound_rule_security_group_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->outbound_rule_security_group_names, "", pa);
                              SET_NEXT(s->outbound_rule_security_group_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "OutboundRuleSecurityGroupNames argument missing\n");
                     s->outbound_rule_security_group_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "OutboundRuleSecurityGroupNames[]")) || aret == '=') {
               TRY(!aa, "OutboundRuleSecurityGroupNames[] argument missing\n");
               SET_NEXT(s->outbound_rule_security_group_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "OutboundRuleToPortRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "OutboundRuleToPortRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "OutboundRuleToPortRanges require an index\n");
                      if (s->outbound_rule_to_port_ranges) {
                              for (; s->outbound_rule_to_port_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->outbound_rule_to_port_ranges[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->outbound_rule_to_port_ranges, 0, pa);
                              SET_NEXT(s->outbound_rule_to_port_ranges, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "OutboundRuleToPortRanges argument missing\n");
                     s->outbound_rule_to_port_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "OutboundRuleToPortRanges[]")) || aret == '=') {
               TRY(!aa, "OutboundRuleToPortRanges[] argument missing\n");
               SET_NEXT(s->outbound_rule_to_port_ranges, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "SecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
                      if (s->security_group_ids) {
                              for (; s->security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_ids, "", pa);
                              SET_NEXT(s->security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupIds argument missing\n");
                     s->security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SecurityGroupNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupNames require an index\n");
                      if (s->security_group_names) {
                              for (; s->security_group_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_names, "", pa);
                              SET_NEXT(s->security_group_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupNames argument missing\n");
                     s->security_group_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupNames[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupNames[] argument missing\n");
               SET_NEXT(s->security_group_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersSecurityGroup'\n", str);
		return -1;
	}
	return 0;
}

int filters_server_certificate_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_server_certificate *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Paths")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Paths argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Paths require an index\n");
                      if (s->paths) {
                              for (; s->paths[last]; ++last);
                      }
                      if (pos < last) {
                              s->paths[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->paths, "", pa);
                              SET_NEXT(s->paths, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Paths argument missing\n");
                     s->paths_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Paths[]")) || aret == '=') {
               TRY(!aa, "Paths[] argument missing\n");
               SET_NEXT(s->paths, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersServerCertificate'\n", str);
		return -1;
	}
	return 0;
}

int filters_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_service *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ServiceIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ServiceIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ServiceIds require an index\n");
                      if (s->service_ids) {
                              for (; s->service_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->service_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->service_ids, "", pa);
                              SET_NEXT(s->service_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ServiceIds argument missing\n");
                     s->service_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ServiceIds[]")) || aret == '=') {
               TRY(!aa, "ServiceIds[] argument missing\n");
               SET_NEXT(s->service_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ServiceNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ServiceNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ServiceNames require an index\n");
                      if (s->service_names) {
                              for (; s->service_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->service_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->service_names, "", pa);
                              SET_NEXT(s->service_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ServiceNames argument missing\n");
                     s->service_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ServiceNames[]")) || aret == '=') {
               TRY(!aa, "ServiceNames[] argument missing\n");
               SET_NEXT(s->service_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersService'\n", str);
		return -1;
	}
	return 0;
}

int filters_snapshot_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_snapshot *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountAliases")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AccountAliases argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AccountAliases require an index\n");
                      if (s->account_aliases) {
                              for (; s->account_aliases[last]; ++last);
                      }
                      if (pos < last) {
                              s->account_aliases[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->account_aliases, "", pa);
                              SET_NEXT(s->account_aliases, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AccountAliases argument missing\n");
                     s->account_aliases_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AccountAliases[]")) || aret == '=') {
               TRY(!aa, "AccountAliases[] argument missing\n");
               SET_NEXT(s->account_aliases, (aa), pa);
         } else
	if ((aret = strcmp(str, "AccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AccountIds require an index\n");
                      if (s->account_ids) {
                              for (; s->account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->account_ids, "", pa);
                              SET_NEXT(s->account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AccountIds argument missing\n");
                     s->account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AccountIds[]")) || aret == '=') {
               TRY(!aa, "AccountIds[] argument missing\n");
               SET_NEXT(s->account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "Descriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Descriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Descriptions require an index\n");
                      if (s->descriptions) {
                              for (; s->descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->descriptions, "", pa);
                              SET_NEXT(s->descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Descriptions argument missing\n");
                     s->descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Descriptions[]")) || aret == '=') {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "FromCreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "FromCreationDate argument missing\n");
            s->from_creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "PermissionsToCreateVolumeAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PermissionsToCreateVolumeAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PermissionsToCreateVolumeAccountIds require an index\n");
                      if (s->permissions_to_create_volume_account_ids) {
                              for (; s->permissions_to_create_volume_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->permissions_to_create_volume_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->permissions_to_create_volume_account_ids, "", pa);
                              SET_NEXT(s->permissions_to_create_volume_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PermissionsToCreateVolumeAccountIds argument missing\n");
                     s->permissions_to_create_volume_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PermissionsToCreateVolumeAccountIds[]")) || aret == '=') {
               TRY(!aa, "PermissionsToCreateVolumeAccountIds[] argument missing\n");
               SET_NEXT(s->permissions_to_create_volume_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "PermissionsToCreateVolumeGlobalPermission")) == 0 || aret == '=' || aret == '.') {
            s->is_set_permissions_to_create_volume_global_permission = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->permissions_to_create_volume_global_permission = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->permissions_to_create_volume_global_permission = 0;
             } else {
            		BAD_RET("PermissionsToCreateVolumeGlobalPermission require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "Progresses")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Progresses argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Progresses require an index\n");
                      if (s->progresses) {
                              for (; s->progresses[last]; ++last);
                      }
                      if (pos < last) {
                              s->progresses[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->progresses, 0, pa);
                              SET_NEXT(s->progresses, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Progresses argument missing\n");
                     s->progresses_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Progresses[]")) || aret == '=') {
               TRY(!aa, "Progresses[] argument missing\n");
               SET_NEXT(s->progresses, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "SnapshotIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SnapshotIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SnapshotIds require an index\n");
                      if (s->snapshot_ids) {
                              for (; s->snapshot_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->snapshot_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->snapshot_ids, "", pa);
                              SET_NEXT(s->snapshot_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SnapshotIds argument missing\n");
                     s->snapshot_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SnapshotIds[]")) || aret == '=') {
               TRY(!aa, "SnapshotIds[] argument missing\n");
               SET_NEXT(s->snapshot_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "ToCreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ToCreationDate argument missing\n");
            s->to_creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "VolumeIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VolumeIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VolumeIds require an index\n");
                      if (s->volume_ids) {
                              for (; s->volume_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->volume_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->volume_ids, "", pa);
                              SET_NEXT(s->volume_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VolumeIds argument missing\n");
                     s->volume_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VolumeIds[]")) || aret == '=') {
               TRY(!aa, "VolumeIds[] argument missing\n");
               SET_NEXT(s->volume_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VolumeSizes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VolumeSizes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VolumeSizes require an index\n");
                      if (s->volume_sizes) {
                              for (; s->volume_sizes[last]; ++last);
                      }
                      if (pos < last) {
                              s->volume_sizes[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->volume_sizes, 0, pa);
                              SET_NEXT(s->volume_sizes, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VolumeSizes argument missing\n");
                     s->volume_sizes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VolumeSizes[]")) || aret == '=') {
               TRY(!aa, "VolumeSizes[] argument missing\n");
               SET_NEXT(s->volume_sizes, atoi(aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersSnapshot'\n", str);
		return -1;
	}
	return 0;
}

int filters_subnet_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_subnet *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AvailableIpsCounts")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AvailableIpsCounts argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AvailableIpsCounts require an index\n");
                      if (s->available_ips_counts) {
                              for (; s->available_ips_counts[last]; ++last);
                      }
                      if (pos < last) {
                              s->available_ips_counts[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->available_ips_counts, 0, pa);
                              SET_NEXT(s->available_ips_counts, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AvailableIpsCounts argument missing\n");
                     s->available_ips_counts_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AvailableIpsCounts[]")) || aret == '=') {
               TRY(!aa, "AvailableIpsCounts[] argument missing\n");
               SET_NEXT(s->available_ips_counts, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "IpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "IpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "IpRanges require an index\n");
                      if (s->ip_ranges) {
                              for (; s->ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ip_ranges, "", pa);
                              SET_NEXT(s->ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "IpRanges argument missing\n");
                     s->ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "IpRanges[]")) || aret == '=') {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubnetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubnetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubnetIds require an index\n");
                      if (s->subnet_ids) {
                              for (; s->subnet_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->subnet_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subnet_ids, "", pa);
                              SET_NEXT(s->subnet_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubnetIds argument missing\n");
                     s->subnet_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubnetIds[]")) || aret == '=') {
               TRY(!aa, "SubnetIds[] argument missing\n");
               SET_NEXT(s->subnet_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersSubnet'\n", str);
		return -1;
	}
	return 0;
}

int filters_subregion_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_subregion *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "RegionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RegionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RegionNames require an index\n");
                      if (s->region_names) {
                              for (; s->region_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->region_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->region_names, "", pa);
                              SET_NEXT(s->region_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RegionNames argument missing\n");
                     s->region_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RegionNames[]")) || aret == '=') {
               TRY(!aa, "RegionNames[] argument missing\n");
               SET_NEXT(s->region_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersSubregion'\n", str);
		return -1;
	}
	return 0;
}

int filters_tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_tag *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Keys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Keys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Keys require an index\n");
                      if (s->keys) {
                              for (; s->keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->keys, "", pa);
                              SET_NEXT(s->keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Keys argument missing\n");
                     s->keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Keys[]")) || aret == '=') {
               TRY(!aa, "Keys[] argument missing\n");
               SET_NEXT(s->keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "ResourceIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ResourceIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ResourceIds require an index\n");
                      if (s->resource_ids) {
                              for (; s->resource_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->resource_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->resource_ids, "", pa);
                              SET_NEXT(s->resource_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ResourceIds argument missing\n");
                     s->resource_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ResourceIds[]")) || aret == '=') {
               TRY(!aa, "ResourceIds[] argument missing\n");
               SET_NEXT(s->resource_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ResourceTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ResourceTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ResourceTypes require an index\n");
                      if (s->resource_types) {
                              for (; s->resource_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->resource_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->resource_types, "", pa);
                              SET_NEXT(s->resource_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ResourceTypes argument missing\n");
                     s->resource_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ResourceTypes[]")) || aret == '=') {
               TRY(!aa, "ResourceTypes[] argument missing\n");
               SET_NEXT(s->resource_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "Values")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Values argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Values require an index\n");
                      if (s->values) {
                              for (; s->values[last]; ++last);
                      }
                      if (pos < last) {
                              s->values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->values, "", pa);
                              SET_NEXT(s->values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Values argument missing\n");
                     s->values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Values[]")) || aret == '=') {
               TRY(!aa, "Values[] argument missing\n");
               SET_NEXT(s->values, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersTag'\n", str);
		return -1;
	}
	return 0;
}

int filters_user_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_user_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "PathPrefix")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PathPrefix argument missing\n");
            s->path_prefix = aa; // string string

         } else
	if ((aret = strcmp(str, "UserGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "UserGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "UserGroupIds require an index\n");
                      if (s->user_group_ids) {
                              for (; s->user_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->user_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->user_group_ids, "", pa);
                              SET_NEXT(s->user_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "UserGroupIds argument missing\n");
                     s->user_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "UserGroupIds[]")) || aret == '=') {
               TRY(!aa, "UserGroupIds[] argument missing\n");
               SET_NEXT(s->user_group_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersUserGroup'\n", str);
		return -1;
	}
	return 0;
}

int filters_virtual_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_virtual_gateway *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ConnectionTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ConnectionTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ConnectionTypes require an index\n");
                      if (s->connection_types) {
                              for (; s->connection_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->connection_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->connection_types, "", pa);
                              SET_NEXT(s->connection_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ConnectionTypes argument missing\n");
                     s->connection_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ConnectionTypes[]")) || aret == '=') {
               TRY(!aa, "ConnectionTypes[] argument missing\n");
               SET_NEXT(s->connection_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkNetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkNetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkNetIds require an index\n");
                      if (s->link_net_ids) {
                              for (; s->link_net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_net_ids, "", pa);
                              SET_NEXT(s->link_net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkNetIds argument missing\n");
                     s->link_net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkNetIds[]")) || aret == '=') {
               TRY(!aa, "LinkNetIds[] argument missing\n");
               SET_NEXT(s->link_net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkStates require an index\n");
                      if (s->link_states) {
                              for (; s->link_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_states, "", pa);
                              SET_NEXT(s->link_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkStates argument missing\n");
                     s->link_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkStates[]")) || aret == '=') {
               TRY(!aa, "LinkStates[] argument missing\n");
               SET_NEXT(s->link_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "VirtualGatewayIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VirtualGatewayIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VirtualGatewayIds require an index\n");
                      if (s->virtual_gateway_ids) {
                              for (; s->virtual_gateway_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->virtual_gateway_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->virtual_gateway_ids, "", pa);
                              SET_NEXT(s->virtual_gateway_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VirtualGatewayIds argument missing\n");
                     s->virtual_gateway_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VirtualGatewayIds[]")) || aret == '=') {
               TRY(!aa, "VirtualGatewayIds[] argument missing\n");
               SET_NEXT(s->virtual_gateway_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVirtualGateway'\n", str);
		return -1;
	}
	return 0;
}

int filters_vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vm *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Architectures")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Architectures argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Architectures require an index\n");
                      if (s->architectures) {
                              for (; s->architectures[last]; ++last);
                      }
                      if (pos < last) {
                              s->architectures[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->architectures, "", pa);
                              SET_NEXT(s->architectures, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Architectures argument missing\n");
                     s->architectures_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Architectures[]")) || aret == '=') {
               TRY(!aa, "Architectures[] argument missing\n");
               SET_NEXT(s->architectures, (aa), pa);
         } else
	if ((aret = strcmp(str, "BlockDeviceMappingDeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_block_device_mapping_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->block_device_mapping_delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->block_device_mapping_delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("BlockDeviceMappingDeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "BlockDeviceMappingDeviceNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BlockDeviceMappingDeviceNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BlockDeviceMappingDeviceNames require an index\n");
                      if (s->block_device_mapping_device_names) {
                              for (; s->block_device_mapping_device_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->block_device_mapping_device_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->block_device_mapping_device_names, "", pa);
                              SET_NEXT(s->block_device_mapping_device_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BlockDeviceMappingDeviceNames argument missing\n");
                     s->block_device_mapping_device_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BlockDeviceMappingDeviceNames[]")) || aret == '=') {
               TRY(!aa, "BlockDeviceMappingDeviceNames[] argument missing\n");
               SET_NEXT(s->block_device_mapping_device_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "BlockDeviceMappingLinkDates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BlockDeviceMappingLinkDates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BlockDeviceMappingLinkDates require an index\n");
                      if (s->block_device_mapping_link_dates) {
                              for (; s->block_device_mapping_link_dates[last]; ++last);
                      }
                      if (pos < last) {
                              s->block_device_mapping_link_dates[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->block_device_mapping_link_dates, "", pa);
                              SET_NEXT(s->block_device_mapping_link_dates, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BlockDeviceMappingLinkDates argument missing\n");
                     s->block_device_mapping_link_dates_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BlockDeviceMappingLinkDates[]")) || aret == '=') {
               TRY(!aa, "BlockDeviceMappingLinkDates[] argument missing\n");
               SET_NEXT(s->block_device_mapping_link_dates, (aa), pa);
         } else
	if ((aret = strcmp(str, "BlockDeviceMappingStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BlockDeviceMappingStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BlockDeviceMappingStates require an index\n");
                      if (s->block_device_mapping_states) {
                              for (; s->block_device_mapping_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->block_device_mapping_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->block_device_mapping_states, "", pa);
                              SET_NEXT(s->block_device_mapping_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BlockDeviceMappingStates argument missing\n");
                     s->block_device_mapping_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BlockDeviceMappingStates[]")) || aret == '=') {
               TRY(!aa, "BlockDeviceMappingStates[] argument missing\n");
               SET_NEXT(s->block_device_mapping_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "BlockDeviceMappingVolumeIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BlockDeviceMappingVolumeIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BlockDeviceMappingVolumeIds require an index\n");
                      if (s->block_device_mapping_volume_ids) {
                              for (; s->block_device_mapping_volume_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->block_device_mapping_volume_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->block_device_mapping_volume_ids, "", pa);
                              SET_NEXT(s->block_device_mapping_volume_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BlockDeviceMappingVolumeIds argument missing\n");
                     s->block_device_mapping_volume_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BlockDeviceMappingVolumeIds[]")) || aret == '=') {
               TRY(!aa, "BlockDeviceMappingVolumeIds[] argument missing\n");
               SET_NEXT(s->block_device_mapping_volume_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ClientTokens")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ClientTokens argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ClientTokens require an index\n");
                      if (s->client_tokens) {
                              for (; s->client_tokens[last]; ++last);
                      }
                      if (pos < last) {
                              s->client_tokens[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->client_tokens, "", pa);
                              SET_NEXT(s->client_tokens, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ClientTokens argument missing\n");
                     s->client_tokens_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ClientTokens[]")) || aret == '=') {
               TRY(!aa, "ClientTokens[] argument missing\n");
               SET_NEXT(s->client_tokens, (aa), pa);
         } else
	if ((aret = strcmp(str, "CreationDates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CreationDates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CreationDates require an index\n");
                      if (s->creation_dates) {
                              for (; s->creation_dates[last]; ++last);
                      }
                      if (pos < last) {
                              s->creation_dates[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->creation_dates, "", pa);
                              SET_NEXT(s->creation_dates, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CreationDates argument missing\n");
                     s->creation_dates_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CreationDates[]")) || aret == '=') {
               TRY(!aa, "CreationDates[] argument missing\n");
               SET_NEXT(s->creation_dates, (aa), pa);
         } else
	if ((aret = strcmp(str, "ImageIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ImageIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ImageIds require an index\n");
                      if (s->image_ids) {
                              for (; s->image_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->image_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->image_ids, "", pa);
                              SET_NEXT(s->image_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ImageIds argument missing\n");
                     s->image_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ImageIds[]")) || aret == '=') {
               TRY(!aa, "ImageIds[] argument missing\n");
               SET_NEXT(s->image_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "IsSourceDestChecked")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_source_dest_checked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_checked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_checked = 0;
             } else {
            		BAD_RET("IsSourceDestChecked require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "KeypairNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "KeypairNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "KeypairNames require an index\n");
                      if (s->keypair_names) {
                              for (; s->keypair_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->keypair_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->keypair_names, "", pa);
                              SET_NEXT(s->keypair_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "KeypairNames argument missing\n");
                     s->keypair_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "KeypairNames[]")) || aret == '=') {
               TRY(!aa, "KeypairNames[] argument missing\n");
               SET_NEXT(s->keypair_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "LaunchNumbers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LaunchNumbers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LaunchNumbers require an index\n");
                      if (s->launch_numbers) {
                              for (; s->launch_numbers[last]; ++last);
                      }
                      if (pos < last) {
                              s->launch_numbers[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->launch_numbers, 0, pa);
                              SET_NEXT(s->launch_numbers, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LaunchNumbers argument missing\n");
                     s->launch_numbers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LaunchNumbers[]")) || aret == '=') {
               TRY(!aa, "LaunchNumbers[] argument missing\n");
               SET_NEXT(s->launch_numbers, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "Lifecycles")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Lifecycles argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Lifecycles require an index\n");
                      if (s->lifecycles) {
                              for (; s->lifecycles[last]; ++last);
                      }
                      if (pos < last) {
                              s->lifecycles[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->lifecycles, "", pa);
                              SET_NEXT(s->lifecycles, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Lifecycles argument missing\n");
                     s->lifecycles_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Lifecycles[]")) || aret == '=') {
               TRY(!aa, "Lifecycles[] argument missing\n");
               SET_NEXT(s->lifecycles, (aa), pa);
         } else
	if ((aret = strcmp(str, "NetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NetIds require an index\n");
                      if (s->net_ids) {
                              for (; s->net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->net_ids, "", pa);
                              SET_NEXT(s->net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NetIds argument missing\n");
                     s->net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NetIds[]")) || aret == '=') {
               TRY(!aa, "NetIds[] argument missing\n");
               SET_NEXT(s->net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicAccountIds require an index\n");
                      if (s->nic_account_ids) {
                              for (; s->nic_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_account_ids, "", pa);
                              SET_NEXT(s->nic_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicAccountIds argument missing\n");
                     s->nic_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicAccountIds[]")) || aret == '=') {
               TRY(!aa, "NicAccountIds[] argument missing\n");
               SET_NEXT(s->nic_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicDescriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicDescriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicDescriptions require an index\n");
                      if (s->nic_descriptions) {
                              for (; s->nic_descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_descriptions, "", pa);
                              SET_NEXT(s->nic_descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicDescriptions argument missing\n");
                     s->nic_descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicDescriptions[]")) || aret == '=') {
               TRY(!aa, "NicDescriptions[] argument missing\n");
               SET_NEXT(s->nic_descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicIsSourceDestChecked")) == 0 || aret == '=' || aret == '.') {
            s->is_set_nic_is_source_dest_checked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->nic_is_source_dest_checked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->nic_is_source_dest_checked = 0;
             } else {
            		BAD_RET("NicIsSourceDestChecked require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "NicLinkNicDeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_nic_link_nic_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->nic_link_nic_delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->nic_link_nic_delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("NicLinkNicDeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "NicLinkNicDeviceNumbers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkNicDeviceNumbers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkNicDeviceNumbers require an index\n");
                      if (s->nic_link_nic_device_numbers) {
                              for (; s->nic_link_nic_device_numbers[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_nic_device_numbers[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_nic_device_numbers, 0, pa);
                              SET_NEXT(s->nic_link_nic_device_numbers, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkNicDeviceNumbers argument missing\n");
                     s->nic_link_nic_device_numbers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkNicDeviceNumbers[]")) || aret == '=') {
               TRY(!aa, "NicLinkNicDeviceNumbers[] argument missing\n");
               SET_NEXT(s->nic_link_nic_device_numbers, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkNicLinkNicDates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkNicLinkNicDates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkNicLinkNicDates require an index\n");
                      if (s->nic_link_nic_link_nic_dates) {
                              for (; s->nic_link_nic_link_nic_dates[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_nic_link_nic_dates[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_nic_link_nic_dates, "", pa);
                              SET_NEXT(s->nic_link_nic_link_nic_dates, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkNicLinkNicDates argument missing\n");
                     s->nic_link_nic_link_nic_dates_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkNicLinkNicDates[]")) || aret == '=') {
               TRY(!aa, "NicLinkNicLinkNicDates[] argument missing\n");
               SET_NEXT(s->nic_link_nic_link_nic_dates, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkNicLinkNicIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkNicLinkNicIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkNicLinkNicIds require an index\n");
                      if (s->nic_link_nic_link_nic_ids) {
                              for (; s->nic_link_nic_link_nic_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_nic_link_nic_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_nic_link_nic_ids, "", pa);
                              SET_NEXT(s->nic_link_nic_link_nic_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkNicLinkNicIds argument missing\n");
                     s->nic_link_nic_link_nic_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkNicLinkNicIds[]")) || aret == '=') {
               TRY(!aa, "NicLinkNicLinkNicIds[] argument missing\n");
               SET_NEXT(s->nic_link_nic_link_nic_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkNicStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkNicStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkNicStates require an index\n");
                      if (s->nic_link_nic_states) {
                              for (; s->nic_link_nic_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_nic_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_nic_states, "", pa);
                              SET_NEXT(s->nic_link_nic_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkNicStates argument missing\n");
                     s->nic_link_nic_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkNicStates[]")) || aret == '=') {
               TRY(!aa, "NicLinkNicStates[] argument missing\n");
               SET_NEXT(s->nic_link_nic_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkNicVmAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkNicVmAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkNicVmAccountIds require an index\n");
                      if (s->nic_link_nic_vm_account_ids) {
                              for (; s->nic_link_nic_vm_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_nic_vm_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_nic_vm_account_ids, "", pa);
                              SET_NEXT(s->nic_link_nic_vm_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkNicVmAccountIds argument missing\n");
                     s->nic_link_nic_vm_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkNicVmAccountIds[]")) || aret == '=') {
               TRY(!aa, "NicLinkNicVmAccountIds[] argument missing\n");
               SET_NEXT(s->nic_link_nic_vm_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkNicVmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkNicVmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkNicVmIds require an index\n");
                      if (s->nic_link_nic_vm_ids) {
                              for (; s->nic_link_nic_vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_nic_vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_nic_vm_ids, "", pa);
                              SET_NEXT(s->nic_link_nic_vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkNicVmIds argument missing\n");
                     s->nic_link_nic_vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkNicVmIds[]")) || aret == '=') {
               TRY(!aa, "NicLinkNicVmIds[] argument missing\n");
               SET_NEXT(s->nic_link_nic_vm_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkPublicIpAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkPublicIpAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkPublicIpAccountIds require an index\n");
                      if (s->nic_link_public_ip_account_ids) {
                              for (; s->nic_link_public_ip_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_public_ip_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_public_ip_account_ids, "", pa);
                              SET_NEXT(s->nic_link_public_ip_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkPublicIpAccountIds argument missing\n");
                     s->nic_link_public_ip_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkPublicIpAccountIds[]")) || aret == '=') {
               TRY(!aa, "NicLinkPublicIpAccountIds[] argument missing\n");
               SET_NEXT(s->nic_link_public_ip_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkPublicIpLinkPublicIpIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkPublicIpLinkPublicIpIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkPublicIpLinkPublicIpIds require an index\n");
                      if (s->nic_link_public_ip_link_public_ip_ids) {
                              for (; s->nic_link_public_ip_link_public_ip_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_public_ip_link_public_ip_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_public_ip_link_public_ip_ids, "", pa);
                              SET_NEXT(s->nic_link_public_ip_link_public_ip_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkPublicIpLinkPublicIpIds argument missing\n");
                     s->nic_link_public_ip_link_public_ip_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkPublicIpLinkPublicIpIds[]")) || aret == '=') {
               TRY(!aa, "NicLinkPublicIpLinkPublicIpIds[] argument missing\n");
               SET_NEXT(s->nic_link_public_ip_link_public_ip_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkPublicIpPublicIpIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkPublicIpPublicIpIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkPublicIpPublicIpIds require an index\n");
                      if (s->nic_link_public_ip_public_ip_ids) {
                              for (; s->nic_link_public_ip_public_ip_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_public_ip_public_ip_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_public_ip_public_ip_ids, "", pa);
                              SET_NEXT(s->nic_link_public_ip_public_ip_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkPublicIpPublicIpIds argument missing\n");
                     s->nic_link_public_ip_public_ip_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkPublicIpPublicIpIds[]")) || aret == '=') {
               TRY(!aa, "NicLinkPublicIpPublicIpIds[] argument missing\n");
               SET_NEXT(s->nic_link_public_ip_public_ip_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicLinkPublicIpPublicIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicLinkPublicIpPublicIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicLinkPublicIpPublicIps require an index\n");
                      if (s->nic_link_public_ip_public_ips) {
                              for (; s->nic_link_public_ip_public_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_link_public_ip_public_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_link_public_ip_public_ips, "", pa);
                              SET_NEXT(s->nic_link_public_ip_public_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicLinkPublicIpPublicIps argument missing\n");
                     s->nic_link_public_ip_public_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicLinkPublicIpPublicIps[]")) || aret == '=') {
               TRY(!aa, "NicLinkPublicIpPublicIps[] argument missing\n");
               SET_NEXT(s->nic_link_public_ip_public_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicMacAddresses")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicMacAddresses argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicMacAddresses require an index\n");
                      if (s->nic_mac_addresses) {
                              for (; s->nic_mac_addresses[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_mac_addresses[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_mac_addresses, "", pa);
                              SET_NEXT(s->nic_mac_addresses, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicMacAddresses argument missing\n");
                     s->nic_mac_addresses_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicMacAddresses[]")) || aret == '=') {
               TRY(!aa, "NicMacAddresses[] argument missing\n");
               SET_NEXT(s->nic_mac_addresses, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicNetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicNetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicNetIds require an index\n");
                      if (s->nic_net_ids) {
                              for (; s->nic_net_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_net_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_net_ids, "", pa);
                              SET_NEXT(s->nic_net_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicNetIds argument missing\n");
                     s->nic_net_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicNetIds[]")) || aret == '=') {
               TRY(!aa, "NicNetIds[] argument missing\n");
               SET_NEXT(s->nic_net_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicNicIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicNicIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicNicIds require an index\n");
                      if (s->nic_nic_ids) {
                              for (; s->nic_nic_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_nic_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_nic_ids, "", pa);
                              SET_NEXT(s->nic_nic_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicNicIds argument missing\n");
                     s->nic_nic_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicNicIds[]")) || aret == '=') {
               TRY(!aa, "NicNicIds[] argument missing\n");
               SET_NEXT(s->nic_nic_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicPrivateIpsLinkPublicIpAccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicPrivateIpsLinkPublicIpAccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicPrivateIpsLinkPublicIpAccountIds require an index\n");
                      if (s->nic_private_ips_link_public_ip_account_ids) {
                              for (; s->nic_private_ips_link_public_ip_account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_private_ips_link_public_ip_account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_private_ips_link_public_ip_account_ids, "", pa);
                              SET_NEXT(s->nic_private_ips_link_public_ip_account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicPrivateIpsLinkPublicIpAccountIds argument missing\n");
                     s->nic_private_ips_link_public_ip_account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicPrivateIpsLinkPublicIpAccountIds[]")) || aret == '=') {
               TRY(!aa, "NicPrivateIpsLinkPublicIpAccountIds[] argument missing\n");
               SET_NEXT(s->nic_private_ips_link_public_ip_account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicPrivateIpsLinkPublicIpIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicPrivateIpsLinkPublicIpIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicPrivateIpsLinkPublicIpIds require an index\n");
                      if (s->nic_private_ips_link_public_ip_ids) {
                              for (; s->nic_private_ips_link_public_ip_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_private_ips_link_public_ip_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_private_ips_link_public_ip_ids, "", pa);
                              SET_NEXT(s->nic_private_ips_link_public_ip_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicPrivateIpsLinkPublicIpIds argument missing\n");
                     s->nic_private_ips_link_public_ip_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicPrivateIpsLinkPublicIpIds[]")) || aret == '=') {
               TRY(!aa, "NicPrivateIpsLinkPublicIpIds[] argument missing\n");
               SET_NEXT(s->nic_private_ips_link_public_ip_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicPrivateIpsPrimaryIp")) == 0 || aret == '=' || aret == '.') {
            s->is_set_nic_private_ips_primary_ip = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->nic_private_ips_primary_ip = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->nic_private_ips_primary_ip = 0;
             } else {
            		BAD_RET("NicPrivateIpsPrimaryIp require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "NicPrivateIpsPrivateIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicPrivateIpsPrivateIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicPrivateIpsPrivateIps require an index\n");
                      if (s->nic_private_ips_private_ips) {
                              for (; s->nic_private_ips_private_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_private_ips_private_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_private_ips_private_ips, "", pa);
                              SET_NEXT(s->nic_private_ips_private_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicPrivateIpsPrivateIps argument missing\n");
                     s->nic_private_ips_private_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicPrivateIpsPrivateIps[]")) || aret == '=') {
               TRY(!aa, "NicPrivateIpsPrivateIps[] argument missing\n");
               SET_NEXT(s->nic_private_ips_private_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicSecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicSecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicSecurityGroupIds require an index\n");
                      if (s->nic_security_group_ids) {
                              for (; s->nic_security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_security_group_ids, "", pa);
                              SET_NEXT(s->nic_security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicSecurityGroupIds argument missing\n");
                     s->nic_security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicSecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "NicSecurityGroupIds[] argument missing\n");
               SET_NEXT(s->nic_security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicSecurityGroupNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicSecurityGroupNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicSecurityGroupNames require an index\n");
                      if (s->nic_security_group_names) {
                              for (; s->nic_security_group_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_security_group_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_security_group_names, "", pa);
                              SET_NEXT(s->nic_security_group_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicSecurityGroupNames argument missing\n");
                     s->nic_security_group_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicSecurityGroupNames[]")) || aret == '=') {
               TRY(!aa, "NicSecurityGroupNames[] argument missing\n");
               SET_NEXT(s->nic_security_group_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicStates require an index\n");
                      if (s->nic_states) {
                              for (; s->nic_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_states, "", pa);
                              SET_NEXT(s->nic_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicStates argument missing\n");
                     s->nic_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicStates[]")) || aret == '=') {
               TRY(!aa, "NicStates[] argument missing\n");
               SET_NEXT(s->nic_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicSubnetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicSubnetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicSubnetIds require an index\n");
                      if (s->nic_subnet_ids) {
                              for (; s->nic_subnet_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_subnet_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_subnet_ids, "", pa);
                              SET_NEXT(s->nic_subnet_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicSubnetIds argument missing\n");
                     s->nic_subnet_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicSubnetIds[]")) || aret == '=') {
               TRY(!aa, "NicSubnetIds[] argument missing\n");
               SET_NEXT(s->nic_subnet_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "NicSubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "NicSubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "NicSubregionNames require an index\n");
                      if (s->nic_subregion_names) {
                              for (; s->nic_subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->nic_subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->nic_subregion_names, "", pa);
                              SET_NEXT(s->nic_subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "NicSubregionNames argument missing\n");
                     s->nic_subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "NicSubregionNames[]")) || aret == '=') {
               TRY(!aa, "NicSubregionNames[] argument missing\n");
               SET_NEXT(s->nic_subregion_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "Platforms")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Platforms argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Platforms require an index\n");
                      if (s->platforms) {
                              for (; s->platforms[last]; ++last);
                      }
                      if (pos < last) {
                              s->platforms[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->platforms, "", pa);
                              SET_NEXT(s->platforms, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Platforms argument missing\n");
                     s->platforms_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Platforms[]")) || aret == '=') {
               TRY(!aa, "Platforms[] argument missing\n");
               SET_NEXT(s->platforms, (aa), pa);
         } else
	if ((aret = strcmp(str, "PrivateIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PrivateIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PrivateIps require an index\n");
                      if (s->private_ips) {
                              for (; s->private_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->private_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->private_ips, "", pa);
                              SET_NEXT(s->private_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PrivateIps argument missing\n");
                     s->private_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PrivateIps[]")) || aret == '=') {
               TRY(!aa, "PrivateIps[] argument missing\n");
               SET_NEXT(s->private_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "ProductCodes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ProductCodes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ProductCodes require an index\n");
                      if (s->product_codes) {
                              for (; s->product_codes[last]; ++last);
                      }
                      if (pos < last) {
                              s->product_codes[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->product_codes, "", pa);
                              SET_NEXT(s->product_codes, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ProductCodes argument missing\n");
                     s->product_codes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ProductCodes[]")) || aret == '=') {
               TRY(!aa, "ProductCodes[] argument missing\n");
               SET_NEXT(s->product_codes, (aa), pa);
         } else
	if ((aret = strcmp(str, "PublicIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PublicIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PublicIps require an index\n");
                      if (s->public_ips) {
                              for (; s->public_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->public_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->public_ips, "", pa);
                              SET_NEXT(s->public_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PublicIps argument missing\n");
                     s->public_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PublicIps[]")) || aret == '=') {
               TRY(!aa, "PublicIps[] argument missing\n");
               SET_NEXT(s->public_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "ReservationIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ReservationIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ReservationIds require an index\n");
                      if (s->reservation_ids) {
                              for (; s->reservation_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->reservation_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->reservation_ids, "", pa);
                              SET_NEXT(s->reservation_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ReservationIds argument missing\n");
                     s->reservation_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ReservationIds[]")) || aret == '=') {
               TRY(!aa, "ReservationIds[] argument missing\n");
               SET_NEXT(s->reservation_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "RootDeviceNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RootDeviceNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RootDeviceNames require an index\n");
                      if (s->root_device_names) {
                              for (; s->root_device_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->root_device_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->root_device_names, "", pa);
                              SET_NEXT(s->root_device_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RootDeviceNames argument missing\n");
                     s->root_device_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RootDeviceNames[]")) || aret == '=') {
               TRY(!aa, "RootDeviceNames[] argument missing\n");
               SET_NEXT(s->root_device_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "RootDeviceTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RootDeviceTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RootDeviceTypes require an index\n");
                      if (s->root_device_types) {
                              for (; s->root_device_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->root_device_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->root_device_types, "", pa);
                              SET_NEXT(s->root_device_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RootDeviceTypes argument missing\n");
                     s->root_device_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RootDeviceTypes[]")) || aret == '=') {
               TRY(!aa, "RootDeviceTypes[] argument missing\n");
               SET_NEXT(s->root_device_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "SecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
                      if (s->security_group_ids) {
                              for (; s->security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_ids, "", pa);
                              SET_NEXT(s->security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupIds argument missing\n");
                     s->security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SecurityGroupNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupNames require an index\n");
                      if (s->security_group_names) {
                              for (; s->security_group_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_names, "", pa);
                              SET_NEXT(s->security_group_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupNames argument missing\n");
                     s->security_group_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupNames[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupNames[] argument missing\n");
               SET_NEXT(s->security_group_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "StateReasonCodes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "StateReasonCodes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "StateReasonCodes require an index\n");
                      if (s->state_reason_codes) {
                              for (; s->state_reason_codes[last]; ++last);
                      }
                      if (pos < last) {
                              s->state_reason_codes[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->state_reason_codes, 0, pa);
                              SET_NEXT(s->state_reason_codes, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "StateReasonCodes argument missing\n");
                     s->state_reason_codes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "StateReasonCodes[]")) || aret == '=') {
               TRY(!aa, "StateReasonCodes[] argument missing\n");
               SET_NEXT(s->state_reason_codes, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "StateReasonMessages")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "StateReasonMessages argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "StateReasonMessages require an index\n");
                      if (s->state_reason_messages) {
                              for (; s->state_reason_messages[last]; ++last);
                      }
                      if (pos < last) {
                              s->state_reason_messages[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->state_reason_messages, "", pa);
                              SET_NEXT(s->state_reason_messages, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "StateReasonMessages argument missing\n");
                     s->state_reason_messages_str = aa;
                 }
         } else if (!(aret = strcmp(str, "StateReasonMessages[]")) || aret == '=') {
               TRY(!aa, "StateReasonMessages[] argument missing\n");
               SET_NEXT(s->state_reason_messages, (aa), pa);
         } else
	if ((aret = strcmp(str, "StateReasons")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "StateReasons argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "StateReasons require an index\n");
                      if (s->state_reasons) {
                              for (; s->state_reasons[last]; ++last);
                      }
                      if (pos < last) {
                              s->state_reasons[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->state_reasons, "", pa);
                              SET_NEXT(s->state_reasons, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "StateReasons argument missing\n");
                     s->state_reasons_str = aa;
                 }
         } else if (!(aret = strcmp(str, "StateReasons[]")) || aret == '=') {
               TRY(!aa, "StateReasons[] argument missing\n");
               SET_NEXT(s->state_reasons, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubnetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubnetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubnetIds require an index\n");
                      if (s->subnet_ids) {
                              for (; s->subnet_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->subnet_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subnet_ids, "", pa);
                              SET_NEXT(s->subnet_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubnetIds argument missing\n");
                     s->subnet_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubnetIds[]")) || aret == '=') {
               TRY(!aa, "SubnetIds[] argument missing\n");
               SET_NEXT(s->subnet_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tenancies")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tenancies argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tenancies require an index\n");
                      if (s->tenancies) {
                              for (; s->tenancies[last]; ++last);
                      }
                      if (pos < last) {
                              s->tenancies[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tenancies, "", pa);
                              SET_NEXT(s->tenancies, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tenancies argument missing\n");
                     s->tenancies_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tenancies[]")) || aret == '=') {
               TRY(!aa, "Tenancies[] argument missing\n");
               SET_NEXT(s->tenancies, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmIds require an index\n");
                      if (s->vm_ids) {
                              for (; s->vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_ids, "", pa);
                              SET_NEXT(s->vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmIds argument missing\n");
                     s->vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmSecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmSecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmSecurityGroupIds require an index\n");
                      if (s->vm_security_group_ids) {
                              for (; s->vm_security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_security_group_ids, "", pa);
                              SET_NEXT(s->vm_security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmSecurityGroupIds argument missing\n");
                     s->vm_security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmSecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "VmSecurityGroupIds[] argument missing\n");
               SET_NEXT(s->vm_security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmSecurityGroupNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmSecurityGroupNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmSecurityGroupNames require an index\n");
                      if (s->vm_security_group_names) {
                              for (; s->vm_security_group_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_security_group_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_security_group_names, "", pa);
                              SET_NEXT(s->vm_security_group_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmSecurityGroupNames argument missing\n");
                     s->vm_security_group_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmSecurityGroupNames[]")) || aret == '=') {
               TRY(!aa, "VmSecurityGroupNames[] argument missing\n");
               SET_NEXT(s->vm_security_group_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmStateCodes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmStateCodes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmStateCodes require an index\n");
                      if (s->vm_state_codes) {
                              for (; s->vm_state_codes[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_state_codes[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_state_codes, 0, pa);
                              SET_NEXT(s->vm_state_codes, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmStateCodes argument missing\n");
                     s->vm_state_codes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmStateCodes[]")) || aret == '=') {
               TRY(!aa, "VmStateCodes[] argument missing\n");
               SET_NEXT(s->vm_state_codes, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "VmStateNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmStateNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmStateNames require an index\n");
                      if (s->vm_state_names) {
                              for (; s->vm_state_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_state_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_state_names, "", pa);
                              SET_NEXT(s->vm_state_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmStateNames argument missing\n");
                     s->vm_state_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmStateNames[]")) || aret == '=') {
               TRY(!aa, "VmStateNames[] argument missing\n");
               SET_NEXT(s->vm_state_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmTypes require an index\n");
                      if (s->vm_types) {
                              for (; s->vm_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_types, "", pa);
                              SET_NEXT(s->vm_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmTypes argument missing\n");
                     s->vm_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmTypes[]")) || aret == '=') {
               TRY(!aa, "VmTypes[] argument missing\n");
               SET_NEXT(s->vm_types, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVm'\n", str);
		return -1;
	}
	return 0;
}

int filters_vm_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vm_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Descriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Descriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Descriptions require an index\n");
                      if (s->descriptions) {
                              for (; s->descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->descriptions, "", pa);
                              SET_NEXT(s->descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Descriptions argument missing\n");
                     s->descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Descriptions[]")) || aret == '=') {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "SecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
                      if (s->security_group_ids) {
                              for (; s->security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_ids, "", pa);
                              SET_NEXT(s->security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupIds argument missing\n");
                     s->security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubnetIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubnetIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubnetIds require an index\n");
                      if (s->subnet_ids) {
                              for (; s->subnet_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->subnet_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subnet_ids, "", pa);
                              SET_NEXT(s->subnet_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubnetIds argument missing\n");
                     s->subnet_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubnetIds[]")) || aret == '=') {
               TRY(!aa, "SubnetIds[] argument missing\n");
               SET_NEXT(s->subnet_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmCounts")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmCounts argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmCounts require an index\n");
                      if (s->vm_counts) {
                              for (; s->vm_counts[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_counts[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_counts, 0, pa);
                              SET_NEXT(s->vm_counts, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmCounts argument missing\n");
                     s->vm_counts_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmCounts[]")) || aret == '=') {
               TRY(!aa, "VmCounts[] argument missing\n");
               SET_NEXT(s->vm_counts, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "VmGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmGroupIds require an index\n");
                      if (s->vm_group_ids) {
                              for (; s->vm_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_group_ids, "", pa);
                              SET_NEXT(s->vm_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmGroupIds argument missing\n");
                     s->vm_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmGroupIds[]")) || aret == '=') {
               TRY(!aa, "VmGroupIds[] argument missing\n");
               SET_NEXT(s->vm_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmGroupNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmGroupNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmGroupNames require an index\n");
                      if (s->vm_group_names) {
                              for (; s->vm_group_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_group_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_group_names, "", pa);
                              SET_NEXT(s->vm_group_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmGroupNames argument missing\n");
                     s->vm_group_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmGroupNames[]")) || aret == '=') {
               TRY(!aa, "VmGroupNames[] argument missing\n");
               SET_NEXT(s->vm_group_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmTemplateIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmTemplateIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmTemplateIds require an index\n");
                      if (s->vm_template_ids) {
                              for (; s->vm_template_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_template_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_template_ids, "", pa);
                              SET_NEXT(s->vm_template_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmTemplateIds argument missing\n");
                     s->vm_template_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmTemplateIds[]")) || aret == '=') {
               TRY(!aa, "VmTemplateIds[] argument missing\n");
               SET_NEXT(s->vm_template_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVmGroup'\n", str);
		return -1;
	}
	return 0;
}

int filters_vm_template_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vm_template *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CpuCores")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CpuCores argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CpuCores require an index\n");
                      if (s->cpu_cores) {
                              for (; s->cpu_cores[last]; ++last);
                      }
                      if (pos < last) {
                              s->cpu_cores[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->cpu_cores, 0, pa);
                              SET_NEXT(s->cpu_cores, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CpuCores argument missing\n");
                     s->cpu_cores_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CpuCores[]")) || aret == '=') {
               TRY(!aa, "CpuCores[] argument missing\n");
               SET_NEXT(s->cpu_cores, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "CpuGenerations")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CpuGenerations argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CpuGenerations require an index\n");
                      if (s->cpu_generations) {
                              for (; s->cpu_generations[last]; ++last);
                      }
                      if (pos < last) {
                              s->cpu_generations[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->cpu_generations, "", pa);
                              SET_NEXT(s->cpu_generations, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CpuGenerations argument missing\n");
                     s->cpu_generations_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CpuGenerations[]")) || aret == '=') {
               TRY(!aa, "CpuGenerations[] argument missing\n");
               SET_NEXT(s->cpu_generations, (aa), pa);
         } else
	if ((aret = strcmp(str, "CpuPerformances")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CpuPerformances argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CpuPerformances require an index\n");
                      if (s->cpu_performances) {
                              for (; s->cpu_performances[last]; ++last);
                      }
                      if (pos < last) {
                              s->cpu_performances[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->cpu_performances, "", pa);
                              SET_NEXT(s->cpu_performances, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CpuPerformances argument missing\n");
                     s->cpu_performances_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CpuPerformances[]")) || aret == '=') {
               TRY(!aa, "CpuPerformances[] argument missing\n");
               SET_NEXT(s->cpu_performances, (aa), pa);
         } else
	if ((aret = strcmp(str, "Descriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Descriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Descriptions require an index\n");
                      if (s->descriptions) {
                              for (; s->descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->descriptions, "", pa);
                              SET_NEXT(s->descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Descriptions argument missing\n");
                     s->descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Descriptions[]")) || aret == '=') {
               TRY(!aa, "Descriptions[] argument missing\n");
               SET_NEXT(s->descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "ImageIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ImageIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ImageIds require an index\n");
                      if (s->image_ids) {
                              for (; s->image_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->image_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->image_ids, "", pa);
                              SET_NEXT(s->image_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ImageIds argument missing\n");
                     s->image_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ImageIds[]")) || aret == '=') {
               TRY(!aa, "ImageIds[] argument missing\n");
               SET_NEXT(s->image_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "KeypairNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "KeypairNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "KeypairNames require an index\n");
                      if (s->keypair_names) {
                              for (; s->keypair_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->keypair_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->keypair_names, "", pa);
                              SET_NEXT(s->keypair_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "KeypairNames argument missing\n");
                     s->keypair_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "KeypairNames[]")) || aret == '=') {
               TRY(!aa, "KeypairNames[] argument missing\n");
               SET_NEXT(s->keypair_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "Rams")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Rams argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Rams require an index\n");
                      if (s->rams) {
                              for (; s->rams[last]; ++last);
                      }
                      if (pos < last) {
                              s->rams[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->rams, 0, pa);
                              SET_NEXT(s->rams, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Rams argument missing\n");
                     s->rams_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Rams[]")) || aret == '=') {
               TRY(!aa, "Rams[] argument missing\n");
               SET_NEXT(s->rams, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmTemplateIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmTemplateIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmTemplateIds require an index\n");
                      if (s->vm_template_ids) {
                              for (; s->vm_template_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_template_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_template_ids, "", pa);
                              SET_NEXT(s->vm_template_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmTemplateIds argument missing\n");
                     s->vm_template_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmTemplateIds[]")) || aret == '=') {
               TRY(!aa, "VmTemplateIds[] argument missing\n");
               SET_NEXT(s->vm_template_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmTemplateNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmTemplateNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmTemplateNames require an index\n");
                      if (s->vm_template_names) {
                              for (; s->vm_template_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_template_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_template_names, "", pa);
                              SET_NEXT(s->vm_template_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmTemplateNames argument missing\n");
                     s->vm_template_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmTemplateNames[]")) || aret == '=') {
               TRY(!aa, "VmTemplateNames[] argument missing\n");
               SET_NEXT(s->vm_template_names, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVmTemplate'\n", str);
		return -1;
	}
	return 0;
}

int filters_vm_type_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vm_type *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "BsuOptimized")) == 0 || aret == '=' || aret == '.') {
            s->is_set_bsu_optimized = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->bsu_optimized = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->bsu_optimized = 0;
             } else {
            		BAD_RET("BsuOptimized require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "EphemeralsTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "EphemeralsTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "EphemeralsTypes require an index\n");
                      if (s->ephemerals_types) {
                              for (; s->ephemerals_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->ephemerals_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ephemerals_types, "", pa);
                              SET_NEXT(s->ephemerals_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "EphemeralsTypes argument missing\n");
                     s->ephemerals_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "EphemeralsTypes[]")) || aret == '=') {
               TRY(!aa, "EphemeralsTypes[] argument missing\n");
               SET_NEXT(s->ephemerals_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "Eths")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Eths argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Eths require an index\n");
                      if (s->eths) {
                              for (; s->eths[last]; ++last);
                      }
                      if (pos < last) {
                              s->eths[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->eths, 0, pa);
                              SET_NEXT(s->eths, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Eths argument missing\n");
                     s->eths_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Eths[]")) || aret == '=') {
               TRY(!aa, "Eths[] argument missing\n");
               SET_NEXT(s->eths, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "Gpus")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Gpus argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Gpus require an index\n");
                      if (s->gpus) {
                              for (; s->gpus[last]; ++last);
                      }
                      if (pos < last) {
                              s->gpus[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->gpus, 0, pa);
                              SET_NEXT(s->gpus, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Gpus argument missing\n");
                     s->gpus_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Gpus[]")) || aret == '=') {
               TRY(!aa, "Gpus[] argument missing\n");
               SET_NEXT(s->gpus, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "MemorySizes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "MemorySizes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "MemorySizes require an index\n");
                      if (s->memory_sizes) {
                              for (; s->memory_sizes[last]; ++last);
                      }
                      if (pos < last) {
                              s->memory_sizes[pos] = atof(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->memory_sizes, 0.0, pa);
                              SET_NEXT(s->memory_sizes, atof(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "MemorySizes argument missing\n");
                     s->memory_sizes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "MemorySizes[]")) || aret == '=') {
               TRY(!aa, "MemorySizes[] argument missing\n");
               SET_NEXT(s->memory_sizes, atof(aa), pa);
         } else
	if ((aret = strcmp(str, "VcoreCounts")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VcoreCounts argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VcoreCounts require an index\n");
                      if (s->vcore_counts) {
                              for (; s->vcore_counts[last]; ++last);
                      }
                      if (pos < last) {
                              s->vcore_counts[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vcore_counts, 0, pa);
                              SET_NEXT(s->vcore_counts, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VcoreCounts argument missing\n");
                     s->vcore_counts_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VcoreCounts[]")) || aret == '=') {
               TRY(!aa, "VcoreCounts[] argument missing\n");
               SET_NEXT(s->vcore_counts, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "VmTypeNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmTypeNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmTypeNames require an index\n");
                      if (s->vm_type_names) {
                              for (; s->vm_type_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_type_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_type_names, "", pa);
                              SET_NEXT(s->vm_type_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmTypeNames argument missing\n");
                     s->vm_type_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmTypeNames[]")) || aret == '=') {
               TRY(!aa, "VmTypeNames[] argument missing\n");
               SET_NEXT(s->vm_type_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "VolumeCounts")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VolumeCounts argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VolumeCounts require an index\n");
                      if (s->volume_counts) {
                              for (; s->volume_counts[last]; ++last);
                      }
                      if (pos < last) {
                              s->volume_counts[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->volume_counts, 0, pa);
                              SET_NEXT(s->volume_counts, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VolumeCounts argument missing\n");
                     s->volume_counts_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VolumeCounts[]")) || aret == '=') {
               TRY(!aa, "VolumeCounts[] argument missing\n");
               SET_NEXT(s->volume_counts, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "VolumeSizes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VolumeSizes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VolumeSizes require an index\n");
                      if (s->volume_sizes) {
                              for (; s->volume_sizes[last]; ++last);
                      }
                      if (pos < last) {
                              s->volume_sizes[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->volume_sizes, 0, pa);
                              SET_NEXT(s->volume_sizes, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VolumeSizes argument missing\n");
                     s->volume_sizes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VolumeSizes[]")) || aret == '=') {
               TRY(!aa, "VolumeSizes[] argument missing\n");
               SET_NEXT(s->volume_sizes, atoi(aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVmType'\n", str);
		return -1;
	}
	return 0;
}

int filters_vms_state_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vms_state *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "MaintenanceEventCodes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "MaintenanceEventCodes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "MaintenanceEventCodes require an index\n");
                      if (s->maintenance_event_codes) {
                              for (; s->maintenance_event_codes[last]; ++last);
                      }
                      if (pos < last) {
                              s->maintenance_event_codes[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->maintenance_event_codes, "", pa);
                              SET_NEXT(s->maintenance_event_codes, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "MaintenanceEventCodes argument missing\n");
                     s->maintenance_event_codes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "MaintenanceEventCodes[]")) || aret == '=') {
               TRY(!aa, "MaintenanceEventCodes[] argument missing\n");
               SET_NEXT(s->maintenance_event_codes, (aa), pa);
         } else
	if ((aret = strcmp(str, "MaintenanceEventDescriptions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "MaintenanceEventDescriptions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "MaintenanceEventDescriptions require an index\n");
                      if (s->maintenance_event_descriptions) {
                              for (; s->maintenance_event_descriptions[last]; ++last);
                      }
                      if (pos < last) {
                              s->maintenance_event_descriptions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->maintenance_event_descriptions, "", pa);
                              SET_NEXT(s->maintenance_event_descriptions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "MaintenanceEventDescriptions argument missing\n");
                     s->maintenance_event_descriptions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "MaintenanceEventDescriptions[]")) || aret == '=') {
               TRY(!aa, "MaintenanceEventDescriptions[] argument missing\n");
               SET_NEXT(s->maintenance_event_descriptions, (aa), pa);
         } else
	if ((aret = strcmp(str, "MaintenanceEventsNotAfter")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "MaintenanceEventsNotAfter argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "MaintenanceEventsNotAfter require an index\n");
                      if (s->maintenance_events_not_after) {
                              for (; s->maintenance_events_not_after[last]; ++last);
                      }
                      if (pos < last) {
                              s->maintenance_events_not_after[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->maintenance_events_not_after, "", pa);
                              SET_NEXT(s->maintenance_events_not_after, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "MaintenanceEventsNotAfter argument missing\n");
                     s->maintenance_events_not_after_str = aa;
                 }
         } else if (!(aret = strcmp(str, "MaintenanceEventsNotAfter[]")) || aret == '=') {
               TRY(!aa, "MaintenanceEventsNotAfter[] argument missing\n");
               SET_NEXT(s->maintenance_events_not_after, (aa), pa);
         } else
	if ((aret = strcmp(str, "MaintenanceEventsNotBefore")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "MaintenanceEventsNotBefore argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "MaintenanceEventsNotBefore require an index\n");
                      if (s->maintenance_events_not_before) {
                              for (; s->maintenance_events_not_before[last]; ++last);
                      }
                      if (pos < last) {
                              s->maintenance_events_not_before[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->maintenance_events_not_before, "", pa);
                              SET_NEXT(s->maintenance_events_not_before, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "MaintenanceEventsNotBefore argument missing\n");
                     s->maintenance_events_not_before_str = aa;
                 }
         } else if (!(aret = strcmp(str, "MaintenanceEventsNotBefore[]")) || aret == '=') {
               TRY(!aa, "MaintenanceEventsNotBefore[] argument missing\n");
               SET_NEXT(s->maintenance_events_not_before, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmIds require an index\n");
                      if (s->vm_ids) {
                              for (; s->vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_ids, "", pa);
                              SET_NEXT(s->vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmIds argument missing\n");
                     s->vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmStates require an index\n");
                      if (s->vm_states) {
                              for (; s->vm_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_states, "", pa);
                              SET_NEXT(s->vm_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmStates argument missing\n");
                     s->vm_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmStates[]")) || aret == '=') {
               TRY(!aa, "VmStates[] argument missing\n");
               SET_NEXT(s->vm_states, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVmsState'\n", str);
		return -1;
	}
	return 0;
}

int filters_volume_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_volume *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CreationDates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "CreationDates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "CreationDates require an index\n");
                      if (s->creation_dates) {
                              for (; s->creation_dates[last]; ++last);
                      }
                      if (pos < last) {
                              s->creation_dates[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->creation_dates, "", pa);
                              SET_NEXT(s->creation_dates, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "CreationDates argument missing\n");
                     s->creation_dates_str = aa;
                 }
         } else if (!(aret = strcmp(str, "CreationDates[]")) || aret == '=') {
               TRY(!aa, "CreationDates[] argument missing\n");
               SET_NEXT(s->creation_dates, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkVolumeDeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_link_volume_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->link_volume_delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->link_volume_delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("LinkVolumeDeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkVolumeDeviceNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkVolumeDeviceNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkVolumeDeviceNames require an index\n");
                      if (s->link_volume_device_names) {
                              for (; s->link_volume_device_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_volume_device_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_volume_device_names, "", pa);
                              SET_NEXT(s->link_volume_device_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkVolumeDeviceNames argument missing\n");
                     s->link_volume_device_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkVolumeDeviceNames[]")) || aret == '=') {
               TRY(!aa, "LinkVolumeDeviceNames[] argument missing\n");
               SET_NEXT(s->link_volume_device_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkVolumeLinkDates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkVolumeLinkDates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkVolumeLinkDates require an index\n");
                      if (s->link_volume_link_dates) {
                              for (; s->link_volume_link_dates[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_volume_link_dates[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_volume_link_dates, "", pa);
                              SET_NEXT(s->link_volume_link_dates, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkVolumeLinkDates argument missing\n");
                     s->link_volume_link_dates_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkVolumeLinkDates[]")) || aret == '=') {
               TRY(!aa, "LinkVolumeLinkDates[] argument missing\n");
               SET_NEXT(s->link_volume_link_dates, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkVolumeLinkStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkVolumeLinkStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkVolumeLinkStates require an index\n");
                      if (s->link_volume_link_states) {
                              for (; s->link_volume_link_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_volume_link_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_volume_link_states, "", pa);
                              SET_NEXT(s->link_volume_link_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkVolumeLinkStates argument missing\n");
                     s->link_volume_link_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkVolumeLinkStates[]")) || aret == '=') {
               TRY(!aa, "LinkVolumeLinkStates[] argument missing\n");
               SET_NEXT(s->link_volume_link_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "LinkVolumeVmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "LinkVolumeVmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "LinkVolumeVmIds require an index\n");
                      if (s->link_volume_vm_ids) {
                              for (; s->link_volume_vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->link_volume_vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->link_volume_vm_ids, "", pa);
                              SET_NEXT(s->link_volume_vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "LinkVolumeVmIds argument missing\n");
                     s->link_volume_vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "LinkVolumeVmIds[]")) || aret == '=') {
               TRY(!aa, "LinkVolumeVmIds[] argument missing\n");
               SET_NEXT(s->link_volume_vm_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SnapshotIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SnapshotIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SnapshotIds require an index\n");
                      if (s->snapshot_ids) {
                              for (; s->snapshot_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->snapshot_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->snapshot_ids, "", pa);
                              SET_NEXT(s->snapshot_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SnapshotIds argument missing\n");
                     s->snapshot_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SnapshotIds[]")) || aret == '=') {
               TRY(!aa, "SnapshotIds[] argument missing\n");
               SET_NEXT(s->snapshot_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "VolumeIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VolumeIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VolumeIds require an index\n");
                      if (s->volume_ids) {
                              for (; s->volume_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->volume_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->volume_ids, "", pa);
                              SET_NEXT(s->volume_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VolumeIds argument missing\n");
                     s->volume_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VolumeIds[]")) || aret == '=') {
               TRY(!aa, "VolumeIds[] argument missing\n");
               SET_NEXT(s->volume_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VolumeSizes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VolumeSizes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VolumeSizes require an index\n");
                      if (s->volume_sizes) {
                              for (; s->volume_sizes[last]; ++last);
                      }
                      if (pos < last) {
                              s->volume_sizes[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->volume_sizes, 0, pa);
                              SET_NEXT(s->volume_sizes, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VolumeSizes argument missing\n");
                     s->volume_sizes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VolumeSizes[]")) || aret == '=') {
               TRY(!aa, "VolumeSizes[] argument missing\n");
               SET_NEXT(s->volume_sizes, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "VolumeStates")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VolumeStates argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VolumeStates require an index\n");
                      if (s->volume_states) {
                              for (; s->volume_states[last]; ++last);
                      }
                      if (pos < last) {
                              s->volume_states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->volume_states, "", pa);
                              SET_NEXT(s->volume_states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VolumeStates argument missing\n");
                     s->volume_states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VolumeStates[]")) || aret == '=') {
               TRY(!aa, "VolumeStates[] argument missing\n");
               SET_NEXT(s->volume_states, (aa), pa);
         } else
	if ((aret = strcmp(str, "VolumeTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VolumeTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VolumeTypes require an index\n");
                      if (s->volume_types) {
                              for (; s->volume_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->volume_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->volume_types, "", pa);
                              SET_NEXT(s->volume_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VolumeTypes argument missing\n");
                     s->volume_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VolumeTypes[]")) || aret == '=') {
               TRY(!aa, "VolumeTypes[] argument missing\n");
               SET_NEXT(s->volume_types, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVolume'\n", str);
		return -1;
	}
	return 0;
}

int filters_vpn_connection_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct filters_vpn_connection *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "BgpAsns")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BgpAsns argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BgpAsns require an index\n");
                      if (s->bgp_asns) {
                              for (; s->bgp_asns[last]; ++last);
                      }
                      if (pos < last) {
                              s->bgp_asns[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->bgp_asns, 0, pa);
                              SET_NEXT(s->bgp_asns, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BgpAsns argument missing\n");
                     s->bgp_asns_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BgpAsns[]")) || aret == '=') {
               TRY(!aa, "BgpAsns[] argument missing\n");
               SET_NEXT(s->bgp_asns, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "ClientGatewayIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ClientGatewayIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ClientGatewayIds require an index\n");
                      if (s->client_gateway_ids) {
                              for (; s->client_gateway_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->client_gateway_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->client_gateway_ids, "", pa);
                              SET_NEXT(s->client_gateway_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ClientGatewayIds argument missing\n");
                     s->client_gateway_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ClientGatewayIds[]")) || aret == '=') {
               TRY(!aa, "ClientGatewayIds[] argument missing\n");
               SET_NEXT(s->client_gateway_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ConnectionTypes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ConnectionTypes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ConnectionTypes require an index\n");
                      if (s->connection_types) {
                              for (; s->connection_types[last]; ++last);
                      }
                      if (pos < last) {
                              s->connection_types[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->connection_types, "", pa);
                              SET_NEXT(s->connection_types, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ConnectionTypes argument missing\n");
                     s->connection_types_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ConnectionTypes[]")) || aret == '=') {
               TRY(!aa, "ConnectionTypes[] argument missing\n");
               SET_NEXT(s->connection_types, (aa), pa);
         } else
	if ((aret = strcmp(str, "RouteDestinationIpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteDestinationIpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteDestinationIpRanges require an index\n");
                      if (s->route_destination_ip_ranges) {
                              for (; s->route_destination_ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_destination_ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_destination_ip_ranges, "", pa);
                              SET_NEXT(s->route_destination_ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteDestinationIpRanges argument missing\n");
                     s->route_destination_ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteDestinationIpRanges[]")) || aret == '=') {
               TRY(!aa, "RouteDestinationIpRanges[] argument missing\n");
               SET_NEXT(s->route_destination_ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "States")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "States argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "States require an index\n");
                      if (s->states) {
                              for (; s->states[last]; ++last);
                      }
                      if (pos < last) {
                              s->states[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->states, "", pa);
                              SET_NEXT(s->states, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "States argument missing\n");
                     s->states_str = aa;
                 }
         } else if (!(aret = strcmp(str, "States[]")) || aret == '=') {
               TRY(!aa, "States[] argument missing\n");
               SET_NEXT(s->states, (aa), pa);
         } else
	if ((aret = strcmp(str, "StaticRoutesOnly")) == 0 || aret == '=' || aret == '.') {
            s->is_set_static_routes_only = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->static_routes_only = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->static_routes_only = 0;
             } else {
            		BAD_RET("StaticRoutesOnly require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "TagKeys")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagKeys argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagKeys require an index\n");
                      if (s->tag_keys) {
                              for (; s->tag_keys[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_keys[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_keys, "", pa);
                              SET_NEXT(s->tag_keys, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagKeys argument missing\n");
                     s->tag_keys_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagKeys[]")) || aret == '=') {
               TRY(!aa, "TagKeys[] argument missing\n");
               SET_NEXT(s->tag_keys, (aa), pa);
         } else
	if ((aret = strcmp(str, "TagValues")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "TagValues argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "TagValues require an index\n");
                      if (s->tag_values) {
                              for (; s->tag_values[last]; ++last);
                      }
                      if (pos < last) {
                              s->tag_values[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tag_values, "", pa);
                              SET_NEXT(s->tag_values, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "TagValues argument missing\n");
                     s->tag_values_str = aa;
                 }
         } else if (!(aret = strcmp(str, "TagValues[]")) || aret == '=') {
               TRY(!aa, "TagValues[] argument missing\n");
               SET_NEXT(s->tag_values, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Tags argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Tags require an index\n");
                      if (s->tags) {
                              for (; s->tags[last]; ++last);
                      }
                      if (pos < last) {
                              s->tags[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->tags, "", pa);
                              SET_NEXT(s->tags, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Tags argument missing\n");
                     s->tags_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Tags[]")) || aret == '=') {
               TRY(!aa, "Tags[] argument missing\n");
               SET_NEXT(s->tags, (aa), pa);
         } else
	if ((aret = strcmp(str, "VirtualGatewayIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VirtualGatewayIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VirtualGatewayIds require an index\n");
                      if (s->virtual_gateway_ids) {
                              for (; s->virtual_gateway_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->virtual_gateway_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->virtual_gateway_ids, "", pa);
                              SET_NEXT(s->virtual_gateway_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VirtualGatewayIds argument missing\n");
                     s->virtual_gateway_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VirtualGatewayIds[]")) || aret == '=') {
               TRY(!aa, "VirtualGatewayIds[] argument missing\n");
               SET_NEXT(s->virtual_gateway_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VpnConnectionIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VpnConnectionIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VpnConnectionIds require an index\n");
                      if (s->vpn_connection_ids) {
                              for (; s->vpn_connection_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vpn_connection_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vpn_connection_ids, "", pa);
                              SET_NEXT(s->vpn_connection_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VpnConnectionIds argument missing\n");
                     s->vpn_connection_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VpnConnectionIds[]")) || aret == '=') {
               TRY(!aa, "VpnConnectionIds[] argument missing\n");
               SET_NEXT(s->vpn_connection_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FiltersVpnConnection'\n", str);
		return -1;
	}
	return 0;
}

int flexible_gpu_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct flexible_gpu *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "FlexibleGpuId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "FlexibleGpuId argument missing\n");
            s->flexible_gpu_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Generation")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Generation argument missing\n");
            s->generation = aa; // string string

         } else
	if ((aret = strcmp(str, "ModelName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ModelName argument missing\n");
            s->model_name = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FlexibleGpu'\n", str);
		return -1;
	}
	return 0;
}

int flexible_gpu_catalog_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct flexible_gpu_catalog *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Generations")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Generations argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Generations require an index\n");
                      if (s->generations) {
                              for (; s->generations[last]; ++last);
                      }
                      if (pos < last) {
                              s->generations[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->generations, "", pa);
                              SET_NEXT(s->generations, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Generations argument missing\n");
                     s->generations_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Generations[]")) || aret == '=') {
               TRY(!aa, "Generations[] argument missing\n");
               SET_NEXT(s->generations, (aa), pa);
         } else
	if ((aret = strcmp(str, "MaxCpu")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MaxCpu argument missing\n");
            s->is_set_max_cpu = 1;
            s->max_cpu = atoi(aa);
         } else
	if ((aret = strcmp(str, "MaxRam")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MaxRam argument missing\n");
            s->is_set_max_ram = 1;
            s->max_ram = atoi(aa);
         } else
	if ((aret = strcmp(str, "ModelName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ModelName argument missing\n");
            s->model_name = aa; // string string

         } else
	if ((aret = strcmp(str, "VRam")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VRam argument missing\n");
            s->is_set_vram = 1;
            s->vram = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'FlexibleGpuCatalog'\n", str);
		return -1;
	}
	return 0;
}

int health_check_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct health_check *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CheckInterval")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CheckInterval argument missing\n");
            s->is_set_check_interval = 1;
            s->check_interval = atoi(aa);
         } else
	if ((aret = strcmp(str, "HealthyThreshold")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "HealthyThreshold argument missing\n");
            s->is_set_healthy_threshold = 1;
            s->healthy_threshold = atoi(aa);
         } else
	if ((aret = strcmp(str, "Path")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Path argument missing\n");
            s->path = aa; // string string

         } else
	if ((aret = strcmp(str, "Port")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Port argument missing\n");
            s->is_set_port = 1;
            s->port = atoi(aa);
         } else
	if ((aret = strcmp(str, "Protocol")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Protocol argument missing\n");
            s->protocol = aa; // string string

         } else
	if ((aret = strcmp(str, "Timeout")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Timeout argument missing\n");
            s->is_set_timeout = 1;
            s->timeout = atoi(aa);
         } else
	if ((aret = strcmp(str, "UnhealthyThreshold")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UnhealthyThreshold argument missing\n");
            s->is_set_unhealthy_threshold = 1;
            s->unhealthy_threshold = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'HealthCheck'\n", str);
		return -1;
	}
	return 0;
}

int image_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct image *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountAlias")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountAlias argument missing\n");
            s->account_alias = aa; // string string

         } else
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Architecture")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Architecture argument missing\n");
            s->architecture = aa; // string string

         } else
	if ((aret = strcmp(str, "BlockDeviceMappings")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingImage.BlockDeviceMappings.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'BlockDeviceMappings' require a .\n");
            	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
            	      cascade_struct = &s->block_device_mappings[pos];
            	      cascade_parser = block_device_mapping_image_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(block_device_mapping_image_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "BlockDeviceMappings argument missing\n");
            	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingImage ref
            }
         } else
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "FileLocation")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "FileLocation argument missing\n");
            s->file_location = aa; // string string

         } else
	if ((aret = strcmp(str, "ImageId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ImageId argument missing\n");
            s->image_id = aa; // string string

         } else
	if ((aret = strcmp(str, "ImageName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ImageName argument missing\n");
            s->image_name = aa; // string string

         } else
	if ((aret = strcmp(str, "ImageType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ImageType argument missing\n");
            s->image_type = aa; // string string

         } else
	if ((aret = strcmp(str, "PermissionsToLaunch")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "PermissionsToLaunch argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->permissions_to_launch;
            	    cascade_parser = permissions_on_resource_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(permissions_on_resource_parser(&s->permissions_to_launch, dot_pos, aa, pa));
            	    s->is_set_permissions_to_launch = 1;
             } else {
                   s->permissions_to_launch_str = aa;
             }
         } else
	if ((aret = strcmp(str, "ProductCodes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ProductCodes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ProductCodes require an index\n");
                      if (s->product_codes) {
                              for (; s->product_codes[last]; ++last);
                      }
                      if (pos < last) {
                              s->product_codes[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->product_codes, "", pa);
                              SET_NEXT(s->product_codes, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ProductCodes argument missing\n");
                     s->product_codes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ProductCodes[]")) || aret == '=') {
               TRY(!aa, "ProductCodes[] argument missing\n");
               SET_NEXT(s->product_codes, (aa), pa);
         } else
	if ((aret = strcmp(str, "RootDeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RootDeviceName argument missing\n");
            s->root_device_name = aa; // string string

         } else
	if ((aret = strcmp(str, "RootDeviceType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RootDeviceType argument missing\n");
            s->root_device_type = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "StateComment")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "StateComment argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->state_comment;
            	    cascade_parser = state_comment_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(state_comment_parser(&s->state_comment, dot_pos, aa, pa));
            	    s->is_set_state_comment = 1;
             } else {
                   s->state_comment_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Image'\n", str);
		return -1;
	}
	return 0;
}

int image_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct image_export_task *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Comment")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Comment argument missing\n");
            s->comment = aa; // string string

         } else
	if ((aret = strcmp(str, "ImageId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ImageId argument missing\n");
            s->image_id = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuExport")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "OsuExport argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->osu_export;
            	    cascade_parser = osu_export_image_export_task_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(osu_export_image_export_task_parser(&s->osu_export, dot_pos, aa, pa));
            	    s->is_set_osu_export = 1;
             } else {
                   s->osu_export_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Progress")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Progress argument missing\n");
            s->is_set_progress = 1;
            s->progress = atoi(aa);
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "TaskId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "TaskId argument missing\n");
            s->task_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ImageExportTask'\n", str);
		return -1;
	}
	return 0;
}

int inline_policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct inline_policy *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Body")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Body argument missing\n");
            s->body = aa; // string string

         } else
	if ((aret = strcmp(str, "Name")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'InlinePolicy'\n", str);
		return -1;
	}
	return 0;
}

int internet_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct internet_service *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "InternetServiceId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "InternetServiceId argument missing\n");
            s->internet_service_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'InternetService'\n", str);
		return -1;
	}
	return 0;
}

int keypair_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct keypair *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "KeypairFingerprint")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "KeypairFingerprint argument missing\n");
            s->keypair_fingerprint = aa; // string string

         } else
	if ((aret = strcmp(str, "KeypairName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "KeypairName argument missing\n");
            s->keypair_name = aa; // string string

         } else
	if ((aret = strcmp(str, "KeypairType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "KeypairType argument missing\n");
            s->keypair_type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Keypair'\n", str);
		return -1;
	}
	return 0;
}

int keypair_created_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct keypair_created *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "KeypairFingerprint")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "KeypairFingerprint argument missing\n");
            s->keypair_fingerprint = aa; // string string

         } else
	if ((aret = strcmp(str, "KeypairName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "KeypairName argument missing\n");
            s->keypair_name = aa; // string string

         } else
	if ((aret = strcmp(str, "KeypairType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "KeypairType argument missing\n");
            s->keypair_type = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateKey")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateKey argument missing\n");
            s->private_key = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'KeypairCreated'\n", str);
		return -1;
	}
	return 0;
}

int link_nic_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_nic *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "DeviceNumber")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DeviceNumber argument missing\n");
            s->is_set_device_number = 1;
            s->device_number = atoi(aa);
         } else
	if ((aret = strcmp(str, "LinkNicId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LinkNicId argument missing\n");
            s->link_nic_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "VmAccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmAccountId argument missing\n");
            s->vm_account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkNic'\n", str);
		return -1;
	}
	return 0;
}

int link_nic_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_nic_light *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "DeviceNumber")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DeviceNumber argument missing\n");
            s->is_set_device_number = 1;
            s->device_number = atoi(aa);
         } else
	if ((aret = strcmp(str, "LinkNicId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LinkNicId argument missing\n");
            s->link_nic_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkNicLight'\n", str);
		return -1;
	}
	return 0;
}

int link_nic_to_update_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_nic_to_update *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkNicId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LinkNicId argument missing\n");
            s->link_nic_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkNicToUpdate'\n", str);
		return -1;
	}
	return 0;
}

int link_public_ip_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_public_ip *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LinkPublicIpId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LinkPublicIpId argument missing\n");
            s->link_public_ip_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicDnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicDnsName argument missing\n");
            s->public_dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIpAccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIpAccountId argument missing\n");
            s->public_ip_account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIpId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIpId argument missing\n");
            s->public_ip_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkPublicIp'\n", str);
		return -1;
	}
	return 0;
}

int link_public_ip_light_for_vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_public_ip_light_for_vm *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "PublicDnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicDnsName argument missing\n");
            s->public_dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIpAccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIpAccountId argument missing\n");
            s->public_ip_account_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkPublicIpLightForVm'\n", str);
		return -1;
	}
	return 0;
}

int link_route_table_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct link_route_table *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LinkRouteTableId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LinkRouteTableId argument missing\n");
            s->link_route_table_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Main")) == 0 || aret == '=' || aret == '.') {
            s->is_set_main = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->main = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->main = 0;
             } else {
            		BAD_RET("Main require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "RouteTableId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RouteTableId argument missing\n");
            s->route_table_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SubnetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkRouteTable'\n", str);
		return -1;
	}
	return 0;
}

int linked_policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct linked_policy *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "LastModificationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LastModificationDate argument missing\n");
            s->last_modification_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Orn")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Orn argument missing\n");
            s->orn = aa; // string string

         } else
	if ((aret = strcmp(str, "PolicyId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PolicyId argument missing\n");
            s->policy_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PolicyName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PolicyName argument missing\n");
            s->policy_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkedPolicy'\n", str);
		return -1;
	}
	return 0;
}

int linked_volume_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct linked_volume *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "DeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DeviceName argument missing\n");
            s->device_name = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VolumeId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LinkedVolume'\n", str);
		return -1;
	}
	return 0;
}

int listener_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct listener *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "BackendPort")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BackendPort argument missing\n");
            s->is_set_backend_port = 1;
            s->backend_port = atoi(aa);
         } else
	if ((aret = strcmp(str, "BackendProtocol")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BackendProtocol argument missing\n");
            s->backend_protocol = aa; // string string

         } else
	if ((aret = strcmp(str, "LoadBalancerPort")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerPort argument missing\n");
            s->is_set_load_balancer_port = 1;
            s->load_balancer_port = atoi(aa);
         } else
	if ((aret = strcmp(str, "LoadBalancerProtocol")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerProtocol argument missing\n");
            s->load_balancer_protocol = aa; // string string

         } else
	if ((aret = strcmp(str, "PolicyNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "PolicyNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "PolicyNames require an index\n");
                      if (s->policy_names) {
                              for (; s->policy_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->policy_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->policy_names, "", pa);
                              SET_NEXT(s->policy_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "PolicyNames argument missing\n");
                     s->policy_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "PolicyNames[]")) || aret == '=') {
               TRY(!aa, "PolicyNames[] argument missing\n");
               SET_NEXT(s->policy_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "ServerCertificateId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ServerCertificateId argument missing\n");
            s->server_certificate_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Listener'\n", str);
		return -1;
	}
	return 0;
}

int listener_for_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct listener_for_creation *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "BackendPort")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BackendPort argument missing\n");
            s->is_set_backend_port = 1;
            s->backend_port = atoi(aa);
         } else
	if ((aret = strcmp(str, "BackendProtocol")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "BackendProtocol argument missing\n");
            s->backend_protocol = aa; // string string

         } else
	if ((aret = strcmp(str, "LoadBalancerPort")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerPort argument missing\n");
            s->is_set_load_balancer_port = 1;
            s->load_balancer_port = atoi(aa);
         } else
	if ((aret = strcmp(str, "LoadBalancerProtocol")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerProtocol argument missing\n");
            s->load_balancer_protocol = aa; // string string

         } else
	if ((aret = strcmp(str, "ServerCertificateId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ServerCertificateId argument missing\n");
            s->server_certificate_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ListenerForCreation'\n", str);
		return -1;
	}
	return 0;
}

int listener_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct listener_rule *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Action")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Action argument missing\n");
            s->action = aa; // string string

         } else
	if ((aret = strcmp(str, "HostNamePattern")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "HostNamePattern argument missing\n");
            s->host_name_pattern = aa; // string string

         } else
	if ((aret = strcmp(str, "ListenerId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ListenerId argument missing\n");
            s->is_set_listener_id = 1;
            s->listener_id = atoi(aa);
         } else
	if ((aret = strcmp(str, "ListenerRuleId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ListenerRuleId argument missing\n");
            s->is_set_listener_rule_id = 1;
            s->listener_rule_id = atoi(aa);
         } else
	if ((aret = strcmp(str, "ListenerRuleName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ListenerRuleName argument missing\n");
            s->listener_rule_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PathPattern")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PathPattern argument missing\n");
            s->path_pattern = aa; // string string

         } else
	if ((aret = strcmp(str, "Priority")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Priority argument missing\n");
            s->is_set_priority = 1;
            s->priority = atoi(aa);
         } else
	if ((aret = strcmp(str, "VmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmIds require an index\n");
                      if (s->vm_ids) {
                              for (; s->vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_ids, "", pa);
                              SET_NEXT(s->vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmIds argument missing\n");
                     s->vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ListenerRule'\n", str);
		return -1;
	}
	return 0;
}

int listener_rule_for_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct listener_rule_for_creation *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Action")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Action argument missing\n");
            s->action = aa; // string string

         } else
	if ((aret = strcmp(str, "HostNamePattern")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "HostNamePattern argument missing\n");
            s->host_name_pattern = aa; // string string

         } else
	if ((aret = strcmp(str, "ListenerRuleName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ListenerRuleName argument missing\n");
            s->listener_rule_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PathPattern")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PathPattern argument missing\n");
            s->path_pattern = aa; // string string

         } else
	if ((aret = strcmp(str, "Priority")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Priority argument missing\n");
            s->is_set_priority = 1;
            s->priority = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ListenerRuleForCreation'\n", str);
		return -1;
	}
	return 0;
}

int load_balancer_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct load_balancer *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccessLog")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "AccessLog argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->access_log;
            	    cascade_parser = access_log_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(access_log_parser(&s->access_log, dot_pos, aa, pa));
            	    s->is_set_access_log = 1;
             } else {
                   s->access_log_str = aa;
             }
         } else
	if ((aret = strcmp(str, "ApplicationStickyCookiePolicies")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'ApplicationStickyCookiePolicies' require an index (example array ref ApplicationStickyCookiePolicy.ApplicationStickyCookiePolicies.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'ApplicationStickyCookiePolicies' require a .\n");
            	      TRY_ALLOC_AT(s,application_sticky_cookie_policies, pa, pos, sizeof(*s->application_sticky_cookie_policies));
            	      cascade_struct = &s->application_sticky_cookie_policies[pos];
            	      cascade_parser = application_sticky_cookie_policy_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(application_sticky_cookie_policy_parser(&s->application_sticky_cookie_policies[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "ApplicationStickyCookiePolicies argument missing\n");
            	s->application_sticky_cookie_policies_str = aa; // array ref ApplicationStickyCookiePolicy ref
            }
         } else
	if ((aret = strcmp(str, "BackendIps")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BackendIps argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BackendIps require an index\n");
                      if (s->backend_ips) {
                              for (; s->backend_ips[last]; ++last);
                      }
                      if (pos < last) {
                              s->backend_ips[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->backend_ips, "", pa);
                              SET_NEXT(s->backend_ips, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BackendIps argument missing\n");
                     s->backend_ips_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BackendIps[]")) || aret == '=') {
               TRY(!aa, "BackendIps[] argument missing\n");
               SET_NEXT(s->backend_ips, (aa), pa);
         } else
	if ((aret = strcmp(str, "BackendVmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "BackendVmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "BackendVmIds require an index\n");
                      if (s->backend_vm_ids) {
                              for (; s->backend_vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->backend_vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->backend_vm_ids, "", pa);
                              SET_NEXT(s->backend_vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "BackendVmIds argument missing\n");
                     s->backend_vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "BackendVmIds[]")) || aret == '=') {
               TRY(!aa, "BackendVmIds[] argument missing\n");
               SET_NEXT(s->backend_vm_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "DnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DnsName argument missing\n");
            s->dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "HealthCheck")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "HealthCheck argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->health_check;
            	    cascade_parser = health_check_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(health_check_parser(&s->health_check, dot_pos, aa, pa));
            	    s->is_set_health_check = 1;
             } else {
                   s->health_check_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Listeners")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Listeners' require an index (example array ref Listener.Listeners.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Listeners' require a .\n");
            	      TRY_ALLOC_AT(s,listeners, pa, pos, sizeof(*s->listeners));
            	      cascade_struct = &s->listeners[pos];
            	      cascade_parser = listener_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(listener_parser(&s->listeners[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Listeners argument missing\n");
            	s->listeners_str = aa; // array ref Listener ref
            }
         } else
	if ((aret = strcmp(str, "LoadBalancerName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerName argument missing\n");
            s->load_balancer_name = aa; // string string

         } else
	if ((aret = strcmp(str, "LoadBalancerStickyCookiePolicies")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'LoadBalancerStickyCookiePolicies' require an index (example array ref LoadBalancerStickyCookiePolicy.LoadBalancerStickyCookiePolicies.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'LoadBalancerStickyCookiePolicies' require a .\n");
            	      TRY_ALLOC_AT(s,load_balancer_sticky_cookie_policies, pa, pos, sizeof(*s->load_balancer_sticky_cookie_policies));
            	      cascade_struct = &s->load_balancer_sticky_cookie_policies[pos];
            	      cascade_parser = load_balancer_sticky_cookie_policy_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(load_balancer_sticky_cookie_policy_parser(&s->load_balancer_sticky_cookie_policies[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "LoadBalancerStickyCookiePolicies argument missing\n");
            	s->load_balancer_sticky_cookie_policies_str = aa; // array ref LoadBalancerStickyCookiePolicy ref
            }
         } else
	if ((aret = strcmp(str, "LoadBalancerType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerType argument missing\n");
            s->load_balancer_type = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "SecuredCookies")) == 0 || aret == '=' || aret == '.') {
            s->is_set_secured_cookies = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->secured_cookies = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->secured_cookies = 0;
             } else {
            		BAD_RET("SecuredCookies require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "SecurityGroups")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroups argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroups require an index\n");
                      if (s->security_groups) {
                              for (; s->security_groups[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_groups[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_groups, "", pa);
                              SET_NEXT(s->security_groups, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroups argument missing\n");
                     s->security_groups_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroups[]")) || aret == '=') {
               TRY(!aa, "SecurityGroups[] argument missing\n");
               SET_NEXT(s->security_groups, (aa), pa);
         } else
	if ((aret = strcmp(str, "SourceSecurityGroup")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "SourceSecurityGroup argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->source_security_group;
            	    cascade_parser = source_security_group_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(source_security_group_parser(&s->source_security_group, dot_pos, aa, pa));
            	    s->is_set_source_security_group = 1;
             } else {
                   s->source_security_group_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Subnets")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Subnets argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Subnets require an index\n");
                      if (s->subnets) {
                              for (; s->subnets[last]; ++last);
                      }
                      if (pos < last) {
                              s->subnets[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subnets, "", pa);
                              SET_NEXT(s->subnets, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Subnets argument missing\n");
                     s->subnets_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Subnets[]")) || aret == '=') {
               TRY(!aa, "Subnets[] argument missing\n");
               SET_NEXT(s->subnets, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubregionNames")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SubregionNames argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SubregionNames require an index\n");
                      if (s->subregion_names) {
                              for (; s->subregion_names[last]; ++last);
                      }
                      if (pos < last) {
                              s->subregion_names[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->subregion_names, "", pa);
                              SET_NEXT(s->subregion_names, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SubregionNames argument missing\n");
                     s->subregion_names_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
               TRY(!aa, "SubregionNames[] argument missing\n");
               SET_NEXT(s->subregion_names, (aa), pa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LoadBalancer'\n", str);
		return -1;
	}
	return 0;
}

int load_balancer_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct load_balancer_light *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LoadBalancerName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerName argument missing\n");
            s->load_balancer_name = aa; // string string

         } else
	if ((aret = strcmp(str, "LoadBalancerPort")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerPort argument missing\n");
            s->is_set_load_balancer_port = 1;
            s->load_balancer_port = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LoadBalancerLight'\n", str);
		return -1;
	}
	return 0;
}

int load_balancer_sticky_cookie_policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct load_balancer_sticky_cookie_policy *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CookieExpirationPeriod")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CookieExpirationPeriod argument missing\n");
            s->is_set_cookie_expiration_period = 1;
            s->cookie_expiration_period = atoi(aa);
         } else
	if ((aret = strcmp(str, "PolicyName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PolicyName argument missing\n");
            s->policy_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LoadBalancerStickyCookiePolicy'\n", str);
		return -1;
	}
	return 0;
}

int load_balancer_tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct load_balancer_tag *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Key")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Key argument missing\n");
            s->key = aa; // string string

         } else
	if ((aret = strcmp(str, "LoadBalancerName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LoadBalancerName argument missing\n");
            s->load_balancer_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Value")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Value argument missing\n");
            s->value = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'LoadBalancerTag'\n", str);
		return -1;
	}
	return 0;
}

int location_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct location *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Code")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Code argument missing\n");
            s->code = aa; // string string

         } else
	if ((aret = strcmp(str, "Name")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Location'\n", str);
		return -1;
	}
	return 0;
}

int log_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct log *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "CallDuration")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CallDuration argument missing\n");
            s->is_set_call_duration = 1;
            s->call_duration = atoi(aa);
         } else
	if ((aret = strcmp(str, "QueryAccessKey")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryAccessKey argument missing\n");
            s->query_access_key = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryApiName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryApiName argument missing\n");
            s->query_api_name = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryApiVersion")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryApiVersion argument missing\n");
            s->query_api_version = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryCallName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryCallName argument missing\n");
            s->query_call_name = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryDate argument missing\n");
            s->query_date = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryHeaderRaw")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryHeaderRaw argument missing\n");
            s->query_header_raw = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryHeaderSize")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryHeaderSize argument missing\n");
            s->is_set_query_header_size = 1;
            s->query_header_size = atoi(aa);
         } else
	if ((aret = strcmp(str, "QueryIpAddress")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryIpAddress argument missing\n");
            s->query_ip_address = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryPayloadRaw")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryPayloadRaw argument missing\n");
            s->query_payload_raw = aa; // string string

         } else
	if ((aret = strcmp(str, "QueryPayloadSize")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryPayloadSize argument missing\n");
            s->is_set_query_payload_size = 1;
            s->query_payload_size = atoi(aa);
         } else
	if ((aret = strcmp(str, "QueryUserAgent")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QueryUserAgent argument missing\n");
            s->query_user_agent = aa; // string string

         } else
	if ((aret = strcmp(str, "RequestId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RequestId argument missing\n");
            s->request_id = aa; // string string

         } else
	if ((aret = strcmp(str, "ResponseSize")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ResponseSize argument missing\n");
            s->is_set_response_size = 1;
            s->response_size = atoi(aa);
         } else
	if ((aret = strcmp(str, "ResponseStatusCode")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ResponseStatusCode argument missing\n");
            s->is_set_response_status_code = 1;
            s->response_status_code = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Log'\n", str);
		return -1;
	}
	return 0;
}

int maintenance_event_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct maintenance_event *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Code")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Code argument missing\n");
            s->code = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "NotAfter")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NotAfter argument missing\n");
            s->not_after = aa; // string string

         } else
	if ((aret = strcmp(str, "NotBefore")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NotBefore argument missing\n");
            s->not_before = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'MaintenanceEvent'\n", str);
		return -1;
	}
	return 0;
}

int nat_service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct nat_service *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ClientToken")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ClientToken argument missing\n");
            s->client_token = aa; // string string

         } else
	if ((aret = strcmp(str, "NatServiceId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NatServiceId argument missing\n");
            s->nat_service_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIps")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'PublicIps' require an index (example array ref PublicIpLight.PublicIps.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'PublicIps' require a .\n");
            	      TRY_ALLOC_AT(s,public_ips, pa, pos, sizeof(*s->public_ips));
            	      cascade_struct = &s->public_ips[pos];
            	      cascade_parser = public_ip_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(public_ip_light_parser(&s->public_ips[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "PublicIps argument missing\n");
            	s->public_ips_str = aa; // array ref PublicIpLight ref
            }
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "SubnetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NatService'\n", str);
		return -1;
	}
	return 0;
}

int net_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DhcpOptionsSetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DhcpOptionsSetId argument missing\n");
            s->dhcp_options_set_id = aa; // string string

         } else
	if ((aret = strcmp(str, "IpRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "IpRange argument missing\n");
            s->ip_range = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "Tenancy")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Tenancy argument missing\n");
            s->tenancy = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Net'\n", str);
		return -1;
	}
	return 0;
}

int net_access_point_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net_access_point *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "NetAccessPointId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetAccessPointId argument missing\n");
            s->net_access_point_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "RouteTableIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "RouteTableIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "RouteTableIds require an index\n");
                      if (s->route_table_ids) {
                              for (; s->route_table_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->route_table_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->route_table_ids, "", pa);
                              SET_NEXT(s->route_table_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "RouteTableIds argument missing\n");
                     s->route_table_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "RouteTableIds[]")) || aret == '=') {
               TRY(!aa, "RouteTableIds[] argument missing\n");
               SET_NEXT(s->route_table_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ServiceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ServiceName argument missing\n");
            s->service_name = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NetAccessPoint'\n", str);
		return -1;
	}
	return 0;
}

int net_peering_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net_peering *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccepterNet")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "AccepterNet argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->accepter_net;
            	    cascade_parser = accepter_net_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(accepter_net_parser(&s->accepter_net, dot_pos, aa, pa));
            	    s->is_set_accepter_net = 1;
             } else {
                   s->accepter_net_str = aa;
             }
         } else
	if ((aret = strcmp(str, "ExpirationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ExpirationDate argument missing\n");
            s->expiration_date = aa; // string string

         } else
	if ((aret = strcmp(str, "NetPeeringId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetPeeringId argument missing\n");
            s->net_peering_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SourceNet")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "SourceNet argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->source_net;
            	    cascade_parser = source_net_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(source_net_parser(&s->source_net, dot_pos, aa, pa));
            	    s->is_set_source_net = 1;
             } else {
                   s->source_net_str = aa;
             }
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "State argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->state;
            	    cascade_parser = net_peering_state_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(net_peering_state_parser(&s->state, dot_pos, aa, pa));
            	    s->is_set_state = 1;
             } else {
                   s->state_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NetPeering'\n", str);
		return -1;
	}
	return 0;
}

int net_peering_state_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net_peering_state *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Message")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Message argument missing\n");
            s->message = aa; // string string

         } else
	if ((aret = strcmp(str, "Name")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NetPeeringState'\n", str);
		return -1;
	}
	return 0;
}

int net_to_virtual_gateway_link_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct net_to_virtual_gateway_link *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NetToVirtualGatewayLink'\n", str);
		return -1;
	}
	return 0;
}

int nic_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct nic *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "IsSourceDestChecked")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_source_dest_checked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_checked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_checked = 0;
             } else {
            		BAD_RET("IsSourceDestChecked require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkNic")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "LinkNic argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_nic;
            	    cascade_parser = link_nic_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(link_nic_parser(&s->link_nic, dot_pos, aa, pa));
            	    s->is_set_link_nic = 1;
             } else {
                   s->link_nic_str = aa;
             }
         } else
	if ((aret = strcmp(str, "LinkPublicIp")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "LinkPublicIp argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_public_ip;
            	    cascade_parser = link_public_ip_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(link_public_ip_parser(&s->link_public_ip, dot_pos, aa, pa));
            	    s->is_set_link_public_ip = 1;
             } else {
                   s->link_public_ip_str = aa;
             }
         } else
	if ((aret = strcmp(str, "MacAddress")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MacAddress argument missing\n");
            s->mac_address = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NicId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateDnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateIps")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'PrivateIps' require an index (example array ref PrivateIp.PrivateIps.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'PrivateIps' require a .\n");
            	      TRY_ALLOC_AT(s,private_ips, pa, pos, sizeof(*s->private_ips));
            	      cascade_struct = &s->private_ips[pos];
            	      cascade_parser = private_ip_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(private_ip_parser(&s->private_ips[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "PrivateIps argument missing\n");
            	s->private_ips_str = aa; // array ref PrivateIp ref
            }
         } else
	if ((aret = strcmp(str, "SecurityGroups")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'SecurityGroups' require an index (example array ref SecurityGroupLight.SecurityGroups.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'SecurityGroups' require a .\n");
            	      TRY_ALLOC_AT(s,security_groups, pa, pos, sizeof(*s->security_groups));
            	      cascade_struct = &s->security_groups[pos];
            	      cascade_parser = security_group_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(security_group_light_parser(&s->security_groups[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "SecurityGroups argument missing\n");
            	s->security_groups_str = aa; // array ref SecurityGroupLight ref
            }
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "SubnetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Nic'\n", str);
		return -1;
	}
	return 0;
}

int nic_for_vm_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct nic_for_vm_creation *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DeleteOnVmDeletion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_delete_on_vm_deletion = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->delete_on_vm_deletion = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->delete_on_vm_deletion = 0;
             } else {
            		BAD_RET("DeleteOnVmDeletion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "DeviceNumber")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DeviceNumber argument missing\n");
            s->is_set_device_number = 1;
            s->device_number = atoi(aa);
         } else
	if ((aret = strcmp(str, "NicId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateIps")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'PrivateIps' require an index (example array ref PrivateIpLight.PrivateIps.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'PrivateIps' require a .\n");
            	      TRY_ALLOC_AT(s,private_ips, pa, pos, sizeof(*s->private_ips));
            	      cascade_struct = &s->private_ips[pos];
            	      cascade_parser = private_ip_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(private_ip_light_parser(&s->private_ips[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "PrivateIps argument missing\n");
            	s->private_ips_str = aa; // array ref PrivateIpLight ref
            }
         } else
	if ((aret = strcmp(str, "SecondaryPrivateIpCount")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecondaryPrivateIpCount argument missing\n");
            s->is_set_secondary_private_ip_count = 1;
            s->secondary_private_ip_count = atoi(aa);
         } else
	if ((aret = strcmp(str, "SecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
                      if (s->security_group_ids) {
                              for (; s->security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_ids, "", pa);
                              SET_NEXT(s->security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupIds argument missing\n");
                     s->security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "SubnetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NicForVmCreation'\n", str);
		return -1;
	}
	return 0;
}

int nic_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct nic_light *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "IsSourceDestChecked")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_source_dest_checked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_checked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_checked = 0;
             } else {
            		BAD_RET("IsSourceDestChecked require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkNic")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "LinkNic argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_nic;
            	    cascade_parser = link_nic_light_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(link_nic_light_parser(&s->link_nic, dot_pos, aa, pa));
            	    s->is_set_link_nic = 1;
             } else {
                   s->link_nic_str = aa;
             }
         } else
	if ((aret = strcmp(str, "LinkPublicIp")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "LinkPublicIp argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_public_ip;
            	    cascade_parser = link_public_ip_light_for_vm_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(link_public_ip_light_for_vm_parser(&s->link_public_ip, dot_pos, aa, pa));
            	    s->is_set_link_public_ip = 1;
             } else {
                   s->link_public_ip_str = aa;
             }
         } else
	if ((aret = strcmp(str, "MacAddress")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MacAddress argument missing\n");
            s->mac_address = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NicId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateDnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateIps")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'PrivateIps' require an index (example array ref PrivateIpLightForVm.PrivateIps.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'PrivateIps' require a .\n");
            	      TRY_ALLOC_AT(s,private_ips, pa, pos, sizeof(*s->private_ips));
            	      cascade_struct = &s->private_ips[pos];
            	      cascade_parser = private_ip_light_for_vm_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(private_ip_light_for_vm_parser(&s->private_ips[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "PrivateIps argument missing\n");
            	s->private_ips_str = aa; // array ref PrivateIpLightForVm ref
            }
         } else
	if ((aret = strcmp(str, "SecurityGroups")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'SecurityGroups' require an index (example array ref SecurityGroupLight.SecurityGroups.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'SecurityGroups' require a .\n");
            	      TRY_ALLOC_AT(s,security_groups, pa, pos, sizeof(*s->security_groups));
            	      cascade_struct = &s->security_groups[pos];
            	      cascade_parser = security_group_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(security_group_light_parser(&s->security_groups[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "SecurityGroups argument missing\n");
            	s->security_groups_str = aa; // array ref SecurityGroupLight ref
            }
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "SubnetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'NicLight'\n", str);
		return -1;
	}
	return 0;
}

int osu_api_key_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct osu_api_key *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ApiKeyId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ApiKeyId argument missing\n");
            s->api_key_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SecretKey")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecretKey argument missing\n");
            s->secret_key = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'OsuApiKey'\n", str);
		return -1;
	}
	return 0;
}

int osu_export_image_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct osu_export_image_export_task *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DiskImageFormat")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DiskImageFormat argument missing\n");
            s->disk_image_format = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuBucket")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuBucket argument missing\n");
            s->osu_bucket = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuManifestUrl")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuManifestUrl argument missing\n");
            s->osu_manifest_url = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuPrefix")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuPrefix argument missing\n");
            s->osu_prefix = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'OsuExportImageExportTask'\n", str);
		return -1;
	}
	return 0;
}

int osu_export_snapshot_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct osu_export_snapshot_export_task *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DiskImageFormat")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DiskImageFormat argument missing\n");
            s->disk_image_format = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuBucket")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuBucket argument missing\n");
            s->osu_bucket = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuPrefix")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuPrefix argument missing\n");
            s->osu_prefix = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'OsuExportSnapshotExportTask'\n", str);
		return -1;
	}
	return 0;
}

int osu_export_to_create_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct osu_export_to_create *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DiskImageFormat")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DiskImageFormat argument missing\n");
            s->disk_image_format = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuApiKey")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "OsuApiKey argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->osu_api_key;
            	    cascade_parser = osu_api_key_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(osu_api_key_parser(&s->osu_api_key, dot_pos, aa, pa));
            	    s->is_set_osu_api_key = 1;
             } else {
                   s->osu_api_key_str = aa;
             }
         } else
	if ((aret = strcmp(str, "OsuBucket")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuBucket argument missing\n");
            s->osu_bucket = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuManifestUrl")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuManifestUrl argument missing\n");
            s->osu_manifest_url = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuPrefix")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsuPrefix argument missing\n");
            s->osu_prefix = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'OsuExportToCreate'\n", str);
		return -1;
	}
	return 0;
}

int permissions_on_resource_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct permissions_on_resource *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "AccountIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "AccountIds require an index\n");
                      if (s->account_ids) {
                              for (; s->account_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->account_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->account_ids, "", pa);
                              SET_NEXT(s->account_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "AccountIds argument missing\n");
                     s->account_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "AccountIds[]")) || aret == '=') {
               TRY(!aa, "AccountIds[] argument missing\n");
               SET_NEXT(s->account_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "GlobalPermission")) == 0 || aret == '=' || aret == '.') {
            s->is_set_global_permission = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->global_permission = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->global_permission = 0;
             } else {
            		BAD_RET("GlobalPermission require true/false\n");
             }
        } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PermissionsOnResource'\n", str);
		return -1;
	}
	return 0;
}

int permissions_on_resource_creation_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct permissions_on_resource_creation *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Additions")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Additions argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->additions;
            	    cascade_parser = permissions_on_resource_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(permissions_on_resource_parser(&s->additions, dot_pos, aa, pa));
            	    s->is_set_additions = 1;
             } else {
                   s->additions_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Removals")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Removals argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->removals;
            	    cascade_parser = permissions_on_resource_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(permissions_on_resource_parser(&s->removals, dot_pos, aa, pa));
            	    s->is_set_removals = 1;
             } else {
                   s->removals_str = aa;
             }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PermissionsOnResourceCreation'\n", str);
		return -1;
	}
	return 0;
}

int phase1_options_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct phase1_options *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DpdTimeoutAction")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DpdTimeoutAction argument missing\n");
            s->dpd_timeout_action = aa; // string string

         } else
	if ((aret = strcmp(str, "DpdTimeoutSeconds")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DpdTimeoutSeconds argument missing\n");
            s->is_set_dpd_timeout_seconds = 1;
            s->dpd_timeout_seconds = atoi(aa);
         } else
	if ((aret = strcmp(str, "IkeVersions")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "IkeVersions argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "IkeVersions require an index\n");
                      if (s->ike_versions) {
                              for (; s->ike_versions[last]; ++last);
                      }
                      if (pos < last) {
                              s->ike_versions[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ike_versions, "", pa);
                              SET_NEXT(s->ike_versions, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "IkeVersions argument missing\n");
                     s->ike_versions_str = aa;
                 }
         } else if (!(aret = strcmp(str, "IkeVersions[]")) || aret == '=') {
               TRY(!aa, "IkeVersions[] argument missing\n");
               SET_NEXT(s->ike_versions, (aa), pa);
         } else
	if ((aret = strcmp(str, "Phase1DhGroupNumbers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Phase1DhGroupNumbers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Phase1DhGroupNumbers require an index\n");
                      if (s->phase1_dh_group_numbers) {
                              for (; s->phase1_dh_group_numbers[last]; ++last);
                      }
                      if (pos < last) {
                              s->phase1_dh_group_numbers[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->phase1_dh_group_numbers, 0, pa);
                              SET_NEXT(s->phase1_dh_group_numbers, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Phase1DhGroupNumbers argument missing\n");
                     s->phase1_dh_group_numbers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Phase1DhGroupNumbers[]")) || aret == '=') {
               TRY(!aa, "Phase1DhGroupNumbers[] argument missing\n");
               SET_NEXT(s->phase1_dh_group_numbers, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "Phase1EncryptionAlgorithms")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Phase1EncryptionAlgorithms argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Phase1EncryptionAlgorithms require an index\n");
                      if (s->phase1_encryption_algorithms) {
                              for (; s->phase1_encryption_algorithms[last]; ++last);
                      }
                      if (pos < last) {
                              s->phase1_encryption_algorithms[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->phase1_encryption_algorithms, "", pa);
                              SET_NEXT(s->phase1_encryption_algorithms, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Phase1EncryptionAlgorithms argument missing\n");
                     s->phase1_encryption_algorithms_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Phase1EncryptionAlgorithms[]")) || aret == '=') {
               TRY(!aa, "Phase1EncryptionAlgorithms[] argument missing\n");
               SET_NEXT(s->phase1_encryption_algorithms, (aa), pa);
         } else
	if ((aret = strcmp(str, "Phase1IntegrityAlgorithms")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Phase1IntegrityAlgorithms argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Phase1IntegrityAlgorithms require an index\n");
                      if (s->phase1_integrity_algorithms) {
                              for (; s->phase1_integrity_algorithms[last]; ++last);
                      }
                      if (pos < last) {
                              s->phase1_integrity_algorithms[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->phase1_integrity_algorithms, "", pa);
                              SET_NEXT(s->phase1_integrity_algorithms, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Phase1IntegrityAlgorithms argument missing\n");
                     s->phase1_integrity_algorithms_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Phase1IntegrityAlgorithms[]")) || aret == '=') {
               TRY(!aa, "Phase1IntegrityAlgorithms[] argument missing\n");
               SET_NEXT(s->phase1_integrity_algorithms, (aa), pa);
         } else
	if ((aret = strcmp(str, "Phase1LifetimeSeconds")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Phase1LifetimeSeconds argument missing\n");
            s->is_set_phase1_lifetime_seconds = 1;
            s->phase1_lifetime_seconds = atoi(aa);
         } else
	if ((aret = strcmp(str, "ReplayWindowSize")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ReplayWindowSize argument missing\n");
            s->is_set_replay_window_size = 1;
            s->replay_window_size = atoi(aa);
         } else
	if ((aret = strcmp(str, "StartupAction")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "StartupAction argument missing\n");
            s->startup_action = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Phase1Options'\n", str);
		return -1;
	}
	return 0;
}

int phase2_options_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct phase2_options *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Phase2DhGroupNumbers")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Phase2DhGroupNumbers argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Phase2DhGroupNumbers require an index\n");
                      if (s->phase2_dh_group_numbers) {
                              for (; s->phase2_dh_group_numbers[last]; ++last);
                      }
                      if (pos < last) {
                              s->phase2_dh_group_numbers[pos] = atoi(aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->phase2_dh_group_numbers, 0, pa);
                              SET_NEXT(s->phase2_dh_group_numbers, atoi(aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Phase2DhGroupNumbers argument missing\n");
                     s->phase2_dh_group_numbers_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Phase2DhGroupNumbers[]")) || aret == '=') {
               TRY(!aa, "Phase2DhGroupNumbers[] argument missing\n");
               SET_NEXT(s->phase2_dh_group_numbers, atoi(aa), pa);
         } else
	if ((aret = strcmp(str, "Phase2EncryptionAlgorithms")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Phase2EncryptionAlgorithms argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Phase2EncryptionAlgorithms require an index\n");
                      if (s->phase2_encryption_algorithms) {
                              for (; s->phase2_encryption_algorithms[last]; ++last);
                      }
                      if (pos < last) {
                              s->phase2_encryption_algorithms[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->phase2_encryption_algorithms, "", pa);
                              SET_NEXT(s->phase2_encryption_algorithms, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Phase2EncryptionAlgorithms argument missing\n");
                     s->phase2_encryption_algorithms_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Phase2EncryptionAlgorithms[]")) || aret == '=') {
               TRY(!aa, "Phase2EncryptionAlgorithms[] argument missing\n");
               SET_NEXT(s->phase2_encryption_algorithms, (aa), pa);
         } else
	if ((aret = strcmp(str, "Phase2IntegrityAlgorithms")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "Phase2IntegrityAlgorithms argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "Phase2IntegrityAlgorithms require an index\n");
                      if (s->phase2_integrity_algorithms) {
                              for (; s->phase2_integrity_algorithms[last]; ++last);
                      }
                      if (pos < last) {
                              s->phase2_integrity_algorithms[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->phase2_integrity_algorithms, "", pa);
                              SET_NEXT(s->phase2_integrity_algorithms, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "Phase2IntegrityAlgorithms argument missing\n");
                     s->phase2_integrity_algorithms_str = aa;
                 }
         } else if (!(aret = strcmp(str, "Phase2IntegrityAlgorithms[]")) || aret == '=') {
               TRY(!aa, "Phase2IntegrityAlgorithms[] argument missing\n");
               SET_NEXT(s->phase2_integrity_algorithms, (aa), pa);
         } else
	if ((aret = strcmp(str, "Phase2LifetimeSeconds")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Phase2LifetimeSeconds argument missing\n");
            s->is_set_phase2_lifetime_seconds = 1;
            s->phase2_lifetime_seconds = atoi(aa);
         } else
	if ((aret = strcmp(str, "PreSharedKey")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PreSharedKey argument missing\n");
            s->pre_shared_key = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Phase2Options'\n", str);
		return -1;
	}
	return 0;
}

int placement_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct placement *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Tenancy")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Tenancy argument missing\n");
            s->tenancy = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Placement'\n", str);
		return -1;
	}
	return 0;
}

int policy_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct policy *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "IsLinkable")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_linkable = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_linkable = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_linkable = 0;
             } else {
            		BAD_RET("IsLinkable require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LastModificationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LastModificationDate argument missing\n");
            s->last_modification_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Orn")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Orn argument missing\n");
            s->orn = aa; // string string

         } else
	if ((aret = strcmp(str, "Path")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Path argument missing\n");
            s->path = aa; // string string

         } else
	if ((aret = strcmp(str, "PolicyDefaultVersionId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PolicyDefaultVersionId argument missing\n");
            s->policy_default_version_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PolicyId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PolicyId argument missing\n");
            s->policy_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PolicyName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PolicyName argument missing\n");
            s->policy_name = aa; // string string

         } else
	if ((aret = strcmp(str, "ResourcesCount")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ResourcesCount argument missing\n");
            s->is_set_resources_count = 1;
            s->resources_count = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Policy'\n", str);
		return -1;
	}
	return 0;
}

int policy_version_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct policy_version *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Body")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Body argument missing\n");
            s->body = aa; // string string

         } else
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "DefaultVersion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_default_version = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->default_version = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->default_version = 0;
             } else {
            		BAD_RET("DefaultVersion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "VersionId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VersionId argument missing\n");
            s->version_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PolicyVersion'\n", str);
		return -1;
	}
	return 0;
}

int private_ip_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct private_ip *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "IsPrimary")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_primary = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_primary = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_primary = 0;
             } else {
            		BAD_RET("IsPrimary require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkPublicIp")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "LinkPublicIp argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_public_ip;
            	    cascade_parser = link_public_ip_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(link_public_ip_parser(&s->link_public_ip, dot_pos, aa, pa));
            	    s->is_set_link_public_ip = 1;
             } else {
                   s->link_public_ip_str = aa;
             }
         } else
	if ((aret = strcmp(str, "PrivateDnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PrivateIp'\n", str);
		return -1;
	}
	return 0;
}

int private_ip_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct private_ip_light *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "IsPrimary")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_primary = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_primary = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_primary = 0;
             } else {
            		BAD_RET("IsPrimary require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "PrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PrivateIpLight'\n", str);
		return -1;
	}
	return 0;
}

int private_ip_light_for_vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct private_ip_light_for_vm *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "IsPrimary")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_primary = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_primary = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_primary = 0;
             } else {
            		BAD_RET("IsPrimary require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "LinkPublicIp")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "LinkPublicIp argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->link_public_ip;
            	    cascade_parser = link_public_ip_light_for_vm_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(link_public_ip_light_for_vm_parser(&s->link_public_ip, dot_pos, aa, pa));
            	    s->is_set_link_public_ip = 1;
             } else {
                   s->link_public_ip_str = aa;
             }
         } else
	if ((aret = strcmp(str, "PrivateDnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PrivateIpLightForVm'\n", str);
		return -1;
	}
	return 0;
}

int product_type_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct product_type *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "ProductTypeId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ProductTypeId argument missing\n");
            s->product_type_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Vendor")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Vendor argument missing\n");
            s->vendor = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ProductType'\n", str);
		return -1;
	}
	return 0;
}

int public_ip_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct public_ip *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LinkPublicIpId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LinkPublicIpId argument missing\n");
            s->link_public_ip_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NicAccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NicAccountId argument missing\n");
            s->nic_account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NicId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIpId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIpId argument missing\n");
            s->public_ip_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PublicIp'\n", str);
		return -1;
	}
	return 0;
}

int public_ip_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct public_ip_light *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "PublicIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIpId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIpId argument missing\n");
            s->public_ip_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'PublicIpLight'\n", str);
		return -1;
	}
	return 0;
}

int quota_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct quota *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "MaxValue")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MaxValue argument missing\n");
            s->is_set_max_value = 1;
            s->max_value = atoi(aa);
         } else
	if ((aret = strcmp(str, "Name")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	if ((aret = strcmp(str, "QuotaCollection")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QuotaCollection argument missing\n");
            s->quota_collection = aa; // string string

         } else
	if ((aret = strcmp(str, "ShortDescription")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ShortDescription argument missing\n");
            s->short_description = aa; // string string

         } else
	if ((aret = strcmp(str, "UsedValue")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UsedValue argument missing\n");
            s->is_set_used_value = 1;
            s->used_value = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Quota'\n", str);
		return -1;
	}
	return 0;
}

int quota_types_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct quota_types *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "QuotaType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "QuotaType argument missing\n");
            s->quota_type = aa; // string string

         } else
	if ((aret = strcmp(str, "Quotas")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Quotas' require an index (example array ref Quota.Quotas.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Quotas' require a .\n");
            	      TRY_ALLOC_AT(s,quotas, pa, pos, sizeof(*s->quotas));
            	      cascade_struct = &s->quotas[pos];
            	      cascade_parser = quota_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(quota_parser(&s->quotas[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Quotas argument missing\n");
            	s->quotas_str = aa; // array ref Quota ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'QuotaTypes'\n", str);
		return -1;
	}
	return 0;
}

int read_linked_policies_filters_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct read_linked_policies_filters *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "PathPrefix")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PathPrefix argument missing\n");
            s->path_prefix = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ReadLinkedPoliciesFilters'\n", str);
		return -1;
	}
	return 0;
}

int read_policies_filters_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct read_policies_filters *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "OnlyLinked")) == 0 || aret == '=' || aret == '.') {
            s->is_set_only_linked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->only_linked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->only_linked = 0;
             } else {
            		BAD_RET("OnlyLinked require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "PathPrefix")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PathPrefix argument missing\n");
            s->path_prefix = aa; // string string

         } else
	if ((aret = strcmp(str, "Scope")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Scope argument missing\n");
            s->scope = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ReadPoliciesFilters'\n", str);
		return -1;
	}
	return 0;
}

int region_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct region *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Endpoint")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Endpoint argument missing\n");
            s->endpoint = aa; // string string

         } else
	if ((aret = strcmp(str, "RegionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RegionName argument missing\n");
            s->region_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Region'\n", str);
		return -1;
	}
	return 0;
}

int resource_load_balancer_tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct resource_load_balancer_tag *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Key")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Key argument missing\n");
            s->key = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ResourceLoadBalancerTag'\n", str);
		return -1;
	}
	return 0;
}

int resource_tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct resource_tag *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Key")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Key argument missing\n");
            s->key = aa; // string string

         } else
	if ((aret = strcmp(str, "Value")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Value argument missing\n");
            s->value = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ResourceTag'\n", str);
		return -1;
	}
	return 0;
}

int route_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct route *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CreationMethod")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationMethod argument missing\n");
            s->creation_method = aa; // string string

         } else
	if ((aret = strcmp(str, "DestinationIpRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DestinationIpRange argument missing\n");
            s->destination_ip_range = aa; // string string

         } else
	if ((aret = strcmp(str, "DestinationServiceId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DestinationServiceId argument missing\n");
            s->destination_service_id = aa; // string string

         } else
	if ((aret = strcmp(str, "GatewayId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "GatewayId argument missing\n");
            s->gateway_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NatServiceId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NatServiceId argument missing\n");
            s->nat_service_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NetAccessPointId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetAccessPointId argument missing\n");
            s->net_access_point_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NetPeeringId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetPeeringId argument missing\n");
            s->net_peering_id = aa; // string string

         } else
	if ((aret = strcmp(str, "NicId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NicId argument missing\n");
            s->nic_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "VmAccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmAccountId argument missing\n");
            s->vm_account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Route'\n", str);
		return -1;
	}
	return 0;
}

int route_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct route_light *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "DestinationIpRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "DestinationIpRange argument missing\n");
            s->destination_ip_range = aa; // string string

         } else
	if ((aret = strcmp(str, "RouteType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RouteType argument missing\n");
            s->route_type = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'RouteLight'\n", str);
		return -1;
	}
	return 0;
}

int route_propagating_virtual_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct route_propagating_virtual_gateway *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "VirtualGatewayId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'RoutePropagatingVirtualGateway'\n", str);
		return -1;
	}
	return 0;
}

int route_table_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct route_table *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LinkRouteTables")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'LinkRouteTables' require an index (example array ref LinkRouteTable.LinkRouteTables.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'LinkRouteTables' require a .\n");
            	      TRY_ALLOC_AT(s,link_route_tables, pa, pos, sizeof(*s->link_route_tables));
            	      cascade_struct = &s->link_route_tables[pos];
            	      cascade_parser = link_route_table_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(link_route_table_parser(&s->link_route_tables[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "LinkRouteTables argument missing\n");
            	s->link_route_tables_str = aa; // array ref LinkRouteTable ref
            }
         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "RoutePropagatingVirtualGateways")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'RoutePropagatingVirtualGateways' require an index (example array ref RoutePropagatingVirtualGateway.RoutePropagatingVirtualGateways.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'RoutePropagatingVirtualGateways' require a .\n");
            	      TRY_ALLOC_AT(s,route_propagating_virtual_gateways, pa, pos, sizeof(*s->route_propagating_virtual_gateways));
            	      cascade_struct = &s->route_propagating_virtual_gateways[pos];
            	      cascade_parser = route_propagating_virtual_gateway_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(route_propagating_virtual_gateway_parser(&s->route_propagating_virtual_gateways[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "RoutePropagatingVirtualGateways argument missing\n");
            	s->route_propagating_virtual_gateways_str = aa; // array ref RoutePropagatingVirtualGateway ref
            }
         } else
	if ((aret = strcmp(str, "RouteTableId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RouteTableId argument missing\n");
            s->route_table_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Routes")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Routes' require an index (example array ref Route.Routes.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Routes' require a .\n");
            	      TRY_ALLOC_AT(s,routes, pa, pos, sizeof(*s->routes));
            	      cascade_struct = &s->routes[pos];
            	      cascade_parser = route_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(route_parser(&s->routes[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Routes argument missing\n");
            	s->routes_str = aa; // array ref Route ref
            }
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'RouteTable'\n", str);
		return -1;
	}
	return 0;
}

int security_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct security_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "InboundRules")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'InboundRules' require an index (example array ref SecurityGroupRule.InboundRules.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'InboundRules' require a .\n");
            	      TRY_ALLOC_AT(s,inbound_rules, pa, pos, sizeof(*s->inbound_rules));
            	      cascade_struct = &s->inbound_rules[pos];
            	      cascade_parser = security_group_rule_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(security_group_rule_parser(&s->inbound_rules[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "InboundRules argument missing\n");
            	s->inbound_rules_str = aa; // array ref SecurityGroupRule ref
            }
         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "OutboundRules")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'OutboundRules' require an index (example array ref SecurityGroupRule.OutboundRules.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'OutboundRules' require a .\n");
            	      TRY_ALLOC_AT(s,outbound_rules, pa, pos, sizeof(*s->outbound_rules));
            	      cascade_struct = &s->outbound_rules[pos];
            	      cascade_parser = security_group_rule_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(security_group_rule_parser(&s->outbound_rules[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "OutboundRules argument missing\n");
            	s->outbound_rules_str = aa; // array ref SecurityGroupRule ref
            }
         } else
	if ((aret = strcmp(str, "SecurityGroupId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecurityGroupId argument missing\n");
            s->security_group_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SecurityGroupName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecurityGroupName argument missing\n");
            s->security_group_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SecurityGroup'\n", str);
		return -1;
	}
	return 0;
}

int security_group_light_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct security_group_light *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "SecurityGroupId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecurityGroupId argument missing\n");
            s->security_group_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SecurityGroupName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecurityGroupName argument missing\n");
            s->security_group_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SecurityGroupLight'\n", str);
		return -1;
	}
	return 0;
}

int security_group_rule_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct security_group_rule *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "FromPortRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "FromPortRange argument missing\n");
            s->is_set_from_port_range = 1;
            s->from_port_range = atoi(aa);
         } else
	if ((aret = strcmp(str, "IpProtocol")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "IpProtocol argument missing\n");
            s->ip_protocol = aa; // string string

         } else
	if ((aret = strcmp(str, "IpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "IpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "IpRanges require an index\n");
                      if (s->ip_ranges) {
                              for (; s->ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ip_ranges, "", pa);
                              SET_NEXT(s->ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "IpRanges argument missing\n");
                     s->ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "IpRanges[]")) || aret == '=') {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "SecurityGroupsMembers")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'SecurityGroupsMembers' require an index (example array ref SecurityGroupsMember.SecurityGroupsMembers.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'SecurityGroupsMembers' require a .\n");
            	      TRY_ALLOC_AT(s,security_groups_members, pa, pos, sizeof(*s->security_groups_members));
            	      cascade_struct = &s->security_groups_members[pos];
            	      cascade_parser = security_groups_member_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(security_groups_member_parser(&s->security_groups_members[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "SecurityGroupsMembers argument missing\n");
            	s->security_groups_members_str = aa; // array ref SecurityGroupsMember ref
            }
         } else
	if ((aret = strcmp(str, "ServiceIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ServiceIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ServiceIds require an index\n");
                      if (s->service_ids) {
                              for (; s->service_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->service_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->service_ids, "", pa);
                              SET_NEXT(s->service_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ServiceIds argument missing\n");
                     s->service_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ServiceIds[]")) || aret == '=') {
               TRY(!aa, "ServiceIds[] argument missing\n");
               SET_NEXT(s->service_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "ToPortRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ToPortRange argument missing\n");
            s->is_set_to_port_range = 1;
            s->to_port_range = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SecurityGroupRule'\n", str);
		return -1;
	}
	return 0;
}

int security_groups_member_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct security_groups_member *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SecurityGroupId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecurityGroupId argument missing\n");
            s->security_group_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SecurityGroupName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecurityGroupName argument missing\n");
            s->security_group_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SecurityGroupsMember'\n", str);
		return -1;
	}
	return 0;
}

int server_certificate_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct server_certificate *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ExpirationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ExpirationDate argument missing\n");
            s->expiration_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Id")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Id argument missing\n");
            s->id = aa; // string string

         } else
	if ((aret = strcmp(str, "Name")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	if ((aret = strcmp(str, "Orn")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Orn argument missing\n");
            s->orn = aa; // string string

         } else
	if ((aret = strcmp(str, "Path")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Path argument missing\n");
            s->path = aa; // string string

         } else
	if ((aret = strcmp(str, "UploadDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UploadDate argument missing\n");
            s->upload_date = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'ServerCertificate'\n", str);
		return -1;
	}
	return 0;
}

int service_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct service *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "IpRanges")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "IpRanges argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "IpRanges require an index\n");
                      if (s->ip_ranges) {
                              for (; s->ip_ranges[last]; ++last);
                      }
                      if (pos < last) {
                              s->ip_ranges[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->ip_ranges, "", pa);
                              SET_NEXT(s->ip_ranges, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "IpRanges argument missing\n");
                     s->ip_ranges_str = aa;
                 }
         } else if (!(aret = strcmp(str, "IpRanges[]")) || aret == '=') {
               TRY(!aa, "IpRanges[] argument missing\n");
               SET_NEXT(s->ip_ranges, (aa), pa);
         } else
	if ((aret = strcmp(str, "ServiceId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ServiceId argument missing\n");
            s->service_id = aa; // string string

         } else
	if ((aret = strcmp(str, "ServiceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ServiceName argument missing\n");
            s->service_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Service'\n", str);
		return -1;
	}
	return 0;
}

int snapshot_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct snapshot *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountAlias")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountAlias argument missing\n");
            s->account_alias = aa; // string string

         } else
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "PermissionsToCreateVolume")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "PermissionsToCreateVolume argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->permissions_to_create_volume;
            	    cascade_parser = permissions_on_resource_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(permissions_on_resource_parser(&s->permissions_to_create_volume, dot_pos, aa, pa));
            	    s->is_set_permissions_to_create_volume = 1;
             } else {
                   s->permissions_to_create_volume_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Progress")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Progress argument missing\n");
            s->is_set_progress = 1;
            s->progress = atoi(aa);
         } else
	if ((aret = strcmp(str, "SnapshotId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SnapshotId argument missing\n");
            s->snapshot_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "VolumeId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VolumeSize")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeSize argument missing\n");
            s->is_set_volume_size = 1;
            s->volume_size = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Snapshot'\n", str);
		return -1;
	}
	return 0;
}

int snapshot_export_task_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct snapshot_export_task *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Comment")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Comment argument missing\n");
            s->comment = aa; // string string

         } else
	if ((aret = strcmp(str, "OsuExport")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "OsuExport argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->osu_export;
            	    cascade_parser = osu_export_snapshot_export_task_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(osu_export_snapshot_export_task_parser(&s->osu_export, dot_pos, aa, pa));
            	    s->is_set_osu_export = 1;
             } else {
                   s->osu_export_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Progress")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Progress argument missing\n");
            s->is_set_progress = 1;
            s->progress = atoi(aa);
         } else
	if ((aret = strcmp(str, "SnapshotId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SnapshotId argument missing\n");
            s->snapshot_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "TaskId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "TaskId argument missing\n");
            s->task_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SnapshotExportTask'\n", str);
		return -1;
	}
	return 0;
}

int source_net_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct source_net *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AccountId argument missing\n");
            s->account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "IpRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "IpRange argument missing\n");
            s->ip_range = aa; // string string

         } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SourceNet'\n", str);
		return -1;
	}
	return 0;
}

int source_security_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct source_security_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "SecurityGroupAccountId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecurityGroupAccountId argument missing\n");
            s->security_group_account_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SecurityGroupName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SecurityGroupName argument missing\n");
            s->security_group_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'SourceSecurityGroup'\n", str);
		return -1;
	}
	return 0;
}

int state_comment_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct state_comment *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "StateCode")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "StateCode argument missing\n");
            s->state_code = aa; // string string

         } else
	if ((aret = strcmp(str, "StateMessage")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "StateMessage argument missing\n");
            s->state_message = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'StateComment'\n", str);
		return -1;
	}
	return 0;
}

int subnet_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct subnet *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AvailableIpsCount")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AvailableIpsCount argument missing\n");
            s->is_set_available_ips_count = 1;
            s->available_ips_count = atoi(aa);
         } else
	if ((aret = strcmp(str, "IpRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "IpRange argument missing\n");
            s->ip_range = aa; // string string

         } else
	if ((aret = strcmp(str, "MapPublicIpOnLaunch")) == 0 || aret == '=' || aret == '.') {
            s->is_set_map_public_ip_on_launch = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->map_public_ip_on_launch = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->map_public_ip_on_launch = 0;
             } else {
            		BAD_RET("MapPublicIpOnLaunch require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "SubnetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Subnet'\n", str);
		return -1;
	}
	return 0;
}

int subregion_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct subregion *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "LocationCode")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LocationCode argument missing\n");
            s->location_code = aa; // string string

         } else
	if ((aret = strcmp(str, "RegionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RegionName argument missing\n");
            s->region_name = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Subregion'\n", str);
		return -1;
	}
	return 0;
}

int tag_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct tag *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Key")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Key argument missing\n");
            s->key = aa; // string string

         } else
	if ((aret = strcmp(str, "ResourceId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ResourceId argument missing\n");
            s->resource_id = aa; // string string

         } else
	if ((aret = strcmp(str, "ResourceType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ResourceType argument missing\n");
            s->resource_type = aa; // string string

         } else
	if ((aret = strcmp(str, "Value")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Value argument missing\n");
            s->value = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Tag'\n", str);
		return -1;
	}
	return 0;
}

int user_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct user *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "LastModificationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LastModificationDate argument missing\n");
            s->last_modification_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Path")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Path argument missing\n");
            s->path = aa; // string string

         } else
	if ((aret = strcmp(str, "UserId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UserId argument missing\n");
            s->user_id = aa; // string string

         } else
	if ((aret = strcmp(str, "UserName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UserName argument missing\n");
            s->user_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'User'\n", str);
		return -1;
	}
	return 0;
}

int user_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct user_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "LastModificationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LastModificationDate argument missing\n");
            s->last_modification_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Name")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Name argument missing\n");
            s->name = aa; // string string

         } else
	if ((aret = strcmp(str, "Orn")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Orn argument missing\n");
            s->orn = aa; // string string

         } else
	if ((aret = strcmp(str, "Path")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Path argument missing\n");
            s->path = aa; // string string

         } else
	if ((aret = strcmp(str, "UserGroupId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UserGroupId argument missing\n");
            s->user_group_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'UserGroup'\n", str);
		return -1;
	}
	return 0;
}

int vgw_telemetry_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vgw_telemetry *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AcceptedRouteCount")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "AcceptedRouteCount argument missing\n");
            s->is_set_accepted_route_count = 1;
            s->accepted_route_count = atoi(aa);
         } else
	if ((aret = strcmp(str, "LastStateChangeDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LastStateChangeDate argument missing\n");
            s->last_state_change_date = aa; // string string

         } else
	if ((aret = strcmp(str, "OutsideIpAddress")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OutsideIpAddress argument missing\n");
            s->outside_ip_address = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "StateDescription")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "StateDescription argument missing\n");
            s->state_description = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VgwTelemetry'\n", str);
		return -1;
	}
	return 0;
}

int virtual_gateway_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct virtual_gateway *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ConnectionType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ConnectionType argument missing\n");
            s->connection_type = aa; // string string

         } else
	if ((aret = strcmp(str, "NetToVirtualGatewayLinks")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'NetToVirtualGatewayLinks' require an index (example array ref NetToVirtualGatewayLink.NetToVirtualGatewayLinks.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'NetToVirtualGatewayLinks' require a .\n");
            	      TRY_ALLOC_AT(s,net_to_virtual_gateway_links, pa, pos, sizeof(*s->net_to_virtual_gateway_links));
            	      cascade_struct = &s->net_to_virtual_gateway_links[pos];
            	      cascade_parser = net_to_virtual_gateway_link_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(net_to_virtual_gateway_link_parser(&s->net_to_virtual_gateway_links[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "NetToVirtualGatewayLinks argument missing\n");
            	s->net_to_virtual_gateway_links_str = aa; // array ref NetToVirtualGatewayLink ref
            }
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "VirtualGatewayId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VirtualGateway'\n", str);
		return -1;
	}
	return 0;
}

int vm_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Architecture")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Architecture argument missing\n");
            s->architecture = aa; // string string

         } else
	if ((aret = strcmp(str, "BlockDeviceMappings")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingCreated.BlockDeviceMappings.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'BlockDeviceMappings' require a .\n");
            	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
            	      cascade_struct = &s->block_device_mappings[pos];
            	      cascade_parser = block_device_mapping_created_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(block_device_mapping_created_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "BlockDeviceMappings argument missing\n");
            	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingCreated ref
            }
         } else
	if ((aret = strcmp(str, "BsuOptimized")) == 0 || aret == '=' || aret == '.') {
            s->is_set_bsu_optimized = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->bsu_optimized = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->bsu_optimized = 0;
             } else {
            		BAD_RET("BsuOptimized require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "ClientToken")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ClientToken argument missing\n");
            s->client_token = aa; // string string

         } else
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "DeletionProtection")) == 0 || aret == '=' || aret == '.') {
            s->is_set_deletion_protection = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->deletion_protection = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->deletion_protection = 0;
             } else {
            		BAD_RET("DeletionProtection require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "Hypervisor")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Hypervisor argument missing\n");
            s->hypervisor = aa; // string string

         } else
	if ((aret = strcmp(str, "ImageId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ImageId argument missing\n");
            s->image_id = aa; // string string

         } else
	if ((aret = strcmp(str, "IsSourceDestChecked")) == 0 || aret == '=' || aret == '.') {
            s->is_set_is_source_dest_checked = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->is_source_dest_checked = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->is_source_dest_checked = 0;
             } else {
            		BAD_RET("IsSourceDestChecked require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "KeypairName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "KeypairName argument missing\n");
            s->keypair_name = aa; // string string

         } else
	if ((aret = strcmp(str, "LaunchNumber")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "LaunchNumber argument missing\n");
            s->is_set_launch_number = 1;
            s->launch_number = atoi(aa);
         } else
	if ((aret = strcmp(str, "NestedVirtualization")) == 0 || aret == '=' || aret == '.') {
            s->is_set_nested_virtualization = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->nested_virtualization = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->nested_virtualization = 0;
             } else {
            		BAD_RET("NestedVirtualization require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "NetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "NetId argument missing\n");
            s->net_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Nics")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Nics' require an index (example array ref NicLight.Nics.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Nics' require a .\n");
            	      TRY_ALLOC_AT(s,nics, pa, pos, sizeof(*s->nics));
            	      cascade_struct = &s->nics[pos];
            	      cascade_parser = nic_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(nic_light_parser(&s->nics[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Nics argument missing\n");
            	s->nics_str = aa; // array ref NicLight ref
            }
         } else
	if ((aret = strcmp(str, "OsFamily")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "OsFamily argument missing\n");
            s->os_family = aa; // string string

         } else
	if ((aret = strcmp(str, "Performance")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Performance argument missing\n");
            s->performance = aa; // string string

         } else
	if ((aret = strcmp(str, "Placement")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Placement argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->placement;
            	    cascade_parser = placement_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(placement_parser(&s->placement, dot_pos, aa, pa));
            	    s->is_set_placement = 1;
             } else {
                   s->placement_str = aa;
             }
         } else
	if ((aret = strcmp(str, "PrivateDnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateDnsName argument missing\n");
            s->private_dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PrivateIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PrivateIp argument missing\n");
            s->private_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "ProductCodes")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "ProductCodes argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "ProductCodes require an index\n");
                      if (s->product_codes) {
                              for (; s->product_codes[last]; ++last);
                      }
                      if (pos < last) {
                              s->product_codes[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->product_codes, "", pa);
                              SET_NEXT(s->product_codes, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "ProductCodes argument missing\n");
                     s->product_codes_str = aa;
                 }
         } else if (!(aret = strcmp(str, "ProductCodes[]")) || aret == '=') {
               TRY(!aa, "ProductCodes[] argument missing\n");
               SET_NEXT(s->product_codes, (aa), pa);
         } else
	if ((aret = strcmp(str, "PublicDnsName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicDnsName argument missing\n");
            s->public_dns_name = aa; // string string

         } else
	if ((aret = strcmp(str, "PublicIp")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PublicIp argument missing\n");
            s->public_ip = aa; // string string

         } else
	if ((aret = strcmp(str, "ReservationId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ReservationId argument missing\n");
            s->reservation_id = aa; // string string

         } else
	if ((aret = strcmp(str, "RootDeviceName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RootDeviceName argument missing\n");
            s->root_device_name = aa; // string string

         } else
	if ((aret = strcmp(str, "RootDeviceType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "RootDeviceType argument missing\n");
            s->root_device_type = aa; // string string

         } else
	if ((aret = strcmp(str, "SecurityGroups")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'SecurityGroups' require an index (example array ref SecurityGroupLight.SecurityGroups.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'SecurityGroups' require a .\n");
            	      TRY_ALLOC_AT(s,security_groups, pa, pos, sizeof(*s->security_groups));
            	      cascade_struct = &s->security_groups[pos];
            	      cascade_parser = security_group_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(security_group_light_parser(&s->security_groups[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "SecurityGroups argument missing\n");
            	s->security_groups_str = aa; // array ref SecurityGroupLight ref
            }
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "StateReason")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "StateReason argument missing\n");
            s->state_reason = aa; // string string

         } else
	if ((aret = strcmp(str, "SubnetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "UserData")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "UserData argument missing\n");
            s->user_data = aa; // string string

         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VmInitiatedShutdownBehavior")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmInitiatedShutdownBehavior argument missing\n");
            s->vm_initiated_shutdown_behavior = aa; // string string

         } else
	if ((aret = strcmp(str, "VmType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmType argument missing\n");
            s->vm_type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Vm'\n", str);
		return -1;
	}
	return 0;
}

int vm_group_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm_group *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "PositioningStrategy")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PositioningStrategy argument missing\n");
            s->positioning_strategy = aa; // string string

         } else
	if ((aret = strcmp(str, "SecurityGroupIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
                      if (s->security_group_ids) {
                              for (; s->security_group_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->security_group_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->security_group_ids, "", pa);
                              SET_NEXT(s->security_group_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "SecurityGroupIds argument missing\n");
                     s->security_group_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
               TRY(!aa, "SecurityGroupIds[] argument missing\n");
               SET_NEXT(s->security_group_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "SubnetId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubnetId argument missing\n");
            s->subnet_id = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "VmCount")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmCount argument missing\n");
            s->is_set_vm_count = 1;
            s->vm_count = atoi(aa);
         } else
	if ((aret = strcmp(str, "VmGroupId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmGroupId argument missing\n");
            s->vm_group_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VmGroupName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmGroupName argument missing\n");
            s->vm_group_name = aa; // string string

         } else
	if ((aret = strcmp(str, "VmIds")) == 0 || aret == '=' || aret == '.') {
                 if (aret == '.') {
                      int pos;
                      char *endptr;
                      int last = 0;
                      char *dot_pos = strchr(str, '.');

                      TRY(!(dot_pos++), "VmIds argument missing\n");
                      pos = strtoul(dot_pos, &endptr, 0);
                      TRY(endptr == dot_pos, "VmIds require an index\n");
                      if (s->vm_ids) {
                              for (; s->vm_ids[last]; ++last);
                      }
                      if (pos < last) {
                              s->vm_ids[pos] = (aa);
                      } else {
                              for (int i = last; i < pos; ++i)
                                      SET_NEXT(s->vm_ids, "", pa);
                              SET_NEXT(s->vm_ids, (aa), pa);
                      }
                 } else {
            	       TRY(!aa, "VmIds argument missing\n");
                     s->vm_ids_str = aa;
                 }
         } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
               TRY(!aa, "VmIds[] argument missing\n");
               SET_NEXT(s->vm_ids, (aa), pa);
         } else
	if ((aret = strcmp(str, "VmTemplateId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmTemplateId argument missing\n");
            s->vm_template_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VmGroup'\n", str);
		return -1;
	}
	return 0;
}

int vm_state_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm_state *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CurrentState")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CurrentState argument missing\n");
            s->current_state = aa; // string string

         } else
	if ((aret = strcmp(str, "PreviousState")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "PreviousState argument missing\n");
            s->previous_state = aa; // string string

         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VmState'\n", str);
		return -1;
	}
	return 0;
}

int vm_states_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm_states *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "MaintenanceEvents")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'MaintenanceEvents' require an index (example array ref MaintenanceEvent.MaintenanceEvents.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'MaintenanceEvents' require a .\n");
            	      TRY_ALLOC_AT(s,maintenance_events, pa, pos, sizeof(*s->maintenance_events));
            	      cascade_struct = &s->maintenance_events[pos];
            	      cascade_parser = maintenance_event_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(maintenance_event_parser(&s->maintenance_events[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "MaintenanceEvents argument missing\n");
            	s->maintenance_events_str = aa; // array ref MaintenanceEvent ref
            }
         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "VmId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmId argument missing\n");
            s->vm_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VmState")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmState argument missing\n");
            s->vm_state = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VmStates'\n", str);
		return -1;
	}
	return 0;
}

int vm_template_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm_template *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CpuCores")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CpuCores argument missing\n");
            s->is_set_cpu_cores = 1;
            s->cpu_cores = atoi(aa);
         } else
	if ((aret = strcmp(str, "CpuGeneration")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CpuGeneration argument missing\n");
            s->cpu_generation = aa; // string string

         } else
	if ((aret = strcmp(str, "CpuPerformance")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CpuPerformance argument missing\n");
            s->cpu_performance = aa; // string string

         } else
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Description")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Description argument missing\n");
            s->description = aa; // string string

         } else
	if ((aret = strcmp(str, "ImageId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ImageId argument missing\n");
            s->image_id = aa; // string string

         } else
	if ((aret = strcmp(str, "KeypairName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "KeypairName argument missing\n");
            s->keypair_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Ram")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Ram argument missing\n");
            s->is_set_ram = 1;
            s->ram = atoi(aa);
         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "VmTemplateId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmTemplateId argument missing\n");
            s->vm_template_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VmTemplateName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmTemplateName argument missing\n");
            s->vm_template_name = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VmTemplate'\n", str);
		return -1;
	}
	return 0;
}

int vm_type_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vm_type *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "BsuOptimized")) == 0 || aret == '=' || aret == '.') {
            s->is_set_bsu_optimized = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->bsu_optimized = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->bsu_optimized = 0;
             } else {
            		BAD_RET("BsuOptimized require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "EphemeralsType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "EphemeralsType argument missing\n");
            s->ephemerals_type = aa; // string string

         } else
	if ((aret = strcmp(str, "Eth")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Eth argument missing\n");
            s->is_set_eth = 1;
            s->eth = atoi(aa);
         } else
	if ((aret = strcmp(str, "Gpu")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Gpu argument missing\n");
            s->is_set_gpu = 1;
            s->gpu = atoi(aa);
         } else
	if ((aret = strcmp(str, "MaxPrivateIps")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MaxPrivateIps argument missing\n");
            s->is_set_max_private_ips = 1;
            s->max_private_ips = atoi(aa);
         } else
	if ((aret = strcmp(str, "MemorySize")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "MemorySize argument missing\n");
            s->is_set_memory_size = 1;
            s->memory_size = atof(aa);
         } else
	if ((aret = strcmp(str, "VcoreCount")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VcoreCount argument missing\n");
            s->is_set_vcore_count = 1;
            s->vcore_count = atoi(aa);
         } else
	if ((aret = strcmp(str, "VmTypeName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VmTypeName argument missing\n");
            s->vm_type_name = aa; // string string

         } else
	if ((aret = strcmp(str, "VolumeCount")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeCount argument missing\n");
            s->is_set_volume_count = 1;
            s->volume_count = atoi(aa);
         } else
	if ((aret = strcmp(str, "VolumeSize")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeSize argument missing\n");
            s->is_set_volume_size = 1;
            s->volume_size = atoi(aa);
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VmType'\n", str);
		return -1;
	}
	return 0;
}

int volume_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct volume *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "CreationDate")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "CreationDate argument missing\n");
            s->creation_date = aa; // string string

         } else
	if ((aret = strcmp(str, "Iops")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Iops argument missing\n");
            s->is_set_iops = 1;
            s->iops = atoi(aa);
         } else
	if ((aret = strcmp(str, "LinkedVolumes")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'LinkedVolumes' require an index (example array ref LinkedVolume.LinkedVolumes.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'LinkedVolumes' require a .\n");
            	      TRY_ALLOC_AT(s,linked_volumes, pa, pos, sizeof(*s->linked_volumes));
            	      cascade_struct = &s->linked_volumes[pos];
            	      cascade_parser = linked_volume_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(linked_volume_parser(&s->linked_volumes[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "LinkedVolumes argument missing\n");
            	s->linked_volumes_str = aa; // array ref LinkedVolume ref
            }
         } else
	if ((aret = strcmp(str, "Size")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "Size argument missing\n");
            s->is_set_size = 1;
            s->size = atoi(aa);
         } else
	if ((aret = strcmp(str, "SnapshotId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SnapshotId argument missing\n");
            s->snapshot_id = aa; // string string

         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "SubregionName")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "SubregionName argument missing\n");
            s->subregion_name = aa; // string string

         } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "VolumeId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeId argument missing\n");
            s->volume_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VolumeType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VolumeType argument missing\n");
            s->volume_type = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'Volume'\n", str);
		return -1;
	}
	return 0;
}

int vpn_connection_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vpn_connection *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "ClientGatewayConfiguration")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ClientGatewayConfiguration argument missing\n");
            s->client_gateway_configuration = aa; // string string

         } else
	if ((aret = strcmp(str, "ClientGatewayId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ClientGatewayId argument missing\n");
            s->client_gateway_id = aa; // string string

         } else
	if ((aret = strcmp(str, "ConnectionType")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "ConnectionType argument missing\n");
            s->connection_type = aa; // string string

         } else
	if ((aret = strcmp(str, "Routes")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Routes' require an index (example array ref RouteLight.Routes.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Routes' require a .\n");
            	      TRY_ALLOC_AT(s,routes, pa, pos, sizeof(*s->routes));
            	      cascade_struct = &s->routes[pos];
            	      cascade_parser = route_light_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(route_light_parser(&s->routes[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Routes argument missing\n");
            	s->routes_str = aa; // array ref RouteLight ref
            }
         } else
	if ((aret = strcmp(str, "State")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "State argument missing\n");
            s->state = aa; // string string

         } else
	if ((aret = strcmp(str, "StaticRoutesOnly")) == 0 || aret == '=' || aret == '.') {
            s->is_set_static_routes_only = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->static_routes_only = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->static_routes_only = 0;
             } else {
            		BAD_RET("StaticRoutesOnly require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "Tags")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'Tags' require a .\n");
            	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
            	      cascade_struct = &s->tags[pos];
            	      cascade_parser = resource_tag_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "Tags argument missing\n");
            	s->tags_str = aa; // array ref ResourceTag ref
            }
         } else
	if ((aret = strcmp(str, "VgwTelemetries")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos = strchr(str, '.');

            if (dot_pos) {
            	      int pos;
            	      char *endptr;

            	      ++dot_pos;
            	      pos = strtoul(dot_pos, &endptr, 0);
            	      if (endptr == dot_pos)
            		      BAD_RET("'VgwTelemetries' require an index (example array ref VgwTelemetry.VgwTelemetries.0)\n");
            	      else if (*endptr != '.')
            		      BAD_RET("'VgwTelemetries' require a .\n");
            	      TRY_ALLOC_AT(s,vgw_telemetries, pa, pos, sizeof(*s->vgw_telemetries));
            	      cascade_struct = &s->vgw_telemetries[pos];
            	      cascade_parser = vgw_telemetry_parser;
            	      if (endptr[1] == '.') {
            		     ++endptr;
            	      }
            	      STRY(vgw_telemetry_parser(&s->vgw_telemetries[pos], endptr + 1, aa, pa));
             } else {
            	TRY(!aa, "VgwTelemetries argument missing\n");
            	s->vgw_telemetries_str = aa; // array ref VgwTelemetry ref
            }
         } else
	if ((aret = strcmp(str, "VirtualGatewayId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VirtualGatewayId argument missing\n");
            s->virtual_gateway_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VpnConnectionId")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "VpnConnectionId argument missing\n");
            s->vpn_connection_id = aa; // string string

         } else
	if ((aret = strcmp(str, "VpnOptions")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "VpnOptions argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->vpn_options;
            	    cascade_parser = vpn_options_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(vpn_options_parser(&s->vpn_options, dot_pos, aa, pa));
            	    s->is_set_vpn_options = 1;
             } else {
                   s->vpn_options_str = aa;
             }
         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VpnConnection'\n", str);
		return -1;
	}
	return 0;
}

int vpn_options_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct vpn_options *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "Phase1Options")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Phase1Options argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->phase1_options;
            	    cascade_parser = phase1_options_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(phase1_options_parser(&s->phase1_options, dot_pos, aa, pa));
            	    s->is_set_phase1_options = 1;
             } else {
                   s->phase1_options_str = aa;
             }
         } else
	if ((aret = strcmp(str, "Phase2Options")) == 0 || aret == '=' || aret == '.') {
            char *dot_pos;

            TRY(!aa, "Phase2Options argument missing\n");
            dot_pos = strchr(str, '.');
            if (dot_pos++) {
            	    cascade_struct = &s->phase2_options;
            	    cascade_parser = phase2_options_parser;
            	    if (*dot_pos == '.') {
            		++dot_pos;
            	    }
            	    STRY(phase2_options_parser(&s->phase2_options, dot_pos, aa, pa));
            	    s->is_set_phase2_options = 1;
             } else {
                   s->phase2_options_str = aa;
             }
         } else
	if ((aret = strcmp(str, "TunnelInsideIpRange")) == 0 || aret == '=' || aret == '.') {
            TRY(!aa, "TunnelInsideIpRange argument missing\n");
            s->tunnel_inside_ip_range = aa; // string string

         } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'VpnOptions'\n", str);
		return -1;
	}
	return 0;
}

int with_parser(void *v_s, char *str, char *aa, struct ptr_array *pa) {
	    struct with *s = v_s;
	    int aret = 0;
	if ((aret = strcmp(str, "AccountId")) == 0 || aret == '=' || aret == '.') {
            s->is_set_account_id = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->account_id = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->account_id = 0;
             } else {
            		BAD_RET("AccountId require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "CallDuration")) == 0 || aret == '=' || aret == '.') {
            s->is_set_call_duration = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->call_duration = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->call_duration = 0;
             } else {
            		BAD_RET("CallDuration require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryAccessKey")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_access_key = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_access_key = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_access_key = 0;
             } else {
            		BAD_RET("QueryAccessKey require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryApiName")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_api_name = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_api_name = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_api_name = 0;
             } else {
            		BAD_RET("QueryApiName require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryApiVersion")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_api_version = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_api_version = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_api_version = 0;
             } else {
            		BAD_RET("QueryApiVersion require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryCallName")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_call_name = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_call_name = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_call_name = 0;
             } else {
            		BAD_RET("QueryCallName require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryDate")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_date = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_date = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_date = 0;
             } else {
            		BAD_RET("QueryDate require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryHeaderRaw")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_header_raw = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_header_raw = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_header_raw = 0;
             } else {
            		BAD_RET("QueryHeaderRaw require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryHeaderSize")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_header_size = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_header_size = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_header_size = 0;
             } else {
            		BAD_RET("QueryHeaderSize require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryIpAddress")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_ip_address = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_ip_address = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_ip_address = 0;
             } else {
            		BAD_RET("QueryIpAddress require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryPayloadRaw")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_payload_raw = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_payload_raw = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_payload_raw = 0;
             } else {
            		BAD_RET("QueryPayloadRaw require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryPayloadSize")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_payload_size = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_payload_size = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_payload_size = 0;
             } else {
            		BAD_RET("QueryPayloadSize require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "QueryUserAgent")) == 0 || aret == '=' || aret == '.') {
            s->is_set_query_user_agent = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->query_user_agent = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->query_user_agent = 0;
             } else {
            		BAD_RET("QueryUserAgent require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "RequestId")) == 0 || aret == '=' || aret == '.') {
            s->is_set_request_id = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->request_id = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->request_id = 0;
             } else {
            		BAD_RET("RequestId require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "ResponseSize")) == 0 || aret == '=' || aret == '.') {
            s->is_set_response_size = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->response_size = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->response_size = 0;
             } else {
            		BAD_RET("ResponseSize require true/false\n");
             }
        } else
	if ((aret = strcmp(str, "ResponseStatusCode")) == 0 || aret == '=' || aret == '.') {
            s->is_set_response_status_code = 1;
            if (!aa || !strcasecmp(aa, "true")) {
            		s->response_status_code = 1;
             } else if (!strcasecmp(aa, "false")) {
            		s->response_status_code = 0;
             } else {
            		BAD_RET("ResponseStatusCode require true/false\n");
             }
        } else
	{
		fprintf(stderr, "'%s' not an argumemt of 'With'\n", str);
		return -1;
	}
	return 0;
}



static int str_auth_method_to_int(const char *str)
{
	if (!strcmp(str, "password") || !strcmp(str, "basic"))
		return OSC_PASSWORD_METHOD;
	else if (!strcmp(str, "none"))
		return OSC_NONE_METHOD;
	else if (!strcmp(str, "accesskey"))
		return OSC_AKSK_METHOD;
	return -1;
}

int main(int ac, char **av)
{
	auto_osc_env struct osc_env e = {0};
	auto_osc_str struct osc_str r = {0};
	int color_flag = 0;
	int i;
	char *help_appent = getenv("COGNAC_HELP_APPEND");
	unsigned int flag = 0;
	unsigned int program_flag = 0;
	char *program_name = strrchr(av[0], '/');
	char *profile = NULL;
	char *login = NULL;
	char *password = NULL;
	int auth_m = OSC_AKSK_METHOD;
	int ret = 1;

	if (!program_name)
		program_name = av[0];
	else
		++program_name;

	for (i = 1; i < ac; ++i) {
		if (!strcmp("--verbose", av[i])) {
		  flag |= OSC_VERBOSE_MODE;
		} else if (!strcmp("--insecure", av[i])) {
		  flag |= OSC_INSECURE_MODE;
		} else if (!strcmp("--version", av[i])) {
			printf("oapi-cli version: %s\n"
			       "osc-sdk-c version: %s\n"
			       "based on osc-api: %s\n",
			       OAPI_CLI_VERSION,
			       osc_sdk_version_str(),
			       OSC_API_VERSION);
			return 0;
		} else if (!strcmp("--raw-print", av[i])) {
		  program_flag |= OAPI_RAW_OUTPUT;
		} else if (!strcmp("--list-calls", av[i])) {
			const char **names = osc_calls_name();

			for (const char **n = names; *n; ++n) {
				printf("%s\n", *n);
			}
			return 0;
		} else if (!strcmp("--help", av[i]) || !strcmp("-h", av[i])) {
		  auth_m = OSC_NONE_METHOD;
		} else if (!argcmp2("--auth-method", av[i], '=')) {
			const char *auth_str;
			if (av[i][sizeof("--auth-method") - 1] == '=') {
				auth_str = &av[i][sizeof("--auth-method")];
			} else if (!av[i][sizeof("--auth-method") - 1]) {
				TRY(!av[i+1], "-- need an auth-method\n");
				auth_str = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--auth-method seems weirds\n");
				return 1;
			}
			auth_m = str_auth_method_to_int(auth_str);
			TRY(auth_m < 0, "%s unknown auth-method\n", auth_str);
		} else if (!argcmp2("--authentication_method", av[i], '=')) {
			const char *auth_str;
			if (av[i][sizeof("--authentication_method") - 1] == '=') {
				auth_str = &av[i][sizeof("--authentication_method")];
			} else if (!av[i][sizeof("--authentication_method") - 1]) {
				TRY(!av[i+1], "-- need an authentication_method\n");
				auth_str = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--authentication_method seems weirds\n");
				return 1;
			}
			auth_m = str_auth_method_to_int(auth_str);
			TRY(auth_m < 0, "%s unknown authentication_method\n", auth_str);
		} else if (!argcmp2("--config", av[i], '=')) {
			const char *cfg_str;
			if (av[i][sizeof("--config") - 1] == '=') {
				cfg_str = &av[i][sizeof("--config")];
			} else if (!av[i][sizeof("--config") - 1]) {
				TRY(!av[i+1], "--config need a path\n");
				cfg_str = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--config seems weirds\n");
				return 1;
			}
			osc_set_cfg_path(cfg_str);
		} else if (!argcmp2("--profile", av[i], '=')) {
			if (av[i][sizeof("--profile") - 1] == '=') {
				profile = &av[i][sizeof("--profile")];
			} else if (!av[i][sizeof("--profile") - 1]) {
				TRY(!av[i+1], "--profile need a profile");
				profile = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--profile seems weirds");
				return 1;
			}
		} else if (!argcmp2("--password", av[i], '=')) {
			if (av[i][sizeof("--password") - 1] == '=') {
				password = &av[i][sizeof("--password")];
			} else if (!av[i][sizeof("--password") - 1]) {
				TRY(!av[i+1], "--password need a password");
				password = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--password seems weirds");
				return 1;
			}
		} else if (!argcmp2("--login", av[i], '=')) {
			if (av[i][sizeof("--login") - 1] == '=') {
				login = &av[i][sizeof("--login")];
			} else if (!av[i][sizeof("--login") - 1]) {
				TRY(!av[i+1], "--login need a login");
				login = av[i+1];
				++i;
			} else {
				fprintf(stderr, "--login seems weirds");
				return 1;
			}
		}
	}

	if (login || password)
		auth_m = OSC_PASSWORD_METHOD;

	if (ac < 2 || (ac == 2 && !strcmp(av[1], "--help"))) {
	show_help:
                printf("Usage: %s [--help] CallName [options] [--Params <param_argument | [--file | --jsonstr-file] <file_name>>] | --var <variable_name>\n"
                       "options:\n"
                       "\t    --auth-method=METHODE set authentification method, password|accesskey|none\n"
                       "\t    --color               try to colorize json if json-c support it\n"
                       "\t    --config=PATH         config file path\n"
		       "\t    --file PATH           use content of PATH as an agrument for a call, example:\n"
		       "\t\t\t\toapi-cli CreateCa  --CaPem --file /$CA_DIR/cert.pem\n"
		       "\t    --jsonstr-file PATH   same as --file, except the content is surrounded by \"\n"
		       "\t\t\t\tand \" inside the file are escape with a \\, this option is useful for CreatePolicy\n"
		       "\t    --set-var ID=VARIABLE_PATH  Create an oapi-cli variable, that can be use with --var\n"
		       "\t\t\t\tExamples: ./oapi-cli ReadVms --Filters.TagValues[] VM_NAME --set-var id=Vms.0.VmId ReadVms --Filters.VmIds[] --var id\n"
		       "\t\t\t\twill find the vm with VM_NAME as it's tag, and read it again, but using it's VmId as filter this time\n"
		       "\t    --var                 use variabble content created by --set-var\n"
                       "\t-h, --help [CallName]     this, can be used with call name, example:\n\t\t\t\t%s --help ReadVms\n"
                       "\t    --list-calls          list all calls\n"
                       "\t    --insecure            doesn't verify SSL certificats\n"
                       "\t    --login=EMAIL         set email, and authentification as password\n"
                       "\t    --password=PASS       set password, and authentification as password\n"
                       "\t    --profile=PROFILE     select profile\n"
                       "\t    --raw-print           doesn't format the output\n"
                       "\t    --verbose             curl backend is now verbose\n"
                       "\t    --version             oapi-cli version info\n%s%s",
		       program_name, program_name, help_appent ? help_appent : "",
		       help_appent ? "\n" : "");
		return 0;
	}

	TRY(osc_init_sdk_ext(&e, profile, flag,
			     &(struct osc_env_conf){
				     .auth_method=auth_m,
				     .password=password,
				     .login=login
			     }),
	    "fail to init C sdk\n");
	osc_init_str(&r);

	char user_agent[OSC_SDK_VERSON_L + sizeof OAPI_CLI_UAGENT] =
		OAPI_CLI_UAGENT;

	strcpy(user_agent + sizeof OAPI_CLI_UAGENT - 1, osc_sdk_version_str());
	osc_sdk_set_useragent(&e, user_agent);

	for (i = 1; i < ac; ++i) {
		if (!strcmp("--verbose", av[i]) ||		\
		    !strcmp("--insecure", av[i]) ||		\
		    !strcmp("--raw-print", av[i])) {
			/* Avoid Unknown Calls */
		} else if (!argcmp2("--profile", av[i], '=')) {
			if (!av[i][sizeof("--profile") - 1]) {
				++i;
			}
		} else if (!argcmp2("--auth-method", av[i], '=')) {
			if (!av[i][sizeof("--auth-method") - 1]) {
				++i;
			}
		} else if (!argcmp2("--authentication_method", av[i], '=')) {
			if (!av[i][sizeof("--authentication_method") - 1]) {
				++i;
			}
		} else if (!argcmp2("--config", av[i], '=')) {
			if (!av[i][sizeof("--config") - 1]) {
				++i;
			}
		} else if (!argcmp2("--password", av[i], '=')) {
			if (!av[i][sizeof("--password") - 1]) {
				++i;
			}
		} else if (!argcmp2("--login", av[i], '=')) {
			if (!av[i][sizeof("--login") - 1]) {
				++i;
			}
		} else if (!strcmp("--help", av[i]) || !strcmp("-h", av[i])) {
			if (av[i+1]) {
				const char *cd = osc_find_description(av[i+1]);
				const char *cad = osc_find_args_description(av[i+1]);
				if (cd) {
					puts(cd);
					puts("Arguments Description:");
					puts(cad);
					goto good;
				} else {
					printf("Unknown Call %s\n", av[i+1]);
					goto out;
				}
			}
			goto show_help;
		} else if (!strcmp("--color", av[i])) {
			color_flag |= JSON_C_TO_STRING_COLOR;
		} else
              if (!strcmp("UpdateVpnConnection", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_vpn_connection_arg a = {0};
		     struct osc_update_vpn_connection_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_vpn_connection_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_vpn_connection_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "ClientGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ClientGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ClientGatewayId argument missing\n");
				          s->client_gateway_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VirtualGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VirtualGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VpnConnectionId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VpnConnectionId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VpnConnectionId argument missing\n");
				          s->vpn_connection_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VpnOptions")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VpnOptions argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "VpnOptions argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->vpn_options;
				          	    cascade_parser = vpn_options_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(vpn_options_parser(&s->vpn_options, dot_pos, aa, pa));
				          	    s->is_set_vpn_options = 1;
				           } else {
				                 s->vpn_options_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateVpnConnection'\n", next_a);
			    }
		            i += incr;
			    goto update_vpn_connection_arg;
		     }
		     cret = osc_update_vpn_connection(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateVpnConnection: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateVolume", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_volume_arg a = {0};
		     struct osc_update_volume_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Iops")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Iops argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Iops argument missing\n");
				          s->is_set_iops = 1;
				          s->iops = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "Size")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Size argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Size argument missing\n");
				          s->is_set_size = 1;
				          s->size = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "VolumeId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VolumeId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VolumeType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VolumeType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VolumeType argument missing\n");
				          s->volume_type = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateVolume'\n", next_a);
			    }
		            i += incr;
			    goto update_volume_arg;
		     }
		     cret = osc_update_volume(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateVolume: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateVmTemplate", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_vm_template_arg a = {0};
		     struct osc_update_vm_template_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_vm_template_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_vm_template_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "VmTemplateId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmTemplateId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmTemplateId argument missing\n");
				          s->vm_template_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmTemplateName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmTemplateName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmTemplateName argument missing\n");
				          s->vm_template_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateVmTemplate'\n", next_a);
			    }
		            i += incr;
			    goto update_vm_template_arg;
		     }
		     cret = osc_update_vm_template(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateVmTemplate: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateVmGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_vm_group_arg a = {0};
		     struct osc_update_vm_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_vm_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_vm_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "VmGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmGroupId argument missing\n");
				          s->vm_group_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmGroupName argument missing\n");
				          s->vm_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmTemplateId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmTemplateId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmTemplateId argument missing\n");
				          s->vm_template_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateVmGroup'\n", next_a);
			    }
		            i += incr;
			    goto update_vm_group_arg;
		     }
		     cret = osc_update_vm_group(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateVmGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateVm", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_vm_arg a = {0};
		     struct osc_update_vm_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_vm_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_vm_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "BlockDeviceMappings")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BlockDeviceMappings argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingVmUpdate.BlockDeviceMappings.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'BlockDeviceMappings' require a .\n");
				          	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
				          	      cascade_struct = &s->block_device_mappings[pos];
				          	      cascade_parser = block_device_mapping_vm_update_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(block_device_mapping_vm_update_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "BlockDeviceMappings argument missing\n");
				          	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingVmUpdate ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "BsuOptimized")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BsuOptimized argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_bsu_optimized = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->bsu_optimized = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->bsu_optimized = 0;
				           } else {
				          		BAD_RET("BsuOptimized require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "DeletionProtection")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DeletionProtection argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_deletion_protection = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->deletion_protection = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->deletion_protection = 0;
				           } else {
				          		BAD_RET("DeletionProtection require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "IsSourceDestChecked")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IsSourceDestChecked argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_is_source_dest_checked = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->is_source_dest_checked = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->is_source_dest_checked = 0;
				           } else {
				          		BAD_RET("IsSourceDestChecked require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "KeypairName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "KeypairName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NestedVirtualization")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NestedVirtualization argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_nested_virtualization = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->nested_virtualization = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->nested_virtualization = 0;
				           } else {
				          		BAD_RET("NestedVirtualization require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Performance")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Performance argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Performance argument missing\n");
				          s->performance = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
				                    if (s->security_group_ids) {
				                            for (; s->security_group_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->security_group_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->security_group_ids, "", pa);
				                            SET_NEXT(s->security_group_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SecurityGroupIds argument missing\n");
				                   s->security_group_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "UserData")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserData argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserData argument missing\n");
				          s->user_data = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmInitiatedShutdownBehavior")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmInitiatedShutdownBehavior argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmInitiatedShutdownBehavior argument missing\n");
				          s->vm_initiated_shutdown_behavior = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmType argument missing\n");
				          s->vm_type = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateVm'\n", next_a);
			    }
		            i += incr;
			    goto update_vm_arg;
		     }
		     cret = osc_update_vm(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateVm: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_user_group_arg a = {0};
		     struct osc_update_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NewPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NewPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NewPath argument missing\n");
				          s->new_path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NewUserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NewUserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NewUserGroupName argument missing\n");
				          s->new_user_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Path")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Path argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Path argument missing\n");
				          s->path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto update_user_group_arg;
		     }
		     cret = osc_update_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateUser", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_user_arg a = {0};
		     struct osc_update_user_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_user_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_user_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NewPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NewPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NewPath argument missing\n");
				          s->new_path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NewUserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NewUserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NewUserName argument missing\n");
				          s->new_user_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateUser'\n", next_a);
			    }
		            i += incr;
			    goto update_user_arg;
		     }
		     cret = osc_update_user(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateUser: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateSubnet", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_subnet_arg a = {0};
		     struct osc_update_subnet_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_subnet_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_subnet_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "MapPublicIpOnLaunch")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "MapPublicIpOnLaunch argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_map_public_ip_on_launch = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->map_public_ip_on_launch = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->map_public_ip_on_launch = 0;
				           } else {
				          		BAD_RET("MapPublicIpOnLaunch require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "SubnetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubnetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateSubnet'\n", next_a);
			    }
		            i += incr;
			    goto update_subnet_arg;
		     }
		     cret = osc_update_subnet(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateSubnet: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateSnapshot", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_snapshot_arg a = {0};
		     struct osc_update_snapshot_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_snapshot_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_snapshot_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PermissionsToCreateVolume")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PermissionsToCreateVolume argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "PermissionsToCreateVolume argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->permissions_to_create_volume;
				          	    cascade_parser = permissions_on_resource_creation_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(permissions_on_resource_creation_parser(&s->permissions_to_create_volume, dot_pos, aa, pa));
				          	    s->is_set_permissions_to_create_volume = 1;
				           } else {
				                 s->permissions_to_create_volume_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "SnapshotId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SnapshotId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SnapshotId argument missing\n");
				          s->snapshot_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateSnapshot'\n", next_a);
			    }
		            i += incr;
			    goto update_snapshot_arg;
		     }
		     cret = osc_update_snapshot(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateSnapshot: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateServerCertificate", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_server_certificate_arg a = {0};
		     struct osc_update_server_certificate_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_server_certificate_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_server_certificate_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Name")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Name argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Name argument missing\n");
				          s->name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NewName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NewName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NewName argument missing\n");
				          s->new_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NewPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NewPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NewPath argument missing\n");
				          s->new_path = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateServerCertificate'\n", next_a);
			    }
		            i += incr;
			    goto update_server_certificate_arg;
		     }
		     cret = osc_update_server_certificate(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateServerCertificate: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateRouteTableLink", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_route_table_link_arg a = {0};
		     struct osc_update_route_table_link_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_route_table_link_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_route_table_link_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LinkRouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LinkRouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LinkRouteTableId argument missing\n");
				          s->link_route_table_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "RouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateRouteTableLink'\n", next_a);
			    }
		            i += incr;
			    goto update_route_table_link_arg;
		     }
		     cret = osc_update_route_table_link(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateRouteTableLink: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateRoutePropagation", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_route_propagation_arg a = {0};
		     struct osc_update_route_propagation_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_route_propagation_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_route_propagation_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Enable")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Enable argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_enable = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->enable = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->enable = 0;
				           } else {
				          		BAD_RET("Enable require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "RouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VirtualGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VirtualGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateRoutePropagation'\n", next_a);
			    }
		            i += incr;
			    goto update_route_propagation_arg;
		     }
		     cret = osc_update_route_propagation(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateRoutePropagation: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateRoute", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_route_arg a = {0};
		     struct osc_update_route_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DestinationIpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DestinationIpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "GatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "GatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "GatewayId argument missing\n");
				          s->gateway_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NatServiceId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NatServiceId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NatServiceId argument missing\n");
				          s->nat_service_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NetPeeringId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetPeeringId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "RouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateRoute'\n", next_a);
			    }
		            i += incr;
			    goto update_route_arg;
		     }
		     cret = osc_update_route(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateRoute: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateNic", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_nic_arg a = {0};
		     struct osc_update_nic_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LinkNic")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LinkNic argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "LinkNic argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->link_nic;
				          	    cascade_parser = link_nic_to_update_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(link_nic_to_update_parser(&s->link_nic, dot_pos, aa, pa));
				          	    s->is_set_link_nic = 1;
				           } else {
				                 s->link_nic_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
				                    if (s->security_group_ids) {
				                            for (; s->security_group_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->security_group_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->security_group_ids, "", pa);
				                            SET_NEXT(s->security_group_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SecurityGroupIds argument missing\n");
				                   s->security_group_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateNic'\n", next_a);
			    }
		            i += incr;
			    goto update_nic_arg;
		     }
		     cret = osc_update_nic(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateNic: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateNetAccessPoint", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_net_access_point_arg a = {0};
		     struct osc_update_net_access_point_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_net_access_point_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_net_access_point_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AddRouteTableIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AddRouteTableIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "AddRouteTableIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "AddRouteTableIds require an index\n");
				                    if (s->add_route_table_ids) {
				                            for (; s->add_route_table_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->add_route_table_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->add_route_table_ids, "", pa);
				                            SET_NEXT(s->add_route_table_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "AddRouteTableIds argument missing\n");
				                   s->add_route_table_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "AddRouteTableIds[]")) || aret == '=') {
				             TRY(!aa, "AddRouteTableIds[] argument missing\n");
				             SET_NEXT(s->add_route_table_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetAccessPointId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetAccessPointId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetAccessPointId argument missing\n");
				          s->net_access_point_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "RemoveRouteTableIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RemoveRouteTableIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "RemoveRouteTableIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "RemoveRouteTableIds require an index\n");
				                    if (s->remove_route_table_ids) {
				                            for (; s->remove_route_table_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->remove_route_table_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->remove_route_table_ids, "", pa);
				                            SET_NEXT(s->remove_route_table_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "RemoveRouteTableIds argument missing\n");
				                   s->remove_route_table_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "RemoveRouteTableIds[]")) || aret == '=') {
				             TRY(!aa, "RemoveRouteTableIds[] argument missing\n");
				             SET_NEXT(s->remove_route_table_ids, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateNetAccessPoint'\n", next_a);
			    }
		            i += incr;
			    goto update_net_access_point_arg;
		     }
		     cret = osc_update_net_access_point(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateNetAccessPoint: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateNet", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_net_arg a = {0};
		     struct osc_update_net_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_net_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_net_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DhcpOptionsSetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DhcpOptionsSetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DhcpOptionsSetId argument missing\n");
				          s->dhcp_options_set_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateNet'\n", next_a);
			    }
		            i += incr;
			    goto update_net_arg;
		     }
		     cret = osc_update_net(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateNet: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateLoadBalancer", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_load_balancer_arg a = {0};
		     struct osc_update_load_balancer_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AccessLog")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AccessLog argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "AccessLog argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->access_log;
				          	    cascade_parser = access_log_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(access_log_parser(&s->access_log, dot_pos, aa, pa));
				          	    s->is_set_access_log = 1;
				           } else {
				                 s->access_log_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "HealthCheck")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "HealthCheck argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "HealthCheck argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->health_check;
				          	    cascade_parser = health_check_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(health_check_parser(&s->health_check, dot_pos, aa, pa));
				          	    s->is_set_health_check = 1;
				           } else {
				                 s->health_check_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "LoadBalancerPort")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerPort argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerPort argument missing\n");
				          s->is_set_load_balancer_port = 1;
				          s->load_balancer_port = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "PolicyNames")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyNames argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "PolicyNames argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "PolicyNames require an index\n");
				                    if (s->policy_names) {
				                            for (; s->policy_names[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->policy_names[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->policy_names, "", pa);
				                            SET_NEXT(s->policy_names, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "PolicyNames argument missing\n");
				                   s->policy_names_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "PolicyNames[]")) || aret == '=') {
				             TRY(!aa, "PolicyNames[] argument missing\n");
				             SET_NEXT(s->policy_names, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "PublicIp")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIp argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecuredCookies")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecuredCookies argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_secured_cookies = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->secured_cookies = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->secured_cookies = 0;
				           } else {
				          		BAD_RET("SecuredCookies require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "SecurityGroups")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroups argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SecurityGroups argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SecurityGroups require an index\n");
				                    if (s->security_groups) {
				                            for (; s->security_groups[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->security_groups[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->security_groups, "", pa);
				                            SET_NEXT(s->security_groups, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SecurityGroups argument missing\n");
				                   s->security_groups_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SecurityGroups[]")) || aret == '=') {
				             TRY(!aa, "SecurityGroups[] argument missing\n");
				             SET_NEXT(s->security_groups, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "ServerCertificateId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ServerCertificateId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ServerCertificateId argument missing\n");
				          s->server_certificate_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateLoadBalancer'\n", next_a);
			    }
		            i += incr;
			    goto update_load_balancer_arg;
		     }
		     cret = osc_update_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateLoadBalancer: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateListenerRule", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_listener_rule_arg a = {0};
		     struct osc_update_listener_rule_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_listener_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_listener_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "HostPattern")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "HostPattern argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "HostPattern argument missing\n");
				          s->host_pattern = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ListenerRuleName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ListenerRuleName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ListenerRuleName argument missing\n");
				          s->listener_rule_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PathPattern")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PathPattern argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PathPattern argument missing\n");
				          s->path_pattern = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateListenerRule'\n", next_a);
			    }
		            i += incr;
			    goto update_listener_rule_arg;
		     }
		     cret = osc_update_listener_rule(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateListenerRule: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateImage", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_image_arg a = {0};
		     struct osc_update_image_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_image_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_image_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ImageId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ImageId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PermissionsToLaunch")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PermissionsToLaunch argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "PermissionsToLaunch argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->permissions_to_launch;
				          	    cascade_parser = permissions_on_resource_creation_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(permissions_on_resource_creation_parser(&s->permissions_to_launch, dot_pos, aa, pa));
				          	    s->is_set_permissions_to_launch = 1;
				           } else {
				                 s->permissions_to_launch_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateImage'\n", next_a);
			    }
		            i += incr;
			    goto update_image_arg;
		     }
		     cret = osc_update_image(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateImage: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateFlexibleGpu", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_flexible_gpu_arg a = {0};
		     struct osc_update_flexible_gpu_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DeleteOnVmDeletion")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DeleteOnVmDeletion argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_delete_on_vm_deletion = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->delete_on_vm_deletion = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->delete_on_vm_deletion = 0;
				           } else {
				          		BAD_RET("DeleteOnVmDeletion require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "FlexibleGpuId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FlexibleGpuId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FlexibleGpuId argument missing\n");
				          s->flexible_gpu_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateFlexibleGpu'\n", next_a);
			    }
		            i += incr;
			    goto update_flexible_gpu_arg;
		     }
		     cret = osc_update_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateDirectLinkInterface", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_direct_link_interface_arg a = {0};
		     struct osc_update_direct_link_interface_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_direct_link_interface_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_direct_link_interface_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DirectLinkInterfaceId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DirectLinkInterfaceId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DirectLinkInterfaceId argument missing\n");
				          s->direct_link_interface_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Mtu")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Mtu argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Mtu argument missing\n");
				          s->is_set_mtu = 1;
				          s->mtu = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateDirectLinkInterface'\n", next_a);
			    }
		            i += incr;
			    goto update_direct_link_interface_arg;
		     }
		     cret = osc_update_direct_link_interface(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateDirectLinkInterface: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateDedicatedGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_dedicated_group_arg a = {0};
		     struct osc_update_dedicated_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_dedicated_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_dedicated_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DedicatedGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DedicatedGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DedicatedGroupId argument missing\n");
				          s->dedicated_group_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Name")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Name argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Name argument missing\n");
				          s->name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateDedicatedGroup'\n", next_a);
			    }
		            i += incr;
			    goto update_dedicated_group_arg;
		     }
		     cret = osc_update_dedicated_group(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateDedicatedGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateCa", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_ca_arg a = {0};
		     struct osc_update_ca_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_ca_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_ca_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "CaId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CaId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CaId argument missing\n");
				          s->ca_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateCa'\n", next_a);
			    }
		            i += incr;
			    goto update_ca_arg;
		     }
		     cret = osc_update_ca(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateCa: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateApiAccessRule", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_api_access_rule_arg a = {0};
		     struct osc_update_api_access_rule_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_api_access_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_api_access_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "ApiAccessRuleId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ApiAccessRuleId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ApiAccessRuleId argument missing\n");
				          s->api_access_rule_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "CaIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CaIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "CaIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "CaIds require an index\n");
				                    if (s->ca_ids) {
				                            for (; s->ca_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->ca_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->ca_ids, "", pa);
				                            SET_NEXT(s->ca_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "CaIds argument missing\n");
				                   s->ca_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "CaIds[]")) || aret == '=') {
				             TRY(!aa, "CaIds[] argument missing\n");
				             SET_NEXT(s->ca_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Cns")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Cns argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "Cns argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "Cns require an index\n");
				                    if (s->cns) {
				                            for (; s->cns[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->cns[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->cns, "", pa);
				                            SET_NEXT(s->cns, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "Cns argument missing\n");
				                   s->cns_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "Cns[]")) || aret == '=') {
				             TRY(!aa, "Cns[] argument missing\n");
				             SET_NEXT(s->cns, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "IpRanges")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IpRanges argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "IpRanges argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "IpRanges require an index\n");
				                    if (s->ip_ranges) {
				                            for (; s->ip_ranges[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->ip_ranges[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->ip_ranges, "", pa);
				                            SET_NEXT(s->ip_ranges, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "IpRanges argument missing\n");
				                   s->ip_ranges_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "IpRanges[]")) || aret == '=') {
				             TRY(!aa, "IpRanges[] argument missing\n");
				             SET_NEXT(s->ip_ranges, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateApiAccessRule'\n", next_a);
			    }
		            i += incr;
			    goto update_api_access_rule_arg;
		     }
		     cret = osc_update_api_access_rule(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateApiAccessRule: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateApiAccessPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_api_access_policy_arg a = {0};
		     struct osc_update_api_access_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_api_access_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_api_access_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "MaxAccessKeyExpirationSeconds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "MaxAccessKeyExpirationSeconds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "MaxAccessKeyExpirationSeconds argument missing\n");
				          s->is_set_max_access_key_expiration_seconds = 1;
				          s->max_access_key_expiration_seconds = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "RequireTrustedEnv")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RequireTrustedEnv argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_require_trusted_env = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->require_trusted_env = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->require_trusted_env = 0;
				           } else {
				          		BAD_RET("RequireTrustedEnv require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateApiAccessPolicy'\n", next_a);
			    }
		            i += incr;
			    goto update_api_access_policy_arg;
		     }
		     cret = osc_update_api_access_policy(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateApiAccessPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateAccount", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_account_arg a = {0};
		     struct osc_update_account_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_account_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_account_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AdditionalEmails")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AdditionalEmails argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "AdditionalEmails argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "AdditionalEmails require an index\n");
				                    if (s->additional_emails) {
				                            for (; s->additional_emails[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->additional_emails[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->additional_emails, "", pa);
				                            SET_NEXT(s->additional_emails, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "AdditionalEmails argument missing\n");
				                   s->additional_emails_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "AdditionalEmails[]")) || aret == '=') {
				             TRY(!aa, "AdditionalEmails[] argument missing\n");
				             SET_NEXT(s->additional_emails, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "City")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "City argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "City argument missing\n");
				          s->city = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "CompanyName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CompanyName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CompanyName argument missing\n");
				          s->company_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Country")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Country argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Country argument missing\n");
				          s->country = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Email")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Email argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Email argument missing\n");
				          s->email = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "FirstName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FirstName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FirstName argument missing\n");
				          s->first_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "JobTitle")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "JobTitle argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "JobTitle argument missing\n");
				          s->job_title = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "LastName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LastName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LastName argument missing\n");
				          s->last_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "MobileNumber")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "MobileNumber argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "MobileNumber argument missing\n");
				          s->mobile_number = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PhoneNumber")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PhoneNumber argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PhoneNumber argument missing\n");
				          s->phone_number = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "StateProvince")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "StateProvince argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "StateProvince argument missing\n");
				          s->state_province = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VatNumber")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VatNumber argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VatNumber argument missing\n");
				          s->vat_number = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ZipCode")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ZipCode argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ZipCode argument missing\n");
				          s->zip_code = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateAccount'\n", next_a);
			    }
		            i += incr;
			    goto update_account_arg;
		     }
		     cret = osc_update_account(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateAccount: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UpdateAccessKey", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_update_access_key_arg a = {0};
		     struct osc_update_access_key_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     update_access_key_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto update_access_key_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AccessKeyId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AccessKeyId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "AccessKeyId argument missing\n");
				          s->access_key_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ExpirationDate")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ExpirationDate argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ExpirationDate argument missing\n");
				          s->expiration_date = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "State")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "State argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "State argument missing\n");
				          s->state = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UpdateAccessKey'\n", next_a);
			    }
		            i += incr;
			    goto update_access_key_arg;
		     }
		     cret = osc_update_access_key(&e, &r, &a);
            	     TRY(cret, "fail to call UpdateAccessKey: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkVolume", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_volume_arg a = {0};
		     struct osc_unlink_volume_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ForceUnlink")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ForceUnlink argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_force_unlink = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->force_unlink = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->force_unlink = 0;
				           } else {
				          		BAD_RET("ForceUnlink require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VolumeId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VolumeId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkVolume'\n", next_a);
			    }
		            i += incr;
			    goto unlink_volume_arg;
		     }
		     cret = osc_unlink_volume(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkVolume: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkVirtualGateway", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_virtual_gateway_arg a = {0};
		     struct osc_unlink_virtual_gateway_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_virtual_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_virtual_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VirtualGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VirtualGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkVirtualGateway'\n", next_a);
			    }
		            i += incr;
			    goto unlink_virtual_gateway_arg;
		     }
		     cret = osc_unlink_virtual_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkVirtualGateway: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkRouteTable", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_route_table_arg a = {0};
		     struct osc_unlink_route_table_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_route_table_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_route_table_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LinkRouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LinkRouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LinkRouteTableId argument missing\n");
				          s->link_route_table_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkRouteTable'\n", next_a);
			    }
		            i += incr;
			    goto unlink_route_table_arg;
		     }
		     cret = osc_unlink_route_table(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkRouteTable: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkPublicIp", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_public_ip_arg a = {0};
		     struct osc_unlink_public_ip_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_public_ip_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_public_ip_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LinkPublicIpId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LinkPublicIpId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LinkPublicIpId argument missing\n");
				          s->link_public_ip_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PublicIp")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIp argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkPublicIp'\n", next_a);
			    }
		            i += incr;
			    goto unlink_public_ip_arg;
		     }
		     cret = osc_unlink_public_ip(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkPublicIp: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkPrivateIps", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_private_ips_arg a = {0};
		     struct osc_unlink_private_ips_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_private_ips_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_private_ips_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PrivateIps")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PrivateIps argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "PrivateIps argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "PrivateIps require an index\n");
				                    if (s->private_ips) {
				                            for (; s->private_ips[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->private_ips[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->private_ips, "", pa);
				                            SET_NEXT(s->private_ips, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "PrivateIps argument missing\n");
				                   s->private_ips_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "PrivateIps[]")) || aret == '=') {
				             TRY(!aa, "PrivateIps[] argument missing\n");
				             SET_NEXT(s->private_ips, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkPrivateIps'\n", next_a);
			    }
		            i += incr;
			    goto unlink_private_ips_arg;
		     }
		     cret = osc_unlink_private_ips(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkPrivateIps: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_policy_arg a = {0};
		     struct osc_unlink_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkPolicy'\n", next_a);
			    }
		            i += incr;
			    goto unlink_policy_arg;
		     }
		     cret = osc_unlink_policy(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkNic", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_nic_arg a = {0};
		     struct osc_unlink_nic_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LinkNicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LinkNicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LinkNicId argument missing\n");
				          s->link_nic_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkNic'\n", next_a);
			    }
		            i += incr;
			    goto unlink_nic_arg;
		     }
		     cret = osc_unlink_nic(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkNic: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkManagedPolicyFromUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_managed_policy_from_user_group_arg a = {0};
		     struct osc_unlink_managed_policy_from_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_managed_policy_from_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_managed_policy_from_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkManagedPolicyFromUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto unlink_managed_policy_from_user_group_arg;
		     }
		     cret = osc_unlink_managed_policy_from_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkManagedPolicyFromUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkLoadBalancerBackendMachines", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_load_balancer_backend_machines_arg a = {0};
		     struct osc_unlink_load_balancer_backend_machines_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_load_balancer_backend_machines_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_load_balancer_backend_machines_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "BackendIps")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BackendIps argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "BackendIps argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "BackendIps require an index\n");
				                    if (s->backend_ips) {
				                            for (; s->backend_ips[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->backend_ips[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->backend_ips, "", pa);
				                            SET_NEXT(s->backend_ips, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "BackendIps argument missing\n");
				                   s->backend_ips_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "BackendIps[]")) || aret == '=') {
				             TRY(!aa, "BackendIps[] argument missing\n");
				             SET_NEXT(s->backend_ips, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "BackendVmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BackendVmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "BackendVmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "BackendVmIds require an index\n");
				                    if (s->backend_vm_ids) {
				                            for (; s->backend_vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->backend_vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->backend_vm_ids, "", pa);
				                            SET_NEXT(s->backend_vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "BackendVmIds argument missing\n");
				                   s->backend_vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "BackendVmIds[]")) || aret == '=') {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkLoadBalancerBackendMachines'\n", next_a);
			    }
		            i += incr;
			    goto unlink_load_balancer_backend_machines_arg;
		     }
		     cret = osc_unlink_load_balancer_backend_machines(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkLoadBalancerBackendMachines: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkInternetService", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_internet_service_arg a = {0};
		     struct osc_unlink_internet_service_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_internet_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_internet_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "InternetServiceId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "InternetServiceId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "InternetServiceId argument missing\n");
				          s->internet_service_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkInternetService'\n", next_a);
			    }
		            i += incr;
			    goto unlink_internet_service_arg;
		     }
		     cret = osc_unlink_internet_service(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkInternetService: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("UnlinkFlexibleGpu", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_unlink_flexible_gpu_arg a = {0};
		     struct osc_unlink_flexible_gpu_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     unlink_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto unlink_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "FlexibleGpuId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FlexibleGpuId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FlexibleGpuId argument missing\n");
				          s->flexible_gpu_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'UnlinkFlexibleGpu'\n", next_a);
			    }
		            i += incr;
			    goto unlink_flexible_gpu_arg;
		     }
		     cret = osc_unlink_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call UnlinkFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("StopVms", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_stop_vms_arg a = {0};
		     struct osc_stop_vms_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     stop_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto stop_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ForceStop")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ForceStop argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_force_stop = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->force_stop = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->force_stop = 0;
				           } else {
				          		BAD_RET("ForceStop require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "VmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "VmIds require an index\n");
				                    if (s->vm_ids) {
				                            for (; s->vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->vm_ids, "", pa);
				                            SET_NEXT(s->vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "VmIds argument missing\n");
				                   s->vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'StopVms'\n", next_a);
			    }
		            i += incr;
			    goto stop_vms_arg;
		     }
		     cret = osc_stop_vms(&e, &r, &a);
            	     TRY(cret, "fail to call StopVms: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("StartVms", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_start_vms_arg a = {0};
		     struct osc_start_vms_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     start_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto start_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "VmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "VmIds require an index\n");
				                    if (s->vm_ids) {
				                            for (; s->vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->vm_ids, "", pa);
				                            SET_NEXT(s->vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "VmIds argument missing\n");
				                   s->vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'StartVms'\n", next_a);
			    }
		            i += incr;
			    goto start_vms_arg;
		     }
		     cret = osc_start_vms(&e, &r, &a);
            	     TRY(cret, "fail to call StartVms: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("SetDefaultPolicyVersion", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_set_default_policy_version_arg a = {0};
		     struct osc_set_default_policy_version_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     set_default_policy_version_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto set_default_policy_version_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VersionId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VersionId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VersionId argument missing\n");
				          s->version_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'SetDefaultPolicyVersion'\n", next_a);
			    }
		            i += incr;
			    goto set_default_policy_version_arg;
		     }
		     cret = osc_set_default_policy_version(&e, &r, &a);
            	     TRY(cret, "fail to call SetDefaultPolicyVersion: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ScaleUpVmGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_scale_up_vm_group_arg a = {0};
		     struct osc_scale_up_vm_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     scale_up_vm_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto scale_up_vm_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmAddition")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmAddition argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmAddition argument missing\n");
				          s->is_set_vm_addition = 1;
				          s->vm_addition = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "VmGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmGroupId argument missing\n");
				          s->vm_group_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ScaleUpVmGroup'\n", next_a);
			    }
		            i += incr;
			    goto scale_up_vm_group_arg;
		     }
		     cret = osc_scale_up_vm_group(&e, &r, &a);
            	     TRY(cret, "fail to call ScaleUpVmGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ScaleDownVmGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_scale_down_vm_group_arg a = {0};
		     struct osc_scale_down_vm_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     scale_down_vm_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto scale_down_vm_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmGroupId argument missing\n");
				          s->vm_group_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmSubtraction")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmSubtraction argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmSubtraction argument missing\n");
				          s->is_set_vm_subtraction = 1;
				          s->vm_subtraction = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ScaleDownVmGroup'\n", next_a);
			    }
		            i += incr;
			    goto scale_down_vm_group_arg;
		     }
		     cret = osc_scale_down_vm_group(&e, &r, &a);
            	     TRY(cret, "fail to call ScaleDownVmGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("RemoveUserFromUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_remove_user_from_user_group_arg a = {0};
		     struct osc_remove_user_from_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     remove_user_from_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto remove_user_from_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupPath argument missing\n");
				          s->user_group_path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserPath argument missing\n");
				          s->user_path = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'RemoveUserFromUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto remove_user_from_user_group_arg;
		     }
		     cret = osc_remove_user_from_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call RemoveUserFromUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("RejectNetPeering", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_reject_net_peering_arg a = {0};
		     struct osc_reject_net_peering_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     reject_net_peering_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto reject_net_peering_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetPeeringId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetPeeringId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'RejectNetPeering'\n", next_a);
			    }
		            i += incr;
			    goto reject_net_peering_arg;
		     }
		     cret = osc_reject_net_peering(&e, &r, &a);
            	     TRY(cret, "fail to call RejectNetPeering: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("RegisterVmsInLoadBalancer", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_register_vms_in_load_balancer_arg a = {0};
		     struct osc_register_vms_in_load_balancer_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     register_vms_in_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto register_vms_in_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "BackendVmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BackendVmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "BackendVmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "BackendVmIds require an index\n");
				                    if (s->backend_vm_ids) {
				                            for (; s->backend_vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->backend_vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->backend_vm_ids, "", pa);
				                            SET_NEXT(s->backend_vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "BackendVmIds argument missing\n");
				                   s->backend_vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "BackendVmIds[]")) || aret == '=') {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'RegisterVmsInLoadBalancer'\n", next_a);
			    }
		            i += incr;
			    goto register_vms_in_load_balancer_arg;
		     }
		     cret = osc_register_vms_in_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call RegisterVmsInLoadBalancer: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("RebootVms", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_reboot_vms_arg a = {0};
		     struct osc_reboot_vms_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     reboot_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto reboot_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "VmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "VmIds require an index\n");
				                    if (s->vm_ids) {
				                            for (; s->vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->vm_ids, "", pa);
				                            SET_NEXT(s->vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "VmIds argument missing\n");
				                   s->vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'RebootVms'\n", next_a);
			    }
		            i += incr;
			    goto reboot_vms_arg;
		     }
		     cret = osc_reboot_vms(&e, &r, &a);
            	     TRY(cret, "fail to call RebootVms: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVpnConnections", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vpn_connections_arg a = {0};
		     struct osc_read_vpn_connections_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vpn_connections_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_vpn_connections_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vpn_connection_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_vpn_connection_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVpnConnections'\n", next_a);
			    }
		            i += incr;
			    goto read_vpn_connections_arg;
		     }
		     cret = osc_read_vpn_connections(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVpnConnections: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVolumes", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_volumes_arg a = {0};
		     struct osc_read_volumes_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_volumes_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_volumes_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_volume_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_volume_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVolumes'\n", next_a);
			    }
		            i += incr;
			    goto read_volumes_arg;
		     }
		     cret = osc_read_volumes(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVolumes: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVmsState", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vms_state_arg a = {0};
		     struct osc_read_vms_state_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vms_state_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_vms_state_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AllVms")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AllVms argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_all_vms = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->all_vms = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->all_vms = 0;
				           } else {
				          		BAD_RET("AllVms require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vms_state_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_vms_state_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVmsState'\n", next_a);
			    }
		            i += incr;
			    goto read_vms_state_arg;
		     }
		     cret = osc_read_vms_state(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVmsState: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVmsHealth", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vms_health_arg a = {0};
		     struct osc_read_vms_health_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vms_health_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_vms_health_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "BackendVmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BackendVmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "BackendVmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "BackendVmIds require an index\n");
				                    if (s->backend_vm_ids) {
				                            for (; s->backend_vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->backend_vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->backend_vm_ids, "", pa);
				                            SET_NEXT(s->backend_vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "BackendVmIds argument missing\n");
				                   s->backend_vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "BackendVmIds[]")) || aret == '=') {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVmsHealth'\n", next_a);
			    }
		            i += incr;
			    goto read_vms_health_arg;
		     }
		     cret = osc_read_vms_health(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVmsHealth: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVms", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vms_arg a = {0};
		     struct osc_read_vms_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vm_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_vm_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVms'\n", next_a);
			    }
		            i += incr;
			    goto read_vms_arg;
		     }
		     cret = osc_read_vms(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVms: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVmTypes", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vm_types_arg a = {0};
		     struct osc_read_vm_types_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vm_types_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_vm_types_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vm_type_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_vm_type_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVmTypes'\n", next_a);
			    }
		            i += incr;
			    goto read_vm_types_arg;
		     }
		     cret = osc_read_vm_types(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVmTypes: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVmTemplates", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vm_templates_arg a = {0};
		     struct osc_read_vm_templates_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vm_templates_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_vm_templates_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vm_template_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_vm_template_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVmTemplates'\n", next_a);
			    }
		            i += incr;
			    goto read_vm_templates_arg;
		     }
		     cret = osc_read_vm_templates(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVmTemplates: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVmGroups", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_vm_groups_arg a = {0};
		     struct osc_read_vm_groups_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_vm_groups_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_vm_groups_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_vm_group_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_vm_group_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVmGroups'\n", next_a);
			    }
		            i += incr;
			    goto read_vm_groups_arg;
		     }
		     cret = osc_read_vm_groups(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVmGroups: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadVirtualGateways", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_virtual_gateways_arg a = {0};
		     struct osc_read_virtual_gateways_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_virtual_gateways_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_virtual_gateways_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_virtual_gateway_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_virtual_gateway_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadVirtualGateways'\n", next_a);
			    }
		            i += incr;
			    goto read_virtual_gateways_arg;
		     }
		     cret = osc_read_virtual_gateways(&e, &r, &a);
            	     TRY(cret, "fail to call ReadVirtualGateways: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadUsers", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_users_arg a = {0};
		     struct osc_read_users_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_users_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_users_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadUsers'\n", next_a);
			    }
		            i += incr;
			    goto read_users_arg;
		     }
		     cret = osc_read_users(&e, &r, &a);
            	     TRY(cret, "fail to call ReadUsers: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadUserGroupsPerUser", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_user_groups_per_user_arg a = {0};
		     struct osc_read_user_groups_per_user_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_user_groups_per_user_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_user_groups_per_user_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserPath argument missing\n");
				          s->user_path = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadUserGroupsPerUser'\n", next_a);
			    }
		            i += incr;
			    goto read_user_groups_per_user_arg;
		     }
		     cret = osc_read_user_groups_per_user(&e, &r, &a);
            	     TRY(cret, "fail to call ReadUserGroupsPerUser: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadUserGroups", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_user_groups_arg a = {0};
		     struct osc_read_user_groups_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_user_groups_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_user_groups_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_user_group_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_user_group_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "FirstItem")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FirstItem argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FirstItem argument missing\n");
				          s->is_set_first_item = 1;
				          s->first_item = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadUserGroups'\n", next_a);
			    }
		            i += incr;
			    goto read_user_groups_arg;
		     }
		     cret = osc_read_user_groups(&e, &r, &a);
            	     TRY(cret, "fail to call ReadUserGroups: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadUserGroupPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_user_group_policy_arg a = {0};
		     struct osc_read_user_group_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_user_group_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_user_group_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PolicyName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyName argument missing\n");
				          s->policy_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupPath argument missing\n");
				          s->user_group_path = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadUserGroupPolicy'\n", next_a);
			    }
		            i += incr;
			    goto read_user_group_policy_arg;
		     }
		     cret = osc_read_user_group_policy(&e, &r, &a);
            	     TRY(cret, "fail to call ReadUserGroupPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadUserGroupPolicies", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_user_group_policies_arg a = {0};
		     struct osc_read_user_group_policies_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_user_group_policies_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_user_group_policies_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "FirstItem")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FirstItem argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FirstItem argument missing\n");
				          s->is_set_first_item = 1;
				          s->first_item = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupPath argument missing\n");
				          s->user_group_path = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadUserGroupPolicies'\n", next_a);
			    }
		            i += incr;
			    goto read_user_group_policies_arg;
		     }
		     cret = osc_read_user_group_policies(&e, &r, &a);
            	     TRY(cret, "fail to call ReadUserGroupPolicies: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_user_group_arg a = {0};
		     struct osc_read_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Path")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Path argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Path argument missing\n");
				          s->path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto read_user_group_arg;
		     }
		     cret = osc_read_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call ReadUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadTags", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_tags_arg a = {0};
		     struct osc_read_tags_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_tag_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_tag_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadTags'\n", next_a);
			    }
		            i += incr;
			    goto read_tags_arg;
		     }
		     cret = osc_read_tags(&e, &r, &a);
            	     TRY(cret, "fail to call ReadTags: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadSubregions", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_subregions_arg a = {0};
		     struct osc_read_subregions_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_subregions_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_subregions_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_subregion_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_subregion_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadSubregions'\n", next_a);
			    }
		            i += incr;
			    goto read_subregions_arg;
		     }
		     cret = osc_read_subregions(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSubregions: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadSubnets", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_subnets_arg a = {0};
		     struct osc_read_subnets_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_subnets_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_subnets_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_subnet_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_subnet_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadSubnets'\n", next_a);
			    }
		            i += incr;
			    goto read_subnets_arg;
		     }
		     cret = osc_read_subnets(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSubnets: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadSnapshots", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_snapshots_arg a = {0};
		     struct osc_read_snapshots_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_snapshots_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_snapshots_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_snapshot_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_snapshot_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadSnapshots'\n", next_a);
			    }
		            i += incr;
			    goto read_snapshots_arg;
		     }
		     cret = osc_read_snapshots(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSnapshots: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadSnapshotExportTasks", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_snapshot_export_tasks_arg a = {0};
		     struct osc_read_snapshot_export_tasks_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_snapshot_export_tasks_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_snapshot_export_tasks_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_export_task_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_export_task_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadSnapshotExportTasks'\n", next_a);
			    }
		            i += incr;
			    goto read_snapshot_export_tasks_arg;
		     }
		     cret = osc_read_snapshot_export_tasks(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSnapshotExportTasks: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadServerCertificates", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_server_certificates_arg a = {0};
		     struct osc_read_server_certificates_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_server_certificates_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_server_certificates_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_server_certificate_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_server_certificate_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadServerCertificates'\n", next_a);
			    }
		            i += incr;
			    goto read_server_certificates_arg;
		     }
		     cret = osc_read_server_certificates(&e, &r, &a);
            	     TRY(cret, "fail to call ReadServerCertificates: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadSecurityGroups", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_security_groups_arg a = {0};
		     struct osc_read_security_groups_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_security_groups_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_security_groups_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_security_group_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_security_group_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadSecurityGroups'\n", next_a);
			    }
		            i += incr;
			    goto read_security_groups_arg;
		     }
		     cret = osc_read_security_groups(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSecurityGroups: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadSecretAccessKey", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_secret_access_key_arg a = {0};
		     struct osc_read_secret_access_key_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_secret_access_key_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_secret_access_key_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AccessKeyId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AccessKeyId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "AccessKeyId argument missing\n");
				          s->access_key_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadSecretAccessKey'\n", next_a);
			    }
		            i += incr;
			    goto read_secret_access_key_arg;
		     }
		     cret = osc_read_secret_access_key(&e, &r, &a);
            	     TRY(cret, "fail to call ReadSecretAccessKey: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadRouteTables", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_route_tables_arg a = {0};
		     struct osc_read_route_tables_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_route_tables_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_route_tables_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_route_table_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_route_table_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadRouteTables'\n", next_a);
			    }
		            i += incr;
			    goto read_route_tables_arg;
		     }
		     cret = osc_read_route_tables(&e, &r, &a);
            	     TRY(cret, "fail to call ReadRouteTables: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadRegions", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_regions_arg a = {0};
		     struct osc_read_regions_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_regions_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_regions_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadRegions'\n", next_a);
			    }
		            i += incr;
			    goto read_regions_arg;
		     }
		     cret = osc_read_regions(&e, &r, &a);
            	     TRY(cret, "fail to call ReadRegions: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadQuotas", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_quotas_arg a = {0};
		     struct osc_read_quotas_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_quotas_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_quotas_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_quota_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_quota_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadQuotas'\n", next_a);
			    }
		            i += incr;
			    goto read_quotas_arg;
		     }
		     cret = osc_read_quotas(&e, &r, &a);
            	     TRY(cret, "fail to call ReadQuotas: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadPublicIps", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_public_ips_arg a = {0};
		     struct osc_read_public_ips_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_public_ips_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_public_ips_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_public_ip_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_public_ip_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadPublicIps'\n", next_a);
			    }
		            i += incr;
			    goto read_public_ips_arg;
		     }
		     cret = osc_read_public_ips(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPublicIps: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadPublicIpRanges", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_public_ip_ranges_arg a = {0};
		     struct osc_read_public_ip_ranges_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_public_ip_ranges_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_public_ip_ranges_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadPublicIpRanges'\n", next_a);
			    }
		            i += incr;
			    goto read_public_ip_ranges_arg;
		     }
		     cret = osc_read_public_ip_ranges(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPublicIpRanges: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadPublicCatalog", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_public_catalog_arg a = {0};
		     struct osc_read_public_catalog_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_public_catalog_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_public_catalog_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadPublicCatalog'\n", next_a);
			    }
		            i += incr;
			    goto read_public_catalog_arg;
		     }
		     cret = osc_read_public_catalog(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPublicCatalog: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadProductTypes", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_product_types_arg a = {0};
		     struct osc_read_product_types_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_product_types_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_product_types_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_product_type_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_product_type_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadProductTypes'\n", next_a);
			    }
		            i += incr;
			    goto read_product_types_arg;
		     }
		     cret = osc_read_product_types(&e, &r, &a);
            	     TRY(cret, "fail to call ReadProductTypes: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadPolicyVersions", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_policy_versions_arg a = {0};
		     struct osc_read_policy_versions_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_policy_versions_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_policy_versions_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "FirstItem")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FirstItem argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FirstItem argument missing\n");
				          s->is_set_first_item = 1;
				          s->first_item = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadPolicyVersions'\n", next_a);
			    }
		            i += incr;
			    goto read_policy_versions_arg;
		     }
		     cret = osc_read_policy_versions(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPolicyVersions: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadPolicyVersion", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_policy_version_arg a = {0};
		     struct osc_read_policy_version_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_policy_version_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_policy_version_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VersionId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VersionId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VersionId argument missing\n");
				          s->version_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadPolicyVersion'\n", next_a);
			    }
		            i += incr;
			    goto read_policy_version_arg;
		     }
		     cret = osc_read_policy_version(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPolicyVersion: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_policy_arg a = {0};
		     struct osc_read_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadPolicy'\n", next_a);
			    }
		            i += incr;
			    goto read_policy_arg;
		     }
		     cret = osc_read_policy(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadPolicies", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_policies_arg a = {0};
		     struct osc_read_policies_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_policies_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_policies_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = read_policies_filters_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(read_policies_filters_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "FirstItem")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FirstItem argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FirstItem argument missing\n");
				          s->is_set_first_item = 1;
				          s->first_item = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadPolicies'\n", next_a);
			    }
		            i += incr;
			    goto read_policies_arg;
		     }
		     cret = osc_read_policies(&e, &r, &a);
            	     TRY(cret, "fail to call ReadPolicies: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadNics", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_nics_arg a = {0};
		     struct osc_read_nics_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_nics_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_nics_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_nic_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_nic_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadNics'\n", next_a);
			    }
		            i += incr;
			    goto read_nics_arg;
		     }
		     cret = osc_read_nics(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNics: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadNets", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_nets_arg a = {0};
		     struct osc_read_nets_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_nets_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_nets_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_net_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_net_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadNets'\n", next_a);
			    }
		            i += incr;
			    goto read_nets_arg;
		     }
		     cret = osc_read_nets(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNets: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadNetPeerings", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_net_peerings_arg a = {0};
		     struct osc_read_net_peerings_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_net_peerings_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_net_peerings_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_net_peering_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_net_peering_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadNetPeerings'\n", next_a);
			    }
		            i += incr;
			    goto read_net_peerings_arg;
		     }
		     cret = osc_read_net_peerings(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNetPeerings: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadNetAccessPoints", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_net_access_points_arg a = {0};
		     struct osc_read_net_access_points_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_net_access_points_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_net_access_points_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_net_access_point_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_net_access_point_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadNetAccessPoints'\n", next_a);
			    }
		            i += incr;
			    goto read_net_access_points_arg;
		     }
		     cret = osc_read_net_access_points(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNetAccessPoints: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadNetAccessPointServices", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_net_access_point_services_arg a = {0};
		     struct osc_read_net_access_point_services_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_net_access_point_services_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_net_access_point_services_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_service_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_service_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadNetAccessPointServices'\n", next_a);
			    }
		            i += incr;
			    goto read_net_access_point_services_arg;
		     }
		     cret = osc_read_net_access_point_services(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNetAccessPointServices: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadNatServices", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_nat_services_arg a = {0};
		     struct osc_read_nat_services_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_nat_services_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_nat_services_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_nat_service_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_nat_service_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadNatServices'\n", next_a);
			    }
		            i += incr;
			    goto read_nat_services_arg;
		     }
		     cret = osc_read_nat_services(&e, &r, &a);
            	     TRY(cret, "fail to call ReadNatServices: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadManagedPoliciesLinkedToUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_managed_policies_linked_to_user_group_arg a = {0};
		     struct osc_read_managed_policies_linked_to_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_managed_policies_linked_to_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_managed_policies_linked_to_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_user_group_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_user_group_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "FirstItem")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FirstItem argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FirstItem argument missing\n");
				          s->is_set_first_item = 1;
				          s->first_item = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadManagedPoliciesLinkedToUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto read_managed_policies_linked_to_user_group_arg;
		     }
		     cret = osc_read_managed_policies_linked_to_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call ReadManagedPoliciesLinkedToUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadLocations", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_locations_arg a = {0};
		     struct osc_read_locations_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_locations_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_locations_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadLocations'\n", next_a);
			    }
		            i += incr;
			    goto read_locations_arg;
		     }
		     cret = osc_read_locations(&e, &r, &a);
            	     TRY(cret, "fail to call ReadLocations: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadLoadBalancers", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_load_balancers_arg a = {0};
		     struct osc_read_load_balancers_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_load_balancers_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_load_balancers_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_load_balancer_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_load_balancer_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadLoadBalancers'\n", next_a);
			    }
		            i += incr;
			    goto read_load_balancers_arg;
		     }
		     cret = osc_read_load_balancers(&e, &r, &a);
            	     TRY(cret, "fail to call ReadLoadBalancers: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadLoadBalancerTags", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_load_balancer_tags_arg a = {0};
		     struct osc_read_load_balancer_tags_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_load_balancer_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_load_balancer_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerNames")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerNames argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "LoadBalancerNames argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "LoadBalancerNames require an index\n");
				                    if (s->load_balancer_names) {
				                            for (; s->load_balancer_names[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->load_balancer_names[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->load_balancer_names, "", pa);
				                            SET_NEXT(s->load_balancer_names, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "LoadBalancerNames argument missing\n");
				                   s->load_balancer_names_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "LoadBalancerNames[]")) || aret == '=') {
				             TRY(!aa, "LoadBalancerNames[] argument missing\n");
				             SET_NEXT(s->load_balancer_names, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadLoadBalancerTags'\n", next_a);
			    }
		            i += incr;
			    goto read_load_balancer_tags_arg;
		     }
		     cret = osc_read_load_balancer_tags(&e, &r, &a);
            	     TRY(cret, "fail to call ReadLoadBalancerTags: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadListenerRules", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_listener_rules_arg a = {0};
		     struct osc_read_listener_rules_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_listener_rules_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_listener_rules_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_listener_rule_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_listener_rule_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadListenerRules'\n", next_a);
			    }
		            i += incr;
			    goto read_listener_rules_arg;
		     }
		     cret = osc_read_listener_rules(&e, &r, &a);
            	     TRY(cret, "fail to call ReadListenerRules: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadLinkedPolicies", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_linked_policies_arg a = {0};
		     struct osc_read_linked_policies_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_linked_policies_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_linked_policies_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = read_linked_policies_filters_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(read_linked_policies_filters_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "FirstItem")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FirstItem argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FirstItem argument missing\n");
				          s->is_set_first_item = 1;
				          s->first_item = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadLinkedPolicies'\n", next_a);
			    }
		            i += incr;
			    goto read_linked_policies_arg;
		     }
		     cret = osc_read_linked_policies(&e, &r, &a);
            	     TRY(cret, "fail to call ReadLinkedPolicies: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadKeypairs", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_keypairs_arg a = {0};
		     struct osc_read_keypairs_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_keypairs_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_keypairs_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_keypair_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_keypair_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadKeypairs'\n", next_a);
			    }
		            i += incr;
			    goto read_keypairs_arg;
		     }
		     cret = osc_read_keypairs(&e, &r, &a);
            	     TRY(cret, "fail to call ReadKeypairs: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadInternetServices", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_internet_services_arg a = {0};
		     struct osc_read_internet_services_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_internet_services_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_internet_services_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_internet_service_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_internet_service_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadInternetServices'\n", next_a);
			    }
		            i += incr;
			    goto read_internet_services_arg;
		     }
		     cret = osc_read_internet_services(&e, &r, &a);
            	     TRY(cret, "fail to call ReadInternetServices: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadImages", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_images_arg a = {0};
		     struct osc_read_images_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_images_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_images_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_image_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_image_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadImages'\n", next_a);
			    }
		            i += incr;
			    goto read_images_arg;
		     }
		     cret = osc_read_images(&e, &r, &a);
            	     TRY(cret, "fail to call ReadImages: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadImageExportTasks", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_image_export_tasks_arg a = {0};
		     struct osc_read_image_export_tasks_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_image_export_tasks_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_image_export_tasks_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_export_task_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_export_task_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadImageExportTasks'\n", next_a);
			    }
		            i += incr;
			    goto read_image_export_tasks_arg;
		     }
		     cret = osc_read_image_export_tasks(&e, &r, &a);
            	     TRY(cret, "fail to call ReadImageExportTasks: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadFlexibleGpus", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_flexible_gpus_arg a = {0};
		     struct osc_read_flexible_gpus_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_flexible_gpus_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_flexible_gpus_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_flexible_gpu_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_flexible_gpu_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadFlexibleGpus'\n", next_a);
			    }
		            i += incr;
			    goto read_flexible_gpus_arg;
		     }
		     cret = osc_read_flexible_gpus(&e, &r, &a);
            	     TRY(cret, "fail to call ReadFlexibleGpus: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadFlexibleGpuCatalog", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_flexible_gpu_catalog_arg a = {0};
		     struct osc_read_flexible_gpu_catalog_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_flexible_gpu_catalog_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_flexible_gpu_catalog_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadFlexibleGpuCatalog'\n", next_a);
			    }
		            i += incr;
			    goto read_flexible_gpu_catalog_arg;
		     }
		     cret = osc_read_flexible_gpu_catalog(&e, &r, &a);
            	     TRY(cret, "fail to call ReadFlexibleGpuCatalog: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadDirectLinks", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_direct_links_arg a = {0};
		     struct osc_read_direct_links_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_direct_links_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_direct_links_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_direct_link_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_direct_link_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadDirectLinks'\n", next_a);
			    }
		            i += incr;
			    goto read_direct_links_arg;
		     }
		     cret = osc_read_direct_links(&e, &r, &a);
            	     TRY(cret, "fail to call ReadDirectLinks: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadDirectLinkInterfaces", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_direct_link_interfaces_arg a = {0};
		     struct osc_read_direct_link_interfaces_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_direct_link_interfaces_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_direct_link_interfaces_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_direct_link_interface_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_direct_link_interface_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadDirectLinkInterfaces'\n", next_a);
			    }
		            i += incr;
			    goto read_direct_link_interfaces_arg;
		     }
		     cret = osc_read_direct_link_interfaces(&e, &r, &a);
            	     TRY(cret, "fail to call ReadDirectLinkInterfaces: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadDhcpOptions", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_dhcp_options_arg a = {0};
		     struct osc_read_dhcp_options_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_dhcp_options_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_dhcp_options_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_dhcp_options_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_dhcp_options_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadDhcpOptions'\n", next_a);
			    }
		            i += incr;
			    goto read_dhcp_options_arg;
		     }
		     cret = osc_read_dhcp_options(&e, &r, &a);
            	     TRY(cret, "fail to call ReadDhcpOptions: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadDedicatedGroups", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_dedicated_groups_arg a = {0};
		     struct osc_read_dedicated_groups_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_dedicated_groups_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_dedicated_groups_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_dedicated_group_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_dedicated_group_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadDedicatedGroups'\n", next_a);
			    }
		            i += incr;
			    goto read_dedicated_groups_arg;
		     }
		     cret = osc_read_dedicated_groups(&e, &r, &a);
            	     TRY(cret, "fail to call ReadDedicatedGroups: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadConsumptionAccount", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_consumption_account_arg a = {0};
		     struct osc_read_consumption_account_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_consumption_account_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_consumption_account_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "FromDate")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FromDate argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FromDate argument missing\n");
				          s->from_date = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Overall")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Overall argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_overall = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->overall = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->overall = 0;
				           } else {
				          		BAD_RET("Overall require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ShowPrice")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ShowPrice argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_show_price = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->show_price = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->show_price = 0;
				           } else {
				          		BAD_RET("ShowPrice require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ToDate")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ToDate argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ToDate argument missing\n");
				          s->to_date = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadConsumptionAccount'\n", next_a);
			    }
		            i += incr;
			    goto read_consumption_account_arg;
		     }
		     cret = osc_read_consumption_account(&e, &r, &a);
            	     TRY(cret, "fail to call ReadConsumptionAccount: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadConsoleOutput", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_console_output_arg a = {0};
		     struct osc_read_console_output_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_console_output_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_console_output_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadConsoleOutput'\n", next_a);
			    }
		            i += incr;
			    goto read_console_output_arg;
		     }
		     cret = osc_read_console_output(&e, &r, &a);
            	     TRY(cret, "fail to call ReadConsoleOutput: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadClientGateways", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_client_gateways_arg a = {0};
		     struct osc_read_client_gateways_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_client_gateways_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_client_gateways_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_client_gateway_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_client_gateway_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadClientGateways'\n", next_a);
			    }
		            i += incr;
			    goto read_client_gateways_arg;
		     }
		     cret = osc_read_client_gateways(&e, &r, &a);
            	     TRY(cret, "fail to call ReadClientGateways: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadCatalogs", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_catalogs_arg a = {0};
		     struct osc_read_catalogs_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_catalogs_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_catalogs_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_catalogs_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_catalogs_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadCatalogs'\n", next_a);
			    }
		            i += incr;
			    goto read_catalogs_arg;
		     }
		     cret = osc_read_catalogs(&e, &r, &a);
            	     TRY(cret, "fail to call ReadCatalogs: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadCatalog", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_catalog_arg a = {0};
		     struct osc_read_catalog_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_catalog_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_catalog_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadCatalog'\n", next_a);
			    }
		            i += incr;
			    goto read_catalog_arg;
		     }
		     cret = osc_read_catalog(&e, &r, &a);
            	     TRY(cret, "fail to call ReadCatalog: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadCas", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_cas_arg a = {0};
		     struct osc_read_cas_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_cas_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_cas_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_ca_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_ca_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadCas'\n", next_a);
			    }
		            i += incr;
			    goto read_cas_arg;
		     }
		     cret = osc_read_cas(&e, &r, &a);
            	     TRY(cret, "fail to call ReadCas: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadApiLogs", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_api_logs_arg a = {0};
		     struct osc_read_api_logs_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_api_logs_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_api_logs_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_api_log_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_api_log_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "NextPageToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NextPageToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NextPageToken argument missing\n");
				          s->next_page_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ResultsPerPage")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResultsPerPage argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ResultsPerPage argument missing\n");
				          s->is_set_results_per_page = 1;
				          s->results_per_page = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "With")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "With argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "With argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->with;
				          	    cascade_parser = with_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(with_parser(&s->with, dot_pos, aa, pa));
				          	    s->is_set_with = 1;
				           } else {
				                 s->with_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadApiLogs'\n", next_a);
			    }
		            i += incr;
			    goto read_api_logs_arg;
		     }
		     cret = osc_read_api_logs(&e, &r, &a);
            	     TRY(cret, "fail to call ReadApiLogs: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadApiAccessRules", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_api_access_rules_arg a = {0};
		     struct osc_read_api_access_rules_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_api_access_rules_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_api_access_rules_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_api_access_rule_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_api_access_rule_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadApiAccessRules'\n", next_a);
			    }
		            i += incr;
			    goto read_api_access_rules_arg;
		     }
		     cret = osc_read_api_access_rules(&e, &r, &a);
            	     TRY(cret, "fail to call ReadApiAccessRules: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadApiAccessPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_api_access_policy_arg a = {0};
		     struct osc_read_api_access_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_api_access_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_api_access_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadApiAccessPolicy'\n", next_a);
			    }
		            i += incr;
			    goto read_api_access_policy_arg;
		     }
		     cret = osc_read_api_access_policy(&e, &r, &a);
            	     TRY(cret, "fail to call ReadApiAccessPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadAdminPassword", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_admin_password_arg a = {0};
		     struct osc_read_admin_password_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_admin_password_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_admin_password_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadAdminPassword'\n", next_a);
			    }
		            i += incr;
			    goto read_admin_password_arg;
		     }
		     cret = osc_read_admin_password(&e, &r, &a);
            	     TRY(cret, "fail to call ReadAdminPassword: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadAccounts", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_accounts_arg a = {0};
		     struct osc_read_accounts_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_accounts_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_accounts_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadAccounts'\n", next_a);
			    }
		            i += incr;
			    goto read_accounts_arg;
		     }
		     cret = osc_read_accounts(&e, &r, &a);
            	     TRY(cret, "fail to call ReadAccounts: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("ReadAccessKeys", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_read_access_keys_arg a = {0};
		     struct osc_read_access_keys_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     read_access_keys_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto read_access_keys_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Filters")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Filters argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Filters argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->filters;
				          	    cascade_parser = filters_access_keys_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(filters_access_keys_parser(&s->filters, dot_pos, aa, pa));
				          	    s->is_set_filters = 1;
				           } else {
				                 s->filters_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'ReadAccessKeys'\n", next_a);
			    }
		            i += incr;
			    goto read_access_keys_arg;
		     }
		     cret = osc_read_access_keys(&e, &r, &a);
            	     TRY(cret, "fail to call ReadAccessKeys: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("PutUserGroupPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_put_user_group_policy_arg a = {0};
		     struct osc_put_user_group_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     put_user_group_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto put_user_group_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PolicyDocument")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyDocument argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyDocument argument missing\n");
				          s->policy_document = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PolicyName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyName argument missing\n");
				          s->policy_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupPath argument missing\n");
				          s->user_group_path = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'PutUserGroupPolicy'\n", next_a);
			    }
		            i += incr;
			    goto put_user_group_policy_arg;
		     }
		     cret = osc_put_user_group_policy(&e, &r, &a);
            	     TRY(cret, "fail to call PutUserGroupPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkVolume", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_volume_arg a = {0};
		     struct osc_link_volume_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DeviceName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DeviceName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DeviceName argument missing\n");
				          s->device_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VolumeId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VolumeId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkVolume'\n", next_a);
			    }
		            i += incr;
			    goto link_volume_arg;
		     }
		     cret = osc_link_volume(&e, &r, &a);
            	     TRY(cret, "fail to call LinkVolume: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkVirtualGateway", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_virtual_gateway_arg a = {0};
		     struct osc_link_virtual_gateway_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_virtual_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_virtual_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VirtualGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VirtualGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkVirtualGateway'\n", next_a);
			    }
		            i += incr;
			    goto link_virtual_gateway_arg;
		     }
		     cret = osc_link_virtual_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call LinkVirtualGateway: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkRouteTable", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_route_table_arg a = {0};
		     struct osc_link_route_table_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_route_table_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_route_table_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "RouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SubnetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubnetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkRouteTable'\n", next_a);
			    }
		            i += incr;
			    goto link_route_table_arg;
		     }
		     cret = osc_link_route_table(&e, &r, &a);
            	     TRY(cret, "fail to call LinkRouteTable: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkPublicIp", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_public_ip_arg a = {0};
		     struct osc_link_public_ip_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_public_ip_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_public_ip_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AllowRelink")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AllowRelink argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_allow_relink = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->allow_relink = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->allow_relink = 0;
				           } else {
				          		BAD_RET("AllowRelink require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PrivateIp")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PrivateIp argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PrivateIp argument missing\n");
				          s->private_ip = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PublicIp")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIp argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PublicIpId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIpId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIpId argument missing\n");
				          s->public_ip_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkPublicIp'\n", next_a);
			    }
		            i += incr;
			    goto link_public_ip_arg;
		     }
		     cret = osc_link_public_ip(&e, &r, &a);
            	     TRY(cret, "fail to call LinkPublicIp: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkPrivateIps", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_private_ips_arg a = {0};
		     struct osc_link_private_ips_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_private_ips_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_private_ips_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AllowRelink")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AllowRelink argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_allow_relink = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->allow_relink = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->allow_relink = 0;
				           } else {
				          		BAD_RET("AllowRelink require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PrivateIps")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PrivateIps argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "PrivateIps argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "PrivateIps require an index\n");
				                    if (s->private_ips) {
				                            for (; s->private_ips[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->private_ips[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->private_ips, "", pa);
				                            SET_NEXT(s->private_ips, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "PrivateIps argument missing\n");
				                   s->private_ips_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "PrivateIps[]")) || aret == '=') {
				             TRY(!aa, "PrivateIps[] argument missing\n");
				             SET_NEXT(s->private_ips, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "SecondaryPrivateIpCount")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecondaryPrivateIpCount argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecondaryPrivateIpCount argument missing\n");
				          s->is_set_secondary_private_ip_count = 1;
				          s->secondary_private_ip_count = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkPrivateIps'\n", next_a);
			    }
		            i += incr;
			    goto link_private_ips_arg;
		     }
		     cret = osc_link_private_ips(&e, &r, &a);
            	     TRY(cret, "fail to call LinkPrivateIps: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_policy_arg a = {0};
		     struct osc_link_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkPolicy'\n", next_a);
			    }
		            i += incr;
			    goto link_policy_arg;
		     }
		     cret = osc_link_policy(&e, &r, &a);
            	     TRY(cret, "fail to call LinkPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkNic", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_nic_arg a = {0};
		     struct osc_link_nic_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DeviceNumber")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DeviceNumber argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DeviceNumber argument missing\n");
				          s->is_set_device_number = 1;
				          s->device_number = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkNic'\n", next_a);
			    }
		            i += incr;
			    goto link_nic_arg;
		     }
		     cret = osc_link_nic(&e, &r, &a);
            	     TRY(cret, "fail to call LinkNic: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkManagedPolicyToUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_managed_policy_to_user_group_arg a = {0};
		     struct osc_link_managed_policy_to_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_managed_policy_to_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_managed_policy_to_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkManagedPolicyToUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto link_managed_policy_to_user_group_arg;
		     }
		     cret = osc_link_managed_policy_to_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call LinkManagedPolicyToUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkLoadBalancerBackendMachines", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_load_balancer_backend_machines_arg a = {0};
		     struct osc_link_load_balancer_backend_machines_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_load_balancer_backend_machines_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_load_balancer_backend_machines_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "BackendIps")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BackendIps argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "BackendIps argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "BackendIps require an index\n");
				                    if (s->backend_ips) {
				                            for (; s->backend_ips[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->backend_ips[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->backend_ips, "", pa);
				                            SET_NEXT(s->backend_ips, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "BackendIps argument missing\n");
				                   s->backend_ips_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "BackendIps[]")) || aret == '=') {
				             TRY(!aa, "BackendIps[] argument missing\n");
				             SET_NEXT(s->backend_ips, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "BackendVmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BackendVmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "BackendVmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "BackendVmIds require an index\n");
				                    if (s->backend_vm_ids) {
				                            for (; s->backend_vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->backend_vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->backend_vm_ids, "", pa);
				                            SET_NEXT(s->backend_vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "BackendVmIds argument missing\n");
				                   s->backend_vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "BackendVmIds[]")) || aret == '=') {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkLoadBalancerBackendMachines'\n", next_a);
			    }
		            i += incr;
			    goto link_load_balancer_backend_machines_arg;
		     }
		     cret = osc_link_load_balancer_backend_machines(&e, &r, &a);
            	     TRY(cret, "fail to call LinkLoadBalancerBackendMachines: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkInternetService", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_internet_service_arg a = {0};
		     struct osc_link_internet_service_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_internet_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_internet_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "InternetServiceId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "InternetServiceId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "InternetServiceId argument missing\n");
				          s->internet_service_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkInternetService'\n", next_a);
			    }
		            i += incr;
			    goto link_internet_service_arg;
		     }
		     cret = osc_link_internet_service(&e, &r, &a);
            	     TRY(cret, "fail to call LinkInternetService: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("LinkFlexibleGpu", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_link_flexible_gpu_arg a = {0};
		     struct osc_link_flexible_gpu_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     link_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto link_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "FlexibleGpuId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FlexibleGpuId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FlexibleGpuId argument missing\n");
				          s->flexible_gpu_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'LinkFlexibleGpu'\n", next_a);
			    }
		            i += incr;
			    goto link_flexible_gpu_arg;
		     }
		     cret = osc_link_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call LinkFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeregisterVmsInLoadBalancer", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_deregister_vms_in_load_balancer_arg a = {0};
		     struct osc_deregister_vms_in_load_balancer_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     deregister_vms_in_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto deregister_vms_in_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "BackendVmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BackendVmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "BackendVmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "BackendVmIds require an index\n");
				                    if (s->backend_vm_ids) {
				                            for (; s->backend_vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->backend_vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->backend_vm_ids, "", pa);
				                            SET_NEXT(s->backend_vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "BackendVmIds argument missing\n");
				                   s->backend_vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "BackendVmIds[]")) || aret == '=') {
				             TRY(!aa, "BackendVmIds[] argument missing\n");
				             SET_NEXT(s->backend_vm_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeregisterVmsInLoadBalancer'\n", next_a);
			    }
		            i += incr;
			    goto deregister_vms_in_load_balancer_arg;
		     }
		     cret = osc_deregister_vms_in_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call DeregisterVmsInLoadBalancer: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteVpnConnectionRoute", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_vpn_connection_route_arg a = {0};
		     struct osc_delete_vpn_connection_route_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_vpn_connection_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_vpn_connection_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DestinationIpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DestinationIpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VpnConnectionId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VpnConnectionId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VpnConnectionId argument missing\n");
				          s->vpn_connection_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteVpnConnectionRoute'\n", next_a);
			    }
		            i += incr;
			    goto delete_vpn_connection_route_arg;
		     }
		     cret = osc_delete_vpn_connection_route(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVpnConnectionRoute: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteVpnConnection", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_vpn_connection_arg a = {0};
		     struct osc_delete_vpn_connection_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_vpn_connection_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_vpn_connection_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VpnConnectionId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VpnConnectionId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VpnConnectionId argument missing\n");
				          s->vpn_connection_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteVpnConnection'\n", next_a);
			    }
		            i += incr;
			    goto delete_vpn_connection_arg;
		     }
		     cret = osc_delete_vpn_connection(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVpnConnection: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteVolume", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_volume_arg a = {0};
		     struct osc_delete_volume_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VolumeId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VolumeId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteVolume'\n", next_a);
			    }
		            i += incr;
			    goto delete_volume_arg;
		     }
		     cret = osc_delete_volume(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVolume: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteVms", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_vms_arg a = {0};
		     struct osc_delete_vms_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "VmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "VmIds require an index\n");
				                    if (s->vm_ids) {
				                            for (; s->vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->vm_ids, "", pa);
				                            SET_NEXT(s->vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "VmIds argument missing\n");
				                   s->vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteVms'\n", next_a);
			    }
		            i += incr;
			    goto delete_vms_arg;
		     }
		     cret = osc_delete_vms(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVms: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteVmTemplate", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_vm_template_arg a = {0};
		     struct osc_delete_vm_template_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_vm_template_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_vm_template_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmTemplateId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmTemplateId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmTemplateId argument missing\n");
				          s->vm_template_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteVmTemplate'\n", next_a);
			    }
		            i += incr;
			    goto delete_vm_template_arg;
		     }
		     cret = osc_delete_vm_template(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVmTemplate: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteVmGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_vm_group_arg a = {0};
		     struct osc_delete_vm_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_vm_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_vm_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VmGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmGroupId argument missing\n");
				          s->vm_group_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteVmGroup'\n", next_a);
			    }
		            i += incr;
			    goto delete_vm_group_arg;
		     }
		     cret = osc_delete_vm_group(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVmGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteVirtualGateway", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_virtual_gateway_arg a = {0};
		     struct osc_delete_virtual_gateway_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_virtual_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_virtual_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VirtualGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VirtualGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteVirtualGateway'\n", next_a);
			    }
		            i += incr;
			    goto delete_virtual_gateway_arg;
		     }
		     cret = osc_delete_virtual_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteVirtualGateway: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteUserGroupPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_user_group_policy_arg a = {0};
		     struct osc_delete_user_group_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_user_group_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_user_group_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PolicyName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyName argument missing\n");
				          s->policy_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupPath argument missing\n");
				          s->user_group_path = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteUserGroupPolicy'\n", next_a);
			    }
		            i += incr;
			    goto delete_user_group_policy_arg;
		     }
		     cret = osc_delete_user_group_policy(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteUserGroupPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_user_group_arg a = {0};
		     struct osc_delete_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Force")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Force argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_force = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->force = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->force = 0;
				           } else {
				          		BAD_RET("Force require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Path")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Path argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Path argument missing\n");
				          s->path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto delete_user_group_arg;
		     }
		     cret = osc_delete_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteUser", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_user_arg a = {0};
		     struct osc_delete_user_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_user_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_user_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteUser'\n", next_a);
			    }
		            i += incr;
			    goto delete_user_arg;
		     }
		     cret = osc_delete_user(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteUser: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteTags", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_tags_arg a = {0};
		     struct osc_delete_tags_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ResourceIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResourceIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "ResourceIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "ResourceIds require an index\n");
				                    if (s->resource_ids) {
				                            for (; s->resource_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->resource_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->resource_ids, "", pa);
				                            SET_NEXT(s->resource_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "ResourceIds argument missing\n");
				                   s->resource_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "ResourceIds[]")) || aret == '=') {
				             TRY(!aa, "ResourceIds[] argument missing\n");
				             SET_NEXT(s->resource_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteTags'\n", next_a);
			    }
		            i += incr;
			    goto delete_tags_arg;
		     }
		     cret = osc_delete_tags(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteTags: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteSubnet", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_subnet_arg a = {0};
		     struct osc_delete_subnet_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_subnet_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_subnet_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "SubnetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubnetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteSubnet'\n", next_a);
			    }
		            i += incr;
			    goto delete_subnet_arg;
		     }
		     cret = osc_delete_subnet(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteSubnet: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteSnapshot", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_snapshot_arg a = {0};
		     struct osc_delete_snapshot_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_snapshot_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_snapshot_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "SnapshotId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SnapshotId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SnapshotId argument missing\n");
				          s->snapshot_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteSnapshot'\n", next_a);
			    }
		            i += incr;
			    goto delete_snapshot_arg;
		     }
		     cret = osc_delete_snapshot(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteSnapshot: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteServerCertificate", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_server_certificate_arg a = {0};
		     struct osc_delete_server_certificate_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_server_certificate_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_server_certificate_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Name")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Name argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Name argument missing\n");
				          s->name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteServerCertificate'\n", next_a);
			    }
		            i += incr;
			    goto delete_server_certificate_arg;
		     }
		     cret = osc_delete_server_certificate(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteServerCertificate: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteSecurityGroupRule", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_security_group_rule_arg a = {0};
		     struct osc_delete_security_group_rule_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_security_group_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_security_group_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Flow")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Flow argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Flow argument missing\n");
				          s->flow = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "FromPortRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FromPortRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FromPortRange argument missing\n");
				          s->is_set_from_port_range = 1;
				          s->from_port_range = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "IpProtocol")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IpProtocol argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "IpProtocol argument missing\n");
				          s->ip_protocol = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "IpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "IpRange argument missing\n");
				          s->ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Rules")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Rules argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Rules' require an index (example array ref SecurityGroupRule.Rules.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Rules' require a .\n");
				          	      TRY_ALLOC_AT(s,rules, pa, pos, sizeof(*s->rules));
				          	      cascade_struct = &s->rules[pos];
				          	      cascade_parser = security_group_rule_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(security_group_rule_parser(&s->rules[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Rules argument missing\n");
				          	s->rules_str = aa; // array ref SecurityGroupRule ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupAccountIdToUnlink")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupAccountIdToUnlink argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupAccountIdToUnlink argument missing\n");
				          s->security_group_account_id_to_unlink = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupId argument missing\n");
				          s->security_group_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupNameToUnlink")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupNameToUnlink argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupNameToUnlink argument missing\n");
				          s->security_group_name_to_unlink = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ToPortRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ToPortRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ToPortRange argument missing\n");
				          s->is_set_to_port_range = 1;
				          s->to_port_range = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteSecurityGroupRule'\n", next_a);
			    }
		            i += incr;
			    goto delete_security_group_rule_arg;
		     }
		     cret = osc_delete_security_group_rule(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteSecurityGroupRule: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteSecurityGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_security_group_arg a = {0};
		     struct osc_delete_security_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_security_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_security_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "SecurityGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupId argument missing\n");
				          s->security_group_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupName argument missing\n");
				          s->security_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteSecurityGroup'\n", next_a);
			    }
		            i += incr;
			    goto delete_security_group_arg;
		     }
		     cret = osc_delete_security_group(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteSecurityGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteRouteTable", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_route_table_arg a = {0};
		     struct osc_delete_route_table_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_route_table_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_route_table_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "RouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteRouteTable'\n", next_a);
			    }
		            i += incr;
			    goto delete_route_table_arg;
		     }
		     cret = osc_delete_route_table(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteRouteTable: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteRoute", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_route_arg a = {0};
		     struct osc_delete_route_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DestinationIpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DestinationIpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "RouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteRoute'\n", next_a);
			    }
		            i += incr;
			    goto delete_route_arg;
		     }
		     cret = osc_delete_route(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteRoute: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeletePublicIp", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_public_ip_arg a = {0};
		     struct osc_delete_public_ip_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_public_ip_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_public_ip_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PublicIp")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIp argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PublicIpId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIpId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIpId argument missing\n");
				          s->public_ip_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeletePublicIp'\n", next_a);
			    }
		            i += incr;
			    goto delete_public_ip_arg;
		     }
		     cret = osc_delete_public_ip(&e, &r, &a);
            	     TRY(cret, "fail to call DeletePublicIp: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeletePolicyVersion", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_policy_version_arg a = {0};
		     struct osc_delete_policy_version_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_policy_version_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_policy_version_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VersionId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VersionId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VersionId argument missing\n");
				          s->version_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeletePolicyVersion'\n", next_a);
			    }
		            i += incr;
			    goto delete_policy_version_arg;
		     }
		     cret = osc_delete_policy_version(&e, &r, &a);
            	     TRY(cret, "fail to call DeletePolicyVersion: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeletePolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_policy_arg a = {0};
		     struct osc_delete_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeletePolicy'\n", next_a);
			    }
		            i += incr;
			    goto delete_policy_arg;
		     }
		     cret = osc_delete_policy(&e, &r, &a);
            	     TRY(cret, "fail to call DeletePolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteNic", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_nic_arg a = {0};
		     struct osc_delete_nic_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteNic'\n", next_a);
			    }
		            i += incr;
			    goto delete_nic_arg;
		     }
		     cret = osc_delete_nic(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNic: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteNetPeering", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_net_peering_arg a = {0};
		     struct osc_delete_net_peering_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_net_peering_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_net_peering_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetPeeringId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetPeeringId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteNetPeering'\n", next_a);
			    }
		            i += incr;
			    goto delete_net_peering_arg;
		     }
		     cret = osc_delete_net_peering(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNetPeering: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteNetAccessPoint", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_net_access_point_arg a = {0};
		     struct osc_delete_net_access_point_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_net_access_point_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_net_access_point_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetAccessPointId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetAccessPointId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetAccessPointId argument missing\n");
				          s->net_access_point_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteNetAccessPoint'\n", next_a);
			    }
		            i += incr;
			    goto delete_net_access_point_arg;
		     }
		     cret = osc_delete_net_access_point(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNetAccessPoint: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteNet", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_net_arg a = {0};
		     struct osc_delete_net_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_net_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_net_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteNet'\n", next_a);
			    }
		            i += incr;
			    goto delete_net_arg;
		     }
		     cret = osc_delete_net(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNet: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteNatService", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_nat_service_arg a = {0};
		     struct osc_delete_nat_service_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_nat_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_nat_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NatServiceId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NatServiceId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NatServiceId argument missing\n");
				          s->nat_service_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteNatService'\n", next_a);
			    }
		            i += incr;
			    goto delete_nat_service_arg;
		     }
		     cret = osc_delete_nat_service(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteNatService: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteLoadBalancerTags", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_load_balancer_tags_arg a = {0};
		     struct osc_delete_load_balancer_tags_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_load_balancer_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_load_balancer_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerNames")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerNames argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "LoadBalancerNames argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "LoadBalancerNames require an index\n");
				                    if (s->load_balancer_names) {
				                            for (; s->load_balancer_names[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->load_balancer_names[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->load_balancer_names, "", pa);
				                            SET_NEXT(s->load_balancer_names, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "LoadBalancerNames argument missing\n");
				                   s->load_balancer_names_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "LoadBalancerNames[]")) || aret == '=') {
				             TRY(!aa, "LoadBalancerNames[] argument missing\n");
				             SET_NEXT(s->load_balancer_names, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceLoadBalancerTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_load_balancer_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_load_balancer_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceLoadBalancerTag ref
				          }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteLoadBalancerTags'\n", next_a);
			    }
		            i += incr;
			    goto delete_load_balancer_tags_arg;
		     }
		     cret = osc_delete_load_balancer_tags(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteLoadBalancerTags: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteLoadBalancerPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_load_balancer_policy_arg a = {0};
		     struct osc_delete_load_balancer_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_load_balancer_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_load_balancer_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PolicyName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyName argument missing\n");
				          s->policy_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteLoadBalancerPolicy'\n", next_a);
			    }
		            i += incr;
			    goto delete_load_balancer_policy_arg;
		     }
		     cret = osc_delete_load_balancer_policy(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteLoadBalancerPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteLoadBalancerListeners", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_load_balancer_listeners_arg a = {0};
		     struct osc_delete_load_balancer_listeners_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_load_balancer_listeners_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_load_balancer_listeners_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "LoadBalancerPorts")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerPorts argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "LoadBalancerPorts argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "LoadBalancerPorts require an index\n");
				                    if (s->load_balancer_ports) {
				                            for (; s->load_balancer_ports[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->load_balancer_ports[pos] = atoi(aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->load_balancer_ports, 0, pa);
				                            SET_NEXT(s->load_balancer_ports, atoi(aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "LoadBalancerPorts argument missing\n");
				                   s->load_balancer_ports_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "LoadBalancerPorts[]")) || aret == '=') {
				             TRY(!aa, "LoadBalancerPorts[] argument missing\n");
				             SET_NEXT(s->load_balancer_ports, atoi(aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteLoadBalancerListeners'\n", next_a);
			    }
		            i += incr;
			    goto delete_load_balancer_listeners_arg;
		     }
		     cret = osc_delete_load_balancer_listeners(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteLoadBalancerListeners: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteLoadBalancer", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_load_balancer_arg a = {0};
		     struct osc_delete_load_balancer_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteLoadBalancer'\n", next_a);
			    }
		            i += incr;
			    goto delete_load_balancer_arg;
		     }
		     cret = osc_delete_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteLoadBalancer: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteListenerRule", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_listener_rule_arg a = {0};
		     struct osc_delete_listener_rule_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_listener_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_listener_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ListenerRuleName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ListenerRuleName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ListenerRuleName argument missing\n");
				          s->listener_rule_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteListenerRule'\n", next_a);
			    }
		            i += incr;
			    goto delete_listener_rule_arg;
		     }
		     cret = osc_delete_listener_rule(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteListenerRule: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteKeypair", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_keypair_arg a = {0};
		     struct osc_delete_keypair_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_keypair_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_keypair_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "KeypairName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "KeypairName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteKeypair'\n", next_a);
			    }
		            i += incr;
			    goto delete_keypair_arg;
		     }
		     cret = osc_delete_keypair(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteKeypair: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteInternetService", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_internet_service_arg a = {0};
		     struct osc_delete_internet_service_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_internet_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_internet_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "InternetServiceId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "InternetServiceId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "InternetServiceId argument missing\n");
				          s->internet_service_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteInternetService'\n", next_a);
			    }
		            i += incr;
			    goto delete_internet_service_arg;
		     }
		     cret = osc_delete_internet_service(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteInternetService: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteImage", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_image_arg a = {0};
		     struct osc_delete_image_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_image_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_image_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ImageId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ImageId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteImage'\n", next_a);
			    }
		            i += incr;
			    goto delete_image_arg;
		     }
		     cret = osc_delete_image(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteImage: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteFlexibleGpu", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_flexible_gpu_arg a = {0};
		     struct osc_delete_flexible_gpu_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "FlexibleGpuId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FlexibleGpuId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FlexibleGpuId argument missing\n");
				          s->flexible_gpu_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteFlexibleGpu'\n", next_a);
			    }
		            i += incr;
			    goto delete_flexible_gpu_arg;
		     }
		     cret = osc_delete_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteExportTask", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_export_task_arg a = {0};
		     struct osc_delete_export_task_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_export_task_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_export_task_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ExportTaskId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ExportTaskId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ExportTaskId argument missing\n");
				          s->export_task_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteExportTask'\n", next_a);
			    }
		            i += incr;
			    goto delete_export_task_arg;
		     }
		     cret = osc_delete_export_task(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteExportTask: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteDirectLinkInterface", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_direct_link_interface_arg a = {0};
		     struct osc_delete_direct_link_interface_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_direct_link_interface_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_direct_link_interface_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DirectLinkInterfaceId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DirectLinkInterfaceId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DirectLinkInterfaceId argument missing\n");
				          s->direct_link_interface_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteDirectLinkInterface'\n", next_a);
			    }
		            i += incr;
			    goto delete_direct_link_interface_arg;
		     }
		     cret = osc_delete_direct_link_interface(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteDirectLinkInterface: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteDirectLink", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_direct_link_arg a = {0};
		     struct osc_delete_direct_link_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_direct_link_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_direct_link_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DirectLinkId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DirectLinkId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DirectLinkId argument missing\n");
				          s->direct_link_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteDirectLink'\n", next_a);
			    }
		            i += incr;
			    goto delete_direct_link_arg;
		     }
		     cret = osc_delete_direct_link(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteDirectLink: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteDhcpOptions", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_dhcp_options_arg a = {0};
		     struct osc_delete_dhcp_options_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_dhcp_options_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_dhcp_options_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DhcpOptionsSetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DhcpOptionsSetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DhcpOptionsSetId argument missing\n");
				          s->dhcp_options_set_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteDhcpOptions'\n", next_a);
			    }
		            i += incr;
			    goto delete_dhcp_options_arg;
		     }
		     cret = osc_delete_dhcp_options(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteDhcpOptions: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteDedicatedGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_dedicated_group_arg a = {0};
		     struct osc_delete_dedicated_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_dedicated_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_dedicated_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DedicatedGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DedicatedGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DedicatedGroupId argument missing\n");
				          s->dedicated_group_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Force")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Force argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_force = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->force = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->force = 0;
				           } else {
				          		BAD_RET("Force require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteDedicatedGroup'\n", next_a);
			    }
		            i += incr;
			    goto delete_dedicated_group_arg;
		     }
		     cret = osc_delete_dedicated_group(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteDedicatedGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteClientGateway", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_client_gateway_arg a = {0};
		     struct osc_delete_client_gateway_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_client_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_client_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "ClientGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ClientGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ClientGatewayId argument missing\n");
				          s->client_gateway_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteClientGateway'\n", next_a);
			    }
		            i += incr;
			    goto delete_client_gateway_arg;
		     }
		     cret = osc_delete_client_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteClientGateway: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteCa", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_ca_arg a = {0};
		     struct osc_delete_ca_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_ca_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_ca_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "CaId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CaId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CaId argument missing\n");
				          s->ca_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteCa'\n", next_a);
			    }
		            i += incr;
			    goto delete_ca_arg;
		     }
		     cret = osc_delete_ca(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteCa: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteApiAccessRule", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_api_access_rule_arg a = {0};
		     struct osc_delete_api_access_rule_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_api_access_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_api_access_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "ApiAccessRuleId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ApiAccessRuleId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ApiAccessRuleId argument missing\n");
				          s->api_access_rule_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteApiAccessRule'\n", next_a);
			    }
		            i += incr;
			    goto delete_api_access_rule_arg;
		     }
		     cret = osc_delete_api_access_rule(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteApiAccessRule: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("DeleteAccessKey", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_delete_access_key_arg a = {0};
		     struct osc_delete_access_key_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     delete_access_key_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto delete_access_key_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AccessKeyId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AccessKeyId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "AccessKeyId argument missing\n");
				          s->access_key_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'DeleteAccessKey'\n", next_a);
			    }
		            i += incr;
			    goto delete_access_key_arg;
		     }
		     cret = osc_delete_access_key(&e, &r, &a);
            	     TRY(cret, "fail to call DeleteAccessKey: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateVpnConnectionRoute", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_vpn_connection_route_arg a = {0};
		     struct osc_create_vpn_connection_route_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_vpn_connection_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_vpn_connection_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DestinationIpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DestinationIpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VpnConnectionId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VpnConnectionId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VpnConnectionId argument missing\n");
				          s->vpn_connection_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateVpnConnectionRoute'\n", next_a);
			    }
		            i += incr;
			    goto create_vpn_connection_route_arg;
		     }
		     cret = osc_create_vpn_connection_route(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVpnConnectionRoute: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateVpnConnection", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_vpn_connection_arg a = {0};
		     struct osc_create_vpn_connection_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_vpn_connection_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_vpn_connection_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "ClientGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ClientGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ClientGatewayId argument missing\n");
				          s->client_gateway_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ConnectionType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ConnectionType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ConnectionType argument missing\n");
				          s->connection_type = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "StaticRoutesOnly")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "StaticRoutesOnly argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_static_routes_only = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->static_routes_only = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->static_routes_only = 0;
				           } else {
				          		BAD_RET("StaticRoutesOnly require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "VirtualGatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VirtualGatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VirtualGatewayId argument missing\n");
				          s->virtual_gateway_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateVpnConnection'\n", next_a);
			    }
		            i += incr;
			    goto create_vpn_connection_arg;
		     }
		     cret = osc_create_vpn_connection(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVpnConnection: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateVolume", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_volume_arg a = {0};
		     struct osc_create_volume_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_volume_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_volume_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Iops")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Iops argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Iops argument missing\n");
				          s->is_set_iops = 1;
				          s->iops = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "Size")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Size argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Size argument missing\n");
				          s->is_set_size = 1;
				          s->size = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "SnapshotId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SnapshotId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SnapshotId argument missing\n");
				          s->snapshot_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SubregionName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubregionName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubregionName argument missing\n");
				          s->subregion_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VolumeType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VolumeType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VolumeType argument missing\n");
				          s->volume_type = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateVolume'\n", next_a);
			    }
		            i += incr;
			    goto create_volume_arg;
		     }
		     cret = osc_create_volume(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVolume: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateVms", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_vms_arg a = {0};
		     struct osc_create_vms_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_vms_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_vms_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "BlockDeviceMappings")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BlockDeviceMappings argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingVmCreation.BlockDeviceMappings.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'BlockDeviceMappings' require a .\n");
				          	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
				          	      cascade_struct = &s->block_device_mappings[pos];
				          	      cascade_parser = block_device_mapping_vm_creation_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(block_device_mapping_vm_creation_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "BlockDeviceMappings argument missing\n");
				          	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingVmCreation ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "BootOnCreation")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BootOnCreation argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_boot_on_creation = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->boot_on_creation = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->boot_on_creation = 0;
				           } else {
				          		BAD_RET("BootOnCreation require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "BsuOptimized")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BsuOptimized argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_bsu_optimized = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->bsu_optimized = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->bsu_optimized = 0;
				           } else {
				          		BAD_RET("BsuOptimized require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ClientToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ClientToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ClientToken argument missing\n");
				          s->client_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DeletionProtection")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DeletionProtection argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_deletion_protection = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->deletion_protection = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->deletion_protection = 0;
				           } else {
				          		BAD_RET("DeletionProtection require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ImageId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ImageId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "KeypairName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "KeypairName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "MaxVmsCount")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "MaxVmsCount argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "MaxVmsCount argument missing\n");
				          s->is_set_max_vms_count = 1;
				          s->max_vms_count = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "MinVmsCount")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "MinVmsCount argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "MinVmsCount argument missing\n");
				          s->is_set_min_vms_count = 1;
				          s->min_vms_count = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "NestedVirtualization")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NestedVirtualization argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_nested_virtualization = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->nested_virtualization = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->nested_virtualization = 0;
				           } else {
				          		BAD_RET("NestedVirtualization require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Nics")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Nics argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Nics' require an index (example array ref NicForVmCreation.Nics.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Nics' require a .\n");
				          	      TRY_ALLOC_AT(s,nics, pa, pos, sizeof(*s->nics));
				          	      cascade_struct = &s->nics[pos];
				          	      cascade_parser = nic_for_vm_creation_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(nic_for_vm_creation_parser(&s->nics[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Nics argument missing\n");
				          	s->nics_str = aa; // array ref NicForVmCreation ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "Performance")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Performance argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Performance argument missing\n");
				          s->performance = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Placement")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Placement argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Placement argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->placement;
				          	    cascade_parser = placement_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(placement_parser(&s->placement, dot_pos, aa, pa));
				          	    s->is_set_placement = 1;
				           } else {
				                 s->placement_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "PrivateIps")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PrivateIps argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "PrivateIps argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "PrivateIps require an index\n");
				                    if (s->private_ips) {
				                            for (; s->private_ips[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->private_ips[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->private_ips, "", pa);
				                            SET_NEXT(s->private_ips, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "PrivateIps argument missing\n");
				                   s->private_ips_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "PrivateIps[]")) || aret == '=') {
				             TRY(!aa, "PrivateIps[] argument missing\n");
				             SET_NEXT(s->private_ips, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
				                    if (s->security_group_ids) {
				                            for (; s->security_group_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->security_group_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->security_group_ids, "", pa);
				                            SET_NEXT(s->security_group_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SecurityGroupIds argument missing\n");
				                   s->security_group_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "SecurityGroups")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroups argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SecurityGroups argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SecurityGroups require an index\n");
				                    if (s->security_groups) {
				                            for (; s->security_groups[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->security_groups[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->security_groups, "", pa);
				                            SET_NEXT(s->security_groups, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SecurityGroups argument missing\n");
				                   s->security_groups_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SecurityGroups[]")) || aret == '=') {
				             TRY(!aa, "SecurityGroups[] argument missing\n");
				             SET_NEXT(s->security_groups, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "SubnetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubnetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserData")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserData argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserData argument missing\n");
				          s->user_data = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmInitiatedShutdownBehavior")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmInitiatedShutdownBehavior argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmInitiatedShutdownBehavior argument missing\n");
				          s->vm_initiated_shutdown_behavior = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmType argument missing\n");
				          s->vm_type = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateVms'\n", next_a);
			    }
		            i += incr;
			    goto create_vms_arg;
		     }
		     cret = osc_create_vms(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVms: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateVmTemplate", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_vm_template_arg a = {0};
		     struct osc_create_vm_template_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_vm_template_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_vm_template_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "CpuCores")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CpuCores argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CpuCores argument missing\n");
				          s->is_set_cpu_cores = 1;
				          s->cpu_cores = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "CpuGeneration")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CpuGeneration argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CpuGeneration argument missing\n");
				          s->cpu_generation = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "CpuPerformance")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CpuPerformance argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CpuPerformance argument missing\n");
				          s->cpu_performance = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ImageId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ImageId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "KeypairName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "KeypairName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Ram")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Ram argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Ram argument missing\n");
				          s->is_set_ram = 1;
				          s->ram = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "VmTemplateName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmTemplateName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmTemplateName argument missing\n");
				          s->vm_template_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateVmTemplate'\n", next_a);
			    }
		            i += incr;
			    goto create_vm_template_arg;
		     }
		     cret = osc_create_vm_template(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVmTemplate: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateVmGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_vm_group_arg a = {0};
		     struct osc_create_vm_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_vm_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_vm_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PositioningStrategy")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PositioningStrategy argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PositioningStrategy argument missing\n");
				          s->positioning_strategy = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
				                    if (s->security_group_ids) {
				                            for (; s->security_group_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->security_group_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->security_group_ids, "", pa);
				                            SET_NEXT(s->security_group_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SecurityGroupIds argument missing\n");
				                   s->security_group_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "SubnetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubnetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "VmCount")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmCount argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmCount argument missing\n");
				          s->is_set_vm_count = 1;
				          s->vm_count = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "VmGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmGroupName argument missing\n");
				          s->vm_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmTemplateId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmTemplateId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmTemplateId argument missing\n");
				          s->vm_template_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateVmGroup'\n", next_a);
			    }
		            i += incr;
			    goto create_vm_group_arg;
		     }
		     cret = osc_create_vm_group(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVmGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateVirtualGateway", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_virtual_gateway_arg a = {0};
		     struct osc_create_virtual_gateway_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_virtual_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_virtual_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "ConnectionType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ConnectionType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ConnectionType argument missing\n");
				          s->connection_type = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateVirtualGateway'\n", next_a);
			    }
		            i += incr;
			    goto create_virtual_gateway_arg;
		     }
		     cret = osc_create_virtual_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call CreateVirtualGateway: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_user_group_arg a = {0};
		     struct osc_create_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Path")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Path argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Path argument missing\n");
				          s->path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto create_user_group_arg;
		     }
		     cret = osc_create_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call CreateUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateUser", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_user_arg a = {0};
		     struct osc_create_user_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_user_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_user_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Path")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Path argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Path argument missing\n");
				          s->path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateUser'\n", next_a);
			    }
		            i += incr;
			    goto create_user_arg;
		     }
		     cret = osc_create_user(&e, &r, &a);
            	     TRY(cret, "fail to call CreateUser: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateTags", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_tags_arg a = {0};
		     struct osc_create_tags_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ResourceIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ResourceIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "ResourceIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "ResourceIds require an index\n");
				                    if (s->resource_ids) {
				                            for (; s->resource_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->resource_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->resource_ids, "", pa);
				                            SET_NEXT(s->resource_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "ResourceIds argument missing\n");
				                   s->resource_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "ResourceIds[]")) || aret == '=') {
				             TRY(!aa, "ResourceIds[] argument missing\n");
				             SET_NEXT(s->resource_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateTags'\n", next_a);
			    }
		            i += incr;
			    goto create_tags_arg;
		     }
		     cret = osc_create_tags(&e, &r, &a);
            	     TRY(cret, "fail to call CreateTags: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateSubnet", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_subnet_arg a = {0};
		     struct osc_create_subnet_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_subnet_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_subnet_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "IpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "IpRange argument missing\n");
				          s->ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SubregionName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubregionName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubregionName argument missing\n");
				          s->subregion_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateSubnet'\n", next_a);
			    }
		            i += incr;
			    goto create_subnet_arg;
		     }
		     cret = osc_create_subnet(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSubnet: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateSnapshotExportTask", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_snapshot_export_task_arg a = {0};
		     struct osc_create_snapshot_export_task_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_snapshot_export_task_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_snapshot_export_task_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "OsuExport")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "OsuExport argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "OsuExport argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->osu_export;
				          	    cascade_parser = osu_export_to_create_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(osu_export_to_create_parser(&s->osu_export, dot_pos, aa, pa));
				          	    s->is_set_osu_export = 1;
				           } else {
				                 s->osu_export_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "SnapshotId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SnapshotId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SnapshotId argument missing\n");
				          s->snapshot_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateSnapshotExportTask'\n", next_a);
			    }
		            i += incr;
			    goto create_snapshot_export_task_arg;
		     }
		     cret = osc_create_snapshot_export_task(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSnapshotExportTask: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateSnapshot", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_snapshot_arg a = {0};
		     struct osc_create_snapshot_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_snapshot_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_snapshot_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "FileLocation")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FileLocation argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FileLocation argument missing\n");
				          s->file_location = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SnapshotSize")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SnapshotSize argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SnapshotSize argument missing\n");
				          s->is_set_snapshot_size = 1;
				          s->snapshot_size = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "SourceRegionName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SourceRegionName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SourceRegionName argument missing\n");
				          s->source_region_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SourceSnapshotId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SourceSnapshotId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SourceSnapshotId argument missing\n");
				          s->source_snapshot_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VolumeId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VolumeId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VolumeId argument missing\n");
				          s->volume_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateSnapshot'\n", next_a);
			    }
		            i += incr;
			    goto create_snapshot_arg;
		     }
		     cret = osc_create_snapshot(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSnapshot: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateServerCertificate", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_server_certificate_arg a = {0};
		     struct osc_create_server_certificate_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_server_certificate_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_server_certificate_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Body")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Body argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Body argument missing\n");
				          s->body = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Chain")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Chain argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Chain argument missing\n");
				          s->chain = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Name")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Name argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Name argument missing\n");
				          s->name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Path")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Path argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Path argument missing\n");
				          s->path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PrivateKey")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PrivateKey argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PrivateKey argument missing\n");
				          s->private_key = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateServerCertificate'\n", next_a);
			    }
		            i += incr;
			    goto create_server_certificate_arg;
		     }
		     cret = osc_create_server_certificate(&e, &r, &a);
            	     TRY(cret, "fail to call CreateServerCertificate: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateSecurityGroupRule", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_security_group_rule_arg a = {0};
		     struct osc_create_security_group_rule_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_security_group_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_security_group_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Flow")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Flow argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Flow argument missing\n");
				          s->flow = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "FromPortRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FromPortRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FromPortRange argument missing\n");
				          s->is_set_from_port_range = 1;
				          s->from_port_range = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "IpProtocol")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IpProtocol argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "IpProtocol argument missing\n");
				          s->ip_protocol = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "IpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "IpRange argument missing\n");
				          s->ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Rules")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Rules argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Rules' require an index (example array ref SecurityGroupRule.Rules.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Rules' require a .\n");
				          	      TRY_ALLOC_AT(s,rules, pa, pos, sizeof(*s->rules));
				          	      cascade_struct = &s->rules[pos];
				          	      cascade_parser = security_group_rule_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(security_group_rule_parser(&s->rules[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Rules argument missing\n");
				          	s->rules_str = aa; // array ref SecurityGroupRule ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupAccountIdToLink")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupAccountIdToLink argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupAccountIdToLink argument missing\n");
				          s->security_group_account_id_to_link = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupId argument missing\n");
				          s->security_group_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupNameToLink")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupNameToLink argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupNameToLink argument missing\n");
				          s->security_group_name_to_link = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ToPortRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ToPortRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ToPortRange argument missing\n");
				          s->is_set_to_port_range = 1;
				          s->to_port_range = atoi(aa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateSecurityGroupRule'\n", next_a);
			    }
		            i += incr;
			    goto create_security_group_rule_arg;
		     }
		     cret = osc_create_security_group_rule(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSecurityGroupRule: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateSecurityGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_security_group_arg a = {0};
		     struct osc_create_security_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_security_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_security_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SecurityGroupName argument missing\n");
				          s->security_group_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateSecurityGroup'\n", next_a);
			    }
		            i += incr;
			    goto create_security_group_arg;
		     }
		     cret = osc_create_security_group(&e, &r, &a);
            	     TRY(cret, "fail to call CreateSecurityGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateRouteTable", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_route_table_arg a = {0};
		     struct osc_create_route_table_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_route_table_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_route_table_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateRouteTable'\n", next_a);
			    }
		            i += incr;
			    goto create_route_table_arg;
		     }
		     cret = osc_create_route_table(&e, &r, &a);
            	     TRY(cret, "fail to call CreateRouteTable: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateRoute", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_route_arg a = {0};
		     struct osc_create_route_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_route_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_route_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DestinationIpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DestinationIpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DestinationIpRange argument missing\n");
				          s->destination_ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "GatewayId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "GatewayId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "GatewayId argument missing\n");
				          s->gateway_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NatServiceId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NatServiceId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NatServiceId argument missing\n");
				          s->nat_service_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NetPeeringId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetPeeringId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NicId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NicId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NicId argument missing\n");
				          s->nic_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "RouteTableId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RouteTableId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "RouteTableId argument missing\n");
				          s->route_table_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateRoute'\n", next_a);
			    }
		            i += incr;
			    goto create_route_arg;
		     }
		     cret = osc_create_route(&e, &r, &a);
            	     TRY(cret, "fail to call CreateRoute: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreatePublicIp", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_public_ip_arg a = {0};
		     struct osc_create_public_ip_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_public_ip_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_public_ip_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreatePublicIp'\n", next_a);
			    }
		            i += incr;
			    goto create_public_ip_arg;
		     }
		     cret = osc_create_public_ip(&e, &r, &a);
            	     TRY(cret, "fail to call CreatePublicIp: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateProductType", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_product_type_arg a = {0};
		     struct osc_create_product_type_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_product_type_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_product_type_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Vendor")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Vendor argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Vendor argument missing\n");
				          s->vendor = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateProductType'\n", next_a);
			    }
		            i += incr;
			    goto create_product_type_arg;
		     }
		     cret = osc_create_product_type(&e, &r, &a);
            	     TRY(cret, "fail to call CreateProductType: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreatePolicyVersion", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_policy_version_arg a = {0};
		     struct osc_create_policy_version_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_policy_version_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_policy_version_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Document")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Document argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Document argument missing\n");
				          s->document = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PolicyOrn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyOrn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyOrn argument missing\n");
				          s->policy_orn = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SetAsDefault")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SetAsDefault argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_set_as_default = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->set_as_default = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->set_as_default = 0;
				           } else {
				          		BAD_RET("SetAsDefault require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreatePolicyVersion'\n", next_a);
			    }
		            i += incr;
			    goto create_policy_version_arg;
		     }
		     cret = osc_create_policy_version(&e, &r, &a);
            	     TRY(cret, "fail to call CreatePolicyVersion: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreatePolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_policy_arg a = {0};
		     struct osc_create_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Document")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Document argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Document argument missing\n");
				          s->document = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Path")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Path argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Path argument missing\n");
				          s->path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PolicyName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyName argument missing\n");
				          s->policy_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreatePolicy'\n", next_a);
			    }
		            i += incr;
			    goto create_policy_arg;
		     }
		     cret = osc_create_policy(&e, &r, &a);
            	     TRY(cret, "fail to call CreatePolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateNic", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_nic_arg a = {0};
		     struct osc_create_nic_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_nic_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_nic_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PrivateIps")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PrivateIps argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'PrivateIps' require an index (example array ref PrivateIpLight.PrivateIps.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'PrivateIps' require a .\n");
				          	      TRY_ALLOC_AT(s,private_ips, pa, pos, sizeof(*s->private_ips));
				          	      cascade_struct = &s->private_ips[pos];
				          	      cascade_parser = private_ip_light_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(private_ip_light_parser(&s->private_ips[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "PrivateIps argument missing\n");
				          	s->private_ips_str = aa; // array ref PrivateIpLight ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "SecurityGroupIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroupIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SecurityGroupIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SecurityGroupIds require an index\n");
				                    if (s->security_group_ids) {
				                            for (; s->security_group_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->security_group_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->security_group_ids, "", pa);
				                            SET_NEXT(s->security_group_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SecurityGroupIds argument missing\n");
				                   s->security_group_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SecurityGroupIds[]")) || aret == '=') {
				             TRY(!aa, "SecurityGroupIds[] argument missing\n");
				             SET_NEXT(s->security_group_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "SubnetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubnetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateNic'\n", next_a);
			    }
		            i += incr;
			    goto create_nic_arg;
		     }
		     cret = osc_create_nic(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNic: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateNetPeering", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_net_peering_arg a = {0};
		     struct osc_create_net_peering_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_net_peering_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_net_peering_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AccepterNetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AccepterNetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "AccepterNetId argument missing\n");
				          s->accepter_net_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "SourceNetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SourceNetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SourceNetId argument missing\n");
				          s->source_net_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateNetPeering'\n", next_a);
			    }
		            i += incr;
			    goto create_net_peering_arg;
		     }
		     cret = osc_create_net_peering(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNetPeering: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateNetAccessPoint", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_net_access_point_arg a = {0};
		     struct osc_create_net_access_point_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_net_access_point_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_net_access_point_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetId argument missing\n");
				          s->net_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "RouteTableIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RouteTableIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "RouteTableIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "RouteTableIds require an index\n");
				                    if (s->route_table_ids) {
				                            for (; s->route_table_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->route_table_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->route_table_ids, "", pa);
				                            SET_NEXT(s->route_table_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "RouteTableIds argument missing\n");
				                   s->route_table_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "RouteTableIds[]")) || aret == '=') {
				             TRY(!aa, "RouteTableIds[] argument missing\n");
				             SET_NEXT(s->route_table_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "ServiceName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ServiceName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ServiceName argument missing\n");
				          s->service_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateNetAccessPoint'\n", next_a);
			    }
		            i += incr;
			    goto create_net_access_point_arg;
		     }
		     cret = osc_create_net_access_point(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNetAccessPoint: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateNet", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_net_arg a = {0};
		     struct osc_create_net_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_net_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_net_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "IpRange")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IpRange argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "IpRange argument missing\n");
				          s->ip_range = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Tenancy")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tenancy argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Tenancy argument missing\n");
				          s->tenancy = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateNet'\n", next_a);
			    }
		            i += incr;
			    goto create_net_arg;
		     }
		     cret = osc_create_net(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNet: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateNatService", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_nat_service_arg a = {0};
		     struct osc_create_nat_service_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_nat_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_nat_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "ClientToken")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ClientToken argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ClientToken argument missing\n");
				          s->client_token = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PublicIpId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIpId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIpId argument missing\n");
				          s->public_ip_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SubnetId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubnetId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubnetId argument missing\n");
				          s->subnet_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateNatService'\n", next_a);
			    }
		            i += incr;
			    goto create_nat_service_arg;
		     }
		     cret = osc_create_nat_service(&e, &r, &a);
            	     TRY(cret, "fail to call CreateNatService: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateLoadBalancerTags", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_load_balancer_tags_arg a = {0};
		     struct osc_create_load_balancer_tags_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_load_balancer_tags_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_load_balancer_tags_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerNames")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerNames argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "LoadBalancerNames argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "LoadBalancerNames require an index\n");
				                    if (s->load_balancer_names) {
				                            for (; s->load_balancer_names[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->load_balancer_names[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->load_balancer_names, "", pa);
				                            SET_NEXT(s->load_balancer_names, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "LoadBalancerNames argument missing\n");
				                   s->load_balancer_names_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "LoadBalancerNames[]")) || aret == '=') {
				             TRY(!aa, "LoadBalancerNames[] argument missing\n");
				             SET_NEXT(s->load_balancer_names, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateLoadBalancerTags'\n", next_a);
			    }
		            i += incr;
			    goto create_load_balancer_tags_arg;
		     }
		     cret = osc_create_load_balancer_tags(&e, &r, &a);
            	     TRY(cret, "fail to call CreateLoadBalancerTags: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateLoadBalancerPolicy", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_load_balancer_policy_arg a = {0};
		     struct osc_create_load_balancer_policy_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_load_balancer_policy_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_load_balancer_policy_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "CookieExpirationPeriod")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CookieExpirationPeriod argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CookieExpirationPeriod argument missing\n");
				          s->is_set_cookie_expiration_period = 1;
				          s->cookie_expiration_period = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "CookieName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CookieName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CookieName argument missing\n");
				          s->cookie_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PolicyName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyName argument missing\n");
				          s->policy_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PolicyType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PolicyType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PolicyType argument missing\n");
				          s->policy_type = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateLoadBalancerPolicy'\n", next_a);
			    }
		            i += incr;
			    goto create_load_balancer_policy_arg;
		     }
		     cret = osc_create_load_balancer_policy(&e, &r, &a);
            	     TRY(cret, "fail to call CreateLoadBalancerPolicy: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateLoadBalancerListeners", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_load_balancer_listeners_arg a = {0};
		     struct osc_create_load_balancer_listeners_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_load_balancer_listeners_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_load_balancer_listeners_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Listeners")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Listeners argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Listeners' require an index (example array ref ListenerForCreation.Listeners.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Listeners' require a .\n");
				          	      TRY_ALLOC_AT(s,listeners, pa, pos, sizeof(*s->listeners));
				          	      cascade_struct = &s->listeners[pos];
				          	      cascade_parser = listener_for_creation_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(listener_for_creation_parser(&s->listeners[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Listeners argument missing\n");
				          	s->listeners_str = aa; // array ref ListenerForCreation ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateLoadBalancerListeners'\n", next_a);
			    }
		            i += incr;
			    goto create_load_balancer_listeners_arg;
		     }
		     cret = osc_create_load_balancer_listeners(&e, &r, &a);
            	     TRY(cret, "fail to call CreateLoadBalancerListeners: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateLoadBalancer", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_load_balancer_arg a = {0};
		     struct osc_create_load_balancer_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_load_balancer_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_load_balancer_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Listeners")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Listeners argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Listeners' require an index (example array ref ListenerForCreation.Listeners.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Listeners' require a .\n");
				          	      TRY_ALLOC_AT(s,listeners, pa, pos, sizeof(*s->listeners));
				          	      cascade_struct = &s->listeners[pos];
				          	      cascade_parser = listener_for_creation_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(listener_for_creation_parser(&s->listeners[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Listeners argument missing\n");
				          	s->listeners_str = aa; // array ref ListenerForCreation ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "LoadBalancerName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerName argument missing\n");
				          s->load_balancer_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "LoadBalancerType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LoadBalancerType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LoadBalancerType argument missing\n");
				          s->load_balancer_type = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PublicIp")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIp argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SecurityGroups")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SecurityGroups argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SecurityGroups argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SecurityGroups require an index\n");
				                    if (s->security_groups) {
				                            for (; s->security_groups[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->security_groups[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->security_groups, "", pa);
				                            SET_NEXT(s->security_groups, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SecurityGroups argument missing\n");
				                   s->security_groups_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SecurityGroups[]")) || aret == '=') {
				             TRY(!aa, "SecurityGroups[] argument missing\n");
				             SET_NEXT(s->security_groups, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Subnets")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Subnets argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "Subnets argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "Subnets require an index\n");
				                    if (s->subnets) {
				                            for (; s->subnets[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->subnets[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->subnets, "", pa);
				                            SET_NEXT(s->subnets, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "Subnets argument missing\n");
				                   s->subnets_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "Subnets[]")) || aret == '=') {
				             TRY(!aa, "Subnets[] argument missing\n");
				             SET_NEXT(s->subnets, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "SubregionNames")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubregionNames argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "SubregionNames argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "SubregionNames require an index\n");
				                    if (s->subregion_names) {
				                            for (; s->subregion_names[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->subregion_names[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->subregion_names, "", pa);
				                            SET_NEXT(s->subregion_names, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "SubregionNames argument missing\n");
				                   s->subregion_names_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "SubregionNames[]")) || aret == '=') {
				             TRY(!aa, "SubregionNames[] argument missing\n");
				             SET_NEXT(s->subregion_names, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Tags")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Tags argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'Tags' require an index (example array ref ResourceTag.Tags.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'Tags' require a .\n");
				          	      TRY_ALLOC_AT(s,tags, pa, pos, sizeof(*s->tags));
				          	      cascade_struct = &s->tags[pos];
				          	      cascade_parser = resource_tag_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(resource_tag_parser(&s->tags[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "Tags argument missing\n");
				          	s->tags_str = aa; // array ref ResourceTag ref
				          }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateLoadBalancer'\n", next_a);
			    }
		            i += incr;
			    goto create_load_balancer_arg;
		     }
		     cret = osc_create_load_balancer(&e, &r, &a);
            	     TRY(cret, "fail to call CreateLoadBalancer: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateListenerRule", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_listener_rule_arg a = {0};
		     struct osc_create_listener_rule_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_listener_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_listener_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Listener")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Listener argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "Listener argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->listener;
				          	    cascade_parser = load_balancer_light_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(load_balancer_light_parser(&s->listener, dot_pos, aa, pa));
				          	    s->is_set_listener = 1;
				           } else {
				                 s->listener_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "ListenerRule")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ListenerRule argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "ListenerRule argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->listener_rule;
				          	    cascade_parser = listener_rule_for_creation_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(listener_rule_for_creation_parser(&s->listener_rule, dot_pos, aa, pa));
				          	    s->is_set_listener_rule = 1;
				           } else {
				                 s->listener_rule_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "VmIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "VmIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "VmIds require an index\n");
				                    if (s->vm_ids) {
				                            for (; s->vm_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->vm_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->vm_ids, "", pa);
				                            SET_NEXT(s->vm_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "VmIds argument missing\n");
				                   s->vm_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "VmIds[]")) || aret == '=') {
				             TRY(!aa, "VmIds[] argument missing\n");
				             SET_NEXT(s->vm_ids, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateListenerRule'\n", next_a);
			    }
		            i += incr;
			    goto create_listener_rule_arg;
		     }
		     cret = osc_create_listener_rule(&e, &r, &a);
            	     TRY(cret, "fail to call CreateListenerRule: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateKeypair", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_keypair_arg a = {0};
		     struct osc_create_keypair_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_keypair_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_keypair_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "KeypairName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "KeypairName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "KeypairName argument missing\n");
				          s->keypair_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PublicKey")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicKey argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicKey argument missing\n");
				          s->public_key = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateKeypair'\n", next_a);
			    }
		            i += incr;
			    goto create_keypair_arg;
		     }
		     cret = osc_create_keypair(&e, &r, &a);
            	     TRY(cret, "fail to call CreateKeypair: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateInternetService", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_internet_service_arg a = {0};
		     struct osc_create_internet_service_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_internet_service_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_internet_service_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateInternetService'\n", next_a);
			    }
		            i += incr;
			    goto create_internet_service_arg;
		     }
		     cret = osc_create_internet_service(&e, &r, &a);
            	     TRY(cret, "fail to call CreateInternetService: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateImageExportTask", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_image_export_task_arg a = {0};
		     struct osc_create_image_export_task_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_image_export_task_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_image_export_task_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ImageId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ImageId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ImageId argument missing\n");
				          s->image_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "OsuExport")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "OsuExport argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "OsuExport argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->osu_export;
				          	    cascade_parser = osu_export_to_create_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(osu_export_to_create_parser(&s->osu_export, dot_pos, aa, pa));
				          	    s->is_set_osu_export = 1;
				           } else {
				                 s->osu_export_str = aa;
				           }
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateImageExportTask'\n", next_a);
			    }
		            i += incr;
			    goto create_image_export_task_arg;
		     }
		     cret = osc_create_image_export_task(&e, &r, &a);
            	     TRY(cret, "fail to call CreateImageExportTask: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateImage", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_image_arg a = {0};
		     struct osc_create_image_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_image_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_image_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Architecture")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Architecture argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Architecture argument missing\n");
				          s->architecture = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "BlockDeviceMappings")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BlockDeviceMappings argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos = strchr(str, '.');

				          if (dot_pos) {
				          	      int pos;
				          	      char *endptr;

				          	      ++dot_pos;
				          	      pos = strtoul(dot_pos, &endptr, 0);
				          	      if (endptr == dot_pos)
				          		      BAD_RET("'BlockDeviceMappings' require an index (example array ref BlockDeviceMappingImage.BlockDeviceMappings.0)\n");
				          	      else if (*endptr != '.')
				          		      BAD_RET("'BlockDeviceMappings' require a .\n");
				          	      TRY_ALLOC_AT(s,block_device_mappings, pa, pos, sizeof(*s->block_device_mappings));
				          	      cascade_struct = &s->block_device_mappings[pos];
				          	      cascade_parser = block_device_mapping_image_parser;
				          	      if (endptr[1] == '.') {
				          		     ++endptr;
				          	      }
				          	      STRY(block_device_mapping_image_parser(&s->block_device_mappings[pos], endptr + 1, aa, pa));
				           } else {
				          	TRY(!aa, "BlockDeviceMappings argument missing\n");
				          	s->block_device_mappings_str = aa; // array ref BlockDeviceMappingImage ref
				          }
				       } else
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "FileLocation")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FileLocation argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FileLocation argument missing\n");
				          s->file_location = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ImageName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ImageName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ImageName argument missing\n");
				          s->image_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "NoReboot")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NoReboot argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_no_reboot = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->no_reboot = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->no_reboot = 0;
				           } else {
				          		BAD_RET("NoReboot require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ProductCodes")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ProductCodes argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "ProductCodes argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "ProductCodes require an index\n");
				                    if (s->product_codes) {
				                            for (; s->product_codes[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->product_codes[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->product_codes, "", pa);
				                            SET_NEXT(s->product_codes, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "ProductCodes argument missing\n");
				                   s->product_codes_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "ProductCodes[]")) || aret == '=') {
				             TRY(!aa, "ProductCodes[] argument missing\n");
				             SET_NEXT(s->product_codes, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "RootDeviceName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "RootDeviceName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "RootDeviceName argument missing\n");
				          s->root_device_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SourceImageId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SourceImageId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SourceImageId argument missing\n");
				          s->source_image_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SourceRegionName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SourceRegionName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SourceRegionName argument missing\n");
				          s->source_region_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VmId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VmId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VmId argument missing\n");
				          s->vm_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateImage'\n", next_a);
			    }
		            i += incr;
			    goto create_image_arg;
		     }
		     cret = osc_create_image(&e, &r, &a);
            	     TRY(cret, "fail to call CreateImage: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateFlexibleGpu", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_flexible_gpu_arg a = {0};
		     struct osc_create_flexible_gpu_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_flexible_gpu_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_flexible_gpu_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DeleteOnVmDeletion")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DeleteOnVmDeletion argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_delete_on_vm_deletion = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->delete_on_vm_deletion = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->delete_on_vm_deletion = 0;
				           } else {
				          		BAD_RET("DeleteOnVmDeletion require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Generation")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Generation argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Generation argument missing\n");
				          s->generation = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ModelName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ModelName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ModelName argument missing\n");
				          s->model_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SubregionName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubregionName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubregionName argument missing\n");
				          s->subregion_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateFlexibleGpu'\n", next_a);
			    }
		            i += incr;
			    goto create_flexible_gpu_arg;
		     }
		     cret = osc_create_flexible_gpu(&e, &r, &a);
            	     TRY(cret, "fail to call CreateFlexibleGpu: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateDirectLinkInterface", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_direct_link_interface_arg a = {0};
		     struct osc_create_direct_link_interface_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_direct_link_interface_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_direct_link_interface_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DirectLinkId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DirectLinkId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DirectLinkId argument missing\n");
				          s->direct_link_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DirectLinkInterface")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DirectLinkInterface argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          char *dot_pos;

				          TRY(!aa, "DirectLinkInterface argument missing\n");
				          dot_pos = strchr(str, '.');
				          if (dot_pos++) {
				          	    cascade_struct = &s->direct_link_interface;
				          	    cascade_parser = direct_link_interface_parser;
				          	    if (*dot_pos == '.') {
				          		++dot_pos;
				          	    }
				          	    STRY(direct_link_interface_parser(&s->direct_link_interface, dot_pos, aa, pa));
				          	    s->is_set_direct_link_interface = 1;
				           } else {
				                 s->direct_link_interface_str = aa;
				           }
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateDirectLinkInterface'\n", next_a);
			    }
		            i += incr;
			    goto create_direct_link_interface_arg;
		     }
		     cret = osc_create_direct_link_interface(&e, &r, &a);
            	     TRY(cret, "fail to call CreateDirectLinkInterface: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateDirectLink", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_direct_link_arg a = {0};
		     struct osc_create_direct_link_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_direct_link_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_direct_link_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "Bandwidth")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Bandwidth argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Bandwidth argument missing\n");
				          s->bandwidth = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DirectLinkName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DirectLinkName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DirectLinkName argument missing\n");
				          s->direct_link_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Location")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Location argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Location argument missing\n");
				          s->location = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateDirectLink'\n", next_a);
			    }
		            i += incr;
			    goto create_direct_link_arg;
		     }
		     cret = osc_create_direct_link(&e, &r, &a);
            	     TRY(cret, "fail to call CreateDirectLink: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateDhcpOptions", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_dhcp_options_arg a = {0};
		     struct osc_create_dhcp_options_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_dhcp_options_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_dhcp_options_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DomainName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DomainName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "DomainName argument missing\n");
				          s->domain_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DomainNameServers")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DomainNameServers argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "DomainNameServers argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "DomainNameServers require an index\n");
				                    if (s->domain_name_servers) {
				                            for (; s->domain_name_servers[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->domain_name_servers[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->domain_name_servers, "", pa);
				                            SET_NEXT(s->domain_name_servers, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "DomainNameServers argument missing\n");
				                   s->domain_name_servers_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "DomainNameServers[]")) || aret == '=') {
				             TRY(!aa, "DomainNameServers[] argument missing\n");
				             SET_NEXT(s->domain_name_servers, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "LogServers")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LogServers argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "LogServers argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "LogServers require an index\n");
				                    if (s->log_servers) {
				                            for (; s->log_servers[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->log_servers[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->log_servers, "", pa);
				                            SET_NEXT(s->log_servers, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "LogServers argument missing\n");
				                   s->log_servers_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "LogServers[]")) || aret == '=') {
				             TRY(!aa, "LogServers[] argument missing\n");
				             SET_NEXT(s->log_servers, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "NtpServers")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NtpServers argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "NtpServers argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "NtpServers require an index\n");
				                    if (s->ntp_servers) {
				                            for (; s->ntp_servers[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->ntp_servers[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->ntp_servers, "", pa);
				                            SET_NEXT(s->ntp_servers, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "NtpServers argument missing\n");
				                   s->ntp_servers_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "NtpServers[]")) || aret == '=') {
				             TRY(!aa, "NtpServers[] argument missing\n");
				             SET_NEXT(s->ntp_servers, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateDhcpOptions'\n", next_a);
			    }
		            i += incr;
			    goto create_dhcp_options_arg;
		     }
		     cret = osc_create_dhcp_options(&e, &r, &a);
            	     TRY(cret, "fail to call CreateDhcpOptions: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateDedicatedGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_dedicated_group_arg a = {0};
		     struct osc_create_dedicated_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_dedicated_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_dedicated_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "CpuGeneration")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CpuGeneration argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CpuGeneration argument missing\n");
				          s->is_set_cpu_generation = 1;
				          s->cpu_generation = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Name")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Name argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Name argument missing\n");
				          s->name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "SubregionName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "SubregionName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "SubregionName argument missing\n");
				          s->subregion_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateDedicatedGroup'\n", next_a);
			    }
		            i += incr;
			    goto create_dedicated_group_arg;
		     }
		     cret = osc_create_dedicated_group(&e, &r, &a);
            	     TRY(cret, "fail to call CreateDedicatedGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateClientGateway", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_client_gateway_arg a = {0};
		     struct osc_create_client_gateway_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_client_gateway_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_client_gateway_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "BgpAsn")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "BgpAsn argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "BgpAsn argument missing\n");
				          s->is_set_bgp_asn = 1;
				          s->bgp_asn = atoi(aa);
				       } else
			      if ((aret = strcmp(next_a, "ConnectionType")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ConnectionType argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ConnectionType argument missing\n");
				          s->connection_type = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "PublicIp")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PublicIp argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PublicIp argument missing\n");
				          s->public_ip = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateClientGateway'\n", next_a);
			    }
		            i += incr;
			    goto create_client_gateway_arg;
		     }
		     cret = osc_create_client_gateway(&e, &r, &a);
            	     TRY(cret, "fail to call CreateClientGateway: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateCa", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_ca_arg a = {0};
		     struct osc_create_ca_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_ca_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_ca_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "CaPem")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CaPem argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CaPem argument missing\n");
				          s->ca_pem = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateCa'\n", next_a);
			    }
		            i += incr;
			    goto create_ca_arg;
		     }
		     cret = osc_create_ca(&e, &r, &a);
            	     TRY(cret, "fail to call CreateCa: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateApiAccessRule", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_api_access_rule_arg a = {0};
		     struct osc_create_api_access_rule_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_api_access_rule_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_api_access_rule_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "CaIds")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CaIds argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "CaIds argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "CaIds require an index\n");
				                    if (s->ca_ids) {
				                            for (; s->ca_ids[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->ca_ids[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->ca_ids, "", pa);
				                            SET_NEXT(s->ca_ids, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "CaIds argument missing\n");
				                   s->ca_ids_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "CaIds[]")) || aret == '=') {
				             TRY(!aa, "CaIds[] argument missing\n");
				             SET_NEXT(s->ca_ids, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Cns")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Cns argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "Cns argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "Cns require an index\n");
				                    if (s->cns) {
				                            for (; s->cns[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->cns[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->cns, "", pa);
				                            SET_NEXT(s->cns, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "Cns argument missing\n");
				                   s->cns_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "Cns[]")) || aret == '=') {
				             TRY(!aa, "Cns[] argument missing\n");
				             SET_NEXT(s->cns, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "Description")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Description argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Description argument missing\n");
				          s->description = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "IpRanges")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "IpRanges argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "IpRanges argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "IpRanges require an index\n");
				                    if (s->ip_ranges) {
				                            for (; s->ip_ranges[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->ip_ranges[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->ip_ranges, "", pa);
				                            SET_NEXT(s->ip_ranges, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "IpRanges argument missing\n");
				                   s->ip_ranges_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "IpRanges[]")) || aret == '=') {
				             TRY(!aa, "IpRanges[] argument missing\n");
				             SET_NEXT(s->ip_ranges, (aa), pa);
				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateApiAccessRule'\n", next_a);
			    }
		            i += incr;
			    goto create_api_access_rule_arg;
		     }
		     cret = osc_create_api_access_rule(&e, &r, &a);
            	     TRY(cret, "fail to call CreateApiAccessRule: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateAccount", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_account_arg a = {0};
		     struct osc_create_account_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_account_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_account_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "AdditionalEmails")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "AdditionalEmails argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				               if (aret == '.') {
				                    int pos;
				                    char *endptr;
				                    int last = 0;
				                    char *dot_pos = strchr(str, '.');

				                    TRY(!(dot_pos++), "AdditionalEmails argument missing\n");
				                    pos = strtoul(dot_pos, &endptr, 0);
				                    TRY(endptr == dot_pos, "AdditionalEmails require an index\n");
				                    if (s->additional_emails) {
				                            for (; s->additional_emails[last]; ++last);
				                    }
				                    if (pos < last) {
				                            s->additional_emails[pos] = (aa);
				                    } else {
				                            for (int i = last; i < pos; ++i)
				                                    SET_NEXT(s->additional_emails, "", pa);
				                            SET_NEXT(s->additional_emails, (aa), pa);
				                    }
				               } else {
				          	       TRY(!aa, "AdditionalEmails argument missing\n");
				                   s->additional_emails_str = aa;
				               }
				       } else if (!(aret = strcmp(str, "AdditionalEmails[]")) || aret == '=') {
				             TRY(!aa, "AdditionalEmails[] argument missing\n");
				             SET_NEXT(s->additional_emails, (aa), pa);
				       } else
			      if ((aret = strcmp(next_a, "City")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "City argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "City argument missing\n");
				          s->city = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "CompanyName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CompanyName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CompanyName argument missing\n");
				          s->company_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Country")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Country argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Country argument missing\n");
				          s->country = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "CustomerId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "CustomerId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "CustomerId argument missing\n");
				          s->customer_id = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Email")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Email argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Email argument missing\n");
				          s->email = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "FirstName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "FirstName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "FirstName argument missing\n");
				          s->first_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "JobTitle")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "JobTitle argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "JobTitle argument missing\n");
				          s->job_title = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "LastName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "LastName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "LastName argument missing\n");
				          s->last_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "MobileNumber")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "MobileNumber argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "MobileNumber argument missing\n");
				          s->mobile_number = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "PhoneNumber")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "PhoneNumber argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "PhoneNumber argument missing\n");
				          s->phone_number = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "StateProvince")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "StateProvince argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "StateProvince argument missing\n");
				          s->state_province = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "VatNumber")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "VatNumber argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "VatNumber argument missing\n");
				          s->vat_number = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "ZipCode")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ZipCode argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ZipCode argument missing\n");
				          s->zip_code = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateAccount'\n", next_a);
			    }
		            i += incr;
			    goto create_account_arg;
		     }
		     cret = osc_create_account(&e, &r, &a);
            	     TRY(cret, "fail to call CreateAccount: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CreateAccessKey", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_create_access_key_arg a = {0};
		     struct osc_create_access_key_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     create_access_key_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto create_access_key_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "ExpirationDate")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "ExpirationDate argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "ExpirationDate argument missing\n");
				          s->expiration_date = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CreateAccessKey'\n", next_a);
			    }
		            i += incr;
			    goto create_access_key_arg;
		     }
		     cret = osc_create_access_key(&e, &r, &a);
            	     TRY(cret, "fail to call CreateAccessKey: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("CheckAuthentication", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_check_authentication_arg a = {0};
		     struct osc_check_authentication_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     check_authentication_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto check_authentication_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "Login")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Login argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Login argument missing\n");
				          s->login = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "Password")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "Password argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "Password argument missing\n");
				          s->password = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'CheckAuthentication'\n", next_a);
			    }
		            i += incr;
			    goto check_authentication_arg;
		     }
		     cret = osc_check_authentication(&e, &r, &a);
            	     TRY(cret, "fail to call CheckAuthentication: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("AddUserToUserGroup", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_add_user_to_user_group_arg a = {0};
		     struct osc_add_user_to_user_group_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     add_user_to_user_group_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto add_user_to_user_group_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "UserGroupName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupName argument missing\n");
				          s->user_group_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserGroupPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserGroupPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserGroupPath argument missing\n");
				          s->user_group_path = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserName")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserName argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserName argument missing\n");
				          s->user_name = aa; // string string

				       } else
			      if ((aret = strcmp(next_a, "UserPath")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "UserPath argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "UserPath argument missing\n");
				          s->user_path = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'AddUserToUserGroup'\n", next_a);
			    }
		            i += incr;
			    goto add_user_to_user_group_arg;
		     }
		     cret = osc_add_user_to_user_group(&e, &r, &a);
            	     TRY(cret, "fail to call AddUserToUserGroup: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
              if (!strcmp("AcceptNetPeering", av[i])) {
		     auto_osc_json_c json_object *jobj = NULL;
		     auto_ptr_array struct ptr_array opa = {0};
		     struct ptr_array *pa = &opa;
	      	     struct osc_accept_net_peering_arg a = {0};
		     struct osc_accept_net_peering_arg *s = &a;
		     __attribute__((cleanup(files_cnt_cleanup))) char *files_cnt[MAX_FILES_PER_CMD] = {NULL};
	             int cret;

		     cascade_struct = NULL;
		     cascade_parser = NULL;

		     accept_net_peering_arg:

		     if (i + 1 < ac && av[i + 1][0] == '.' && av[i + 1][1] == '.') {
 		           char *next_a = &av[i + 1][2];
		           char *aa = i + 2 < ac ? av[i + 2] : 0;
			   int incr = 2;
			   char *eq_ptr = strchr(next_a, '=');

	      	           CHK_BAD_RET(!cascade_struct, "cascade need to be se first\n");
			   if (eq_ptr) {
			      	  CHK_BAD_RET(!*eq_ptr, "cascade need an argument\n");
			      	  incr = 1;
				  aa = eq_ptr + 1;
			   } else {
			     	  CHK_BAD_RET(!aa, "cascade need an argument\n");
					  META_ARGS({CHK_BAD_RET(aa[0] == '-', "cascade need an argument"); })
			   }
		      	   STRY(cascade_parser(cascade_struct, next_a, aa, pa));
			   i += incr;
		       	   goto accept_net_peering_arg;
		      }

		     if (i + 1 < ac && av[i + 1][0] == '-' && av[i + 1][1] == '-' && strcmp(av[i + 1] + 2, "set-var")) {
 		             char *next_a = &av[i + 1][2];
			     char *str = next_a;
 		     	     char *aa = i + 2 < ac ? av[i + 2] : 0;
			     int aret = 0;
			     int incr = aa ? 2 : 1;

			     (void)str;
			     if (aa && aa[0] == '-' && aa[1] == '-' && aa[2] != '-') {
				 	META_ARGS({ aa = 0; incr = 1; });
			     }
			      if ((aret = strcmp(next_a, "DryRun")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "DryRun argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          s->is_set_dry_run = 1;
				          if (!aa || !strcasecmp(aa, "true")) {
				          		s->dry_run = 1;
				           } else if (!strcasecmp(aa, "false")) {
				          		s->dry_run = 0;
				           } else {
				          		BAD_RET("DryRun require true/false\n");
				           }
				      } else
			      if ((aret = strcmp(next_a, "NetPeeringId")) == 0 || aret == '='  || aret == '.') {
			      	 char *eq_ptr = strchr(next_a, '=');
			      	 if (eq_ptr) {
				    TRY((!*eq_ptr), "NetPeeringId argument missing\n");
				    aa = eq_ptr + 1;
				    incr = 1;
				 }
				          TRY(!aa, "NetPeeringId argument missing\n");
				          s->net_peering_id = aa; // string string

				       } else
			    {
				BAD_RET("'%s' is not a valide argument for 'AcceptNetPeering'\n", next_a);
			    }
		            i += incr;
			    goto accept_net_peering_arg;
		     }
		     cret = osc_accept_net_peering(&e, &r, &a);
            	     TRY(cret, "fail to call AcceptNetPeering: %s\n", curl_easy_strerror(cret));
		     CHK_BAD_RET(!r.buf, "connection sucessful, but empty responce\n");
		     jobj = NULL;
		     if (program_flag & OAPI_RAW_OUTPUT)
		             puts(r.buf);
		     else {
			     jobj = json_tokener_parse(r.buf);
			     puts(json_object_to_json_string_ext(jobj,
					JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_NOSLASHESCAPE |
					color_flag));
		     }
		     while (i + 1 < ac && !strcmp(av[i + 1], "--set-var")) {
		     	     ++i;
			     TRY(i + 1 >= ac, "--set-var require an argument");
		     	     if (!jobj)
			     	jobj = json_tokener_parse(r.buf);
			     if (parse_variable(jobj, av, ac, i))
			     	return -1;
		     	     ++i;
		      }

		      if (jobj) {
			     json_object_put(jobj);
			     jobj = NULL;
		      }
		     osc_deinit_str(&r);
	      } else
		{
			printf("Unknown Call %s\n", av[i]);
			ret = 1;
			goto out;
		}
	}
good:
	ret = 0;
out:
	return ret;
}
