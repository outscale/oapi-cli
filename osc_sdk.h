/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, Outscale SAS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

 /*
  * This code is autogenerated, don't edit it directely
  */

#ifndef __SDK_C__
#define __SDK_C__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <curl/curl.h>

#ifdef __GNUC__
/*
 * note that thoses attribute work, on the struct, not the pointer
 * so, use it with "auto_osc_env struct osc_env e;"
 * note the absence of '*' before e; (and same with osc_str)
 */
#define auto_osc_str __attribute__((cleanup(osc_deinit_str)))
#define auto_osc_env __attribute__((cleanup(osc_deinit_sdk)))

#endif

struct osc_str {
	int len;
	char *buf;
};

#define OSC_ENV_FREE_AK 1 << 0
#define OSC_ENV_FREE_REGION 1 << 1
#define OSC_VERBOSE_MODE  1 << 2 /* curl verbose mode + print request content */
#define OSC_INSECURE_MODE 1 << 3 /* see --insecure option of curl */
#define OSC_ENV_FREE_CERT 1 << 4
#define OSC_ENV_FREE_SSLKEY 1 << 5
#define OSC_ENV_FREE_SK 1 << 6

#define OSC_ENV_FREE_AK_SK (OSC_ENV_FREE_AK | OSC_ENV_FREE_SK)

#define OSC_API_VERSION "1.28.5"
#define OSC_SDK_VERSION 0X000700

enum osc_auth_method {
	OSC_AKSK_METHOD,
	OSC_PASSWORD_METHOD,
	OSC_NONE_METHOD
};

struct osc_env_conf {
	char *login;
	char *password;
	enum osc_auth_method auth_method;
};

struct osc_env {
	char *ak;
	char *sk;
	char *region;
	char *cert;
	char *sslkey;
	int flag;
	enum osc_auth_method auth_method;
	struct curl_slist *headers;
	struct osc_str endpoint;
	CURL *c;
};

#define OSC_SDK_VERSON_L (sizeof "00.11.22" - 1)

static const char *osc_sdk_version_str(void)
{
	static char ret[OSC_SDK_VERSON_L + 1];

	if (OSC_SDK_VERSION == 0xC061AC)
		return "unstable";
	ret[1] = (OSC_SDK_VERSION & 0x00000F) + '0';
	ret[0] = ((OSC_SDK_VERSION & 0x0000F0) >> 4) + '0';
	ret[2] = '.';
	ret[4] = ((OSC_SDK_VERSION & 0x000F00) >> 8) + '0';
	ret[3] = ((OSC_SDK_VERSION & 0x00F000) >> 12) + '0';
	ret[5] = '.';
	ret[7] = ((OSC_SDK_VERSION & 0x0F0000) >> 16) + '0';
	ret[6] = ((OSC_SDK_VERSION & 0xF00000) >> 20) + '0';
	ret[8] = 0;
	return ret;
}

struct accepter_net {
        /*
         * The account ID of the owner of the accepter Net.
         */
	char *account_id; /* string */
        /*
         * The IP range for the accepter Net, in CIDR notation (for example, 
         * `10.0.0.0/16`).
         */
	char *ip_range; /* string */
        /*
         * The ID of the accepter Net.
         */
	char *net_id; /* string */
};

struct access_key {
        /*
         * The ID of the access key.
         */
	char *access_key_id; /* string */
        /*
         * The date and time (UTC) of creation of the access key.
         */
	char *creation_date; /* string */
        /*
         * The date (UTC) at which the access key expires.
         */
	char *expiration_date; /* string */
        /*
         * The date and time (UTC) of the last modification of the access key.
         */
	char *last_modification_date; /* string */
        /*
         * The state of the access key (`ACTIVE` if the key is valid for API 
         * calls, or `INACTIVE` if not).
         */
	char *state; /* string */
};

struct access_key_secret_key {
        /*
         * The ID of the access key.
         */
	char *access_key_id; /* string */
        /*
         * The date and time (UTC) of creation of the access key.
         */
	char *creation_date; /* string */
        /*
         * The date and time (UTC) at which the access key expires.
         */
	char *expiration_date; /* string */
        /*
         * The date and time (UTC) of the last modification of the access key.
         */
	char *last_modification_date; /* string */
        /*
         * The access key that enables you to send requests.
         */
	char *secret_key; /* string */
        /*
         * The state of the access key (`ACTIVE` if the key is valid for API 
         * calls, or `INACTIVE` if not).
         */
	char *state; /* string */
};

struct access_log {
        /*
         * If true, access logs are enabled for your load balancer. If false, 
         * they are not. If you set this to true in your request, the 
         * `OsuBucketName` parameter is required.
         */
        int is_set_is_enabled;
	int is_enabled; /* bool */
        /*
         * The name of the OOS bucket for the access logs.
         */
	char *osu_bucket_name; /* string */
        /*
         * The path to the folder of the access logs in your OOS bucket (by 
         * default, the `root` level of your bucket).
         */
	char *osu_bucket_prefix; /* string */
        /*
         * The time interval for the publication of access logs in the OOS 
         * bucket, in minutes. This value can be either `5` or `60` (by default, 
         * `60`).
         */
        int is_set_publication_interval;
	int publication_interval; /* int */
};

struct account {
        /*
         * The ID of the account.
         */
	char *account_id; /* string */
        /*
         * One or more additional email addresses for the account. These 
         * addresses are used for notifications only.
         */
        char *additional_emails_str;
	char **additional_emails; /* array string */
        /*
         * The city of the account owner.
         */
	char *city; /* string */
        /*
         * The name of the company for the account.
         */
	char *company_name; /* string */
        /*
         * The country of the account owner.
         */
	char *country; /* string */
        /*
         * The ID of the customer.
         */
	char *customer_id; /* string */
        /*
         * The main email address for the account. This address is used for your 
         * credentials and for notifications.
         */
	char *email; /* string */
        /*
         * The first name of the account owner.
         */
	char *first_name; /* string */
        /*
         * The job title of the account owner.
         */
	char *job_title; /* string */
        /*
         * The last name of the account owner.
         */
	char *last_name; /* string */
        /*
         * The mobile phone number of the account owner.
         */
	char *mobile_number; /* string */
        /*
         * The landline phone number of the account owner.
         */
	char *phone_number; /* string */
        /*
         * The state/province of the account.
         */
	char *state_province; /* string */
        /*
         * The value added tax (VAT) number for the account.
         */
	char *vat_number; /* string */
        /*
         * The ZIP code of the city.
         */
	char *zip_code; /* string */
};

struct api_access_policy {
        /*
         * The maximum possible lifetime for your access keys, in seconds. If 
         * `0`, your access keys can have unlimited lifetimes.
         */
        int is_set_max_access_key_expiration_seconds;
	int max_access_key_expiration_seconds; /* int */
        /*
         * If true, a trusted session is activated, allowing you to bypass 
         * Certificate Authorities (CAs) enforcement. For more information, see 
         * [About Your API Access 
         * Policy](https://docs.outscale.com/en/userguide/About-Your-API-Access-P
         * olicy.html).<br />\nIf this is enabled, it is required that you and 
         * all your users log in to Cockpit v2 using the WebAuthn method for 
         * multi-factor authentication. For more information, see [About 
         * Authentication > Multi-Factor 
         * Authentication](https://docs.outscale.com/en/userguide/About-Authentic
         * ation.html#_multi_factor_authentication).
         */
        int is_set_require_trusted_env;
	int require_trusted_env; /* bool */
};

struct api_access_rule {
        /*
         *  The ID of the API access rule.
         */
	char *api_access_rule_id; /* string */
        /*
         * One or more IDs of Client Certificate Authorities (CAs) used for the 
         * API access rule.
         */
        char *ca_ids_str;
	char **ca_ids; /* array string */
        /*
         * One or more Client Certificate Common Names (CNs).
         */
        char *cns_str;
	char **cns; /* array string */
        /*
         * The description of the API access rule.
         */
	char *description; /* string */
        /*
         * One or more IP ranges used for the API access rule, in CIDR notation 
         * (for example, `192.0.2.0/16`).
         */
        char *ip_ranges_str;
	char **ip_ranges; /* array string */
};

struct application_sticky_cookie_policy {
        /*
         * The name of the application cookie used for stickiness.
         */
	char *cookie_name; /* string */
        /*
         * The mnemonic name for the policy being created. The name must be 
         * unique within a set of policies for this load balancer.
         */
	char *policy_name; /* string */
};

struct backend_vm_health {
        /*
         * The description of the state of the back-end VM.
         */
	char *description; /* string */
        /*
         * The state of the back-end VM (`InService` \\| `OutOfService` \\| 
         * `Unknown`).
         */
	char *state; /* string */
        /*
         * Information about the cause of `OutOfService` VMs.<br 
         * />\nSpecifically, whether the cause is Elastic Load Balancing or the 
         * VM (`ELB` \\| `Instance` \\| `N/A`).
         */
	char *state_reason; /* string */
        /*
         * The ID of the back-end VM.
         */
	char *vm_id; /* string */
};

struct bsu_created {
        /*
         * If true, the volume is deleted when terminating the VM. If false, the 
         * volume is not deleted when terminating the VM.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The date and time of attachment of the volume to the VM, in ISO 8601 
         * date-time format.
         */
	char *link_date; /* string */
        /*
         * The state of the volume.
         */
	char *state; /* string */
        /*
         * The ID of the volume.
         */
	char *volume_id; /* string */
};

struct block_device_mapping_created {
        /*
         *   Information about the created BSU volume.
         *   -DeleteOnVmDeletion: bool
         *     If true, the volume is deleted when terminating the VM. If 
         *     false, the volume is not deleted when terminating the VM.
         *   -LinkDate: string
         *     The date and time of attachment of the volume to the VM, in 
         *     ISO 8601 date-time format.
         *   -State: string
         *     The state of the volume.
         *   -VolumeId: string
         *     The ID of the volume.
         */
        char *bsu_str;
        int is_set_bsu;
	struct bsu_created bsu; /* ref BsuCreated */
        /*
         * The name of the device.
         */
	char *device_name; /* string */
};

struct bsu_to_create {
        /*
         * By default or if set to true, the volume is deleted when terminating 
         * the VM. If false, the volume is not deleted when terminating the VM.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The number of I/O operations per second (IOPS). This parameter must 
         * be specified only if you create an `io1` volume. The maximum number 
         * of IOPS allowed for `io1` volumes is `13000` with a maximum 
         * performance ratio of 300 IOPS per gibibyte.
         */
        int is_set_iops;
	int iops; /* int */
        /*
         * The ID of the snapshot used to create the volume.
         */
	char *snapshot_id; /* string */
        /*
         * The size of the volume, in gibibytes (GiB).<br />\nIf you specify a 
         * snapshot ID, the volume size must be at least equal to the snapshot 
         * size.<br />\nIf you specify a snapshot ID but no volume size, the 
         * volume is created with a size similar to the snapshot one.
         */
        int is_set_volume_size;
	int volume_size; /* int */
        /*
         * The type of the volume (`standard` \\| `io1` \\| `gp2`). If not 
         * specified in the request, a `standard` volume is created.<br />\nFor 
         * more information about volume types, see [About Volumes > Volume 
         * Types and 
         * IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volum
         * e_types_and_iops).
         */
	char *volume_type; /* string */
};

struct block_device_mapping_image {
        /*
         *   Information about the BSU volume to create.
         *   -DeleteOnVmDeletion: bool
         *     By default or if set to true, the volume is deleted when 
         *     terminating the VM. If false, the volume is not deleted when 
         *     terminating the VM.
         *   -Iops: int
         *     The number of I/O operations per second (IOPS). This parameter 
         *     must be specified only if you create an `io1` volume. The 
         *     maximum number of IOPS allowed for `io1` volumes is `13000` 
         *     with a maximum performance ratio of 300 IOPS per gibibyte.
         *   -SnapshotId: string
         *     The ID of the snapshot used to create the volume.
         *   -VolumeSize: int
         *     The size of the volume, in gibibytes (GiB).<br />\nIf you 
         *     specify a snapshot ID, the volume size must be at least equal 
         *     to the snapshot size.<br />\nIf you specify a snapshot ID but 
         *     no volume size, the volume is created with a size similar to 
         *     the snapshot one.
         *   -VolumeType: string
         *     The type of the volume (`standard` \\| `io1` \\| `gp2`). If 
         *     not specified in the request, a `standard` volume is 
         *     created.<br />\nFor more information about volume types, see 
         *     [About Volumes > Volume Types and 
         *     IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#
         *     _volume_types_and_iops).
         */
        char *bsu_str;
        int is_set_bsu;
	struct bsu_to_create bsu; /* ref BsuToCreate */
        /*
         * The device name for the volume. For a root device, you must use 
         * `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, 
         * `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between 
         * `b` and `z`, and the second `X` is a letter between `a` and `z`).
         */
	char *device_name; /* string */
        /*
         * The name of the virtual device (`ephemeralN`).
         */
	char *virtual_device_name; /* string */
};

struct block_device_mapping_vm_creation {
        /*
         *   Information about the BSU volume to create.
         *   -DeleteOnVmDeletion: bool
         *     By default or if set to true, the volume is deleted when 
         *     terminating the VM. If false, the volume is not deleted when 
         *     terminating the VM.
         *   -Iops: int
         *     The number of I/O operations per second (IOPS). This parameter 
         *     must be specified only if you create an `io1` volume. The 
         *     maximum number of IOPS allowed for `io1` volumes is `13000` 
         *     with a maximum performance ratio of 300 IOPS per gibibyte.
         *   -SnapshotId: string
         *     The ID of the snapshot used to create the volume.
         *   -VolumeSize: int
         *     The size of the volume, in gibibytes (GiB).<br />\nIf you 
         *     specify a snapshot ID, the volume size must be at least equal 
         *     to the snapshot size.<br />\nIf you specify a snapshot ID but 
         *     no volume size, the volume is created with a size similar to 
         *     the snapshot one.
         *   -VolumeType: string
         *     The type of the volume (`standard` \\| `io1` \\| `gp2`). If 
         *     not specified in the request, a `standard` volume is 
         *     created.<br />\nFor more information about volume types, see 
         *     [About Volumes > Volume Types and 
         *     IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#
         *     _volume_types_and_iops).
         */
        char *bsu_str;
        int is_set_bsu;
	struct bsu_to_create bsu; /* ref BsuToCreate */
        /*
         * The device name for the volume. For a root device, you must use 
         * `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, 
         * `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between 
         * `b` and `z`, and the second `X` is a letter between `a` and `z`).
         */
	char *device_name; /* string */
        /*
         * Removes the device which is included in the block device mapping of 
         * the OMI.
         */
	char *no_device; /* string */
        /*
         * The name of the virtual device (`ephemeralN`).
         */
	char *virtual_device_name; /* string */
};

struct bsu_to_update_vm {
        /*
         * If set to true, the volume is deleted when terminating the VM. If set 
         * to false, the volume is not deleted when terminating the VM.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The ID of the volume.
         */
	char *volume_id; /* string */
};

struct block_device_mapping_vm_update {
        /*
         *   Information about the BSU volume.
         *   -DeleteOnVmDeletion: bool
         *     If set to true, the volume is deleted when terminating the VM. 
         *     If set to false, the volume is not deleted when terminating the 
         *     VM.
         *   -VolumeId: string
         *     The ID of the volume.
         */
        char *bsu_str;
        int is_set_bsu;
	struct bsu_to_update_vm bsu; /* ref BsuToUpdateVm */
        /*
         * The device name for the volume. For a root device, you must use 
         * `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, 
         * `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between 
         * `b` and `z`, and the second `X` is a letter between `a` and `z`).
         */
	char *device_name; /* string */
        /*
         * Removes the device which is included in the block device mapping of 
         * the OMI.
         */
	char *no_device; /* string */
        /*
         * The name of the virtual device (`ephemeralN`).
         */
	char *virtual_device_name; /* string */
};

struct ca {
        /*
         * The fingerprint of the CA.
         */
	char *ca_fingerprint; /* string */
        /*
         * The ID of the CA.
         */
	char *ca_id; /* string */
        /*
         * The description of the CA.
         */
	char *description; /* string */
};

struct catalog {
        /*
         * One or more catalog entries.
         *   Information about the catalog entry.
         *   -Category: string
         *     The category of the catalog entry (for example, `network`).
         *   -Flags: string
         *     When returned and equal to `PER_MONTH`, the price of the 
         *     catalog entry is calculated on a monthly basis.
         *   -Operation: string
         *     The API call associated with the catalog entry (for example, 
         *     `CreateVms` or `RunInstances`).
         *   -Service: string
         *     The service associated with the catalog entry (`TinaOS-FCU`, 
         *     `TinaOS-LBU`, `TinaOS-DirectLink`, or `TinaOS-OOS`).
         *   -SubregionName: string
         *     The Subregion associated with the catalog entry.
         *   -Title: string
         *     The description of the catalog entry.
         *   -Type: string
         *     The type of resource associated with the catalog entry.
         *   -UnitPrice: double
         *     The unit price of the catalog entry, in the currency of the 
         *     catalog of the Region where the API method was used.
         */
        char *entries_str;
        int nb_entries;
	struct catalog_entry *entries; /* array ref CatalogEntry */
};

struct catalog_entry {
        /*
         * The category of the catalog entry (for example, `network`).
         */
	char *category; /* string */
        /*
         * When returned and equal to `PER_MONTH`, the price of the catalog 
         * entry is calculated on a monthly basis.
         */
	char *flags; /* string */
        /*
         * The API call associated with the catalog entry (for example, 
         * `CreateVms` or `RunInstances`).
         */
	char *operation; /* string */
        /*
         * The service associated with the catalog entry (`TinaOS-FCU`, 
         * `TinaOS-LBU`, `TinaOS-DirectLink`, or `TinaOS-OOS`).
         */
	char *service; /* string */
        /*
         * The Subregion associated with the catalog entry.
         */
	char *subregion_name; /* string */
        /*
         * The description of the catalog entry.
         */
	char *title; /* string */
        /*
         * The type of resource associated with the catalog entry.
         */
	char *type; /* string */
        /*
         * The unit price of the catalog entry, in the currency of the catalog 
         * of the Region where the API method was used.
         */
        int is_set_unit_price;
	double unit_price; /* double */
};

struct catalogs {
        /*
         * One or more catalog entries.
         *   Information about the catalog entry.
         *   -Category: string
         *     The category of the catalog entry (for example, `network`).
         *   -Flags: string
         *     When returned and equal to `PER_MONTH`, the price of the 
         *     catalog entry is calculated on a monthly basis.
         *   -Operation: string
         *     The API call associated with the catalog entry (for example, 
         *     `CreateVms` or `RunInstances`).
         *   -Service: string
         *     The service associated with the catalog entry (`TinaOS-FCU`, 
         *     `TinaOS-LBU`, `TinaOS-DirectLink`, or `TinaOS-OOS`).
         *   -SubregionName: string
         *     The Subregion associated with the catalog entry.
         *   -Title: string
         *     The description of the catalog entry.
         *   -Type: string
         *     The type of resource associated with the catalog entry.
         *   -UnitPrice: double
         *     The unit price of the catalog entry, in the currency of the 
         *     catalog of the Region where the API method was used.
         */
        char *entries_str;
        int nb_entries;
	struct catalog_entry *entries; /* array ref CatalogEntry */
        /*
         * The beginning of the time period, in ISO 8601 date-time format.
         */
	char *from_date; /* string */
        /*
         * The state of the catalog (`CURRENT` \\| `OBSOLETE`).
         */
	char *state; /* string */
        /*
         * The end of the time period, in ISO 8601 date-time format.
         */
	char *to_date; /* string */
};

struct client_gateway {
        /*
         * The Autonomous System Number (ASN) used by the Border Gateway 
         * Protocol (BGP) to find the path to your client gateway through the 
         * Internet.
         */
        int is_set_bgp_asn;
	int bgp_asn; /* int */
        /*
         * The ID of the client gateway.
         */
	char *client_gateway_id; /* string */
        /*
         * The type of communication tunnel used by the client gateway (only 
         * `ipsec.1` is supported).
         */
	char *connection_type; /* string */
        /*
         * The public IPv4 address of the client gateway (must be a fixed 
         * address into a NATed network).
         */
	char *public_ip; /* string */
        /*
         * The state of the client gateway (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
	char *state; /* string */
        /*
         * One or more tags associated with the client gateway.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct consumption_entry {
        /*
         * The ID of your TINA account.
         */
	char *account_id; /* string */
        /*
         * The category of the resource (for example, `network`).
         */
	char *category; /* string */
        /*
         * The beginning of the time period, in ISO 8601 date-time format.
         */
	char *from_date; /* string */
        /*
         * The API call that triggered the resource consumption (for example, 
         * `RunInstances` or `CreateVolume`).
         */
	char *operation; /* string */
        /*
         * The ID of the TINA account which is billed for your consumption. It 
         * can be different from your account in the `AccountId` parameter.
         */
	char *paying_account_id; /* string */
        /*
         * The total price of the consumed resource during the specified time 
         * period, in the currency of the catalog of the Region where the API 
         * method was used.
         */
        int is_set_price;
	double price; /* double */
        /*
         * The service of the API call (`TinaOS-FCU`, `TinaOS-LBU`, 
         * `TinaOS-DirectLink`, `TinaOS-OOS`, or `TinaOS-OSU`).
         */
	char *service; /* string */
        /*
         * The name of the Subregion.
         */
	char *subregion_name; /* string */
        /*
         * A description of the consumed resource.
         */
	char *title; /* string */
        /*
         * The end of the time period, in ISO 8601 date-time format.
         */
	char *to_date; /* string */
        /*
         * The type of resource, depending on the API call.
         */
	char *type; /* string */
        /*
         * The unit price of the consumed resource, in the currency of the 
         * catalog of the Region where the API method was used.
         */
        int is_set_unit_price;
	double unit_price; /* double */
        /*
         * The consumed amount for the resource. The unit depends on the 
         * resource type. For more information, see the `Title` element.
         */
        int is_set_value;
	double value; /* double */
};

struct dedicated_group {
        /*
         * The account ID of the owners of the dedicated group.
         */
	char *account_id; /* string */
        /*
         * The processor generation.
         */
        int is_set_cpu_generation;
	int cpu_generation; /* int */
        /*
         * The ID of the dedicated group.
         */
	char *dedicated_group_id; /* string */
        /*
         * The name of the dedicated group.
         */
	char *name; /* string */
        /*
         * The IDs of the Nets in the dedicated group.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The name of the Subregion in which the dedicated group is located.
         */
	char *subregion_name; /* string */
        /*
         * The IDs of the VMs in the dedicated group.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct dhcp_options_set {
        /*
         * If true, the DHCP options set is a default one. If false, it is not.
         */
        int is_set_default_arg;
	int default_arg; /* bool */
        /*
         * The ID of the DHCP options set.
         */
	char *dhcp_options_set_id; /* string */
        /*
         * The domain name.
         */
	char *domain_name; /* string */
        /*
         * One or more IPs for the domain name servers.
         */
        char *domain_name_servers_str;
	char **domain_name_servers; /* array string */
        /*
         * One or more IPs for the log servers.
         */
        char *log_servers_str;
	char **log_servers; /* array string */
        /*
         * One or more IPs for the NTP servers.
         */
        char *ntp_servers_str;
	char **ntp_servers; /* array string */
        /*
         * One or more tags associated with the DHCP options set.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct direct_link {
        /*
         * The account ID of the owner of the DirectLink.
         */
	char *account_id; /* string */
        /*
         * The physical link bandwidth (either 1 Gbps or 10 Gbps).
         */
	char *bandwidth; /* string */
        /*
         * The ID of the DirectLink (for example, `dxcon-xxxxxxxx`).
         */
	char *direct_link_id; /* string */
        /*
         * The name of the DirectLink.
         */
	char *direct_link_name; /* string */
        /*
         * The datacenter where the DirectLink is located.
         */
	char *location; /* string */
        /*
         * The Region in which the DirectLink has been created.
         */
	char *region_name; /* string */
        /*
         * The state of the DirectLink.<br />\n* `requested`: The DirectLink is 
         * requested but the request has not been validated yet.<br />\n* 
         * `pending`: The DirectLink request has been validated. It remains in 
         * the `pending` state until you establish the physical link.<br />\n* 
         * `available`: The physical link is established and the connection is 
         * ready to use.<br />\n* `deleting`: The deletion process is in 
         * progress.<br />\n* `deleted`: The DirectLink is deleted.
         */
	char *state; /* string */
};

struct direct_link_interface {
        /*
         * The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on 
         * the customer's side of the DirectLink interface. This number must be 
         * between `64512` and `65534`.
         */
        int is_set_bgp_asn;
	int bgp_asn; /* int */
        /*
         * The BGP authentication key.
         */
	char *bgp_key; /* string */
        /*
         * The IP on the customer's side of the DirectLink interface.
         */
	char *client_private_ip; /* string */
        /*
         * The name of the DirectLink interface.
         */
	char *direct_link_interface_name; /* string */
        /*
         * The IP on the OUTSCALE side of the DirectLink interface.
         */
	char *outscale_private_ip; /* string */
        /*
         * The ID of the target virtual gateway.
         */
	char *virtual_gateway_id; /* string */
        /*
         * The VLAN number associated with the DirectLink interface. This number 
         * must be unique and be between `2` and `4094`.
         */
        int is_set_vlan;
	int vlan; /* int */
};

struct direct_link_interfaces {
        /*
         * The account ID of the owner of the DirectLink interface.
         */
	char *account_id; /* string */
        /*
         * The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on 
         * the customer's side of the DirectLink interface.
         */
        int is_set_bgp_asn;
	int bgp_asn; /* int */
        /*
         * The BGP authentication key.
         */
	char *bgp_key; /* string */
        /*
         * The IP on the customer's side of the DirectLink interface.
         */
	char *client_private_ip; /* string */
        /*
         * The ID of the DirectLink.
         */
	char *direct_link_id; /* string */
        /*
         * The ID of the DirectLink interface.
         */
	char *direct_link_interface_id; /* string */
        /*
         * The name of the DirectLink interface.
         */
	char *direct_link_interface_name; /* string */
        /*
         * The type of the DirectLink interface (always `private`).
         */
	char *interface_type; /* string */
        /*
         * The datacenter where the DirectLink interface is located.
         */
	char *location; /* string */
        /*
         * The maximum transmission unit (MTU) of the DirectLink interface, in 
         * bytes (always `1500`).
         */
        int is_set_mtu;
	int mtu; /* int */
        /*
         * The IP on the OUTSCALE side of the DirectLink interface.
         */
	char *outscale_private_ip; /* string */
        /*
         * The state of the DirectLink interface (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted` \\| `confirming` \\| `rejected` \\| 
         * `expired`).
         */
	char *state; /* string */
        /*
         * The ID of the target virtual gateway.
         */
	char *virtual_gateway_id; /* string */
        /*
         * The VLAN number associated with the DirectLink interface.
         */
        int is_set_vlan;
	int vlan; /* int */
};

struct errors {
        /*
         * The code of the error.
         */
	char *code; /* string */
        /*
         * The details of the error.
         */
	char *details; /* string */
        /*
         * The type of the error.
         */
	char *type; /* string */
};

struct filters_access_keys {
        /*
         * The IDs of the access keys.
         */
        char *access_key_ids_str;
	char **access_key_ids; /* array string */
        /*
         * The states of the access keys (`ACTIVE` \\| `INACTIVE`).
         */
        char *states_str;
	char **states; /* array string */
};

struct filters_api_access_rule {
        /*
         * One or more IDs of API access rules.
         */
        char *api_access_rule_ids_str;
	char **api_access_rule_ids; /* array string */
        /*
         * One or more IDs of Client Certificate Authorities (CAs).
         */
        char *ca_ids_str;
	char **ca_ids; /* array string */
        /*
         * One or more Client Certificate Common Names (CNs).
         */
        char *cns_str;
	char **cns; /* array string */
        /*
         * One or more descriptions of API access rules.
         */
        char *descriptions_str;
	char **descriptions; /* array string */
        /*
         * One or more IP addresses or CIDR blocks (for example, `192.0.2.0/16`).
         */
        char *ip_ranges_str;
	char **ip_ranges; /* array string */
};

struct filters_api_log {
        /*
         * The access keys used for the logged calls.
         */
        char *query_access_keys_str;
	char **query_access_keys; /* array string */
        /*
         * The names of the APIs of the logged calls (always `oapi` for the 
         * OUTSCALE API).
         */
        char *query_api_names_str;
	char **query_api_names; /* array string */
        /*
         * The names of the logged calls.
         */
        char *query_call_names_str;
	char **query_call_names; /* array string */
        /*
         * The date and time, or the date, after which you want to retrieve 
         * logged calls, in ISO 8601 format (for example, 
         * `2020-06-14T00:00:00.000Z` or `2020-06-14`). By default, this date is 
         * set to 48 hours before the `QueryDateBefore` parameter value.
         */
	char *query_date_after; /* string */
        /*
         * The date and time, or the date, before which you want to retrieve 
         * logged calls, in ISO 8601 format (for example, 
         * `2020-06-30T00:00:00.000Z` or `2020-06-14`). By default, this date is 
         * set to now, or 48 hours after the `QueryDateAfter` parameter value.
         */
	char *query_date_before; /* string */
        /*
         * The IPs used for the logged calls.
         */
        char *query_ip_addresses_str;
	char **query_ip_addresses; /* array string */
        /*
         * The user agents of the HTTP requests of the logged calls.
         */
        char *query_user_agents_str;
	char **query_user_agents; /* array string */
        /*
         * The request IDs provided in the responses of the logged calls.
         */
        char *request_ids_str;
	char **request_ids; /* array string */
        /*
         * The HTTP status codes of the logged calls.
         */
        char *response_status_codes_str;
	int *response_status_codes; /* array integer */
};

struct filters_ca {
        /*
         * The fingerprints of the CAs.
         */
        char *ca_fingerprints_str;
	char **ca_fingerprints; /* array string */
        /*
         * The IDs of the CAs.
         */
        char *ca_ids_str;
	char **ca_ids; /* array string */
        /*
         * The descriptions of the CAs.
         */
        char *descriptions_str;
	char **descriptions; /* array string */
};

struct filters_catalogs {
        /*
         * By default or if set to true, only returns the current catalog. If 
         * false, returns the current catalog and past catalogs.
         */
        int is_set_current_catalog_only;
	int current_catalog_only; /* bool */
        /*
         * The beginning of the time period, in ISO 8601 date format (for 
         * example, `2020-06-14`). This date cannot be older than 3 years. You 
         * must specify the parameters `FromDate` and `ToDate` together.
         */
	char *from_date; /* string */
        /*
         * The end of the time period, in ISO 8601 date format (for example, 
         * `2020-06-30`). You must specify the parameters `FromDate` and 
         * `ToDate` together.
         */
	char *to_date; /* string */
};

struct filters_client_gateway {
        /*
         * The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of 
         * the connections.
         */
        char *bgp_asns_str;
	int *bgp_asns; /* array integer */
        /*
         * The IDs of the client gateways.
         */
        char *client_gateway_ids_str;
	char **client_gateway_ids; /* array string */
        /*
         * The types of communication tunnels used by the client gateways (only 
         * `ipsec.1` is supported).
         */
        char *connection_types_str;
	char **connection_types; /* array string */
        /*
         * The public IPv4 addresses of the client gateways.
         */
        char *public_ips_str;
	char **public_ips; /* array string */
        /*
         * The states of the client gateways (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The keys of the tags associated with the client gateways.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the client gateways.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the client 
         * gateways, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_dedicated_group {
        /*
         * The processor generation for the VMs in the dedicated group (for 
         * example, `4`).
         */
        char *cpu_generations_str;
	int *cpu_generations; /* array integer */
        /*
         * The IDs of the dedicated groups.
         */
        char *dedicated_group_ids_str;
	char **dedicated_group_ids; /* array string */
        /*
         * The names of the dedicated groups.
         */
        char *names_str;
	char **names; /* array string */
        /*
         * The names of the Subregions in which the dedicated groups are located.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
};

struct filters_dhcp_options {
        /*
         * If true, lists all default DHCP options set. If false, lists all 
         * non-default DHCP options set.
         */
        int is_set_default_arg;
	int default_arg; /* bool */
        /*
         * The IDs of the DHCP options sets.
         */
        char *dhcp_options_set_ids_str;
	char **dhcp_options_set_ids; /* array string */
        /*
         * The IPs of the domain name servers used for the DHCP options sets.
         */
        char *domain_name_servers_str;
	char **domain_name_servers; /* array string */
        /*
         * The domain names used for the DHCP options sets.
         */
        char *domain_names_str;
	char **domain_names; /* array string */
        /*
         * The IPs of the log servers used for the DHCP options sets.
         */
        char *log_servers_str;
	char **log_servers; /* array string */
        /*
         * The IPs of the Network Time Protocol (NTP) servers used for the DHCP 
         * options sets.
         */
        char *ntp_servers_str;
	char **ntp_servers; /* array string */
        /*
         * The keys of the tags associated with the DHCP options sets.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the DHCP options sets.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the DHCP 
         * options sets, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_direct_link {
        /*
         * The IDs of the DirectLinks.
         */
        char *direct_link_ids_str;
	char **direct_link_ids; /* array string */
};

struct filters_direct_link_interface {
        /*
         * The IDs of the DirectLinks.
         */
        char *direct_link_ids_str;
	char **direct_link_ids; /* array string */
        /*
         * The IDs of the DirectLink interfaces.
         */
        char *direct_link_interface_ids_str;
	char **direct_link_interface_ids; /* array string */
};

struct filters_export_task {
        /*
         * The IDs of the export tasks.
         */
        char *task_ids_str;
	char **task_ids; /* array string */
};

struct filters_flexible_gpu {
        /*
         * Indicates whether the fGPU is deleted when terminating the VM.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * One or more IDs of fGPUs.
         */
        char *flexible_gpu_ids_str;
	char **flexible_gpu_ids; /* array string */
        /*
         * The processor generations that the fGPUs are compatible with.
         */
        char *generations_str;
	char **generations; /* array string */
        /*
         * One or more models of fGPUs. For more information, see [About 
         * Flexible 
         * GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html)
         * .
         */
        char *model_names_str;
	char **model_names; /* array string */
        /*
         * The states of the fGPUs (`allocated` \\| `attaching` \\| `attached` 
         * \\| `detaching`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The Subregions where the fGPUs are located.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
        /*
         * One or more IDs of VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct filters_image {
        /*
         * The account aliases of the owners of the OMIs.
         */
        char *account_aliases_str;
	char **account_aliases; /* array string */
        /*
         * The account IDs of the owners of the OMIs. By default, all the OMIs 
         * for which you have launch permissions are described.
         */
        char *account_ids_str;
	char **account_ids; /* array string */
        /*
         * The architectures of the OMIs (`i386` \\| `x86_64`).
         */
        char *architectures_str;
	char **architectures; /* array string */
        /*
         * Whether the volumes are deleted or not when terminating the VM.
         */
        int is_set_block_device_mapping_delete_on_vm_deletion;
	int block_device_mapping_delete_on_vm_deletion; /* bool */
        /*
         * The device names for the volumes.
         */
        char *block_device_mapping_device_names_str;
	char **block_device_mapping_device_names; /* array string */
        /*
         * The IDs of the snapshots used to create the volumes.
         */
        char *block_device_mapping_snapshot_ids_str;
	char **block_device_mapping_snapshot_ids; /* array string */
        /*
         * The sizes of the volumes, in gibibytes (GiB).
         */
        char *block_device_mapping_volume_sizes_str;
	int *block_device_mapping_volume_sizes; /* array integer */
        /*
         * The types of volumes (`standard` \\| `gp2` \\| `io1`).
         */
        char *block_device_mapping_volume_types_str;
	char **block_device_mapping_volume_types; /* array string */
        /*
         * The descriptions of the OMIs, provided when they were created.
         */
        char *descriptions_str;
	char **descriptions; /* array string */
        /*
         * The locations of the buckets where the OMI files are stored.
         */
        char *file_locations_str;
	char **file_locations; /* array string */
        /*
         * The hypervisor type of the OMI (always `xen`).
         */
        char *hypervisors_str;
	char **hypervisors; /* array string */
        /*
         * The IDs of the OMIs.
         */
        char *image_ids_str;
	char **image_ids; /* array string */
        /*
         * The names of the OMIs, provided when they were created.
         */
        char *image_names_str;
	char **image_names; /* array string */
        /*
         * The account IDs which have launch permissions for the OMIs.
         */
        char *permissions_to_launch_account_ids_str;
	char **permissions_to_launch_account_ids; /* array string */
        /*
         * If true, lists all public OMIs. If false, lists all private OMIs.
         */
        int is_set_permissions_to_launch_global_permission;
	int permissions_to_launch_global_permission; /* bool */
        /*
         * The names of the product codes associated with the OMI.
         */
        char *product_code_names_str;
	char **product_code_names; /* array string */
        /*
         * The product codes associated with the OMI.
         */
        char *product_codes_str;
	char **product_codes; /* array string */
        /*
         * The name of the root device. This value must be /dev/sda1.
         */
        char *root_device_names_str;
	char **root_device_names; /* array string */
        /*
         * The types of root device used by the OMIs (`bsu` or `ebs`).
         */
        char *root_device_types_str;
	char **root_device_types; /* array string */
        /*
         * The states of the OMIs (`pending` \\| `available` \\| `failed`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The keys of the tags associated with the OMIs.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the OMIs.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the OMIs, in 
         * the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The virtualization types (always `hvm`).
         */
        char *virtualization_types_str;
	char **virtualization_types; /* array string */
};

struct filters_internet_service {
        /*
         * The IDs of the Internet services.
         */
        char *internet_service_ids_str;
	char **internet_service_ids; /* array string */
        /*
         * The IDs of the Nets the Internet services are attached to.
         */
        char *link_net_ids_str;
	char **link_net_ids; /* array string */
        /*
         * The current states of the attachments between the Internet services 
         * and the Nets (only `available`, if the Internet gateway is attached 
         * to a Net).
         */
        char *link_states_str;
	char **link_states; /* array string */
        /*
         * The keys of the tags associated with the Internet services.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the Internet services.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the Internet 
         * services, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_keypair {
        /*
         * The fingerprints of the keypairs.
         */
        char *keypair_fingerprints_str;
	char **keypair_fingerprints; /* array string */
        /*
         * The names of the keypairs.
         */
        char *keypair_names_str;
	char **keypair_names; /* array string */
        /*
         * The types of the keypairs (`ssh-rsa`, `ssh-ed25519`, 
         * `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or 
         * `ecdsa-sha2-nistp521`).
         */
        char *keypair_types_str;
	char **keypair_types; /* array string */
};

struct filters_listener_rule {
        /*
         * The names of the listener rules.
         */
        char *listener_rule_names_str;
	char **listener_rule_names; /* array string */
};

struct filters_load_balancer {
        /*
         * The names of the load balancers.
         */
        char *load_balancer_names_str;
	char **load_balancer_names; /* array string */
};

struct filters_nat_service {
        /*
         * The IDs of the NAT services.
         */
        char *nat_service_ids_str;
	char **nat_service_ids; /* array string */
        /*
         * The IDs of the Nets in which the NAT services are.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The states of the NAT services (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The IDs of the Subnets in which the NAT services are.
         */
        char *subnet_ids_str;
	char **subnet_ids; /* array string */
        /*
         * The keys of the tags associated with the NAT services.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the NAT services.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the NAT 
         * services, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_net {
        /*
         * The IDs of the DHCP options sets.
         */
        char *dhcp_options_set_ids_str;
	char **dhcp_options_set_ids; /* array string */
        /*
         * The IP ranges for the Nets, in CIDR notation (for example, 
         * `10.0.0.0/16`).
         */
        char *ip_ranges_str;
	char **ip_ranges; /* array string */
        /*
         * If true, the Net used is the default one.
         */
        int is_set_is_default;
	int is_default; /* bool */
        /*
         * The IDs of the Nets.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The states of the Nets (`pending` \\| `available` \\| `deleting`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The keys of the tags associated with the Nets.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the Nets.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the Nets, in 
         * the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_net_access_point {
        /*
         * The IDs of the Net access points.
         */
        char *net_access_point_ids_str;
	char **net_access_point_ids; /* array string */
        /*
         * The IDs of the Nets.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The names of the services. For more information, see 
         * [ReadNetAccessPointServices](#readnetaccesspointservices).
         */
        char *service_names_str;
	char **service_names; /* array string */
        /*
         * The states of the Net access points (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The keys of the tags associated with the Net access points.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the Net access points.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the Net access 
         * points, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_net_peering {
        /*
         * The account IDs of the owners of the peer Nets.
         */
        char *accepter_net_account_ids_str;
	char **accepter_net_account_ids; /* array string */
        /*
         * The IP ranges of the peer Nets, in CIDR notation (for example, 
         * `10.0.0.0/24`).
         */
        char *accepter_net_ip_ranges_str;
	char **accepter_net_ip_ranges; /* array string */
        /*
         * The IDs of the peer Nets.
         */
        char *accepter_net_net_ids_str;
	char **accepter_net_net_ids; /* array string */
        /*
         * The dates and times at which the Net peerings expire, in ISO 8601 
         * date-time format (for example, `2020-06-14T00:00:00.000Z`).
         */
        char *expiration_dates_str;
	char **expiration_dates; /* array string */
        /*
         * The IDs of the Net peerings.
         */
        char *net_peering_ids_str;
	char **net_peering_ids; /* array string */
        /*
         * The account IDs of the owners of the peer Nets.
         */
        char *source_net_account_ids_str;
	char **source_net_account_ids; /* array string */
        /*
         * The IP ranges of the peer Nets.
         */
        char *source_net_ip_ranges_str;
	char **source_net_ip_ranges; /* array string */
        /*
         * The IDs of the peer Nets.
         */
        char *source_net_net_ids_str;
	char **source_net_net_ids; /* array string */
        /*
         * Additional information about the states of the Net peerings.
         */
        char *state_messages_str;
	char **state_messages; /* array string */
        /*
         * The states of the Net peerings (`pending-acceptance` \\| `active` \\| 
         * `rejected` \\| `failed` \\| `expired` \\| `deleted`).
         */
        char *state_names_str;
	char **state_names; /* array string */
        /*
         * The keys of the tags associated with the Net peerings.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the Net peerings.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the Net 
         * peerings, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_nic {
        /*
         * The descriptions of the NICs.
         */
        char *descriptions_str;
	char **descriptions; /* array string */
        /*
         * Whether the source/destination checking is enabled (true) or disabled 
         * (false).
         */
        int is_set_is_source_dest_check;
	int is_source_dest_check; /* bool */
        /*
         * Whether the NICs are deleted when the VMs they are attached to are 
         * terminated.
         */
        int is_set_link_nic_delete_on_vm_deletion;
	int link_nic_delete_on_vm_deletion; /* bool */
        /*
         * The device numbers the NICs are attached to.
         */
        char *link_nic_device_numbers_str;
	int *link_nic_device_numbers; /* array integer */
        /*
         * The attachment IDs of the NICs.
         */
        char *link_nic_link_nic_ids_str;
	char **link_nic_link_nic_ids; /* array string */
        /*
         * The states of the attachments.
         */
        char *link_nic_states_str;
	char **link_nic_states; /* array string */
        /*
         * The account IDs of the owners of the VMs the NICs are attached to.
         */
        char *link_nic_vm_account_ids_str;
	char **link_nic_vm_account_ids; /* array string */
        /*
         * The IDs of the VMs the NICs are attached to.
         */
        char *link_nic_vm_ids_str;
	char **link_nic_vm_ids; /* array string */
        /*
         * The account IDs of the owners of the public IPs associated with the 
         * NICs.
         */
        char *link_public_ip_account_ids_str;
	char **link_public_ip_account_ids; /* array string */
        /*
         * The association IDs returned when the public IPs were associated with 
         * the NICs.
         */
        char *link_public_ip_link_public_ip_ids_str;
	char **link_public_ip_link_public_ip_ids; /* array string */
        /*
         * The allocation IDs returned when the public IPs were allocated to 
         * their accounts.
         */
        char *link_public_ip_public_ip_ids_str;
	char **link_public_ip_public_ip_ids; /* array string */
        /*
         * The public IPs associated with the NICs.
         */
        char *link_public_ip_public_ips_str;
	char **link_public_ip_public_ips; /* array string */
        /*
         * The Media Access Control (MAC) addresses of the NICs.
         */
        char *mac_addresses_str;
	char **mac_addresses; /* array string */
        /*
         * The IDs of the Nets where the NICs are located.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The IDs of the NICs.
         */
        char *nic_ids_str;
	char **nic_ids; /* array string */
        /*
         * The private DNS names associated with the primary private IPs.
         */
        char *private_dns_names_str;
	char **private_dns_names; /* array string */
        /*
         * The account IDs of the owner of the public IPs associated with the 
         * private IPs.
         */
        char *private_ips_link_public_ip_account_ids_str;
	char **private_ips_link_public_ip_account_ids; /* array string */
        /*
         * The public IPs associated with the private IPs.
         */
        char *private_ips_link_public_ip_public_ips_str;
	char **private_ips_link_public_ip_public_ips; /* array string */
        /*
         * Whether the private IP is the primary IP associated with the NIC.
         */
        int is_set_private_ips_primary_ip;
	int private_ips_primary_ip; /* bool */
        /*
         * The private IPs of the NICs.
         */
        char *private_ips_private_ips_str;
	char **private_ips_private_ips; /* array string */
        /*
         * The IDs of the security groups associated with the NICs.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The names of the security groups associated with the NICs.
         */
        char *security_group_names_str;
	char **security_group_names; /* array string */
        /*
         * The states of the NICs.
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The IDs of the Subnets for the NICs.
         */
        char *subnet_ids_str;
	char **subnet_ids; /* array string */
        /*
         * The Subregions where the NICs are located.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
        /*
         * The keys of the tags associated with the NICs.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the NICs.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the NICs, in 
         * the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_product_type {
        /*
         * The IDs of the product types.
         */
        char *product_type_ids_str;
	char **product_type_ids; /* array string */
};

struct filters_public_ip {
        /*
         * The IDs representing the associations of public IPs with VMs or NICs.
         */
        char *link_public_ip_ids_str;
	char **link_public_ip_ids; /* array string */
        /*
         * The account IDs of the owners of the NICs.
         */
        char *nic_account_ids_str;
	char **nic_account_ids; /* array string */
        /*
         * The IDs of the NICs.
         */
        char *nic_ids_str;
	char **nic_ids; /* array string */
        /*
         * Whether the public IPs are for use in the public Cloud or in a Net.
         */
        char *placements_str;
	char **placements; /* array string */
        /*
         * The private IPs associated with the public IPs.
         */
        char *private_ips_str;
	char **private_ips; /* array string */
        /*
         * The IDs of the public IPs.
         */
        char *public_ip_ids_str;
	char **public_ip_ids; /* array string */
        /*
         * The public IPs.
         */
        char *public_ips_str;
	char **public_ips; /* array string */
        /*
         * The keys of the tags associated with the public IPs.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the public IPs.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the public IPs, 
         * in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The IDs of the VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct filters_quota {
        /*
         * The group names of the quotas.
         */
        char *collections_str;
	char **collections; /* array string */
        /*
         * The names of the quotas.
         */
        char *quota_names_str;
	char **quota_names; /* array string */
        /*
         * The resource IDs if these are resource-specific quotas, `global` if 
         * they are not.
         */
        char *quota_types_str;
	char **quota_types; /* array string */
        /*
         * The description of the quotas.
         */
        char *short_descriptions_str;
	char **short_descriptions; /* array string */
};

struct filters_route_table {
        /*
         * The IDs of the route tables involved in the associations.
         */
        char *link_route_table_ids_str;
	char **link_route_table_ids; /* array string */
        /*
         * The IDs of the associations between the route tables and the Subnets.
         */
        char *link_route_table_link_route_table_ids_str;
	char **link_route_table_link_route_table_ids; /* array string */
        /*
         * If true, the route tables are the main ones for their Nets.
         */
        int is_set_link_route_table_main;
	int link_route_table_main; /* bool */
        /*
         * The IDs of the Subnets involved in the associations.
         */
        char *link_subnet_ids_str;
	char **link_subnet_ids; /* array string */
        /*
         * The IDs of the Nets for the route tables.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The methods used to create a route.
         */
        char *route_creation_methods_str;
	char **route_creation_methods; /* array string */
        /*
         * The IP ranges specified in routes in the tables.
         */
        char *route_destination_ip_ranges_str;
	char **route_destination_ip_ranges; /* array string */
        /*
         * The service IDs specified in routes in the tables.
         */
        char *route_destination_service_ids_str;
	char **route_destination_service_ids; /* array string */
        /*
         * The IDs of the gateways specified in routes in the tables.
         */
        char *route_gateway_ids_str;
	char **route_gateway_ids; /* array string */
        /*
         * The IDs of the NAT services specified in routes in the tables.
         */
        char *route_nat_service_ids_str;
	char **route_nat_service_ids; /* array string */
        /*
         * The IDs of the Net peerings specified in routes in the tables.
         */
        char *route_net_peering_ids_str;
	char **route_net_peering_ids; /* array string */
        /*
         * The states of routes in the route tables (always `active`).
         */
        char *route_states_str;
	char **route_states; /* array string */
        /*
         * The IDs of the route tables.
         */
        char *route_table_ids_str;
	char **route_table_ids; /* array string */
        /*
         * The IDs of the VMs specified in routes in the tables.
         */
        char *route_vm_ids_str;
	char **route_vm_ids; /* array string */
        /*
         * The keys of the tags associated with the route tables.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the route tables.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the route 
         * tables, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_security_group {
        /*
         * The descriptions of the security groups.
         */
        char *descriptions_str;
	char **descriptions; /* array string */
        /*
         * The account IDs that have been granted permissions.
         */
        char *inbound_rule_account_ids_str;
	char **inbound_rule_account_ids; /* array string */
        /*
         * The beginnings of the port ranges for the TCP and UDP protocols, or 
         * the ICMP type numbers.
         */
        char *inbound_rule_from_port_ranges_str;
	int *inbound_rule_from_port_ranges; /* array integer */
        /*
         * The IP ranges that have been granted permissions, in CIDR notation 
         * (for example, `10.0.0.0/24`).
         */
        char *inbound_rule_ip_ranges_str;
	char **inbound_rule_ip_ranges; /* array string */
        /*
         * The IP protocols for the permissions (`tcp` \\| `udp` \\| `icmp`, or 
         * a protocol number, or `-1` for all protocols).
         */
        char *inbound_rule_protocols_str;
	char **inbound_rule_protocols; /* array string */
        /*
         * The IDs of the security groups that have been granted permissions.
         */
        char *inbound_rule_security_group_ids_str;
	char **inbound_rule_security_group_ids; /* array string */
        /*
         * The names of the security groups that have been granted permissions.
         */
        char *inbound_rule_security_group_names_str;
	char **inbound_rule_security_group_names; /* array string */
        /*
         * The ends of the port ranges for the TCP and UDP protocols, or the 
         * ICMP code numbers.
         */
        char *inbound_rule_to_port_ranges_str;
	int *inbound_rule_to_port_ranges; /* array integer */
        /*
         * The IDs of the Nets specified when the security groups were created.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The account IDs that have been granted permissions.
         */
        char *outbound_rule_account_ids_str;
	char **outbound_rule_account_ids; /* array string */
        /*
         * The beginnings of the port ranges for the TCP and UDP protocols, or 
         * the ICMP type numbers.
         */
        char *outbound_rule_from_port_ranges_str;
	int *outbound_rule_from_port_ranges; /* array integer */
        /*
         * The IP ranges that have been granted permissions, in CIDR notation 
         * (for example, `10.0.0.0/24`).
         */
        char *outbound_rule_ip_ranges_str;
	char **outbound_rule_ip_ranges; /* array string */
        /*
         * The IP protocols for the permissions (`tcp` \\| `udp` \\| `icmp`, or 
         * a protocol number, or `-1` for all protocols).
         */
        char *outbound_rule_protocols_str;
	char **outbound_rule_protocols; /* array string */
        /*
         * The IDs of the security groups that have been granted permissions.
         */
        char *outbound_rule_security_group_ids_str;
	char **outbound_rule_security_group_ids; /* array string */
        /*
         * The names of the security groups that have been granted permissions.
         */
        char *outbound_rule_security_group_names_str;
	char **outbound_rule_security_group_names; /* array string */
        /*
         * The ends of the port ranges for the TCP and UDP protocols, or the 
         * ICMP code numbers.
         */
        char *outbound_rule_to_port_ranges_str;
	int *outbound_rule_to_port_ranges; /* array integer */
        /*
         * The IDs of the security groups.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The names of the security groups.
         */
        char *security_group_names_str;
	char **security_group_names; /* array string */
        /*
         * The keys of the tags associated with the security groups.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the security groups.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the security 
         * groups, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_server_certificate {
        /*
         * The paths to the server certificates.
         */
        char *paths_str;
	char **paths; /* array string */
};

struct filters_service {
        /*
         * The IDs of the services.
         */
        char *service_ids_str;
	char **service_ids; /* array string */
        /*
         * The names of the services.
         */
        char *service_names_str;
	char **service_names; /* array string */
};

struct filters_snapshot {
        /*
         * The account aliases of the owners of the snapshots.
         */
        char *account_aliases_str;
	char **account_aliases; /* array string */
        /*
         * The account IDs of the owners of the snapshots.
         */
        char *account_ids_str;
	char **account_ids; /* array string */
        /*
         * The descriptions of the snapshots.
         */
        char *descriptions_str;
	char **descriptions; /* array string */
        /*
         * The beginning of the time period, in ISO 8601 date-time format (for 
         * example, `2020-06-14T00:00:00.000Z`).
         */
	char *from_creation_date; /* string */
        /*
         * The account IDs which have permissions to create volumes.
         */
        char *permissions_to_create_volume_account_ids_str;
	char **permissions_to_create_volume_account_ids; /* array string */
        /*
         * If true, lists all public volumes. If false, lists all private 
         * volumes.
         */
        int is_set_permissions_to_create_volume_global_permission;
	int permissions_to_create_volume_global_permission; /* bool */
        /*
         * The progresses of the snapshots, as a percentage.
         */
        char *progresses_str;
	int *progresses; /* array integer */
        /*
         * The IDs of the snapshots.
         */
        char *snapshot_ids_str;
	char **snapshot_ids; /* array string */
        /*
         * The states of the snapshots (`in-queue` \\| `completed` \\| `error`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The keys of the tags associated with the snapshots.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the snapshots.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the snapshots, 
         * in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The end of the time period, in ISO 8601 date-time format (for 
         * example, `2020-06-30T00:00:00.000Z`).
         */
	char *to_creation_date; /* string */
        /*
         * The IDs of the volumes used to create the snapshots.
         */
        char *volume_ids_str;
	char **volume_ids; /* array string */
        /*
         * The sizes of the volumes used to create the snapshots, in gibibytes 
         * (GiB).
         */
        char *volume_sizes_str;
	int *volume_sizes; /* array integer */
};

struct filters_subnet {
        /*
         * The number of available IPs.
         */
        char *available_ips_counts_str;
	int *available_ips_counts; /* array integer */
        /*
         * The IP ranges in the Subnets, in CIDR notation (for example, 
         * `10.0.0.0/16`).
         */
        char *ip_ranges_str;
	char **ip_ranges; /* array string */
        /*
         * The IDs of the Nets in which the Subnets are.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The states of the Subnets (`pending` \\| `available` \\| `deleted`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The IDs of the Subnets.
         */
        char *subnet_ids_str;
	char **subnet_ids; /* array string */
        /*
         * The names of the Subregions in which the Subnets are located.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
        /*
         * The keys of the tags associated with the Subnets.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the Subnets.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the Subnets, in 
         * the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
};

struct filters_subregion {
        /*
         * The names of the Regions containing the Subregions.
         */
        char *region_names_str;
	char **region_names; /* array string */
        /*
         * The states of the Subregions.
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The names of the Subregions.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
};

struct filters_tag {
        /*
         * The keys of the tags that are assigned to the resources. You can use 
         * this filter alongside the `Values` filter. In that case, you filter 
         * the resources corresponding to each tag, regardless of the other 
         * filter.
         */
        char *keys_str;
	char **keys; /* array string */
        /*
         * The IDs of the resources with which the tags are associated.
         */
        char *resource_ids_str;
	char **resource_ids; /* array string */
        /*
         * The resource type (`vm` \\| `image` \\| `volume` \\| `snapshot` \\| 
         * `public-ip` \\| `security-group` \\| `route-table` \\| `nic` \\| 
         * `net` \\| `subnet` \\| `net-peering` \\| `net-access-point` \\| 
         * `nat-service` \\| `internet-service` \\| `client-gateway` \\| 
         * `virtual-gateway` \\| `vpn-connection` \\| `dhcp-options` \\| `task`).
         */
        char *resource_types_str;
	char **resource_types; /* array string */
        /*
         * The values of the tags that are assigned to the resources. You can 
         * use this filter alongside the `TagKeys` filter. In that case, you 
         * filter the resources corresponding to each tag, regardless of the 
         * other filter.
         */
        char *values_str;
	char **values; /* array string */
};

struct filters_virtual_gateway {
        /*
         * The types of the virtual gateways (only `ipsec.1` is supported).
         */
        char *connection_types_str;
	char **connection_types; /* array string */
        /*
         * The IDs of the Nets the virtual gateways are attached to.
         */
        char *link_net_ids_str;
	char **link_net_ids; /* array string */
        /*
         * The current states of the attachments between the virtual gateways 
         * and the Nets (`attaching` \\| `attached` \\| `detaching` \\| 
         * `detached`).
         */
        char *link_states_str;
	char **link_states; /* array string */
        /*
         * The states of the virtual gateways (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * The keys of the tags associated with the virtual gateways.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the virtual gateways.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the virtual 
         * gateways, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The IDs of the virtual gateways.
         */
        char *virtual_gateway_ids_str;
	char **virtual_gateway_ids; /* array string */
};

struct filters_vm {
        /*
         * The architectures of the VMs (`i386` \\| `x86_64`).
         */
        char *architectures_str;
	char **architectures; /* array string */
        /*
         * Whether the BSU volumes are deleted when terminating the VMs.
         */
        int is_set_block_device_mapping_delete_on_vm_deletion;
	int block_device_mapping_delete_on_vm_deletion; /* bool */
        /*
         * The device names for the BSU volumes (in the format `/dev/sdX`, 
         * `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX`).
         */
        char *block_device_mapping_device_names_str;
	char **block_device_mapping_device_names; /* array string */
        /*
         * The link dates for the BSU volumes mapped to the VMs (for example, 
         * `2016-01-23T18:45:30.000Z`).
         */
        char *block_device_mapping_link_dates_str;
	char **block_device_mapping_link_dates; /* array string */
        /*
         * The states for the BSU volumes (`attaching` \\| `attached` \\| 
         * `detaching` \\| `detached`).
         */
        char *block_device_mapping_states_str;
	char **block_device_mapping_states; /* array string */
        /*
         * The volume IDs of the BSU volumes.
         */
        char *block_device_mapping_volume_ids_str;
	char **block_device_mapping_volume_ids; /* array string */
        /*
         * The idempotency tokens provided when launching the VMs.
         */
        char *client_tokens_str;
	char **client_tokens; /* array string */
        /*
         * The dates when the VMs were launched.
         */
        char *creation_dates_str;
	char **creation_dates; /* array string */
        /*
         * The IDs of the OMIs used to launch the VMs.
         */
        char *image_ids_str;
	char **image_ids; /* array string */
        /*
         * Whether the source/destination checking is enabled (true) or disabled 
         * (false).
         */
        int is_set_is_source_dest_checked;
	int is_source_dest_checked; /* bool */
        /*
         * The names of the keypairs used when launching the VMs.
         */
        char *keypair_names_str;
	char **keypair_names; /* array string */
        /*
         * The numbers for the VMs when launching a group of several VMs (for 
         * example, `0`, `1`, `2`, and so on).
         */
        char *launch_numbers_str;
	int *launch_numbers; /* array integer */
        /*
         * Whether the VMs are Spot Instances (spot).
         */
        char *lifecycles_str;
	char **lifecycles; /* array string */
        /*
         * The IDs of the Nets in which the VMs are running.
         */
        char *net_ids_str;
	char **net_ids; /* array string */
        /*
         * The IDs of the NICs.
         */
        char *nic_account_ids_str;
	char **nic_account_ids; /* array string */
        /*
         * The descriptions of the NICs.
         */
        char *nic_descriptions_str;
	char **nic_descriptions; /* array string */
        /*
         * Whether the source/destination checking is enabled (true) or disabled 
         * (false).
         */
        int is_set_nic_is_source_dest_checked;
	int nic_is_source_dest_checked; /* bool */
        /*
         * Whether the NICs are deleted when the VMs they are attached to are 
         * deleted.
         */
        int is_set_nic_link_nic_delete_on_vm_deletion;
	int nic_link_nic_delete_on_vm_deletion; /* bool */
        /*
         * The device numbers the NICs are attached to.
         */
        char *nic_link_nic_device_numbers_str;
	int *nic_link_nic_device_numbers; /* array integer */
        /*
         * The dates and time when the NICs were attached to the VMs.
         */
        char *nic_link_nic_link_nic_dates_str;
	char **nic_link_nic_link_nic_dates; /* array string */
        /*
         * The IDs of the NIC attachments.
         */
        char *nic_link_nic_link_nic_ids_str;
	char **nic_link_nic_link_nic_ids; /* array string */
        /*
         * The states of the attachments.
         */
        char *nic_link_nic_states_str;
	char **nic_link_nic_states; /* array string */
        /*
         * The account IDs of the owners of the VMs the NICs are attached to.
         */
        char *nic_link_nic_vm_account_ids_str;
	char **nic_link_nic_vm_account_ids; /* array string */
        /*
         * The IDs of the VMs the NICs are attached to.
         */
        char *nic_link_nic_vm_ids_str;
	char **nic_link_nic_vm_ids; /* array string */
        /*
         * The account IDs of the owners of the public IPs associated with the 
         * NICs.
         */
        char *nic_link_public_ip_account_ids_str;
	char **nic_link_public_ip_account_ids; /* array string */
        /*
         * The association IDs returned when the public IPs were associated with 
         * the NICs.
         */
        char *nic_link_public_ip_link_public_ip_ids_str;
	char **nic_link_public_ip_link_public_ip_ids; /* array string */
        /*
         * The allocation IDs returned when the public IPs were allocated to 
         * their accounts.
         */
        char *nic_link_public_ip_public_ip_ids_str;
	char **nic_link_public_ip_public_ip_ids; /* array string */
        /*
         * The public IPs associated with the NICs.
         */
        char *nic_link_public_ip_public_ips_str;
	char **nic_link_public_ip_public_ips; /* array string */
        /*
         * The Media Access Control (MAC) addresses of the NICs.
         */
        char *nic_mac_addresses_str;
	char **nic_mac_addresses; /* array string */
        /*
         * The IDs of the Nets where the NICs are located.
         */
        char *nic_net_ids_str;
	char **nic_net_ids; /* array string */
        /*
         * The IDs of the NICs.
         */
        char *nic_nic_ids_str;
	char **nic_nic_ids; /* array string */
        /*
         * The account IDs of the owner of the public IPs associated with the 
         * private IPs.
         */
        char *nic_private_ips_link_public_ip_account_ids_str;
	char **nic_private_ips_link_public_ip_account_ids; /* array string */
        /*
         * The public IPs associated with the private IPs.
         */
        char *nic_private_ips_link_public_ip_ids_str;
	char **nic_private_ips_link_public_ip_ids; /* array string */
        /*
         * Whether the private IPs are the primary IPs associated with the NICs.
         */
        int is_set_nic_private_ips_primary_ip;
	int nic_private_ips_primary_ip; /* bool */
        /*
         * The private IPs of the NICs.
         */
        char *nic_private_ips_private_ips_str;
	char **nic_private_ips_private_ips; /* array string */
        /*
         * The IDs of the security groups associated with the NICs.
         */
        char *nic_security_group_ids_str;
	char **nic_security_group_ids; /* array string */
        /*
         * The names of the security groups associated with the NICs.
         */
        char *nic_security_group_names_str;
	char **nic_security_group_names; /* array string */
        /*
         * The states of the NICs (`available` \\| `in-use`).
         */
        char *nic_states_str;
	char **nic_states; /* array string */
        /*
         * The IDs of the Subnets for the NICs.
         */
        char *nic_subnet_ids_str;
	char **nic_subnet_ids; /* array string */
        /*
         * The Subregions where the NICs are located.
         */
        char *nic_subregion_names_str;
	char **nic_subregion_names; /* array string */
        /*
         * The platforms. Use windows if you have Windows VMs. Otherwise, leave 
         * this filter blank.
         */
        char *platforms_str;
	char **platforms; /* array string */
        /*
         * The private IPs of the VMs.
         */
        char *private_ips_str;
	char **private_ips; /* array string */
        /*
         * The product codes associated with the OMI used to create the VMs.
         */
        char *product_codes_str;
	char **product_codes; /* array string */
        /*
         * The public IPs of the VMs.
         */
        char *public_ips_str;
	char **public_ips; /* array string */
        /*
         * The IDs of the reservation of the VMs, created every time you launch 
         * VMs. These reservation IDs can be associated with several VMs when 
         * you lauch a group of VMs using the same launch request.
         */
        char *reservation_ids_str;
	char **reservation_ids; /* array string */
        /*
         * The names of the root devices for the VMs (for example, `/dev/sda1`)
         */
        char *root_device_names_str;
	char **root_device_names; /* array string */
        /*
         * The root devices types used by the VMs (always `ebs`)
         */
        char *root_device_types_str;
	char **root_device_types; /* array string */
        /*
         * The IDs of the security groups for the VMs (only in the public Cloud).
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The names of the security groups for the VMs (only in the public 
         * Cloud).
         */
        char *security_group_names_str;
	char **security_group_names; /* array string */
        /*
         * The reason codes for the state changes.
         */
        char *state_reason_codes_str;
	int *state_reason_codes; /* array integer */
        /*
         * The messages describing the state changes.
         */
        char *state_reason_messages_str;
	char **state_reason_messages; /* array string */
        /*
         * The reasons explaining the current states of the VMs. This filter is 
         * like the `StateReasonCodes` one.
         */
        char *state_reasons_str;
	char **state_reasons; /* array string */
        /*
         * The IDs of the Subnets for the VMs.
         */
        char *subnet_ids_str;
	char **subnet_ids; /* array string */
        /*
         * The names of the Subregions of the VMs.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
        /*
         * The keys of the tags associated with the VMs.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the VMs.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the VMs, in the 
         * following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The tenancies of the VMs (`dedicated` \\| `default` \\| `host`).
         */
        char *tenancies_str;
	char **tenancies; /* array string */
        /*
         * One or more IDs of VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
        /*
         * The IDs of the security groups for the VMs.
         */
        char *vm_security_group_ids_str;
	char **vm_security_group_ids; /* array string */
        /*
         * The names of the security group for the VMs.
         */
        char *vm_security_group_names_str;
	char **vm_security_group_names; /* array string */
        /*
         * The state codes of the VMs: `-1` (quarantine), `0` (pending), `16` 
         * (running), `32` (shutting-down), `48` (terminated), `64` (stopping), 
         * and `80` (stopped).
         */
        char *vm_state_codes_str;
	int *vm_state_codes; /* array integer */
        /*
         * The state names of the VMs (`pending` \\| `running` \\| `stopping` 
         * \\| `stopped` \\| `shutting-down` \\| `terminated` \\| `quarantine`).
         */
        char *vm_state_names_str;
	char **vm_state_names; /* array string */
        /*
         * The VM types (for example, t2.micro). For more information, see [VM 
         * Types](https://docs.outscale.com/en/userguide/VM-Types.html).
         */
        char *vm_types_str;
	char **vm_types; /* array string */
};

struct filters_vm_group {
        /*
         * The descriptions of the VM groups.
         */
        char *descriptions_str;
	char **descriptions; /* array string */
        /*
         * The IDs of the security groups.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The IDs of the Subnets.
         */
        char *subnet_ids_str;
	char **subnet_ids; /* array string */
        /*
         * The keys of the tags associated with the VM groups.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the VM groups.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the VMs, in the 
         * following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The number of VMs in the VM group.
         */
        char *vm_counts_str;
	int *vm_counts; /* array integer */
        /*
         * The IDs of the VM groups.
         */
        char *vm_group_ids_str;
	char **vm_group_ids; /* array string */
        /*
         * The names of the VM groups.
         */
        char *vm_group_names_str;
	char **vm_group_names; /* array string */
        /*
         * The IDs of the VM templates.
         */
        char *vm_template_ids_str;
	char **vm_template_ids; /* array string */
};

struct filters_vm_template {
        /*
         * The number of vCores.
         */
        char *cpu_cores_str;
	int *cpu_cores; /* array integer */
        /*
         * The processor generations (for example, `v4`).
         */
        char *cpu_generations_str;
	char **cpu_generations; /* array string */
        /*
         * The performances of the VMs.
         */
        char *cpu_performances_str;
	char **cpu_performances; /* array string */
        /*
         * The descriptions of the VM templates.
         */
        char *descriptions_str;
	char **descriptions; /* array string */
        /*
         * The IDs of the OMIs.
         */
        char *image_ids_str;
	char **image_ids; /* array string */
        /*
         * The names of the keypairs.
         */
        char *keypair_names_str;
	char **keypair_names; /* array string */
        /*
         * The amount of RAM.
         */
        char *rams_str;
	int *rams; /* array integer */
        /*
         * The keys of the tags associated with the VM templates.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the VM templates.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the VM 
         * templates, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The IDs of the VM templates.
         */
        char *vm_template_ids_str;
	char **vm_template_ids; /* array string */
        /*
         * The names of the VM templates.
         */
        char *vm_template_names_str;
	char **vm_template_names; /* array string */
};

struct filters_vm_type {
        /*
         * This parameter is not available. It is present in our API for the 
         * sake of historical compatibility with AWS.
         */
        int is_set_bsu_optimized;
	int bsu_optimized; /* bool */
        /*
         * The types of ephemeral storage disk.
         */
        char *ephemerals_types_str;
	char **ephemerals_types; /* array string */
        /*
         * The number of Ethernet interfaces available.
         */
        char *eths_str;
	int *eths; /* array integer */
        /*
         * The number of GPUs available.
         */
        char *gpus_str;
	int *gpus; /* array integer */
        /*
         * The amounts of memory, in gibibytes (GiB).
         */
        char *memory_sizes_str;
	double *memory_sizes; /* array double */
        /*
         * The numbers of vCores.
         */
        char *vcore_counts_str;
	int *vcore_counts; /* array integer */
        /*
         * The names of the VM types. For more information, see [VM 
         * Types](https://docs.outscale.com/en/userguide/VM-Types.html).
         */
        char *vm_type_names_str;
	char **vm_type_names; /* array string */
        /*
         * The maximum number of ephemeral storage disks.
         */
        char *volume_counts_str;
	int *volume_counts; /* array integer */
        /*
         * The size of one ephemeral storage disk, in gibibytes (GiB).
         */
        char *volume_sizes_str;
	int *volume_sizes; /* array integer */
};

struct filters_vms_state {
        /*
         * The code for the scheduled event (`system-reboot` \\| 
         * `system-maintenance`).
         */
        char *maintenance_event_codes_str;
	char **maintenance_event_codes; /* array string */
        /*
         * The description of the scheduled event.
         */
        char *maintenance_event_descriptions_str;
	char **maintenance_event_descriptions; /* array string */
        /*
         * The latest time the event can end.
         */
        char *maintenance_events_not_after_str;
	char **maintenance_events_not_after; /* array string */
        /*
         * The earliest time the event can start.
         */
        char *maintenance_events_not_before_str;
	char **maintenance_events_not_before; /* array string */
        /*
         * The names of the Subregions of the VMs.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
        /*
         * One or more IDs of VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
        /*
         * The states of the VMs (`pending` \\| `running` \\| `stopping` \\| 
         * `stopped` \\| `shutting-down` \\| `terminated` \\| `quarantine`).
         */
        char *vm_states_str;
	char **vm_states; /* array string */
};

struct filters_volume {
        /*
         * The dates and times of creation of the volumes, in ISO 8601 date-time 
         * format (for example, `2020-06-30T00:00:00.000Z`).
         */
        char *creation_dates_str;
	char **creation_dates; /* array string */
        /*
         * Whether the volumes are deleted or not when terminating the VMs.
         */
        int is_set_link_volume_delete_on_vm_deletion;
	int link_volume_delete_on_vm_deletion; /* bool */
        /*
         * The VM device names.
         */
        char *link_volume_device_names_str;
	char **link_volume_device_names; /* array string */
        /*
         * The dates and times of creation of the volumes, in ISO 8601 date-time 
         * format (for example, `2020-06-30T00:00:00.000Z`).
         */
        char *link_volume_link_dates_str;
	char **link_volume_link_dates; /* array string */
        /*
         * The attachment states of the volumes (`attaching` \\| `detaching` \\| 
         * `attached` \\| `detached`).
         */
        char *link_volume_link_states_str;
	char **link_volume_link_states; /* array string */
        /*
         * One or more IDs of VMs.
         */
        char *link_volume_vm_ids_str;
	char **link_volume_vm_ids; /* array string */
        /*
         * The snapshots from which the volumes were created.
         */
        char *snapshot_ids_str;
	char **snapshot_ids; /* array string */
        /*
         * The names of the Subregions in which the volumes were created.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
        /*
         * The keys of the tags associated with the volumes.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the volumes.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the volumes, in 
         * the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The IDs of the volumes.
         */
        char *volume_ids_str;
	char **volume_ids; /* array string */
        /*
         * The sizes of the volumes, in gibibytes (GiB).
         */
        char *volume_sizes_str;
	int *volume_sizes; /* array integer */
        /*
         * The states of the volumes (`creating` \\| `available` \\| `in-use` 
         * \\| `updating` \\| `deleting` \\| `error`).
         */
        char *volume_states_str;
	char **volume_states; /* array string */
        /*
         * The types of the volumes (`standard` \\| `gp2` \\| `io1`).
         */
        char *volume_types_str;
	char **volume_types; /* array string */
};

struct filters_vpn_connection {
        /*
         * The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of 
         * the connections.
         */
        char *bgp_asns_str;
	int *bgp_asns; /* array integer */
        /*
         * The IDs of the client gateways.
         */
        char *client_gateway_ids_str;
	char **client_gateway_ids; /* array string */
        /*
         * The types of the VPN connections (only `ipsec.1` is supported).
         */
        char *connection_types_str;
	char **connection_types; /* array string */
        /*
         * The destination IP ranges.
         */
        char *route_destination_ip_ranges_str;
	char **route_destination_ip_ranges; /* array string */
        /*
         * The states of the VPN connections (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
        char *states_str;
	char **states; /* array string */
        /*
         * If false, the VPN connection uses dynamic routing with Border Gateway 
         * Protocol (BGP). If true, routing is controlled using static routes. 
         * For more information about how to create and delete static routes, 
         * see [CreateVpnConnectionRoute](#createvpnconnectionroute) and 
         * [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
         */
        int is_set_static_routes_only;
	int static_routes_only; /* bool */
        /*
         * The keys of the tags associated with the VPN connections.
         */
        char *tag_keys_str;
	char **tag_keys; /* array string */
        /*
         * The values of the tags associated with the VPN connections.
         */
        char *tag_values_str;
	char **tag_values; /* array string */
        /*
         * The key/value combination of the tags associated with the VPN 
         * connections, in the following format: 
         * &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
         */
        char *tags_str;
	char **tags; /* array string */
        /*
         * The IDs of the virtual gateways.
         */
        char *virtual_gateway_ids_str;
	char **virtual_gateway_ids; /* array string */
        /*
         * The IDs of the VPN connections.
         */
        char *vpn_connection_ids_str;
	char **vpn_connection_ids; /* array string */
};

struct flexible_gpu {
        /*
         * If true, the fGPU is deleted when the VM is terminated.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The ID of the fGPU.
         */
	char *flexible_gpu_id; /* string */
        /*
         * The compatible processor generation.
         */
	char *generation; /* string */
        /*
         * The model of fGPU. For more information, see [About Flexible 
         * GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html)
         * .
         */
	char *model_name; /* string */
        /*
         * The state of the fGPU (`allocated` \\| `attaching` \\| `attached` \\| 
         * `detaching`).
         */
	char *state; /* string */
        /*
         * The Subregion where the fGPU is located.
         */
	char *subregion_name; /* string */
        /*
         * The ID of the VM the fGPU is attached to, if any.
         */
	char *vm_id; /* string */
};

struct flexible_gpu_catalog {
        /*
         * The generations of VMs that the fGPU is compatible with.
         */
        char *generations_str;
	char **generations; /* array string */
        /*
         * The maximum number of VM vCores that the fGPU is compatible with.
         */
        int is_set_max_cpu;
	int max_cpu; /* int */
        /*
         * The maximum amount of VM memory that the fGPU is compatible with.
         */
        int is_set_max_ram;
	int max_ram; /* int */
        /*
         * The model of fGPU.
         */
	char *model_name; /* string */
        /*
         * The amount of video RAM (VRAM) of the fGPU.
         */
        int is_set_vram;
	int vram; /* int */
};

struct health_check {
        /*
         * The number of seconds between two requests (between `5` and `600` 
         * both included).
         */
        int is_set_check_interval;
	int check_interval; /* int */
        /*
         * The number of consecutive successful requests before considering the 
         * VM as healthy (between `2` and `10` both included).
         */
        int is_set_healthy_threshold;
	int healthy_threshold; /* int */
        /*
         * If you use the HTTP or HTTPS protocols, the request URL path.
         */
	char *path; /* string */
        /*
         * The port number (between `1` and `65535`, both included).
         */
        int is_set_port;
	int port; /* int */
        /*
         * The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| 
         * `SSL`).
         */
	char *protocol; /* string */
        /*
         * The maximum waiting time for a response before considering the VM as 
         * unhealthy, in seconds (between `2` and `60` both included).
         */
        int is_set_timeout;
	int timeout; /* int */
        /*
         * The number of consecutive failed requests before considering the VM 
         * as unhealthy (between `2` and `10` both included).
         */
        int is_set_unhealthy_threshold;
	int unhealthy_threshold; /* int */
};

struct permissions_on_resource {
        /*
         * One or more account IDs that the permission is associated with.
         */
        char *account_ids_str;
	char **account_ids; /* array string */
        /*
         * A global permission for all accounts.<br />\n(Request) Set this 
         * parameter to true to make the resource public (if the parent 
         * parameter is `Additions`) or to make the resource private (if the 
         * parent parameter is `Removals`).<br />\n(Response) If true, the 
         * resource is public. If false, the resource is private.
         */
        int is_set_global_permission;
	int global_permission; /* bool */
};

struct state_comment {
        /*
         * The code of the change of state.
         */
	char *state_code; /* string */
        /*
         * A message explaining the change of state.
         */
	char *state_message; /* string */
};

struct image {
        /*
         * The account alias of the owner of the OMI.
         */
	char *account_alias; /* string */
        /*
         * The account ID of the owner of the OMI.
         */
	char *account_id; /* string */
        /*
         * The architecture of the OMI.
         */
	char *architecture; /* string */
        /*
         * One or more block device mappings.
         *   One or more parameters used to automatically set up volumes 
         *   when the VM is created.
         *   -Bsu: ref BsuToCreate
         *       Information about the BSU volume to create.
         *       -DeleteOnVmDeletion: bool
         *         By default or if set to true, the volume is deleted when 
         *         terminating the VM. If false, the volume is not deleted when 
         *         terminating the VM.
         *       -Iops: int
         *         The number of I/O operations per second (IOPS). This 
         * parameter 
         *         must be specified only if you create an `io1` volume. The 
         *         maximum number of IOPS allowed for `io1` volumes is `13000` 
         *         with a maximum performance ratio of 300 IOPS per gibibyte.
         *       -SnapshotId: string
         *         The ID of the snapshot used to create the volume.
         *       -VolumeSize: int
         *         The size of the volume, in gibibytes (GiB).<br />\nIf you 
         *         specify a snapshot ID, the volume size must be at least equal 
         *         to the snapshot size.<br />\nIf you specify a snapshot ID but 
         *         no volume size, the volume is created with a size similar to 
         *         the snapshot one.
         *       -VolumeType: string
         *         The type of the volume (`standard` \\| `io1` \\| `gp2`). If 
         *         not specified in the request, a `standard` volume is 
         *         created.<br />\nFor more information about volume types, see 
         *         [About Volumes > Volume Types and 
         *         
         * IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#
         *         _volume_types_and_iops).
         *   -DeviceName: string
         *     The device name for the volume. For a root device, you must 
         *     use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, 
         *     `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` 
         *     is a letter between `b` and `z`, and the second `X` is a letter 
         *     between `a` and `z`).
         *   -VirtualDeviceName: string
         *     The name of the virtual device (`ephemeralN`).
         */
        char *block_device_mappings_str;
        int nb_block_device_mappings;
	struct block_device_mapping_image *block_device_mappings; /* array ref BlockDeviceMappingImage */
        /*
         * The date and time of creation of the OMI, in ISO 8601 date-time 
         * format.
         */
	char *creation_date; /* string */
        /*
         * The description of the OMI.
         */
	char *description; /* string */
        /*
         * The location from which the OMI files were created.
         */
	char *file_location; /* string */
        /*
         * The ID of the OMI.
         */
	char *image_id; /* string */
        /*
         * The name of the OMI.
         */
	char *image_name; /* string */
        /*
         * The type of the OMI.
         */
	char *image_type; /* string */
        /*
         *   Permissions for the resource.
         *   -AccountIds: array string
         *     One or more account IDs that the permission is associated 
         *     with.
         *   -GlobalPermission: bool
         *     A global permission for all accounts.<br />\n(Request) Set 
         *     this parameter to true to make the resource public (if the 
         *     parent parameter is `Additions`) or to make the resource 
         *     private (if the parent parameter is `Removals`).<br 
         *     />\n(Response) If true, the resource is public. If false, the 
         *     resource is private.
         */
        char *permissions_to_launch_str;
        int is_set_permissions_to_launch;
	struct permissions_on_resource permissions_to_launch; /* ref PermissionsOnResource */
        /*
         * The product codes associated with the OMI.
         */
        char *product_codes_str;
	char **product_codes; /* array string */
        /*
         * The name of the root device.
         */
	char *root_device_name; /* string */
        /*
         * The type of root device used by the OMI (always `bsu`).
         */
	char *root_device_type; /* string */
        /*
         * The state of the OMI (`pending` \\| `available` \\| `failed`).
         */
	char *state; /* string */
        /*
         *   Information about the change of state.
         *   -StateCode: string
         *     The code of the change of state.
         *   -StateMessage: string
         *     A message explaining the change of state.
         */
        char *state_comment_str;
        int is_set_state_comment;
	struct state_comment state_comment; /* ref StateComment */
        /*
         * One or more tags associated with the OMI.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct osu_export_image_export_task {
        /*
         * The format of the export disk (`qcow2` \\| `raw`).
         */
	char *disk_image_format; /* string */
        /*
         * The name of the OOS bucket the OMI is exported to.
         */
	char *osu_bucket; /* string */
        /*
         * The URL of the manifest file.
         */
	char *osu_manifest_url; /* string */
        /*
         * The prefix for the key of the OOS object corresponding to the image.
         */
	char *osu_prefix; /* string */
};

struct image_export_task {
        /*
         * If the OMI export task fails, an error message appears.
         */
	char *comment; /* string */
        /*
         * The ID of the OMI to be exported.
         */
	char *image_id; /* string */
        /*
         *   Information about the OMI export task.
         *   -DiskImageFormat: string
         *     The format of the export disk (`qcow2` \\| `raw`).
         *   -OsuBucket: string
         *     The name of the OOS bucket the OMI is exported to.
         *   -OsuManifestUrl: string
         *     The URL of the manifest file.
         *   -OsuPrefix: string
         *     The prefix for the key of the OOS object corresponding to the 
         *     image.
         */
        char *osu_export_str;
        int is_set_osu_export;
	struct osu_export_image_export_task osu_export; /* ref OsuExportImageExportTask */
        /*
         * The progress of the OMI export task, as a percentage.
         */
        int is_set_progress;
	int progress; /* int */
        /*
         * The state of the OMI export task (`pending/queued` \\| `pending` \\| 
         * `completed` \\| `failed` \\| `cancelled`).
         */
	char *state; /* string */
        /*
         * One or more tags associated with the image export task.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the OMI export task.
         */
	char *task_id; /* string */
};

struct internet_service {
        /*
         * The ID of the Internet service.
         */
	char *internet_service_id; /* string */
        /*
         * The ID of the Net attached to the Internet service.
         */
	char *net_id; /* string */
        /*
         * The state of the attachment of the Internet service to the Net 
         * (always `available`).
         */
	char *state; /* string */
        /*
         * One or more tags associated with the Internet service.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct keypair {
        /*
         * The MD5 public key fingerprint as specified in section 4 of RFC 4716.
         */
	char *keypair_fingerprint; /* string */
        /*
         * The name of the keypair.
         */
	char *keypair_name; /* string */
        /*
         * The type of the keypair (`ssh-rsa`, `ssh-ed25519`, 
         * `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or 
         * `ecdsa-sha2-nistp521`).
         */
	char *keypair_type; /* string */
};

struct keypair_created {
        /*
         * The MD5 public key fingerprint, as specified in section 4 of RFC 4716.
         */
	char *keypair_fingerprint; /* string */
        /*
         * The name of the keypair.
         */
	char *keypair_name; /* string */
        /*
         * The type of the keypair (`ssh-rsa`, `ssh-ed25519`, 
         * `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or 
         * `ecdsa-sha2-nistp521`).
         */
	char *keypair_type; /* string */
        /*
         * The private key, returned only if you are creating a keypair (not if 
         * you are importing). When you save this private key in a .rsa file, 
         * make sure you replace the `\\n` escape sequences with real line 
         * breaks.
         */
	char *private_key; /* string */
};

struct link_nic {
        /*
         * If true, the NIC is deleted when the VM is terminated.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The device index for the NIC attachment (between `1` and `7`, both 
         * included).
         */
        int is_set_device_number;
	int device_number; /* int */
        /*
         * The ID of the NIC to attach.
         */
	char *link_nic_id; /* string */
        /*
         * The state of the attachment (`attaching` \\| `attached` \\| 
         * `detaching` \\| `detached`).
         */
	char *state; /* string */
        /*
         * The account ID of the owner of the VM.
         */
	char *vm_account_id; /* string */
        /*
         * The ID of the VM.
         */
	char *vm_id; /* string */
};

struct link_nic_light {
        /*
         * If true, the NIC is deleted when the VM is terminated.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The device index for the NIC attachment (between `1` and `7`, both 
         * included).
         */
        int is_set_device_number;
	int device_number; /* int */
        /*
         * The ID of the NIC to attach.
         */
	char *link_nic_id; /* string */
        /*
         * The state of the attachment (`attaching` \\| `attached` \\| 
         * `detaching` \\| `detached`).
         */
	char *state; /* string */
};

struct link_nic_to_update {
        /*
         * If true, the NIC is deleted when the VM is terminated. If false, the 
         * NIC is detached from the VM.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The ID of the NIC attachment.
         */
	char *link_nic_id; /* string */
};

struct link_public_ip {
        /*
         * (Required in a Net) The ID representing the association of the public 
         * IP with the VM or the NIC.
         */
	char *link_public_ip_id; /* string */
        /*
         * The name of the public DNS.
         */
	char *public_dns_name; /* string */
        /*
         * The public IP associated with the NIC.
         */
	char *public_ip; /* string */
        /*
         * The account ID of the owner of the public IP.
         */
	char *public_ip_account_id; /* string */
        /*
         * The allocation ID of the public IP.
         */
	char *public_ip_id; /* string */
};

struct link_public_ip_light_for_vm {
        /*
         * The name of the public DNS.
         */
	char *public_dns_name; /* string */
        /*
         * The public IP associated with the NIC.
         */
	char *public_ip; /* string */
        /*
         * The account ID of the owner of the public IP.
         */
	char *public_ip_account_id; /* string */
};

struct link_route_table {
        /*
         * The ID of the association between the route table and the Subnet.
         */
	char *link_route_table_id; /* string */
        /*
         * If true, the route table is the main one.
         */
        int is_set_main;
	int main; /* bool */
        /*
         * The ID of the Net.
         */
	char *net_id; /* string */
        /*
         * The ID of the route table.
         */
	char *route_table_id; /* string */
        /*
         * The ID of the Subnet.
         */
	char *subnet_id; /* string */
};

struct linked_policy {
        /*
         * The date and time of creation of the attached policy.
         */
	char *creation_date; /* string */
        /*
         * The date and time at which the attached policy was last modified.
         */
	char *last_modification_date; /* string */
        /*
         * The Outscale Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *orn; /* string */
        /*
         * The ID of the policy.
         */
	char *policy_id; /* string */
        /*
         * The name of the policy.
         */
	char *policy_name; /* string */
};

struct linked_volume {
        /*
         * If true, the volume is deleted when terminating the VM. If false, the 
         * volume is not deleted when terminating the VM.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The name of the device.
         */
	char *device_name; /* string */
        /*
         * The state of the attachment of the volume (`attaching` \\| 
         * `detaching` \\| `attached` \\| `detached`).
         */
	char *state; /* string */
        /*
         * The ID of the VM.
         */
	char *vm_id; /* string */
        /*
         * The ID of the volume.
         */
	char *volume_id; /* string */
};

struct listener {
        /*
         * The port on which the back-end VM is listening (between `1` and 
         * `65535`, both included).
         */
        int is_set_backend_port;
	int backend_port; /* int */
        /*
         * The protocol for routing traffic to back-end VMs (`HTTP` \\| `HTTPS` 
         * \\| `TCP` \\| `SSL`).
         */
	char *backend_protocol; /* string */
        /*
         * The port on which the load balancer is listening (between `1` and 
         * `65535`, both included).
         */
        int is_set_load_balancer_port;
	int load_balancer_port; /* int */
        /*
         * The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
         */
	char *load_balancer_protocol; /* string */
        /*
         * The names of the policies. If there are no policies enabled, the list 
         * is empty.
         */
        char *policy_names_str;
	char **policy_names; /* array string */
        /*
         * The OUTSCALE Resource Name (ORN) of the server certificate. For more 
         * information, see [Resource Identifiers > OUTSCALE Resource Names 
         * (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.ht
         * ml#_outscale_resource_names_orns).
         */
	char *server_certificate_id; /* string */
};

struct listener_for_creation {
        /*
         * The port on which the back-end VM is listening (between `1` and 
         * `65535`, both included).
         */
        int is_set_backend_port;
	int backend_port; /* int */
        /*
         * The protocol for routing traffic to back-end VMs (`HTTP` \\| `HTTPS` 
         * \\| `TCP` \\| `SSL`).
         */
	char *backend_protocol; /* string */
        /*
         * The port on which the load balancer is listening (between `1` and 
         * `65535`, both included).
         */
        int is_set_load_balancer_port;
	int load_balancer_port; /* int */
        /*
         * The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
         */
	char *load_balancer_protocol; /* string */
        /*
         * The OUTSCALE Resource Name (ORN) of the server certificate. For more 
         * information, see [Resource Identifiers > OUTSCALE Resource Names 
         * (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.ht
         * ml#_outscale_resource_names_orns).
         */
	char *server_certificate_id; /* string */
};

struct listener_rule {
        /*
         * The type of action for the rule (always `forward`).
         */
	char *action; /* string */
        /*
         * A host-name pattern for the rule, with a maximum length of 128 
         * characters. This host-name pattern supports maximum three wildcards, 
         * and must not contain any special characters except [-.?].
         */
	char *host_name_pattern; /* string */
        /*
         * The ID of the listener.
         */
        int is_set_listener_id;
	int listener_id; /* int */
        /*
         * The ID of the listener rule.
         */
        int is_set_listener_rule_id;
	int listener_rule_id; /* int */
        /*
         * A human-readable name for the listener rule.
         */
	char *listener_rule_name; /* string */
        /*
         * A path pattern for the rule, with a maximum length of 128 characters. 
         * This path pattern supports maximum three wildcards, and must not 
         * contain any special characters except [_-.$/~&quot;'@:+?].
         */
	char *path_pattern; /* string */
        /*
         * The priority level of the listener rule, between `1` and `19999` both 
         * included. Each rule must have a unique priority level. Otherwise, an 
         * error is returned.
         */
        int is_set_priority;
	int priority; /* int */
        /*
         * The IDs of the backend VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct listener_rule_for_creation {
        /*
         * The type of action for the rule (always `forward`).
         */
	char *action; /* string */
        /*
         * A host-name pattern for the rule, with a maximum length of 128 
         * characters. This host-name pattern supports maximum three wildcards, 
         * and must not contain any special characters except [-.?]. 
         */
	char *host_name_pattern; /* string */
        /*
         * A human-readable name for the listener rule.
         */
	char *listener_rule_name; /* string */
        /*
         * A path pattern for the rule, with a maximum length of 128 characters. 
         * This path pattern supports maximum three wildcards, and must not 
         * contain any special characters except [_-.$/~&quot;'@:+?].
         */
	char *path_pattern; /* string */
        /*
         * The priority level of the listener rule, between `1` and `19999` both 
         * included. Each rule must have a unique priority level. Otherwise, an 
         * error is returned.
         */
        int is_set_priority;
	int priority; /* int */
};

struct source_security_group {
        /*
         * The account ID of the owner of the security group.
         */
	char *security_group_account_id; /* string */
        /*
         * The name of the security group.
         */
	char *security_group_name; /* string */
};

struct load_balancer {
        /*
         *   Information about access logs.
         *   -IsEnabled: bool
         *     If true, access logs are enabled for your load balancer. If 
         *     false, they are not. If you set this to true in your request, 
         *     the `OsuBucketName` parameter is required.
         *   -OsuBucketName: string
         *     The name of the OOS bucket for the access logs.
         *   -OsuBucketPrefix: string
         *     The path to the folder of the access logs in your OOS bucket 
         *     (by default, the `root` level of your bucket).
         *   -PublicationInterval: int
         *     The time interval for the publication of access logs in the 
         *     OOS bucket, in minutes. This value can be either `5` or `60` 
         *     (by default, `60`).
         */
        char *access_log_str;
        int is_set_access_log;
	struct access_log access_log; /* ref AccessLog */
        /*
         * The stickiness policies defined for the load balancer.
         *   Information about the stickiness policy.
         *   -CookieName: string
         *     The name of the application cookie used for stickiness.
         *   -PolicyName: string
         *     The mnemonic name for the policy being created. The name must 
         *     be unique within a set of policies for this load balancer.
         */
        char *application_sticky_cookie_policies_str;
        int nb_application_sticky_cookie_policies;
	struct application_sticky_cookie_policy *application_sticky_cookie_policies; /* array ref ApplicationStickyCookiePolicy */
        /*
         * One or more public IPs of back-end VMs.
         */
        char *backend_ips_str;
	char **backend_ips; /* array string */
        /*
         * One or more IDs of back-end VMs for the load balancer.
         */
        char *backend_vm_ids_str;
	char **backend_vm_ids; /* array string */
        /*
         * The DNS name of the load balancer.
         */
	char *dns_name; /* string */
        /*
         *   Information about the health check configuration.
         *   -CheckInterval: int
         *     The number of seconds between two requests (between `5` and 
         *     `600` both included).
         *   -HealthyThreshold: int
         *     The number of consecutive successful requests before 
         *     considering the VM as healthy (between `2` and `10` both 
         *     included).
         *   -Path: string
         *     If you use the HTTP or HTTPS protocols, the request URL path.
         *   -Port: int
         *     The port number (between `1` and `65535`, both included).
         *   -Protocol: string
         *     The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| 
         *     `TCP` \\| `SSL`).
         *   -Timeout: int
         *     The maximum waiting time for a response before considering the 
         *     VM as unhealthy, in seconds (between `2` and `60` both 
         *     included).
         *   -UnhealthyThreshold: int
         *     The number of consecutive failed requests before considering 
         *     the VM as unhealthy (between `2` and `10` both included).
         */
        char *health_check_str;
        int is_set_health_check;
	struct health_check health_check; /* ref HealthCheck */
        /*
         * The listeners for the load balancer.
         *   Information about the listener.
         *   -BackendPort: int
         *     The port on which the back-end VM is listening (between `1` 
         *     and `65535`, both included).
         *   -BackendProtocol: string
         *     The protocol for routing traffic to back-end VMs (`HTTP` \\| 
         *     `HTTPS` \\| `TCP` \\| `SSL`).
         *   -LoadBalancerPort: int
         *     The port on which the load balancer is listening (between `1` 
         *     and `65535`, both included).
         *   -LoadBalancerProtocol: string
         *     The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
         *   -PolicyNames: array string
         *     The names of the policies. If there are no policies enabled, 
         *     the list is empty.
         *   -ServerCertificateId: string
         *     The OUTSCALE Resource Name (ORN) of the server certificate. 
         *     For more information, see [Resource Identifiers > OUTSCALE 
         *     Resource Names 
         *     (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifi
         *     ers.html#_outscale_resource_names_orns).
         */
        char *listeners_str;
        int nb_listeners;
	struct listener *listeners; /* array ref Listener */
        /*
         * The name of the load balancer.
         */
	char *load_balancer_name; /* string */
        /*
         * The policies defined for the load balancer.
         *   Information about the stickiness policy.
         *   -CookieExpirationPeriod: int
         *     The time period, in seconds, after which the cookie should be 
         *     considered stale.<br />\nIf `1`, the stickiness session lasts 
         *     for the duration of the browser session.
         *   -PolicyName: string
         *     The name of the stickiness policy.
         */
        char *load_balancer_sticky_cookie_policies_str;
        int nb_load_balancer_sticky_cookie_policies;
	struct load_balancer_sticky_cookie_policy *load_balancer_sticky_cookie_policies; /* array ref LoadBalancerStickyCookiePolicy */
        /*
         * The type of load balancer. Valid only for load balancers in a Net.<br 
         * />\nIf `LoadBalancerType` is `internet-facing`, the load balancer has 
         * a public DNS name that resolves to a public IP.<br />\nIf 
         * `LoadBalancerType` is `internal`, the load balancer has a public DNS 
         * name that resolves to a private IP.
         */
	char *load_balancer_type; /* string */
        /*
         * The ID of the Net for the load balancer.
         */
	char *net_id; /* string */
        /*
         * (internet-facing only) The public IP associated with the load 
         * balancer.
         */
	char *public_ip; /* string */
        /*
         * Whether secure cookies are enabled for the load balancer.
         */
        int is_set_secured_cookies;
	int secured_cookies; /* bool */
        /*
         * One or more IDs of security groups for the load balancers. Valid only 
         * for load balancers in a Net.
         */
        char *security_groups_str;
	char **security_groups; /* array string */
        /*
         *   Information about the source security group of the load 
         *   balancer, which you can use as part of your inbound rules for 
         *   your registered VMs.<br />\nTo only allow traffic from load 
         *   balancers, add a security group rule that specifies this source 
         *   security group as the inbound source.
         *   -SecurityGroupAccountId: string
         *     The account ID of the owner of the security group.
         *   -SecurityGroupName: string
         *     The name of the security group.
         */
        char *source_security_group_str;
        int is_set_source_security_group;
	struct source_security_group source_security_group; /* ref SourceSecurityGroup */
        /*
         * The ID of the Subnet in which the load balancer was created.
         */
        char *subnets_str;
	char **subnets; /* array string */
        /*
         * The ID of the Subregion in which the load balancer was created.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
        /*
         * One or more tags associated with the load balancer.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct load_balancer_light {
        /*
         * The name of the load balancer to which the listener is attached.
         */
	char *load_balancer_name; /* string */
        /*
         * The port of load balancer on which the load balancer is listening 
         * (between `1` and `65535` both included).
         */
        int is_set_load_balancer_port;
	int load_balancer_port; /* int */
};

struct load_balancer_sticky_cookie_policy {
        /*
         * The time period, in seconds, after which the cookie should be 
         * considered stale.<br />\nIf `1`, the stickiness session lasts for the 
         * duration of the browser session.
         */
        int is_set_cookie_expiration_period;
	int cookie_expiration_period; /* int */
        /*
         * The name of the stickiness policy.
         */
	char *policy_name; /* string */
};

struct load_balancer_tag {
        /*
         * The key of the tag.
         */
	char *key; /* string */
        /*
         * The name of the load balancer.
         */
	char *load_balancer_name; /* string */
        /*
         * The value of the tag.
         */
	char *value; /* string */
};

struct location {
        /*
         * The location code, to be set as the `Location` parameter of the 
         * *CreateDirectLink* method when creating a DirectLink.
         */
	char *code; /* string */
        /*
         * The name and description of the location, corresponding to a 
         * datacenter.
         */
	char *name; /* string */
};

struct log {
        /*
         * The account ID of the logged call.
         */
	char *account_id; /* string */
        /*
         * The duration of the logged call, in microseconds.
         */
        int is_set_call_duration;
	int call_duration; /* int */
        /*
         * The access key used for the logged call.
         */
	char *query_access_key; /* string */
        /*
         * The name of the API used by the logged call (always `oapi` for the 
         * OUTSCALE API).
         */
	char *query_api_name; /* string */
        /*
         * The version of the API used by the logged call.
         */
	char *query_api_version; /* string */
        /*
         * The name of the logged call.
         */
	char *query_call_name; /* string */
        /*
         * The date and time of the logged call, in ISO 8601 date-time format.
         */
	char *query_date; /* string */
        /*
         * The raw header of the HTTP request of the logged call.
         */
	char *query_header_raw; /* string */
        /*
         * The size of the raw header of the HTTP request of the logged call, in 
         * bytes.
         */
        int is_set_query_header_size;
	int query_header_size; /* int */
        /*
         * The IP used for the logged call.
         */
	char *query_ip_address; /* string */
        /*
         * The raw payload of the HTTP request of the logged call.
         */
	char *query_payload_raw; /* string */
        /*
         * The size of the raw payload of the HTTP request of the logged call, 
         * in bytes.
         */
        int is_set_query_payload_size;
	int query_payload_size; /* int */
        /*
         * The user agent of the HTTP request of the logged call.
         */
	char *query_user_agent; /* string */
        /*
         * The request ID provided in the response of the logged call.
         */
	char *request_id; /* string */
        /*
         * The size of the response of the logged call, in bytes.
         */
        int is_set_response_size;
	int response_size; /* int */
        /*
         * The HTTP status code of the response of the logged call.
         */
        int is_set_response_status_code;
	int response_status_code; /* int */
};

struct maintenance_event {
        /*
         * The code of the event (`system-reboot` \\| `system-maintenance`).
         */
	char *code; /* string */
        /*
         * The description of the event.
         */
	char *description; /* string */
        /*
         * The latest scheduled end time for the event.
         */
	char *not_after; /* string */
        /*
         * The earliest scheduled start time for the event.
         */
	char *not_before; /* string */
};

struct nat_service {
        /*
         * The ID of the NAT service.
         */
	char *nat_service_id; /* string */
        /*
         * The ID of the Net in which the NAT service is.
         */
	char *net_id; /* string */
        /*
         * Information about the public IP or IPs associated with the NAT 
         * service.
         *   Information about the public IP.
         *   -PublicIp: string
         *     The public IP associated with the NAT service.
         *   -PublicIpId: string
         *     The allocation ID of the public IP associated with the NAT 
         *     service.
         */
        char *public_ips_str;
        int nb_public_ips;
	struct public_ip_light *public_ips; /* array ref PublicIpLight */
        /*
         * The state of the NAT service (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
	char *state; /* string */
        /*
         * The ID of the Subnet in which the NAT service is.
         */
	char *subnet_id; /* string */
        /*
         * One or more tags associated with the NAT service.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct net {
        /*
         * The ID of the DHCP options set (or `default` if you want to associate 
         * the default one).
         */
	char *dhcp_options_set_id; /* string */
        /*
         * The IP range for the Net, in CIDR notation (for example, 
         * `10.0.0.0/16`).
         */
	char *ip_range; /* string */
        /*
         * The ID of the Net.
         */
	char *net_id; /* string */
        /*
         * The state of the Net (`pending` \\| `available` \\| `deleting`).
         */
	char *state; /* string */
        /*
         * One or more tags associated with the Net.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The VM tenancy in a Net.
         */
	char *tenancy; /* string */
};

struct net_access_point {
        /*
         * The ID of the Net access point.
         */
	char *net_access_point_id; /* string */
        /*
         * The ID of the Net with which the Net access point is associated.
         */
	char *net_id; /* string */
        /*
         * The ID of the route tables associated with the Net access point.
         */
        char *route_table_ids_str;
	char **route_table_ids; /* array string */
        /*
         * The name of the service with which the Net access point is associated.
         */
	char *service_name; /* string */
        /*
         * The state of the Net access point (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
	char *state; /* string */
        /*
         * One or more tags associated with the Net access point.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct source_net {
        /*
         * The account ID of the owner of the source Net.
         */
	char *account_id; /* string */
        /*
         * The IP range for the source Net, in CIDR notation (for example, 
         * `10.0.0.0/16`).
         */
	char *ip_range; /* string */
        /*
         * The ID of the source Net.
         */
	char *net_id; /* string */
};

struct net_peering_state {
        /*
         * Additional information about the state of the Net peering.
         */
	char *message; /* string */
        /*
         * The state of the Net peering (`pending-acceptance` \\| `active` \\| 
         * `rejected` \\| `failed` \\| `expired` \\| `deleted`).
         */
	char *name; /* string */
};

struct net_peering {
        /*
         *   Information about the accepter Net.
         *   -AccountId: string
         *     The account ID of the owner of the accepter Net.
         *   -IpRange: string
         *     The IP range for the accepter Net, in CIDR notation (for 
         *     example, `10.0.0.0/16`).
         *   -NetId: string
         *     The ID of the accepter Net.
         */
        char *accepter_net_str;
        int is_set_accepter_net;
	struct accepter_net accepter_net; /* ref AccepterNet */
        /*
         * The date and time at which the Net peerings expire.
         */
	char *expiration_date; /* string */
        /*
         * The ID of the Net peering.
         */
	char *net_peering_id; /* string */
        /*
         *   Information about the source Net.
         *   -AccountId: string
         *     The account ID of the owner of the source Net.
         *   -IpRange: string
         *     The IP range for the source Net, in CIDR notation (for 
         *     example, `10.0.0.0/16`).
         *   -NetId: string
         *     The ID of the source Net.
         */
        char *source_net_str;
        int is_set_source_net;
	struct source_net source_net; /* ref SourceNet */
        /*
         *   Information about the state of the Net peering.
         *   -Message: string
         *     Additional information about the state of the Net peering.
         *   -Name: string
         *     The state of the Net peering (`pending-acceptance` \\| 
         *     `active` \\| `rejected` \\| `failed` \\| `expired` \\| 
         *     `deleted`).
         */
        char *state_str;
        int is_set_state;
	struct net_peering_state state; /* ref NetPeeringState */
        /*
         * One or more tags associated with the Net peering.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct net_to_virtual_gateway_link {
        /*
         * The ID of the Net to which the virtual gateway is attached.
         */
	char *net_id; /* string */
        /*
         * The state of the attachment (`attaching` \\| `attached` \\| 
         * `detaching` \\| `detached`).
         */
	char *state; /* string */
};

struct nic {
        /*
         * The account ID of the owner of the NIC.
         */
	char *account_id; /* string */
        /*
         * The description of the NIC.
         */
	char *description; /* string */
        /*
         * (Net only) If true, the source/destination check is enabled. If 
         * false, it is disabled. This value must be false for a NAT VM to 
         * perform network address translation (NAT) in a Net.
         */
        int is_set_is_source_dest_checked;
	int is_source_dest_checked; /* bool */
        /*
         *   Information about the NIC attachment.
         *   -DeleteOnVmDeletion: bool
         *     If true, the NIC is deleted when the VM is terminated.
         *   -DeviceNumber: int
         *     The device index for the NIC attachment (between `1` and `7`, 
         *     both included).
         *   -LinkNicId: string
         *     The ID of the NIC to attach.
         *   -State: string
         *     The state of the attachment (`attaching` \\| `attached` \\| 
         *     `detaching` \\| `detached`).
         *   -VmAccountId: string
         *     The account ID of the owner of the VM.
         *   -VmId: string
         *     The ID of the VM.
         */
        char *link_nic_str;
        int is_set_link_nic;
	struct link_nic link_nic; /* ref LinkNic */
        /*
         *   Information about the public IP association.
         *   -LinkPublicIpId: string
         *     (Required in a Net) The ID representing the association of the 
         *     public IP with the VM or the NIC.
         *   -PublicDnsName: string
         *     The name of the public DNS.
         *   -PublicIp: string
         *     The public IP associated with the NIC.
         *   -PublicIpAccountId: string
         *     The account ID of the owner of the public IP.
         *   -PublicIpId: string
         *     The allocation ID of the public IP.
         */
        char *link_public_ip_str;
        int is_set_link_public_ip;
	struct link_public_ip link_public_ip; /* ref LinkPublicIp */
        /*
         * The Media Access Control (MAC) address of the NIC.
         */
	char *mac_address; /* string */
        /*
         * The ID of the Net for the NIC.
         */
	char *net_id; /* string */
        /*
         * The ID of the NIC.
         */
	char *nic_id; /* string */
        /*
         * The name of the private DNS.
         */
	char *private_dns_name; /* string */
        /*
         * The private IPs of the NIC.
         *   Information about the private IP.
         *   -IsPrimary: bool
         *     If true, the IP is the primary private IP of the NIC.
         *   -LinkPublicIp: ref LinkPublicIp
         *       Information about the public IP association.
         *       -LinkPublicIpId: string
         *         (Required in a Net) The ID representing the association of 
         * the 
         *         public IP with the VM or the NIC.
         *       -PublicDnsName: string
         *         The name of the public DNS.
         *       -PublicIp: string
         *         The public IP associated with the NIC.
         *       -PublicIpAccountId: string
         *         The account ID of the owner of the public IP.
         *       -PublicIpId: string
         *         The allocation ID of the public IP.
         *   -PrivateDnsName: string
         *     The name of the private DNS.
         *   -PrivateIp: string
         *     The private IP of the NIC.
         */
        char *private_ips_str;
        int nb_private_ips;
	struct private_ip *private_ips; /* array ref PrivateIp */
        /*
         * One or more IDs of security groups for the NIC.
         *   Information about the security group.
         *   -SecurityGroupId: string
         *     The ID of the security group.
         *   -SecurityGroupName: string
         *     The name of the security group.
         */
        char *security_groups_str;
        int nb_security_groups;
	struct security_group_light *security_groups; /* array ref SecurityGroupLight */
        /*
         * The state of the NIC (`available` \\| `attaching` \\| `in-use` \\| 
         * `detaching`).
         */
	char *state; /* string */
        /*
         * The ID of the Subnet.
         */
	char *subnet_id; /* string */
        /*
         * The Subregion in which the NIC is located.
         */
	char *subregion_name; /* string */
        /*
         * One or more tags associated with the NIC.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct nic_for_vm_creation {
        /*
         * If true, the NIC is deleted when the VM is terminated. You can 
         * specify this parameter only for a new NIC. To modify this value for 
         * an existing NIC, see [UpdateNic](#updatenic).
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * The description of the NIC, if you are creating a NIC when creating 
         * the VM.
         */
	char *description; /* string */
        /*
         * The index of the VM device for the NIC attachment (between `0` and 
         * `7`, both included). This parameter is required if you create a NIC 
         * when creating the VM.
         */
        int is_set_device_number;
	int device_number; /* int */
        /*
         * The ID of the NIC, if you are attaching an existing NIC when creating 
         * a VM.
         */
	char *nic_id; /* string */
        /*
         * One or more private IPs to assign to the NIC, if you create a NIC 
         * when creating a VM. Only one private IP can be the primary private IP.
         *   Information about the private IP.
         *   -IsPrimary: bool
         *     If true, the IP is the primary private IP of the NIC.
         *   -PrivateIp: string
         *     The private IP of the NIC.
         */
        char *private_ips_str;
        int nb_private_ips;
	struct private_ip_light *private_ips; /* array ref PrivateIpLight */
        /*
         * The number of secondary private IPs, if you create a NIC when 
         * creating a VM. This parameter cannot be specified if you specified 
         * more than one private IP in the `PrivateIps` parameter.
         */
        int is_set_secondary_private_ip_count;
	int secondary_private_ip_count; /* int */
        /*
         * One or more IDs of security groups for the NIC, if you create a NIC 
         * when creating a VM.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The ID of the Subnet for the NIC, if you create a NIC when creating a 
         * VM. This parameter is required if you create a NIC when creating the 
         * VM.
         */
	char *subnet_id; /* string */
};

struct nic_light {
        /*
         * The account ID of the owner of the NIC.
         */
	char *account_id; /* string */
        /*
         * The description of the NIC.
         */
	char *description; /* string */
        /*
         * (Net only) If true, the source/destination check is enabled. If 
         * false, it is disabled. This value must be false for a NAT VM to 
         * perform network address translation (NAT) in a Net.
         */
        int is_set_is_source_dest_checked;
	int is_source_dest_checked; /* bool */
        /*
         *   Information about the network interface card (NIC).
         *   -DeleteOnVmDeletion: bool
         *     If true, the NIC is deleted when the VM is terminated.
         *   -DeviceNumber: int
         *     The device index for the NIC attachment (between `1` and `7`, 
         *     both included).
         *   -LinkNicId: string
         *     The ID of the NIC to attach.
         *   -State: string
         *     The state of the attachment (`attaching` \\| `attached` \\| 
         *     `detaching` \\| `detached`).
         */
        char *link_nic_str;
        int is_set_link_nic;
	struct link_nic_light link_nic; /* ref LinkNicLight */
        /*
         *   Information about the public IP associated with the NIC.
         *   -PublicDnsName: string
         *     The name of the public DNS.
         *   -PublicIp: string
         *     The public IP associated with the NIC.
         *   -PublicIpAccountId: string
         *     The account ID of the owner of the public IP.
         */
        char *link_public_ip_str;
        int is_set_link_public_ip;
	struct link_public_ip_light_for_vm link_public_ip; /* ref LinkPublicIpLightForVm */
        /*
         * The Media Access Control (MAC) address of the NIC.
         */
	char *mac_address; /* string */
        /*
         * The ID of the Net for the NIC.
         */
	char *net_id; /* string */
        /*
         * The ID of the NIC.
         */
	char *nic_id; /* string */
        /*
         * The name of the private DNS.
         */
	char *private_dns_name; /* string */
        /*
         * The private IP or IPs of the NIC.
         *   Information about the private IP of the NIC.
         *   -IsPrimary: bool
         *     If true, the IP is the primary private IP of the NIC.
         *   -LinkPublicIp: ref LinkPublicIpLightForVm
         *       Information about the public IP associated with the NIC.
         *       -PublicDnsName: string
         *         The name of the public DNS.
         *       -PublicIp: string
         *         The public IP associated with the NIC.
         *       -PublicIpAccountId: string
         *         The account ID of the owner of the public IP.
         *   -PrivateDnsName: string
         *     The name of the private DNS.
         *   -PrivateIp: string
         *     The private IP.
         */
        char *private_ips_str;
        int nb_private_ips;
	struct private_ip_light_for_vm *private_ips; /* array ref PrivateIpLightForVm */
        /*
         * One or more IDs of security groups for the NIC.
         *   Information about the security group.
         *   -SecurityGroupId: string
         *     The ID of the security group.
         *   -SecurityGroupName: string
         *     The name of the security group.
         */
        char *security_groups_str;
        int nb_security_groups;
	struct security_group_light *security_groups; /* array ref SecurityGroupLight */
        /*
         * The state of the NIC (`available` \\| `attaching` \\| `in-use` \\| 
         * `detaching`).
         */
	char *state; /* string */
        /*
         * The ID of the Subnet for the NIC.
         */
	char *subnet_id; /* string */
};

struct osu_api_key {
        /*
         * The API key of the OOS account that enables you to access the bucket.
         */
	char *api_key_id; /* string */
        /*
         * The secret key of the OOS account that enables you to access the 
         * bucket.
         */
	char *secret_key; /* string */
};

struct osu_export_snapshot_export_task {
        /*
         * The format of the export disk (`qcow2` \\| `raw`).
         */
	char *disk_image_format; /* string */
        /*
         * The name of the OOS bucket the snapshot is exported to.
         */
	char *osu_bucket; /* string */
        /*
         * The prefix for the key of the OOS object corresponding to the 
         * snapshot.
         */
	char *osu_prefix; /* string */
};

struct osu_export_to_create {
        /*
         * The format of the export disk (`qcow2` \\| `raw`).
         */
	char *disk_image_format; /* string */
        /*
         *   Information about the OOS API key.
         *   -ApiKeyId: string
         *     The API key of the OOS account that enables you to access the 
         *     bucket.
         *   -SecretKey: string
         *     The secret key of the OOS account that enables you to access 
         *     the bucket.
         */
        char *osu_api_key_str;
        int is_set_osu_api_key;
	struct osu_api_key osu_api_key; /* ref OsuApiKey */
        /*
         * The name of the OOS bucket where you want to export the object.
         */
	char *osu_bucket; /* string */
        /*
         * The URL of the manifest file.
         */
	char *osu_manifest_url; /* string */
        /*
         * The prefix for the key of the OOS object.
         */
	char *osu_prefix; /* string */
};

struct permissions_on_resource_creation {
        /*
         *   Permissions for the resource.
         *   -AccountIds: array string
         *     One or more account IDs that the permission is associated 
         *     with.
         *   -GlobalPermission: bool
         *     A global permission for all accounts.<br />\n(Request) Set 
         *     this parameter to true to make the resource public (if the 
         *     parent parameter is `Additions`) or to make the resource 
         *     private (if the parent parameter is `Removals`).<br 
         *     />\n(Response) If true, the resource is public. If false, the 
         *     resource is private.
         */
        char *additions_str;
        int is_set_additions;
	struct permissions_on_resource additions; /* ref PermissionsOnResource */
        /*
         *   Permissions for the resource.
         *   -AccountIds: array string
         *     One or more account IDs that the permission is associated 
         *     with.
         *   -GlobalPermission: bool
         *     A global permission for all accounts.<br />\n(Request) Set 
         *     this parameter to true to make the resource public (if the 
         *     parent parameter is `Additions`) or to make the resource 
         *     private (if the parent parameter is `Removals`).<br 
         *     />\n(Response) If true, the resource is public. If false, the 
         *     resource is private.
         */
        char *removals_str;
        int is_set_removals;
	struct permissions_on_resource removals; /* ref PermissionsOnResource */
};

struct phase1_options {
        /*
         * The action to carry out after a Dead Peer Detection (DPD) timeout 
         * occurs.
         */
	char *dpd_timeout_action; /* string */
        /*
         * The maximum waiting time for a Dead Peer Detection (DPD) response 
         * before considering the peer as dead, in seconds.
         */
        int is_set_dpd_timeout_seconds;
	int dpd_timeout_seconds; /* int */
        /*
         * The Internet Key Exchange (IKE) versions allowed for the VPN tunnel.
         */
        char *ike_versions_str;
	char **ike_versions; /* array string */
        /*
         * The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for 
         * phase 1.
         */
        char *phase1_dh_group_numbers_str;
	int *phase1_dh_group_numbers; /* array integer */
        /*
         * The encryption algorithms allowed for the VPN tunnel for phase 1.
         */
        char *phase1_encryption_algorithms_str;
	char **phase1_encryption_algorithms; /* array string */
        /*
         * The integrity algorithms allowed for the VPN tunnel for phase 1.
         */
        char *phase1_integrity_algorithms_str;
	char **phase1_integrity_algorithms; /* array string */
        /*
         * The lifetime for phase 1 of the IKE negotiation process, in seconds.
         */
        int is_set_phase1_lifetime_seconds;
	int phase1_lifetime_seconds; /* int */
        /*
         * The number of packets in an IKE replay window.
         */
        int is_set_replay_window_size;
	int replay_window_size; /* int */
        /*
         * The action to carry out when establishing tunnels for a VPN 
         * connection.
         */
	char *startup_action; /* string */
};

struct phase2_options {
        /*
         * The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for 
         * phase 2.
         */
        char *phase2_dh_group_numbers_str;
	int *phase2_dh_group_numbers; /* array integer */
        /*
         * The encryption algorithms allowed for the VPN tunnel for phase 2.
         */
        char *phase2_encryption_algorithms_str;
	char **phase2_encryption_algorithms; /* array string */
        /*
         * The integrity algorithms allowed for the VPN tunnel for phase 2.
         */
        char *phase2_integrity_algorithms_str;
	char **phase2_integrity_algorithms; /* array string */
        /*
         * The lifetime for phase 2 of the Internet Key Exchange (IKE) 
         * negociation process, in seconds.
         */
        int is_set_phase2_lifetime_seconds;
	int phase2_lifetime_seconds; /* int */
        /*
         * The pre-shared key to establish the initial authentication between 
         * the client gateway and the virtual gateway. This key can contain any 
         * character except line breaks and double quotes (&quot;).
         */
	char *pre_shared_key; /* string */
};

struct phase2_options_to_update {
        /*
         * The pre-shared key to establish the initial authentication between 
         * the client gateway and the virtual gateway. This key can contain any 
         * character except line breaks and double quotes (&quot;).
         */
	char *pre_shared_key; /* string */
};

struct placement {
        /*
         * The name of the Subregion. If you specify this parameter, you must 
         * not specify the `Nics` parameter.
         */
	char *subregion_name; /* string */
        /*
         * The tenancy of the VM (`default`, `dedicated`, or a dedicated group 
         * ID).
         */
	char *tenancy; /* string */
};

struct policy {
        /*
         * The date and time of creation of the policy.
         */
	char *creation_date; /* string */
        /*
         * A friendly name for the policy (between 0 and 1000 characters).
         */
	char *description; /* string */
        /*
         * Indicates whether the policy can be linked to a group or an EIM user.
         */
        int is_set_is_linkable;
	int is_linkable; /* bool */
        /*
         * The date and time at which the policy was last modified.
         */
	char *last_modification_date; /* string */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *orn; /* string */
        /*
         * The path to the policy.
         */
	char *path; /* string */
        /*
         * The ID of the policy default version.
         */
	char *policy_default_version_id; /* string */
        /*
         * The ID of the policy.
         */
	char *policy_id; /* string */
        /*
         * The name of the policy.
         */
	char *policy_name; /* string */
        /*
         * The number of resources attached to the policy.
         */
        int is_set_resources_count;
	int resources_count; /* int */
};

struct policy_version {
        /*
         * The policy document as a json string.
         */
	char *body; /* string */
        /*
         * The date and time of creation of the version.
         */
	char *creation_date; /* string */
        /*
         * If true, the version is the default one.
         */
        int is_set_default_version;
	int default_version; /* bool */
        /*
         * The ID of the version.
         */
	char *version_id; /* string */
};

struct private_ip {
        /*
         * If true, the IP is the primary private IP of the NIC.
         */
        int is_set_is_primary;
	int is_primary; /* bool */
        /*
         *   Information about the public IP association.
         *   -LinkPublicIpId: string
         *     (Required in a Net) The ID representing the association of the 
         *     public IP with the VM or the NIC.
         *   -PublicDnsName: string
         *     The name of the public DNS.
         *   -PublicIp: string
         *     The public IP associated with the NIC.
         *   -PublicIpAccountId: string
         *     The account ID of the owner of the public IP.
         *   -PublicIpId: string
         *     The allocation ID of the public IP.
         */
        char *link_public_ip_str;
        int is_set_link_public_ip;
	struct link_public_ip link_public_ip; /* ref LinkPublicIp */
        /*
         * The name of the private DNS.
         */
	char *private_dns_name; /* string */
        /*
         * The private IP of the NIC.
         */
	char *private_ip; /* string */
};

struct private_ip_light {
        /*
         * If true, the IP is the primary private IP of the NIC.
         */
        int is_set_is_primary;
	int is_primary; /* bool */
        /*
         * The private IP of the NIC.
         */
	char *private_ip; /* string */
};

struct private_ip_light_for_vm {
        /*
         * If true, the IP is the primary private IP of the NIC.
         */
        int is_set_is_primary;
	int is_primary; /* bool */
        /*
         *   Information about the public IP associated with the NIC.
         *   -PublicDnsName: string
         *     The name of the public DNS.
         *   -PublicIp: string
         *     The public IP associated with the NIC.
         *   -PublicIpAccountId: string
         *     The account ID of the owner of the public IP.
         */
        char *link_public_ip_str;
        int is_set_link_public_ip;
	struct link_public_ip_light_for_vm link_public_ip; /* ref LinkPublicIpLightForVm */
        /*
         * The name of the private DNS.
         */
	char *private_dns_name; /* string */
        /*
         * The private IP.
         */
	char *private_ip; /* string */
};

struct product_type {
        /*
         * The description of the product type.
         */
	char *description; /* string */
        /*
         * The ID of the product type.
         */
	char *product_type_id; /* string */
        /*
         * The vendor of the product type.
         */
	char *vendor; /* string */
};

struct public_ip {
        /*
         * (Required in a Net) The ID representing the association of the public 
         * IP with the VM or the NIC.
         */
	char *link_public_ip_id; /* string */
        /*
         * The account ID of the owner of the NIC.
         */
	char *nic_account_id; /* string */
        /*
         * The ID of the NIC the public IP is associated with (if any).
         */
	char *nic_id; /* string */
        /*
         * The private IP associated with the public IP.
         */
	char *private_ip; /* string */
        /*
         * The public IP.
         */
	char *public_ip; /* string */
        /*
         * The allocation ID of the public IP.
         */
	char *public_ip_id; /* string */
        /*
         * One or more tags associated with the public IP.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the VM the public IP is associated with (if any).
         */
	char *vm_id; /* string */
};

struct public_ip_light {
        /*
         * The public IP associated with the NAT service.
         */
	char *public_ip; /* string */
        /*
         * The allocation ID of the public IP associated with the NAT service.
         */
	char *public_ip_id; /* string */
};

struct quota {
        /*
         * The account ID of the owner of the quotas.
         */
	char *account_id; /* string */
        /*
         * The description of the quota.
         */
	char *description; /* string */
        /*
         * The maximum value of the quota for the account (if there is no limit, 
         * `0`).
         */
        int is_set_max_value;
	int max_value; /* int */
        /*
         * The unique name of the quota.
         */
	char *name; /* string */
        /*
         * The group name of the quota.
         */
	char *quota_collection; /* string */
        /*
         * The description of the quota.
         */
	char *short_description; /* string */
        /*
         * The limit value currently used by the account.
         */
        int is_set_used_value;
	int used_value; /* int */
};

struct quota_types {
        /*
         * The resource ID if it is a resource-specific quota, `global` if it is 
         * not.
         */
	char *quota_type; /* string */
        /*
         * One or more quotas associated with the account.
         *   Information about the quota.
         *   -AccountId: string
         *     The account ID of the owner of the quotas.
         *   -Description: string
         *     The description of the quota.
         *   -MaxValue: int
         *     The maximum value of the quota for the account (if there is no 
         *     limit, `0`).
         *   -Name: string
         *     The unique name of the quota.
         *   -QuotaCollection: string
         *     The group name of the quota.
         *   -ShortDescription: string
         *     The description of the quota.
         *   -UsedValue: int
         *     The limit value currently used by the account.
         */
        char *quotas_str;
        int nb_quotas;
	struct quota *quotas; /* array ref Quota */
};

struct read_linked_policies_filters {
        /*
         * The path prefix of the policies, set to a slash (`/`) by default.
         */
	char *path_prefix; /* string */
};

struct read_policies_filters {
        /*
         * If set to true, lists only the policies attached to a user.
         */
        int is_set_only_linked;
	int only_linked; /* bool */
        /*
         * The path prefix you can use to filter the results, set to a slash 
         * (`/`) by default.
         */
	char *path_prefix; /* string */
        /*
         * The scope to filter policies (`ALL` \\| `OWS` \\| `local`).
         */
	char *scope; /* string */
};

struct region {
        /*
         * The hostname of the gateway to access the Region.
         */
	char *endpoint; /* string */
        /*
         * The administrative name of the Region.
         */
	char *region_name; /* string */
};

struct resource_load_balancer_tag {
        /*
         * The key of the tag, with a minimum of 1 character.
         */
	char *key; /* string */
};

struct resource_tag {
        /*
         * The key of the tag, with a minimum of 1 character.
         */
	char *key; /* string */
        /*
         * The value of the tag, between 0 and 255 characters.
         */
	char *value; /* string */
};

struct route {
        /*
         * The method used to create the route.
         */
	char *creation_method; /* string */
        /*
         * The IP range used for the destination match, in CIDR notation (for 
         * example, `10.0.0.0/24`).
         */
	char *destination_ip_range; /* string */
        /*
         * The ID of the OUTSCALE service.
         */
	char *destination_service_id; /* string */
        /*
         * The ID of the Internet service or virtual gateway attached to the Net.
         */
	char *gateway_id; /* string */
        /*
         * The ID of a NAT service attached to the Net.
         */
	char *nat_service_id; /* string */
        /*
         * The ID of the Net access point.
         */
	char *net_access_point_id; /* string */
        /*
         * The ID of the Net peering.
         */
	char *net_peering_id; /* string */
        /*
         * The ID of the NIC.
         */
	char *nic_id; /* string */
        /*
         * The state of a route in the route table (always `active`). 
         */
	char *state; /* string */
        /*
         * The account ID of the owner of the VM.
         */
	char *vm_account_id; /* string */
        /*
         * The ID of a VM specified in a route in the table.
         */
	char *vm_id; /* string */
};

struct route_light {
        /*
         * The IP range used for the destination match, in CIDR notation (for 
         * example, `10.0.0.0/24`).
         */
	char *destination_ip_range; /* string */
        /*
         * The type of route (always `static`).
         */
	char *route_type; /* string */
        /*
         * The current state of the static route (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
	char *state; /* string */
};

struct route_propagating_virtual_gateway {
        /*
         * The ID of the virtual gateway.
         */
	char *virtual_gateway_id; /* string */
};

struct route_table {
        /*
         * One or more associations between the route table and Subnets.
         *   One or more associations between the route table and the 
         *   Subnets.
         *   -LinkRouteTableId: string
         *     The ID of the association between the route table and the 
         *     Subnet.
         *   -Main: bool
         *     If true, the route table is the main one.
         *   -NetId: string
         *     The ID of the Net.
         *   -RouteTableId: string
         *     The ID of the route table.
         *   -SubnetId: string
         *     The ID of the Subnet.
         */
        char *link_route_tables_str;
        int nb_link_route_tables;
	struct link_route_table *link_route_tables; /* array ref LinkRouteTable */
        /*
         * The ID of the Net for the route table.
         */
	char *net_id; /* string */
        /*
         * Information about virtual gateways propagating routes.
         *   Information about the route propagating virtual gateway.
         *   -VirtualGatewayId: string
         *     The ID of the virtual gateway.
         */
        char *route_propagating_virtual_gateways_str;
        int nb_route_propagating_virtual_gateways;
	struct route_propagating_virtual_gateway *route_propagating_virtual_gateways; /* array ref RoutePropagatingVirtualGateway */
        /*
         * The ID of the route table.
         */
	char *route_table_id; /* string */
        /*
         * One or more routes in the route table.
         *   Information about the route.
         *   -CreationMethod: string
         *     The method used to create the route.
         *   -DestinationIpRange: string
         *     The IP range used for the destination match, in CIDR notation 
         *     (for example, `10.0.0.0/24`).
         *   -DestinationServiceId: string
         *     The ID of the OUTSCALE service.
         *   -GatewayId: string
         *     The ID of the Internet service or virtual gateway attached to 
         *     the Net.
         *   -NatServiceId: string
         *     The ID of a NAT service attached to the Net.
         *   -NetAccessPointId: string
         *     The ID of the Net access point.
         *   -NetPeeringId: string
         *     The ID of the Net peering.
         *   -NicId: string
         *     The ID of the NIC.
         *   -State: string
         *     The state of a route in the route table (always `active`). 
         *   -VmAccountId: string
         *     The account ID of the owner of the VM.
         *   -VmId: string
         *     The ID of a VM specified in a route in the table.
         */
        char *routes_str;
        int nb_routes;
	struct route *routes; /* array ref Route */
        /*
         * One or more tags associated with the route table.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct security_group {
        /*
         * The account ID that has been granted permission.
         */
	char *account_id; /* string */
        /*
         * The description of the security group.
         */
	char *description; /* string */
        /*
         * The inbound rules associated with the security group.
         *   Information about the security group rule.
         *   -FromPortRange: int
         *     The beginning of the port range for the TCP and UDP protocols, 
         *     or an ICMP type number.
         *   -IpProtocol: string
         *     The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all 
         *     protocols). By default, `-1`. In a Net, this can also be an IP 
         *     protocol number. For more information, see the [IANA.org 
         *     website](https://www.iana.org/assignments/protocol-numbers/proto
         *     col-numbers.xhtml).
         *   -IpRanges: array string
         *     One or more IP ranges for the security group rules, in CIDR 
         *     notation (for example, `10.0.0.0/16`).
         *   -SecurityGroupsMembers: array ref SecurityGroupsMember
         *     Information about one or more source or destination security 
         *     groups.
         *       Information about a source or destination security group.
         *       -AccountId: string
         *         The account ID that owns the source or destination security 
         *         group.
         *       -SecurityGroupId: string
         *         The ID of a source or destination security group that you 
         * want 
         *         to link to the security group of the rule.
         *       -SecurityGroupName: string
         *         (Public Cloud only) The name of a source or destination 
         *         security group that you want to link to the security group of 
         *         the rule.
         *   -ServiceIds: array string
         *     One or more service IDs to allow traffic from a Net to access 
         *     the corresponding OUTSCALE services. For more information, see 
         *     [ReadNetAccessPointServices](#readnetaccesspointservices).
         *   -ToPortRange: int
         *     The end of the port range for the TCP and UDP protocols, or an 
         *     ICMP code number.
         */
        char *inbound_rules_str;
        int nb_inbound_rules;
	struct security_group_rule *inbound_rules; /* array ref SecurityGroupRule */
        /*
         * The ID of the Net for the security group.
         */
	char *net_id; /* string */
        /*
         * The outbound rules associated with the security group.
         *   Information about the security group rule.
         *   -FromPortRange: int
         *     The beginning of the port range for the TCP and UDP protocols, 
         *     or an ICMP type number.
         *   -IpProtocol: string
         *     The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all 
         *     protocols). By default, `-1`. In a Net, this can also be an IP 
         *     protocol number. For more information, see the [IANA.org 
         *     website](https://www.iana.org/assignments/protocol-numbers/proto
         *     col-numbers.xhtml).
         *   -IpRanges: array string
         *     One or more IP ranges for the security group rules, in CIDR 
         *     notation (for example, `10.0.0.0/16`).
         *   -SecurityGroupsMembers: array ref SecurityGroupsMember
         *     Information about one or more source or destination security 
         *     groups.
         *       Information about a source or destination security group.
         *       -AccountId: string
         *         The account ID that owns the source or destination security 
         *         group.
         *       -SecurityGroupId: string
         *         The ID of a source or destination security group that you 
         * want 
         *         to link to the security group of the rule.
         *       -SecurityGroupName: string
         *         (Public Cloud only) The name of a source or destination 
         *         security group that you want to link to the security group of 
         *         the rule.
         *   -ServiceIds: array string
         *     One or more service IDs to allow traffic from a Net to access 
         *     the corresponding OUTSCALE services. For more information, see 
         *     [ReadNetAccessPointServices](#readnetaccesspointservices).
         *   -ToPortRange: int
         *     The end of the port range for the TCP and UDP protocols, or an 
         *     ICMP code number.
         */
        char *outbound_rules_str;
        int nb_outbound_rules;
	struct security_group_rule *outbound_rules; /* array ref SecurityGroupRule */
        /*
         * The ID of the security group.
         */
	char *security_group_id; /* string */
        /*
         * The name of the security group.
         */
	char *security_group_name; /* string */
        /*
         * One or more tags associated with the security group.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct security_group_light {
        /*
         * The ID of the security group.
         */
	char *security_group_id; /* string */
        /*
         * The name of the security group.
         */
	char *security_group_name; /* string */
};

struct security_group_rule {
        /*
         * The beginning of the port range for the TCP and UDP protocols, or an 
         * ICMP type number.
         */
        int is_set_from_port_range;
	int from_port_range; /* int */
        /*
         * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all 
         * protocols). By default, `-1`. In a Net, this can also be an IP 
         * protocol number. For more information, see the [IANA.org 
         * website](https://www.iana.org/assignments/protocol-numbers/protocol-nu
         * mbers.xhtml).
         */
	char *ip_protocol; /* string */
        /*
         * One or more IP ranges for the security group rules, in CIDR notation 
         * (for example, `10.0.0.0/16`).
         */
        char *ip_ranges_str;
	char **ip_ranges; /* array string */
        /*
         * Information about one or more source or destination security groups.
         *   Information about a source or destination security group.
         *   -AccountId: string
         *     The account ID that owns the source or destination security 
         *     group.
         *   -SecurityGroupId: string
         *     The ID of a source or destination security group that you want 
         *     to link to the security group of the rule.
         *   -SecurityGroupName: string
         *     (Public Cloud only) The name of a source or destination 
         *     security group that you want to link to the security group of 
         *     the rule.
         */
        char *security_groups_members_str;
        int nb_security_groups_members;
	struct security_groups_member *security_groups_members; /* array ref SecurityGroupsMember */
        /*
         * One or more service IDs to allow traffic from a Net to access the 
         * corresponding OUTSCALE services. For more information, see 
         * [ReadNetAccessPointServices](#readnetaccesspointservices).
         */
        char *service_ids_str;
	char **service_ids; /* array string */
        /*
         * The end of the port range for the TCP and UDP protocols, or an ICMP 
         * code number.
         */
        int is_set_to_port_range;
	int to_port_range; /* int */
};

struct security_groups_member {
        /*
         * The account ID that owns the source or destination security group.
         */
	char *account_id; /* string */
        /*
         * The ID of a source or destination security group that you want to 
         * link to the security group of the rule.
         */
	char *security_group_id; /* string */
        /*
         * (Public Cloud only) The name of a source or destination security 
         * group that you want to link to the security group of the rule.
         */
	char *security_group_name; /* string */
};

struct server_certificate {
        /*
         * The date at which the server certificate expires.
         */
	char *expiration_date; /* string */
        /*
         * The ID of the server certificate.
         */
	char *id; /* string */
        /*
         * The name of the server certificate.
         */
	char *name; /* string */
        /*
         * The Outscale Resource Name (ORN) of the server certificate. For more 
         * information, see [Resource Identifiers > Outscale Resource Names 
         * (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.ht
         * ml#_outscale_resource_names_orns).
         */
	char *orn; /* string */
        /*
         * The path to the server certificate.
         */
	char *path; /* string */
        /*
         * The date at which the server certificate has been uploaded.
         */
	char *upload_date; /* string */
};

struct service {
        /*
         * The list of network prefixes used by the service, in CIDR notation.
         */
        char *ip_ranges_str;
	char **ip_ranges; /* array string */
        /*
         * The ID of the service.
         */
	char *service_id; /* string */
        /*
         * The name of the service.
         */
	char *service_name; /* string */
};

struct snapshot {
        /*
         * The account alias of the owner of the snapshot.
         */
	char *account_alias; /* string */
        /*
         * The account ID of the owner of the snapshot.
         */
	char *account_id; /* string */
        /*
         * The date and time of creation of the snapshot.
         */
	char *creation_date; /* string */
        /*
         * The description of the snapshot.
         */
	char *description; /* string */
        /*
         *   Permissions for the resource.
         *   -AccountIds: array string
         *     One or more account IDs that the permission is associated 
         *     with.
         *   -GlobalPermission: bool
         *     A global permission for all accounts.<br />\n(Request) Set 
         *     this parameter to true to make the resource public (if the 
         *     parent parameter is `Additions`) or to make the resource 
         *     private (if the parent parameter is `Removals`).<br 
         *     />\n(Response) If true, the resource is public. If false, the 
         *     resource is private.
         */
        char *permissions_to_create_volume_str;
        int is_set_permissions_to_create_volume;
	struct permissions_on_resource permissions_to_create_volume; /* ref PermissionsOnResource */
        /*
         * The progress of the snapshot, as a percentage.
         */
        int is_set_progress;
	int progress; /* int */
        /*
         * The ID of the snapshot.
         */
	char *snapshot_id; /* string */
        /*
         * The state of the snapshot (`in-queue` \\| `completed` \\| `error`).
         */
	char *state; /* string */
        /*
         * One or more tags associated with the snapshot.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the volume used to create the snapshot.
         */
	char *volume_id; /* string */
        /*
         * The size of the volume used to create the snapshot, in gibibytes 
         * (GiB).
         */
        int is_set_volume_size;
	int volume_size; /* int */
};

struct snapshot_export_task {
        /*
         * If the snapshot export task fails, an error message appears.
         */
	char *comment; /* string */
        /*
         *   Information about the snapshot export task.
         *   -DiskImageFormat: string
         *     The format of the export disk (`qcow2` \\| `raw`).
         *   -OsuBucket: string
         *     The name of the OOS bucket the snapshot is exported to.
         *   -OsuPrefix: string
         *     The prefix for the key of the OOS object corresponding to the 
         *     snapshot.
         */
        char *osu_export_str;
        int is_set_osu_export;
	struct osu_export_snapshot_export_task osu_export; /* ref OsuExportSnapshotExportTask */
        /*
         * The progress of the snapshot export task, as a percentage.
         */
        int is_set_progress;
	int progress; /* int */
        /*
         * The ID of the snapshot to be exported.
         */
	char *snapshot_id; /* string */
        /*
         * The state of the snapshot export task (`pending` \\| `active` \\| 
         * `completed` \\| `failed`).
         */
	char *state; /* string */
        /*
         * One or more tags associated with the snapshot export task.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the snapshot export task.
         */
	char *task_id; /* string */
};

struct subnet {
        /*
         * The number of available IPs in the Subnets.
         */
        int is_set_available_ips_count;
	int available_ips_count; /* int */
        /*
         * The IP range in the Subnet, in CIDR notation (for example, 
         * `10.0.0.0/16`).
         */
	char *ip_range; /* string */
        /*
         * If true, a public IP is assigned to the network interface cards 
         * (NICs) created in the specified Subnet.
         */
        int is_set_map_public_ip_on_launch;
	int map_public_ip_on_launch; /* bool */
        /*
         * The ID of the Net in which the Subnet is.
         */
	char *net_id; /* string */
        /*
         * The state of the Subnet (`pending` \\| `available` \\| `deleted`).
         */
	char *state; /* string */
        /*
         * The ID of the Subnet.
         */
	char *subnet_id; /* string */
        /*
         * The name of the Subregion in which the Subnet is located.
         */
	char *subregion_name; /* string */
        /*
         * One or more tags associated with the Subnet.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct subregion {
        /*
         * The location code of the Subregion.
         */
	char *location_code; /* string */
        /*
         * The name of the Region containing the Subregion.
         */
	char *region_name; /* string */
        /*
         * The state of the Subregion.
         */
	char *state; /* string */
        /*
         * The name of the Subregion.
         */
	char *subregion_name; /* string */
};

struct tag {
        /*
         * The key of the tag, with a minimum of 1 character.
         */
	char *key; /* string */
        /*
         * The ID of the resource.
         */
	char *resource_id; /* string */
        /*
         * The type of the resource.
         */
	char *resource_type; /* string */
        /*
         * The value of the tag, between 0 and 255 characters.
         */
	char *value; /* string */
};

struct user {
        /*
         * The path to the EIM user.
         */
	char *path; /* string */
        /*
         *  The ID of the EIM user.
         */
	char *user_id; /* string */
        /*
         * The name of the EIM user.
         */
	char *user_name; /* string */
};

struct vgw_telemetry {
        /*
         * The number of routes accepted through BGP (Border Gateway Protocol) 
         * route exchanges.
         */
        int is_set_accepted_route_count;
	int accepted_route_count; /* int */
        /*
         * The date and time (UTC) of the latest state update.
         */
	char *last_state_change_date; /* string */
        /*
         * The IP on the OUTSCALE side of the tunnel.
         */
	char *outside_ip_address; /* string */
        /*
         * The state of the IPSEC tunnel (`UP` \\| `DOWN`).
         */
	char *state; /* string */
        /*
         * A description of the current state of the tunnel.
         */
	char *state_description; /* string */
};

struct virtual_gateway {
        /*
         * The type of VPN connection supported by the virtual gateway (only 
         * `ipsec.1` is supported).
         */
	char *connection_type; /* string */
        /*
         * The Net to which the virtual gateway is attached.
         *   Information about the attachment.
         *   -NetId: string
         *     The ID of the Net to which the virtual gateway is attached.
         *   -State: string
         *     The state of the attachment (`attaching` \\| `attached` \\| 
         *     `detaching` \\| `detached`).
         */
        char *net_to_virtual_gateway_links_str;
        int nb_net_to_virtual_gateway_links;
	struct net_to_virtual_gateway_link *net_to_virtual_gateway_links; /* array ref NetToVirtualGatewayLink */
        /*
         * The state of the virtual gateway (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
	char *state; /* string */
        /*
         * One or more tags associated with the virtual gateway.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the virtual gateway.
         */
	char *virtual_gateway_id; /* string */
};

struct vm {
        /*
         * The architecture of the VM (`i386` \\| `x86_64`).
         */
	char *architecture; /* string */
        /*
         * The block device mapping of the VM.
         *   Information about the created block device mapping.
         *   -Bsu: ref BsuCreated
         *       Information about the created BSU volume.
         *       -DeleteOnVmDeletion: bool
         *         If true, the volume is deleted when terminating the VM. If 
         *         false, the volume is not deleted when terminating the VM.
         *       -LinkDate: string
         *         The date and time of attachment of the volume to the VM, in 
         *         ISO 8601 date-time format.
         *       -State: string
         *         The state of the volume.
         *       -VolumeId: string
         *         The ID of the volume.
         *   -DeviceName: string
         *     The name of the device.
         */
        char *block_device_mappings_str;
        int nb_block_device_mappings;
	struct block_device_mapping_created *block_device_mappings; /* array ref BlockDeviceMappingCreated */
        /*
         * This parameter is not available. It is present in our API for the 
         * sake of historical compatibility with AWS.
         */
        int is_set_bsu_optimized;
	int bsu_optimized; /* bool */
        /*
         * The idempotency token provided when launching the VM.
         */
	char *client_token; /* string */
        /*
         * The date and time of creation of the VM.
         */
	char *creation_date; /* string */
        /*
         * If true, you cannot delete the VM unless you change this parameter 
         * back to false.
         */
        int is_set_deletion_protection;
	int deletion_protection; /* bool */
        /*
         * The hypervisor type of the VMs (`ovm` \\| `xen`).
         */
	char *hypervisor; /* string */
        /*
         * The ID of the OMI used to create the VM.
         */
	char *image_id; /* string */
        /*
         * (Net only) If true, the source/destination check is enabled. If 
         * false, it is disabled. This value must be false for a NAT VM to 
         * perform network address translation (NAT) in a Net.
         */
        int is_set_is_source_dest_checked;
	int is_source_dest_checked; /* bool */
        /*
         * The name of the keypair used when launching the VM.
         */
	char *keypair_name; /* string */
        /*
         * The number for the VM when launching a group of several VMs (for 
         * example, `0`, `1`, `2`, and so on).
         */
        int is_set_launch_number;
	int launch_number; /* int */
        /*
         * If true, nested virtualization is enabled. If false, it is disabled.
         */
        int is_set_nested_virtualization;
	int nested_virtualization; /* bool */
        /*
         * The ID of the Net in which the VM is running.
         */
	char *net_id; /* string */
        /*
         * (Net only) The network interface cards (NICs) the VMs are attached to.
         *   Information about the network interface card (NIC).
         *   -AccountId: string
         *     The account ID of the owner of the NIC.
         *   -Description: string
         *     The description of the NIC.
         *   -IsSourceDestChecked: bool
         *     (Net only) If true, the source/destination check is enabled. 
         *     If false, it is disabled. This value must be false for a NAT VM 
         *     to perform network address translation (NAT) in a Net.
         *   -LinkNic: ref LinkNicLight
         *       Information about the network interface card (NIC).
         *       -DeleteOnVmDeletion: bool
         *         If true, the NIC is deleted when the VM is terminated.
         *       -DeviceNumber: int
         *         The device index for the NIC attachment (between `1` and `7`, 
         *         both included).
         *       -LinkNicId: string
         *         The ID of the NIC to attach.
         *       -State: string
         *         The state of the attachment (`attaching` \\| `attached` \\| 
         *         `detaching` \\| `detached`).
         *   -LinkPublicIp: ref LinkPublicIpLightForVm
         *       Information about the public IP associated with the NIC.
         *       -PublicDnsName: string
         *         The name of the public DNS.
         *       -PublicIp: string
         *         The public IP associated with the NIC.
         *       -PublicIpAccountId: string
         *         The account ID of the owner of the public IP.
         *   -MacAddress: string
         *     The Media Access Control (MAC) address of the NIC.
         *   -NetId: string
         *     The ID of the Net for the NIC.
         *   -NicId: string
         *     The ID of the NIC.
         *   -PrivateDnsName: string
         *     The name of the private DNS.
         *   -PrivateIps: array ref PrivateIpLightForVm
         *     The private IP or IPs of the NIC.
         *       Information about the private IP of the NIC.
         *       -IsPrimary: bool
         *         If true, the IP is the primary private IP of the NIC.
         *       -LinkPublicIp: ref LinkPublicIpLightForVm
         *           Information about the public IP associated with the NIC.
         *           -PublicDnsName: string
         *             The name of the public DNS.
         *           -PublicIp: string
         *             The public IP associated with the NIC.
         *           -PublicIpAccountId: string
         *             The account ID of the owner of the public IP.
         *       -PrivateDnsName: string
         *         The name of the private DNS.
         *       -PrivateIp: string
         *         The private IP.
         *   -SecurityGroups: array ref SecurityGroupLight
         *     One or more IDs of security groups for the NIC.
         *       Information about the security group.
         *       -SecurityGroupId: string
         *         The ID of the security group.
         *       -SecurityGroupName: string
         *         The name of the security group.
         *   -State: string
         *     The state of the NIC (`available` \\| `attaching` \\| `in-use` 
         *     \\| `detaching`).
         *   -SubnetId: string
         *     The ID of the Subnet for the NIC.
         */
        char *nics_str;
        int nb_nics;
	struct nic_light *nics; /* array ref NicLight */
        /*
         * Indicates the operating system (OS) of the VM.
         */
	char *os_family; /* string */
        /*
         * The performance of the VM (`medium` \\| `high` \\| `highest`).
         */
	char *performance; /* string */
        /*
         *   Information about the placement of the VM.
         *   -SubregionName: string
         *     The name of the Subregion. If you specify this parameter, you 
         *     must not specify the `Nics` parameter.
         *   -Tenancy: string
         *     The tenancy of the VM (`default`, `dedicated`, or a dedicated 
         *     group ID).
         */
        char *placement_str;
        int is_set_placement;
	struct placement placement; /* ref Placement */
        /*
         * The name of the private DNS.
         */
	char *private_dns_name; /* string */
        /*
         * The primary private IP of the VM.
         */
	char *private_ip; /* string */
        /*
         * The product codes associated with the OMI used to create the VM.
         */
        char *product_codes_str;
	char **product_codes; /* array string */
        /*
         * The name of the public DNS.
         */
	char *public_dns_name; /* string */
        /*
         * The public IP of the VM.
         */
	char *public_ip; /* string */
        /*
         * The reservation ID of the VM.
         */
	char *reservation_id; /* string */
        /*
         * The name of the root device for the VM (for example, `/dev/sda1`).
         */
	char *root_device_name; /* string */
        /*
         * The type of root device used by the VM (always `bsu`).
         */
	char *root_device_type; /* string */
        /*
         * One or more security groups associated with the VM.
         *   Information about the security group.
         *   -SecurityGroupId: string
         *     The ID of the security group.
         *   -SecurityGroupName: string
         *     The name of the security group.
         */
        char *security_groups_str;
        int nb_security_groups;
	struct security_group_light *security_groups; /* array ref SecurityGroupLight */
        /*
         * The state of the VM (`pending` \\| `running` \\| `stopping` \\| 
         * `stopped` \\| `shutting-down` \\| `terminated` \\| `quarantine`).
         */
	char *state; /* string */
        /*
         * The reason explaining the current state of the VM.
         */
	char *state_reason; /* string */
        /*
         * The ID of the Subnet for the VM.
         */
	char *subnet_id; /* string */
        /*
         * One or more tags associated with the VM.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The Base64-encoded MIME user data.
         */
	char *user_data; /* string */
        /*
         * The ID of the VM.
         */
	char *vm_id; /* string */
        /*
         * The VM behavior when you stop it. If set to `stop`, the VM stops. If 
         * set to `restart`, the VM stops then automatically restarts. If set to 
         * `terminate`, the VM stops and is deleted.
         */
	char *vm_initiated_shutdown_behavior; /* string */
        /*
         * The type of VM. For more information, see [VM 
         * Types](https://docs.outscale.com/en/userguide/VM-Types.html).
         */
	char *vm_type; /* string */
};

struct vm_group {
        /*
         * The date and time of creation of the VM group.
         */
	char *creation_date; /* string */
        /*
         * The description of the VM group.
         */
	char *description; /* string */
        /*
         * The positioning strategy of the VMs on hypervisors. By default, or if 
         * set to `no-strategy`, TINA determines the most adequate position for 
         * the VMs. If set to `attract`, the VMs are deployed on the same 
         * hypervisor, which improves network performance. If set to `repulse`, 
         * the VMs are deployed on a different hypervisor, which improves fault 
         * tolerance.
         */
	char *positioning_strategy; /* string */
        /*
         * One or more IDs of security groups for the VM group.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The state of the VM group (`pending` \\| `available` \\| `scaling up` 
         * \\| `scaling down` \\| `deleting` \\| `deleted`).
         */
	char *state; /* string */
        /*
         * The ID of the Subnet for the VM group.
         */
	char *subnet_id; /* string */
        /*
         * One or more tags associated with the VM group.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The number of VMs in the VM group.
         */
        int is_set_vm_count;
	int vm_count; /* int */
        /*
         * The ID of the VM group.
         */
	char *vm_group_id; /* string */
        /*
         * The name of the VM group.
         */
	char *vm_group_name; /* string */
        /*
         * The IDs of the VMs in the VM group.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
        /*
         * The ID of the VM template used by the VM group.
         */
	char *vm_template_id; /* string */
};

struct vm_state {
        /*
         * The current state of the VM (`InService` \\| `OutOfService` \\| 
         * `Unknown`).
         */
	char *current_state; /* string */
        /*
         * The previous state of the VM (`InService` \\| `OutOfService` \\| 
         * `Unknown`).
         */
	char *previous_state; /* string */
        /*
         * The ID of the VM.
         */
	char *vm_id; /* string */
};

struct vm_states {
        /*
         * One or more scheduled events associated with the VM.
         *   Information about the maintenance event.
         *   -Code: string
         *     The code of the event (`system-reboot` \\| 
         *     `system-maintenance`).
         *   -Description: string
         *     The description of the event.
         *   -NotAfter: string
         *     The latest scheduled end time for the event.
         *   -NotBefore: string
         *     The earliest scheduled start time for the event.
         */
        char *maintenance_events_str;
        int nb_maintenance_events;
	struct maintenance_event *maintenance_events; /* array ref MaintenanceEvent */
        /*
         * The name of the Subregion of the VM.
         */
	char *subregion_name; /* string */
        /*
         * The ID of the VM.
         */
	char *vm_id; /* string */
        /*
         * The state of the VM (`pending` \\| `running` \\| `stopping` \\| 
         * `stopped` \\| `shutting-down` \\| `terminated` \\| `quarantine`).
         */
	char *vm_state; /* string */
};

struct vm_template {
        /*
         * The number of vCores.
         */
        int is_set_cpu_cores;
	int cpu_cores; /* int */
        /*
         * The processor generation.
         */
	char *cpu_generation; /* string */
        /*
         * The performance of the VMs.
         */
	char *cpu_performance; /* string */
        /*
         * The date and time of creation of the VM template.
         */
	char *creation_date; /* string */
        /*
         * The description of the VM template.
         */
	char *description; /* string */
        /*
         * The ID of the OMI.
         */
	char *image_id; /* string */
        /*
         * The name of the keypair.
         */
	char *keypair_name; /* string */
        /*
         * The amount of RAM.
         */
        int is_set_ram;
	int ram; /* int */
        /*
         * One or more tags associated with the VM template.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the VM template.
         */
	char *vm_template_id; /* string */
        /*
         * The name of the VM template.
         */
	char *vm_template_name; /* string */
};

struct vm_type {
        /*
         * This parameter is not available. It is present in our API for the 
         * sake of historical compatibility with AWS.
         */
        int is_set_bsu_optimized;
	int bsu_optimized; /* bool */
        /*
         * The type of ephemeral storage disk.
         */
	char *ephemerals_type; /* string */
        /*
         * The number of Ethernet interface available.
         */
        int is_set_eth;
	int eth; /* int */
        /*
         * The number of GPU available.
         */
        int is_set_gpu;
	int gpu; /* int */
        /*
         * The maximum number of private IPs per network interface card (NIC).
         */
        int is_set_max_private_ips;
	int max_private_ips; /* int */
        /*
         * The amount of memory, in gibibytes.
         */
        int is_set_memory_size;
	double memory_size; /* double */
        /*
         * The number of vCores.
         */
        int is_set_vcore_count;
	int vcore_count; /* int */
        /*
         * The name of the VM type.
         */
	char *vm_type_name; /* string */
        /*
         * The maximum number of ephemeral storage disks.
         */
        int is_set_volume_count;
	int volume_count; /* int */
        /*
         * The size of one ephemeral storage disk, in gibibytes (GiB).
         */
        int is_set_volume_size;
	int volume_size; /* int */
};

struct volume {
        /*
         * The date and time of creation of the volume.
         */
	char *creation_date; /* string */
        /*
         * The number of I/O operations per second (IOPS):<br />\n- For `io1` 
         * volumes, the number of provisioned IOPS<br />\n- For `gp2` volumes, 
         * the baseline performance of the volume
         */
        int is_set_iops;
	int iops; /* int */
        /*
         * Information about your volume attachment.
         *   Information about volume attachment.
         *   -DeleteOnVmDeletion: bool
         *     If true, the volume is deleted when terminating the VM. If 
         *     false, the volume is not deleted when terminating the VM.
         *   -DeviceName: string
         *     The name of the device.
         *   -State: string
         *     The state of the attachment of the volume (`attaching` \\| 
         *     `detaching` \\| `attached` \\| `detached`).
         *   -VmId: string
         *     The ID of the VM.
         *   -VolumeId: string
         *     The ID of the volume.
         */
        char *linked_volumes_str;
        int nb_linked_volumes;
	struct linked_volume *linked_volumes; /* array ref LinkedVolume */
        /*
         * The size of the volume, in gibibytes (GiB).
         */
        int is_set_size;
	int size; /* int */
        /*
         * The snapshot from which the volume was created.
         */
	char *snapshot_id; /* string */
        /*
         * The state of the volume (`creating` \\| `available` \\| `in-use` \\| 
         * `updating` \\| `deleting` \\| `error`).
         */
	char *state; /* string */
        /*
         * The Subregion in which the volume was created.
         */
	char *subregion_name; /* string */
        /*
         * One or more tags associated with the volume.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the volume.
         */
	char *volume_id; /* string */
        /*
         * The type of the volume (`standard` \\| `gp2` \\| `io1`).
         */
	char *volume_type; /* string */
};

struct vpn_options {
        /*
         *   Information about Phase 1 of the Internet Key Exchange (IKE) 
         *   negotiation. When Phase 1 finishes successfully, peers proceed 
         *   to Phase 2 negotiations. 
         *   -DpdTimeoutAction: string
         *     The action to carry out after a Dead Peer Detection (DPD) 
         *     timeout occurs.
         *   -DpdTimeoutSeconds: int
         *     The maximum waiting time for a Dead Peer Detection (DPD) 
         *     response before considering the peer as dead, in seconds.
         *   -IkeVersions: array string
         *     The Internet Key Exchange (IKE) versions allowed for the VPN 
         *     tunnel.
         *   -Phase1DhGroupNumbers: array integer
         *     The Diffie-Hellman (DH) group numbers allowed for the VPN 
         *     tunnel for phase 1.
         *   -Phase1EncryptionAlgorithms: array string
         *     The encryption algorithms allowed for the VPN tunnel for phase 
         *     1.
         *   -Phase1IntegrityAlgorithms: array string
         *     The integrity algorithms allowed for the VPN tunnel for phase 
         *     1.
         *   -Phase1LifetimeSeconds: int
         *     The lifetime for phase 1 of the IKE negotiation process, in 
         *     seconds.
         *   -ReplayWindowSize: int
         *     The number of packets in an IKE replay window.
         *   -StartupAction: string
         *     The action to carry out when establishing tunnels for a VPN 
         *     connection.
         */
        char *phase1_options_str;
        int is_set_phase1_options;
	struct phase1_options phase1_options; /* ref Phase1Options */
        /*
         *   Information about Phase 2 of the Internet Key Exchange (IKE) 
         *   negotiation. 
         *   -Phase2DhGroupNumbers: array integer
         *     The Diffie-Hellman (DH) group numbers allowed for the VPN 
         *     tunnel for phase 2.
         *   -Phase2EncryptionAlgorithms: array string
         *     The encryption algorithms allowed for the VPN tunnel for phase 
         *     2.
         *   -Phase2IntegrityAlgorithms: array string
         *     The integrity algorithms allowed for the VPN tunnel for phase 
         *     2.
         *   -Phase2LifetimeSeconds: int
         *     The lifetime for phase 2 of the Internet Key Exchange (IKE) 
         *     negociation process, in seconds.
         *   -PreSharedKey: string
         *     The pre-shared key to establish the initial authentication 
         *     between the client gateway and the virtual gateway. This key 
         *     can contain any character except line breaks and double quotes 
         *     (&quot;).
         */
        char *phase2_options_str;
        int is_set_phase2_options;
	struct phase2_options phase2_options; /* ref Phase2Options */
        /*
         * The range of inside IPs for the tunnel. This must be a /30 CIDR block 
         * from the 169.254.254.0/24 range.
         */
	char *tunnel_inside_ip_range; /* string */
};

struct vpn_connection {
        /*
         * Example configuration for the client gateway.
         */
	char *client_gateway_configuration; /* string */
        /*
         * The ID of the client gateway used on the client end of the connection.
         */
	char *client_gateway_id; /* string */
        /*
         * The type of VPN connection (always `ipsec.1`).
         */
	char *connection_type; /* string */
        /*
         * Information about one or more static routes associated with the VPN 
         * connection, if any.
         *   Information about the route.
         *   -DestinationIpRange: string
         *     The IP range used for the destination match, in CIDR notation 
         *     (for example, `10.0.0.0/24`).
         *   -RouteType: string
         *     The type of route (always `static`).
         *   -State: string
         *     The current state of the static route (`pending` \\| 
         *     `available` \\| `deleting` \\| `deleted`).
         */
        char *routes_str;
        int nb_routes;
	struct route_light *routes; /* array ref RouteLight */
        /*
         * The state of the VPN connection (`pending` \\| `available` \\| 
         * `deleting` \\| `deleted`).
         */
	char *state; /* string */
        /*
         * If false, the VPN connection uses dynamic routing with Border Gateway 
         * Protocol (BGP). If true, routing is controlled using static routes. 
         * For more information about how to create and delete static routes, 
         * see [CreateVpnConnectionRoute](#createvpnconnectionroute) and 
         * [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
         */
        int is_set_static_routes_only;
	int static_routes_only; /* bool */
        /*
         * One or more tags associated with the VPN connection.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * Information about the current state of one or more of the VPN tunnels.
         *   Information about the current state of a VPN tunnel.
         *   -AcceptedRouteCount: int
         *     The number of routes accepted through BGP (Border Gateway 
         *     Protocol) route exchanges.
         *   -LastStateChangeDate: string
         *     The date and time (UTC) of the latest state update.
         *   -OutsideIpAddress: string
         *     The IP on the OUTSCALE side of the tunnel.
         *   -State: string
         *     The state of the IPSEC tunnel (`UP` \\| `DOWN`).
         *   -StateDescription: string
         *     A description of the current state of the tunnel.
         */
        char *vgw_telemetries_str;
        int nb_vgw_telemetries;
	struct vgw_telemetry *vgw_telemetries; /* array ref VgwTelemetry */
        /*
         * The ID of the virtual gateway used on the OUTSCALE end of the 
         * connection.
         */
	char *virtual_gateway_id; /* string */
        /*
         * The ID of the VPN connection.
         */
	char *vpn_connection_id; /* string */
        /*
         *   Information about the VPN options.
         *   -Phase1Options: ref Phase1Options
         *       Information about Phase 1 of the Internet Key Exchange (IKE) 
         *       negotiation. When Phase 1 finishes successfully, peers proceed 
         *       to Phase 2 negotiations. 
         *       -DpdTimeoutAction: string
         *         The action to carry out after a Dead Peer Detection (DPD) 
         *         timeout occurs.
         *       -DpdTimeoutSeconds: int
         *         The maximum waiting time for a Dead Peer Detection (DPD) 
         *         response before considering the peer as dead, in seconds.
         *       -IkeVersions: array string
         *         The Internet Key Exchange (IKE) versions allowed for the VPN 
         *         tunnel.
         *       -Phase1DhGroupNumbers: array integer
         *         The Diffie-Hellman (DH) group numbers allowed for the VPN 
         *         tunnel for phase 1.
         *       -Phase1EncryptionAlgorithms: array string
         *         The encryption algorithms allowed for the VPN tunnel for 
         * phase 
         *         1.
         *       -Phase1IntegrityAlgorithms: array string
         *         The integrity algorithms allowed for the VPN tunnel for phase 
         *         1.
         *       -Phase1LifetimeSeconds: int
         *         The lifetime for phase 1 of the IKE negotiation process, in 
         *         seconds.
         *       -ReplayWindowSize: int
         *         The number of packets in an IKE replay window.
         *       -StartupAction: string
         *         The action to carry out when establishing tunnels for a VPN 
         *         connection.
         *   -Phase2Options: ref Phase2Options
         *       Information about Phase 2 of the Internet Key Exchange (IKE) 
         *       negotiation. 
         *       -Phase2DhGroupNumbers: array integer
         *         The Diffie-Hellman (DH) group numbers allowed for the VPN 
         *         tunnel for phase 2.
         *       -Phase2EncryptionAlgorithms: array string
         *         The encryption algorithms allowed for the VPN tunnel for 
         * phase 
         *         2.
         *       -Phase2IntegrityAlgorithms: array string
         *         The integrity algorithms allowed for the VPN tunnel for phase 
         *         2.
         *       -Phase2LifetimeSeconds: int
         *         The lifetime for phase 2 of the Internet Key Exchange (IKE) 
         *         negociation process, in seconds.
         *       -PreSharedKey: string
         *         The pre-shared key to establish the initial authentication 
         *         between the client gateway and the virtual gateway. This key 
         *         can contain any character except line breaks and double 
         * quotes 
         *         (&quot;).
         *   -TunnelInsideIpRange: string
         *     The range of inside IPs for the tunnel. This must be a /30 
         *     CIDR block from the 169.254.254.0/24 range.
         */
        char *vpn_options_str;
        int is_set_vpn_options;
	struct vpn_options vpn_options; /* ref VpnOptions */
};

struct vpn_options_to_update {
        /*
         *   Information about Phase 2 of the Internet Key Exchange (IKE) 
         *   negotiation. 
         *   -PreSharedKey: string
         *     The pre-shared key to establish the initial authentication 
         *     between the client gateway and the virtual gateway. This key 
         *     can contain any character except line breaks and double quotes 
         *     (&quot;).
         */
        char *phase2_options_str;
        int is_set_phase2_options;
	struct phase2_options_to_update phase2_options; /* ref Phase2OptionsToUpdate */
        /*
         * The range of inside IPs for the tunnel. This must be a /30 CIDR block 
         * from the 169.254.254.0/24 range.
         */
	char *tunnel_inside_ip_range; /* string */
};

struct with {
        /*
         * By default or if set to true, the account ID is displayed.
         */
        int is_set_account_id;
	int account_id; /* bool */
        /*
         * By default or if set to true, the duration of the call is displayed.
         */
        int is_set_call_duration;
	int call_duration; /* bool */
        /*
         * By default or if set to true, the access key is displayed.
         */
        int is_set_query_access_key;
	int query_access_key; /* bool */
        /*
         * By default or if set to true, the name of the API is displayed.
         */
        int is_set_query_api_name;
	int query_api_name; /* bool */
        /*
         * By default or if set to true, the version of the API is displayed.
         */
        int is_set_query_api_version;
	int query_api_version; /* bool */
        /*
         * By default or if set to true, the name of the call is displayed.
         */
        int is_set_query_call_name;
	int query_call_name; /* bool */
        /*
         * By default or if set to true, the date of the call is displayed.
         */
        int is_set_query_date;
	int query_date; /* bool */
        /*
         * By default or if set to true, the raw header of the HTTP request is 
         * displayed.
         */
        int is_set_query_header_raw;
	int query_header_raw; /* bool */
        /*
         * By default or if set to true, the size of the raw header of the HTTP 
         * request is displayed.
         */
        int is_set_query_header_size;
	int query_header_size; /* bool */
        /*
         * By default or if set to true, the IP is displayed.
         */
        int is_set_query_ip_address;
	int query_ip_address; /* bool */
        /*
         * By default or if set to true, the raw payload of the HTTP request is 
         * displayed.
         */
        int is_set_query_payload_raw;
	int query_payload_raw; /* bool */
        /*
         * By default or if set to true, the size of the raw payload of the HTTP 
         * request is displayed.
         */
        int is_set_query_payload_size;
	int query_payload_size; /* bool */
        /*
         * By default or if set to true, the user agent of the HTTP request is 
         * displayed.
         */
        int is_set_query_user_agent;
	int query_user_agent; /* bool */
        /*
         * By default or if set to true, the request ID is displayed.
         */
        int is_set_request_id;
	int request_id; /* bool */
        /*
         * By default or if set to true, the size of the response is displayed.
         */
        int is_set_response_size;
	int response_size; /* bool */
        /*
         * By default or if set to true, the HTTP status code of the response is 
         * displayed.
         */
        int is_set_response_status_code;
	int response_status_code; /* bool */
};

struct osc_update_vpn_connection_arg  {
        /* Required: vpn_connection_id */
        /*
         * The ID of the client gateway.
         */
	char *client_gateway_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the virtual gateway.
         */
	char *virtual_gateway_id; /* string */
        /*
         * The ID of the VPN connection you want to modify.
         */
	char *vpn_connection_id; /* string */
        /*
         *   Information about the VPN options.
         *   -Phase2Options: ref Phase2OptionsToUpdate
         *       Information about Phase 2 of the Internet Key Exchange (IKE) 
         *       negotiation. 
         *       -PreSharedKey: string
         *         The pre-shared key to establish the initial authentication 
         *         between the client gateway and the virtual gateway. This key 
         *         can contain any character except line breaks and double 
         * quotes 
         *         (&quot;).
         *   -TunnelInsideIpRange: string
         *     The range of inside IPs for the tunnel. This must be a /30 
         *     CIDR block from the 169.254.254.0/24 range.
         */
        char *vpn_options_str;
        int is_set_vpn_options;
	struct vpn_options_to_update vpn_options; /* ref VpnOptionsToUpdate */
};

struct osc_update_volume_arg  {
        /* Required: volume_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * **Cold volume**: the new number of I/O operations per second (IOPS). 
         * This parameter can be specified only if you update an `io1` volume or 
         * if you change the type of the volume for an `io1`. This modification 
         * is instantaneous. <br />\n**Hot volume**: the new number of I/O 
         * operations per second (IOPS). This parameter can be specified only if 
         * you update an `io1` volume. This modification is not instantaneous. 
         * <br /><br />\nThe maximum number of IOPS allowed for `io1` volumes is 
         * `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
         */
        int is_set_iops;
	int iops; /* int */
        /*
         * **Cold volume**: the new size of the volume, in gibibytes (GiB). This 
         * value must be equal to or greater than the current size of the 
         * volume. This modification is not instantaneous. <br />\n**Hot 
         * volume**: you cannot change the size of a hot volume.
         */
        int is_set_size;
	int size; /* int */
        /*
         * The ID of the volume you want to update.
         */
	char *volume_id; /* string */
        /*
         * **Cold volume**: the new type of the volume (`standard` \\| `io1` \\| 
         * `gp2`). This modification is instantaneous. If you update to an `io1` 
         * volume, you must also specify the `Iops` parameter.<br />\n**Hot 
         * volume**: you cannot change the type of a hot volume.
         */
	char *volume_type; /* string */
};

struct osc_update_vm_template_arg  {
        /* Required: vm_template_id */
        /*
         * A new description for the VM template.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * New tags for your VM template.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the VM template you want to update.
         */
	char *vm_template_id; /* string */
        /*
         * A new name for your VM template.
         */
	char *vm_template_name; /* string */
};

struct osc_update_vm_group_arg  {
        /* Required: vm_group_id */
        /*
         * A new description for the VM group.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * New tags for your VM group.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The ID of the VM group you want to update.
         */
	char *vm_group_id; /* string */
        /*
         * A new name for your VM group.
         */
	char *vm_group_name; /* string */
        /*
         * A new VM template ID for your VM group.
         */
	char *vm_template_id; /* string */
};

struct osc_update_vm_arg  {
        /* Required: vm_id */
        /*
         * One or more block device mappings of the VM.
         *   Information about the block device mapping.
         *   -Bsu: ref BsuToUpdateVm
         *       Information about the BSU volume.
         *       -DeleteOnVmDeletion: bool
         *         If set to true, the volume is deleted when terminating the 
         * VM. 
         *         If set to false, the volume is not deleted when terminating 
         * the 
         *         VM.
         *       -VolumeId: string
         *         The ID of the volume.
         *   -DeviceName: string
         *     The device name for the volume. For a root device, you must 
         *     use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, 
         *     `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` 
         *     is a letter between `b` and `z`, and the second `X` is a letter 
         *     between `a` and `z`).
         *   -NoDevice: string
         *     Removes the device which is included in the block device 
         *     mapping of the OMI.
         *   -VirtualDeviceName: string
         *     The name of the virtual device (`ephemeralN`).
         */
        char *block_device_mappings_str;
        int nb_block_device_mappings;
	struct block_device_mapping_vm_update *block_device_mappings; /* array ref BlockDeviceMappingVmUpdate */
        /*
         * This parameter is not available. It is present in our API for the 
         * sake of historical compatibility with AWS.
         */
        int is_set_bsu_optimized;
	int bsu_optimized; /* bool */
        /*
         * If true, you cannot delete the VM unless you change this parameter 
         * back to false.
         */
        int is_set_deletion_protection;
	int deletion_protection; /* bool */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * (Net only) If true, the source/destination check is enabled. If 
         * false, it is disabled. This value must be false for a NAT VM to 
         * perform network address translation (NAT) in a Net.
         */
        int is_set_is_source_dest_checked;
	int is_source_dest_checked; /* bool */
        /*
         * The name of a keypair you want to associate with the VM.<br />\nWhen 
         * you replace the keypair of a VM with another one, the metadata of the 
         * VM is modified to reflect the new public key, but the replacement is 
         * still not effective in the operating system of the VM. To complete 
         * the replacement and effectively apply the new keypair, you need to 
         * perform other actions inside the VM. For more information, see 
         * [Modifying the Keypair of a 
         * VM](https://docs.outscale.com/en/userguide/Modifying-the-Keypair-of-a-
         * VM.html).
         */
	char *keypair_name; /* string */
        /*
         * (dedicated tenancy only) If true, nested virtualization is enabled. 
         * If false, it is disabled.
         */
        int is_set_nested_virtualization;
	int nested_virtualization; /* bool */
        /*
         * The performance of the VM (`medium` \\| `high` \\| `highest`).
         */
	char *performance; /* string */
        /*
         * One or more IDs of security groups for the VM.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The Base64-encoded MIME user data, limited to 500 kibibytes (KiB).
         */
	char *user_data; /* string */
        /*
         * The ID of the VM.
         */
	char *vm_id; /* string */
        /*
         * The VM behavior when you stop it. If set to `stop`, the VM stops. If 
         * set to `restart`, the VM stops then automatically restarts. If set to 
         * `terminate`, the VM stops and is terminated.
         */
	char *vm_initiated_shutdown_behavior; /* string */
        /*
         * The type of VM. For more information, see [VM 
         * Types](https://docs.outscale.com/en/userguide/VM-Types.html).
         */
	char *vm_type; /* string */
};

struct osc_update_user_arg  {
        /* Required: user_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * A new path for the EIM user.
         */
	char *new_path; /* string */
        /*
         * A new name for the EIM user.
         */
	char *new_user_name; /* string */
        /*
         * The name of the EIM user you want to modify.
         */
	char *user_name; /* string */
};

struct osc_update_subnet_arg  {
        /* Required: subnet_id, map_public_ip_on_launch */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * If true, a public IP is assigned to the network interface cards 
         * (NICs) created in the specified Subnet.
         */
        int is_set_map_public_ip_on_launch;
	int map_public_ip_on_launch; /* bool */
        /*
         * The ID of the Subnet.
         */
	char *subnet_id; /* string */
};

struct osc_update_snapshot_arg  {
        /* Required: snapshot_id, permissions_to_create_volume */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   Information about the permissions for the resource.<br 
         *   />\nSpecify either the `Additions` or the `Removals` parameter.
         *   -Additions: ref PermissionsOnResource
         *       Permissions for the resource.
         *       -AccountIds: array string
         *         One or more account IDs that the permission is associated 
         *         with.
         *       -GlobalPermission: bool
         *         A global permission for all accounts.<br />\n(Request) Set 
         *         this parameter to true to make the resource public (if the 
         *         parent parameter is `Additions`) or to make the resource 
         *         private (if the parent parameter is `Removals`).<br 
         *         />\n(Response) If true, the resource is public. If false, the 
         *         resource is private.
         *   -Removals: ref PermissionsOnResource
         *       Permissions for the resource.
         *       -AccountIds: array string
         *         One or more account IDs that the permission is associated 
         *         with.
         *       -GlobalPermission: bool
         *         A global permission for all accounts.<br />\n(Request) Set 
         *         this parameter to true to make the resource public (if the 
         *         parent parameter is `Additions`) or to make the resource 
         *         private (if the parent parameter is `Removals`).<br 
         *         />\n(Response) If true, the resource is public. If false, the 
         *         resource is private.
         */
        char *permissions_to_create_volume_str;
        int is_set_permissions_to_create_volume;
	struct permissions_on_resource_creation permissions_to_create_volume; /* ref PermissionsOnResourceCreation */
        /*
         * The ID of the snapshot.
         */
	char *snapshot_id; /* string */
};

struct osc_update_server_certificate_arg  {
        /* Required: name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the server certificate you want to modify.
         */
	char *name; /* string */
        /*
         * A new name for the server certificate.
         */
	char *new_name; /* string */
        /*
         * A new path for the server certificate.
         */
	char *new_path; /* string */
};

struct osc_update_route_table_link_arg  {
        /* Required: route_table_id, link_route_table_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the current route table link.
         */
	char *link_route_table_id; /* string */
        /*
         * The ID of the new route table to associate with the Subnet.
         */
	char *route_table_id; /* string */
};

struct osc_update_route_propagation_arg  {
        /* Required: enable, route_table_id, virtual_gateway_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * If true, a virtual gateway can propagate routes to a specified route 
         * table of a Net. If false, the propagation is disabled.
         */
        int is_set_enable;
	int enable; /* bool */
        /*
         * The ID of the route table.
         */
	char *route_table_id; /* string */
        /*
         * The ID of the virtual gateway.
         */
	char *virtual_gateway_id; /* string */
};

struct osc_update_route_arg  {
        /* Required: route_table_id, destination_ip_range */
        /*
         * The IP range used for the destination match, in CIDR notation (for 
         * example, `10.0.0.0/24`).
         */
	char *destination_ip_range; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of an Internet service or virtual gateway attached to your Net.
         */
	char *gateway_id; /* string */
        /*
         * The ID of a NAT service.
         */
	char *nat_service_id; /* string */
        /*
         * The ID of a Net peering.
         */
	char *net_peering_id; /* string */
        /*
         * The ID of a network interface card (NIC).
         */
	char *nic_id; /* string */
        /*
         * The ID of the route table.
         */
	char *route_table_id; /* string */
        /*
         * The ID of a NAT VM in your Net.
         */
	char *vm_id; /* string */
};

struct osc_update_nic_arg  {
        /* Required: nic_id */
        /*
         * A new description for the NIC.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   Information about the NIC attachment. If you are modifying the 
         *   `DeleteOnVmDeletion` attribute, you must specify the ID of the 
         *   NIC attachment.
         *   -DeleteOnVmDeletion: bool
         *     If true, the NIC is deleted when the VM is terminated. If 
         *     false, the NIC is detached from the VM.
         *   -LinkNicId: string
         *     The ID of the NIC attachment.
         */
        char *link_nic_str;
        int is_set_link_nic;
	struct link_nic_to_update link_nic; /* ref LinkNicToUpdate */
        /*
         * The ID of the NIC you want to modify.
         */
	char *nic_id; /* string */
        /*
         * One or more IDs of security groups for the NIC.<br />\nYou must 
         * specify at least one group, even if you use the default security 
         * group in the Net.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
};

struct osc_update_net_access_point_arg  {
        /* Required: net_access_point_id */
        /*
         * One or more IDs of route tables to associate with the specified Net 
         * access point.
         */
        char *add_route_table_ids_str;
	char **add_route_table_ids; /* array string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net access point.
         */
	char *net_access_point_id; /* string */
        /*
         * One or more IDs of route tables to disassociate from the specified 
         * Net access point.
         */
        char *remove_route_table_ids_str;
	char **remove_route_table_ids; /* array string */
};

struct osc_update_net_arg  {
        /* Required: dhcp_options_set_id, net_id */
        /*
         * The ID of the DHCP options set (or `default` if you want to associate 
         * the default one).
         */
	char *dhcp_options_set_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net.
         */
	char *net_id; /* string */
};

struct osc_update_load_balancer_arg  {
        /* Required: load_balancer_name */
        /*
         *   Information about access logs.
         *   -IsEnabled: bool
         *     If true, access logs are enabled for your load balancer. If 
         *     false, they are not. If you set this to true in your request, 
         *     the `OsuBucketName` parameter is required.
         *   -OsuBucketName: string
         *     The name of the OOS bucket for the access logs.
         *   -OsuBucketPrefix: string
         *     The path to the folder of the access logs in your OOS bucket 
         *     (by default, the `root` level of your bucket).
         *   -PublicationInterval: int
         *     The time interval for the publication of access logs in the 
         *     OOS bucket, in minutes. This value can be either `5` or `60` 
         *     (by default, `60`).
         */
        char *access_log_str;
        int is_set_access_log;
	struct access_log access_log; /* ref AccessLog */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   Information about the health check configuration.
         *   -CheckInterval: int
         *     The number of seconds between two requests (between `5` and 
         *     `600` both included).
         *   -HealthyThreshold: int
         *     The number of consecutive successful requests before 
         *     considering the VM as healthy (between `2` and `10` both 
         *     included).
         *   -Path: string
         *     If you use the HTTP or HTTPS protocols, the request URL path.
         *   -Port: int
         *     The port number (between `1` and `65535`, both included).
         *   -Protocol: string
         *     The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| 
         *     `TCP` \\| `SSL`).
         *   -Timeout: int
         *     The maximum waiting time for a response before considering the 
         *     VM as unhealthy, in seconds (between `2` and `60` both 
         *     included).
         *   -UnhealthyThreshold: int
         *     The number of consecutive failed requests before considering 
         *     the VM as unhealthy (between `2` and `10` both included).
         */
        char *health_check_str;
        int is_set_health_check;
	struct health_check health_check; /* ref HealthCheck */
        /*
         * The name of the load balancer.
         */
	char *load_balancer_name; /* string */
        /*
         * The port on which the load balancer is listening (between `1` and 
         * `65535`, both included). This parameter is required if you want to 
         * update the server certificate.
         */
        int is_set_load_balancer_port;
	int load_balancer_port; /* int */
        /*
         * The name of the policy you want to enable for the listener.
         */
        char *policy_names_str;
	char **policy_names; /* array string */
        /*
         * (internet-facing only) The public IP you want to associate with the 
         * load balancer. The former public IP of the load balancer is then 
         * disassociated. If you specify an empty string and the former public 
         * IP belonged to you, it is disassociated and replaced by a public IP 
         * owned by 3DS OUTSCALE.
         */
	char *public_ip; /* string */
        /*
         * If true, secure cookies are enabled for the load balancer.
         */
        int is_set_secured_cookies;
	int secured_cookies; /* bool */
        /*
         * (Net only) One or more IDs of security groups you want to assign to 
         * the load balancer. You need to specify the already assigned security 
         * groups that you want to keep along with the new ones you are 
         * assigning. If the list is empty, the default security group of the 
         * Net is assigned to the load balancer.
         */
        char *security_groups_str;
	char **security_groups; /* array string */
        /*
         * The Outscale Resource Name (ORN) of the server certificate. For more 
         * information, see [Resource Identifiers > Outscale Resource Names 
         * (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.ht
         * ml#_outscale_resource_names_orns). If this parameter is specified, 
         * you must also specify the `LoadBalancerPort` parameter.
         */
	char *server_certificate_id; /* string */
};

struct osc_update_listener_rule_arg  {
        /* Required: listener_rule_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * A host-name pattern for the rule, with a maximum length of 128 
         * characters. This host-name pattern supports maximum three wildcards, 
         * and must not contain any special characters except [-.?].
         */
	char *host_pattern; /* string */
        /*
         * The name of the listener rule.
         */
	char *listener_rule_name; /* string */
        /*
         * A path pattern for the rule, with a maximum length of 128 characters. 
         * This path pattern supports maximum three wildcards, and must not 
         * contain any special characters except [_-.$/~&quot;'@:+?].
         */
	char *path_pattern; /* string */
};

struct osc_update_image_arg  {
        /* Required: image_id, permissions_to_launch */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the OMI you want to modify.
         */
	char *image_id; /* string */
        /*
         *   Information about the permissions for the resource.<br 
         *   />\nSpecify either the `Additions` or the `Removals` parameter.
         *   -Additions: ref PermissionsOnResource
         *       Permissions for the resource.
         *       -AccountIds: array string
         *         One or more account IDs that the permission is associated 
         *         with.
         *       -GlobalPermission: bool
         *         A global permission for all accounts.<br />\n(Request) Set 
         *         this parameter to true to make the resource public (if the 
         *         parent parameter is `Additions`) or to make the resource 
         *         private (if the parent parameter is `Removals`).<br 
         *         />\n(Response) If true, the resource is public. If false, the 
         *         resource is private.
         *   -Removals: ref PermissionsOnResource
         *       Permissions for the resource.
         *       -AccountIds: array string
         *         One or more account IDs that the permission is associated 
         *         with.
         *       -GlobalPermission: bool
         *         A global permission for all accounts.<br />\n(Request) Set 
         *         this parameter to true to make the resource public (if the 
         *         parent parameter is `Additions`) or to make the resource 
         *         private (if the parent parameter is `Removals`).<br 
         *         />\n(Response) If true, the resource is public. If false, the 
         *         resource is private.
         */
        char *permissions_to_launch_str;
        int is_set_permissions_to_launch;
	struct permissions_on_resource_creation permissions_to_launch; /* ref PermissionsOnResourceCreation */
};

struct osc_update_flexible_gpu_arg  {
        /* Required: flexible_gpu_id */
        /*
         * If true, the fGPU is deleted when the VM is terminated.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the fGPU you want to modify.
         */
	char *flexible_gpu_id; /* string */
};

struct osc_update_direct_link_interface_arg  {
        /* Required: direct_link_interface_id, mtu */
        /*
         * The ID of the DirectLink interface you want to update.
         */
	char *direct_link_interface_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The maximum transmission unit (MTU) of the DirectLink interface, in 
         * bytes (always `1500`).
         */
        int is_set_mtu;
	int mtu; /* int */
};

struct osc_update_dedicated_group_arg  {
        /* Required: dedicated_group_id, name */
        /*
         * The ID of the dedicated group you want to update.
         */
	char *dedicated_group_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The new name of the dedicated group.
         */
	char *name; /* string */
};

struct osc_update_ca_arg  {
        /* Required: ca_id */
        /*
         * The ID of the CA.
         */
	char *ca_id; /* string */
        /*
         * The description of the CA.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_update_api_access_rule_arg  {
        /* Required: api_access_rule_id */
        /*
         * The ID of the API access rule you want to update.
         */
	char *api_access_rule_id; /* string */
        /*
         * One or more IDs of Client Certificate Authorities (CAs).
         */
        char *ca_ids_str;
	char **ca_ids; /* array string */
        /*
         * One or more Client Certificate Common Names (CNs).
         */
        char *cns_str;
	char **cns; /* array string */
        /*
         * A new description for the API access rule.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more IP addresses or CIDR blocks (for example, `192.0.2.0/16`).
         */
        char *ip_ranges_str;
	char **ip_ranges; /* array string */
};

struct osc_update_api_access_policy_arg  {
        /* Required: max_access_key_expiration_seconds, require_trusted_env */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The maximum possible lifetime for your access keys, in seconds 
         * (between `0` and `3153600000`, both included). If set to `O`, your 
         * access keys can have unlimited lifetimes, but a trusted session 
         * cannot be activated. Otherwise, all your access keys must have an 
         * expiration date. This value must be greater than the remaining 
         * lifetime of each access key of your account.
         */
        int is_set_max_access_key_expiration_seconds;
	int max_access_key_expiration_seconds; /* int */
        /*
         * If true, a trusted session is activated, provided that you specify 
         * the `MaxAccessKeyExpirationSeconds` parameter with a value greater 
         * than `0`.<br />\nEnabling this will require you and all your users to 
         * log in to Cockpit v2 using the WebAuthn method for multi-factor 
         * authentication. For more information, see [About Authentication > 
         * Multi-Factor 
         * Authentication](https://docs.outscale.com/en/userguide/About-Authentic
         * ation.html#_multi_factor_authentication).
         */
        int is_set_require_trusted_env;
	int require_trusted_env; /* bool */
};

struct osc_update_account_arg  {
        /* Required:none */
        /*
         * One or more additional email addresses for the account. These 
         * addresses are used for notifications only. If you already have a list 
         * of additional emails registered, you cannot add to it, only replace 
         * it. To remove all registered additional emails, specify an empty list.
         */
        char *additional_emails_str;
	char **additional_emails; /* array string */
        /*
         * The new city of the account owner.
         */
	char *city; /* string */
        /*
         * The new name of the company for the account.
         */
	char *company_name; /* string */
        /*
         * The new country of the account owner.
         */
	char *country; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The main email address for the account. This address is used for your 
         * credentials and notifications.
         */
	char *email; /* string */
        /*
         * The new first name of the account owner.
         */
	char *first_name; /* string */
        /*
         * The new job title of the account owner.
         */
	char *job_title; /* string */
        /*
         * The new last name of the account owner.
         */
	char *last_name; /* string */
        /*
         * The new mobile phone number of the account owner.
         */
	char *mobile_number; /* string */
        /*
         * The new landline phone number of the account owner.
         */
	char *phone_number; /* string */
        /*
         * The new state/province of the account owner.
         */
	char *state_province; /* string */
        /*
         * The new value added tax (VAT) number for the account.
         */
	char *vat_number; /* string */
        /*
         * The new ZIP code of the city.
         */
	char *zip_code; /* string */
};

struct osc_update_access_key_arg  {
        /* Required: access_key_id, state */
        /*
         * The ID of the access key.
         */
	char *access_key_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The date and time, or the date, at which you want the access key to 
         * expire, in ISO 8601 format (for example, `2020-06-14T00:00:00.000Z` 
         * or `2020-06-14`). If not specified, the access key is set to not 
         * expire.
         */
	char *expiration_date; /* string */
        /*
         * The new state for the access key (`ACTIVE` \\| `INACTIVE`). When set 
         * to `ACTIVE`, the access key is enabled and can be used to send 
         * requests. When set to `INACTIVE`, the access key is disabled.
         */
	char *state; /* string */
        /*
         * The name of the EIM user that the access key you want to modify is 
         * associated with. If you do not specify a user name, this action 
         * modifies the access key of the user who sends the request (which can 
         * be the root account).
         */
	char *user_name; /* string */
};

struct osc_unlink_volume_arg  {
        /* Required: volume_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * Forces the detachment of the volume in case of previous failure. 
         * Important: This action may damage your data or file systems.
         */
        int is_set_force_unlink;
	int force_unlink; /* bool */
        /*
         * The ID of the volume you want to detach.
         */
	char *volume_id; /* string */
};

struct osc_unlink_virtual_gateway_arg  {
        /* Required: net_id, virtual_gateway_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net from which you want to detach the virtual gateway.
         */
	char *net_id; /* string */
        /*
         * The ID of the virtual gateway.
         */
	char *virtual_gateway_id; /* string */
};

struct osc_unlink_route_table_arg  {
        /* Required: link_route_table_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the association between the route table and the Subnet.
         */
	char *link_route_table_id; /* string */
};

struct osc_unlink_public_ip_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID representing the association of the public IP with the VM or 
         * the NIC. This parameter is required unless you use the `PublicIp` 
         * parameter.
         */
	char *link_public_ip_id; /* string */
        /*
         * The public IP. This parameter is required unless you use the 
         * `LinkPublicIpId` parameter.
         */
	char *public_ip; /* string */
};

struct osc_unlink_private_ips_arg  {
        /* Required: nic_id, private_ips */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the NIC.
         */
	char *nic_id; /* string */
        /*
         * One or more secondary private IPs you want to unassign from the NIC.
         */
        char *private_ips_str;
	char **private_ips; /* array string */
};

struct osc_unlink_policy_arg  {
        /* Required: policy_orn, user_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
        /*
         * The name of the user you want to detach the policy from.
         */
	char *user_name; /* string */
};

struct osc_unlink_nic_arg  {
        /* Required: link_nic_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the attachment operation.
         */
	char *link_nic_id; /* string */
};

struct osc_unlink_load_balancer_backend_machines_arg  {
        /* Required: load_balancer_name */
        /*
         *  One or more public IPs of back-end VMs.
         */
        char *backend_ips_str;
	char **backend_ips; /* array string */
        /*
         *  One or more IDs of back-end VMs.
         */
        char *backend_vm_ids_str;
	char **backend_vm_ids; /* array string */
        /*
         *  If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *  The name of the load balancer.
         */
	char *load_balancer_name; /* string */
};

struct osc_unlink_internet_service_arg  {
        /* Required: internet_service_id, net_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Internet service you want to detach.
         */
	char *internet_service_id; /* string */
        /*
         * The ID of the Net from which you want to detach the Internet service.
         */
	char *net_id; /* string */
};

struct osc_unlink_flexible_gpu_arg  {
        /* Required: flexible_gpu_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the fGPU you want to detach from your VM.
         */
	char *flexible_gpu_id; /* string */
};

struct osc_stop_vms_arg  {
        /* Required: vm_ids */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * Forces the VM to stop.
         */
        int is_set_force_stop;
	int force_stop; /* bool */
        /*
         * One or more IDs of VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct osc_start_vms_arg  {
        /* Required: vm_ids */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more IDs of VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct osc_set_default_policy_version_arg  {
        /* Required: policy_orn, version_id */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
        /*
         * The ID of the version.
         */
	char *version_id; /* string */
};

struct osc_scale_up_vm_group_arg  {
        /* Required: vm_group_id, vm_addition */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The number of VMs you want to add to the VM group.
         */
        int is_set_vm_addition;
	int vm_addition; /* int */
        /*
         * The ID of the VM group you want to scale up.
         */
	char *vm_group_id; /* string */
};

struct osc_scale_down_vm_group_arg  {
        /* Required: vm_group_id, vm_subtraction */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the VM group you want to scale down.
         */
	char *vm_group_id; /* string */
        /*
         * The number of VMs you want to delete from the VM group.
         */
        int is_set_vm_subtraction;
	int vm_subtraction; /* int */
};

struct osc_reject_net_peering_arg  {
        /* Required: net_peering_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net peering you want to reject.
         */
	char *net_peering_id; /* string */
};

struct osc_register_vms_in_load_balancer_arg  {
        /* Required: backend_vm_ids, load_balancer_name */
        /*
         * One or more IDs of back-end VMs.<br />\nSpecifying the same ID 
         * several times has no effect as each back-end VM has equal weight.
         */
        char *backend_vm_ids_str;
	char **backend_vm_ids; /* array string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the load balancer.
         */
	char *load_balancer_name; /* string */
};

struct osc_reboot_vms_arg  {
        /* Required: vm_ids */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more IDs of the VMs you want to reboot.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct osc_read_vpn_connections_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -BgpAsns: array integer
         *     The Border Gateway Protocol (BGP) Autonomous System Numbers 
         *     (ASNs) of the connections.
         *   -ClientGatewayIds: array string
         *     The IDs of the client gateways.
         *   -ConnectionTypes: array string
         *     The types of the VPN connections (only `ipsec.1` is 
         *     supported).
         *   -RouteDestinationIpRanges: array string
         *     The destination IP ranges.
         *   -States: array string
         *     The states of the VPN connections (`pending` \\| `available` 
         *     \\| `deleting` \\| `deleted`).
         *   -StaticRoutesOnly: bool
         *     If false, the VPN connection uses dynamic routing with Border 
         *     Gateway Protocol (BGP). If true, routing is controlled using 
         *     static routes. For more information about how to create and 
         *     delete static routes, see 
         *     [CreateVpnConnectionRoute](#createvpnconnectionroute) and 
         *     [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
         *   -TagKeys: array string
         *     The keys of the tags associated with the VPN connections.
         *   -TagValues: array string
         *     The values of the tags associated with the VPN connections.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the VPN 
         *     connections, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -VirtualGatewayIds: array string
         *     The IDs of the virtual gateways.
         *   -VpnConnectionIds: array string
         *     The IDs of the VPN connections.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_vpn_connection filters; /* ref FiltersVpnConnection */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_volumes_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -CreationDates: array string
         *     The dates and times of creation of the volumes, in ISO 8601 
         *     date-time format (for example, `2020-06-30T00:00:00.000Z`).
         *   -LinkVolumeDeleteOnVmDeletion: bool
         *     Whether the volumes are deleted or not when terminating the 
         *     VMs.
         *   -LinkVolumeDeviceNames: array string
         *     The VM device names.
         *   -LinkVolumeLinkDates: array string
         *     The dates and times of creation of the volumes, in ISO 8601 
         *     date-time format (for example, `2020-06-30T00:00:00.000Z`).
         *   -LinkVolumeLinkStates: array string
         *     The attachment states of the volumes (`attaching` \\| 
         *     `detaching` \\| `attached` \\| `detached`).
         *   -LinkVolumeVmIds: array string
         *     One or more IDs of VMs.
         *   -SnapshotIds: array string
         *     The snapshots from which the volumes were created.
         *   -SubregionNames: array string
         *     The names of the Subregions in which the volumes were created.
         *   -TagKeys: array string
         *     The keys of the tags associated with the volumes.
         *   -TagValues: array string
         *     The values of the tags associated with the volumes.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     volumes, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -VolumeIds: array string
         *     The IDs of the volumes.
         *   -VolumeSizes: array integer
         *     The sizes of the volumes, in gibibytes (GiB).
         *   -VolumeStates: array string
         *     The states of the volumes (`creating` \\| `available` \\| 
         *     `in-use` \\| `updating` \\| `deleting` \\| `error`).
         *   -VolumeTypes: array string
         *     The types of the volumes (`standard` \\| `gp2` \\| `io1`).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_volume filters; /* ref FiltersVolume */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_vms_state_arg  {
        /* Required:none */
        /*
         * If true, includes the status of all VMs. By default or if set to 
         * false, only includes the status of running VMs.
         */
        int is_set_all_vms;
	int all_vms; /* bool */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -MaintenanceEventCodes: array string
         *     The code for the scheduled event (`system-reboot` \\| 
         *     `system-maintenance`).
         *   -MaintenanceEventDescriptions: array string
         *     The description of the scheduled event.
         *   -MaintenanceEventsNotAfter: array string
         *     The latest time the event can end.
         *   -MaintenanceEventsNotBefore: array string
         *     The earliest time the event can start.
         *   -SubregionNames: array string
         *     The names of the Subregions of the VMs.
         *   -VmIds: array string
         *     One or more IDs of VMs.
         *   -VmStates: array string
         *     The states of the VMs (`pending` \\| `running` \\| `stopping` 
         *     \\| `stopped` \\| `shutting-down` \\| `terminated` \\| 
         *     `quarantine`).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_vms_state filters; /* ref FiltersVmsState */
};

struct osc_read_vms_health_arg  {
        /* Required: load_balancer_name */
        /*
         * One or more IDs of back-end VMs.
         */
        char *backend_vm_ids_str;
	char **backend_vm_ids; /* array string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the load balancer.
         */
	char *load_balancer_name; /* string */
};

struct osc_read_vms_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -Architectures: array string
         *     The architectures of the VMs (`i386` \\| `x86_64`).
         *   -BlockDeviceMappingDeleteOnVmDeletion: bool
         *     Whether the BSU volumes are deleted when terminating the VMs.
         *   -BlockDeviceMappingDeviceNames: array string
         *     The device names for the BSU volumes (in the format 
         *     `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX`).
         *   -BlockDeviceMappingLinkDates: array string
         *     The link dates for the BSU volumes mapped to the VMs (for 
         *     example, `2016-01-23T18:45:30.000Z`).
         *   -BlockDeviceMappingStates: array string
         *     The states for the BSU volumes (`attaching` \\| `attached` \\| 
         *     `detaching` \\| `detached`).
         *   -BlockDeviceMappingVolumeIds: array string
         *     The volume IDs of the BSU volumes.
         *   -ClientTokens: array string
         *     The idempotency tokens provided when launching the VMs.
         *   -CreationDates: array string
         *     The dates when the VMs were launched.
         *   -ImageIds: array string
         *     The IDs of the OMIs used to launch the VMs.
         *   -IsSourceDestChecked: bool
         *     Whether the source/destination checking is enabled (true) or 
         *     disabled (false).
         *   -KeypairNames: array string
         *     The names of the keypairs used when launching the VMs.
         *   -LaunchNumbers: array integer
         *     The numbers for the VMs when launching a group of several VMs 
         *     (for example, `0`, `1`, `2`, and so on).
         *   -Lifecycles: array string
         *     Whether the VMs are Spot Instances (spot).
         *   -NetIds: array string
         *     The IDs of the Nets in which the VMs are running.
         *   -NicAccountIds: array string
         *     The IDs of the NICs.
         *   -NicDescriptions: array string
         *     The descriptions of the NICs.
         *   -NicIsSourceDestChecked: bool
         *     Whether the source/destination checking is enabled (true) or 
         *     disabled (false).
         *   -NicLinkNicDeleteOnVmDeletion: bool
         *     Whether the NICs are deleted when the VMs they are attached to 
         *     are deleted.
         *   -NicLinkNicDeviceNumbers: array integer
         *     The device numbers the NICs are attached to.
         *   -NicLinkNicLinkNicDates: array string
         *     The dates and time when the NICs were attached to the VMs.
         *   -NicLinkNicLinkNicIds: array string
         *     The IDs of the NIC attachments.
         *   -NicLinkNicStates: array string
         *     The states of the attachments.
         *   -NicLinkNicVmAccountIds: array string
         *     The account IDs of the owners of the VMs the NICs are attached 
         *     to.
         *   -NicLinkNicVmIds: array string
         *     The IDs of the VMs the NICs are attached to.
         *   -NicLinkPublicIpAccountIds: array string
         *     The account IDs of the owners of the public IPs associated 
         *     with the NICs.
         *   -NicLinkPublicIpLinkPublicIpIds: array string
         *     The association IDs returned when the public IPs were 
         *     associated with the NICs.
         *   -NicLinkPublicIpPublicIpIds: array string
         *     The allocation IDs returned when the public IPs were allocated 
         *     to their accounts.
         *   -NicLinkPublicIpPublicIps: array string
         *     The public IPs associated with the NICs.
         *   -NicMacAddresses: array string
         *     The Media Access Control (MAC) addresses of the NICs.
         *   -NicNetIds: array string
         *     The IDs of the Nets where the NICs are located.
         *   -NicNicIds: array string
         *     The IDs of the NICs.
         *   -NicPrivateIpsLinkPublicIpAccountIds: array string
         *     The account IDs of the owner of the public IPs associated with 
         *     the private IPs.
         *   -NicPrivateIpsLinkPublicIpIds: array string
         *     The public IPs associated with the private IPs.
         *   -NicPrivateIpsPrimaryIp: bool
         *     Whether the private IPs are the primary IPs associated with 
         *     the NICs.
         *   -NicPrivateIpsPrivateIps: array string
         *     The private IPs of the NICs.
         *   -NicSecurityGroupIds: array string
         *     The IDs of the security groups associated with the NICs.
         *   -NicSecurityGroupNames: array string
         *     The names of the security groups associated with the NICs.
         *   -NicStates: array string
         *     The states of the NICs (`available` \\| `in-use`).
         *   -NicSubnetIds: array string
         *     The IDs of the Subnets for the NICs.
         *   -NicSubregionNames: array string
         *     The Subregions where the NICs are located.
         *   -Platforms: array string
         *     The platforms. Use windows if you have Windows VMs. Otherwise, 
         *     leave this filter blank.
         *   -PrivateIps: array string
         *     The private IPs of the VMs.
         *   -ProductCodes: array string
         *     The product codes associated with the OMI used to create the 
         *     VMs.
         *   -PublicIps: array string
         *     The public IPs of the VMs.
         *   -ReservationIds: array string
         *     The IDs of the reservation of the VMs, created every time you 
         *     launch VMs. These reservation IDs can be associated with 
         *     several VMs when you lauch a group of VMs using the same launch 
         *     request.
         *   -RootDeviceNames: array string
         *     The names of the root devices for the VMs (for example, 
         *     `/dev/sda1`)
         *   -RootDeviceTypes: array string
         *     The root devices types used by the VMs (always `ebs`)
         *   -SecurityGroupIds: array string
         *     The IDs of the security groups for the VMs (only in the public 
         *     Cloud).
         *   -SecurityGroupNames: array string
         *     The names of the security groups for the VMs (only in the 
         *     public Cloud).
         *   -StateReasonCodes: array integer
         *     The reason codes for the state changes.
         *   -StateReasonMessages: array string
         *     The messages describing the state changes.
         *   -StateReasons: array string
         *     The reasons explaining the current states of the VMs. This 
         *     filter is like the `StateReasonCodes` one.
         *   -SubnetIds: array string
         *     The IDs of the Subnets for the VMs.
         *   -SubregionNames: array string
         *     The names of the Subregions of the VMs.
         *   -TagKeys: array string
         *     The keys of the tags associated with the VMs.
         *   -TagValues: array string
         *     The values of the tags associated with the VMs.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the VMs, 
         *     in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -Tenancies: array string
         *     The tenancies of the VMs (`dedicated` \\| `default` \\| 
         *     `host`).
         *   -VmIds: array string
         *     One or more IDs of VMs.
         *   -VmSecurityGroupIds: array string
         *     The IDs of the security groups for the VMs.
         *   -VmSecurityGroupNames: array string
         *     The names of the security group for the VMs.
         *   -VmStateCodes: array integer
         *     The state codes of the VMs: `-1` (quarantine), `0` (pending), 
         *     `16` (running), `32` (shutting-down), `48` (terminated), `64` 
         *     (stopping), and `80` (stopped).
         *   -VmStateNames: array string
         *     The state names of the VMs (`pending` \\| `running` \\| 
         *     `stopping` \\| `stopped` \\| `shutting-down` \\| `terminated` 
         *     \\| `quarantine`).
         *   -VmTypes: array string
         *     The VM types (for example, t2.micro). For more information, 
         *     see [VM 
         *     Types](https://docs.outscale.com/en/userguide/VM-Types.html).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_vm filters; /* ref FiltersVm */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_vm_types_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -BsuOptimized: bool
         *     This parameter is not available. It is present in our API for 
         *     the sake of historical compatibility with AWS.
         *   -EphemeralsTypes: array string
         *     The types of ephemeral storage disk.
         *   -Eths: array integer
         *     The number of Ethernet interfaces available.
         *   -Gpus: array integer
         *     The number of GPUs available.
         *   -MemorySizes: array double
         *     The amounts of memory, in gibibytes (GiB).
         *   -VcoreCounts: array integer
         *     The numbers of vCores.
         *   -VmTypeNames: array string
         *     The names of the VM types. For more information, see [VM 
         *     Types](https://docs.outscale.com/en/userguide/VM-Types.html).
         *   -VolumeCounts: array integer
         *     The maximum number of ephemeral storage disks.
         *   -VolumeSizes: array integer
         *     The size of one ephemeral storage disk, in gibibytes (GiB).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_vm_type filters; /* ref FiltersVmType */
};

struct osc_read_vm_templates_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -CpuCores: array integer
         *     The number of vCores.
         *   -CpuGenerations: array string
         *     The processor generations (for example, `v4`).
         *   -CpuPerformances: array string
         *     The performances of the VMs.
         *   -Descriptions: array string
         *     The descriptions of the VM templates.
         *   -ImageIds: array string
         *     The IDs of the OMIs.
         *   -KeypairNames: array string
         *     The names of the keypairs.
         *   -Rams: array integer
         *     The amount of RAM.
         *   -TagKeys: array string
         *     The keys of the tags associated with the VM templates.
         *   -TagValues: array string
         *     The values of the tags associated with the VM templates.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the VM 
         *     templates, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -VmTemplateIds: array string
         *     The IDs of the VM templates.
         *   -VmTemplateNames: array string
         *     The names of the VM templates.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_vm_template filters; /* ref FiltersVmTemplate */
};

struct osc_read_vm_groups_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -Descriptions: array string
         *     The descriptions of the VM groups.
         *   -SecurityGroupIds: array string
         *     The IDs of the security groups.
         *   -SubnetIds: array string
         *     The IDs of the Subnets.
         *   -TagKeys: array string
         *     The keys of the tags associated with the VM groups.
         *   -TagValues: array string
         *     The values of the tags associated with the VM groups.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the VMs, 
         *     in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -VmCounts: array integer
         *     The number of VMs in the VM group.
         *   -VmGroupIds: array string
         *     The IDs of the VM groups.
         *   -VmGroupNames: array string
         *     The names of the VM groups.
         *   -VmTemplateIds: array string
         *     The IDs of the VM templates.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_vm_group filters; /* ref FiltersVmGroup */
};

struct osc_read_virtual_gateways_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -ConnectionTypes: array string
         *     The types of the virtual gateways (only `ipsec.1` is 
         *     supported).
         *   -LinkNetIds: array string
         *     The IDs of the Nets the virtual gateways are attached to.
         *   -LinkStates: array string
         *     The current states of the attachments between the virtual 
         *     gateways and the Nets (`attaching` \\| `attached` \\| 
         *     `detaching` \\| `detached`).
         *   -States: array string
         *     The states of the virtual gateways (`pending` \\| `available` 
         *     \\| `deleting` \\| `deleted`).
         *   -TagKeys: array string
         *     The keys of the tags associated with the virtual gateways.
         *   -TagValues: array string
         *     The values of the tags associated with the virtual gateways.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     virtual gateways, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -VirtualGatewayIds: array string
         *     The IDs of the virtual gateways.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_virtual_gateway filters; /* ref FiltersVirtualGateway */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_users_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_tags_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -Keys: array string
         *     The keys of the tags that are assigned to the resources. You 
         *     can use this filter alongside the `Values` filter. In that 
         *     case, you filter the resources corresponding to each tag, 
         *     regardless of the other filter.
         *   -ResourceIds: array string
         *     The IDs of the resources with which the tags are associated.
         *   -ResourceTypes: array string
         *     The resource type (`vm` \\| `image` \\| `volume` \\| 
         *     `snapshot` \\| `public-ip` \\| `security-group` \\| 
         *     `route-table` \\| `nic` \\| `net` \\| `subnet` \\| 
         *     `net-peering` \\| `net-access-point` \\| `nat-service` \\| 
         *     `internet-service` \\| `client-gateway` \\| `virtual-gateway` 
         *     \\| `vpn-connection` \\| `dhcp-options` \\| `task`).
         *   -Values: array string
         *     The values of the tags that are assigned to the resources. You 
         *     can use this filter alongside the `TagKeys` filter. In that 
         *     case, you filter the resources corresponding to each tag, 
         *     regardless of the other filter.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_tag filters; /* ref FiltersTag */
};

struct osc_read_subregions_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -RegionNames: array string
         *     The names of the Regions containing the Subregions.
         *   -States: array string
         *     The states of the Subregions.
         *   -SubregionNames: array string
         *     The names of the Subregions.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_subregion filters; /* ref FiltersSubregion */
};

struct osc_read_subnets_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -AvailableIpsCounts: array integer
         *     The number of available IPs.
         *   -IpRanges: array string
         *     The IP ranges in the Subnets, in CIDR notation (for example, 
         *     `10.0.0.0/16`).
         *   -NetIds: array string
         *     The IDs of the Nets in which the Subnets are.
         *   -States: array string
         *     The states of the Subnets (`pending` \\| `available` \\| 
         *     `deleted`).
         *   -SubnetIds: array string
         *     The IDs of the Subnets.
         *   -SubregionNames: array string
         *     The names of the Subregions in which the Subnets are located.
         *   -TagKeys: array string
         *     The keys of the tags associated with the Subnets.
         *   -TagValues: array string
         *     The values of the tags associated with the Subnets.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     Subnets, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_subnet filters; /* ref FiltersSubnet */
};

struct osc_read_snapshots_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -AccountAliases: array string
         *     The account aliases of the owners of the snapshots.
         *   -AccountIds: array string
         *     The account IDs of the owners of the snapshots.
         *   -Descriptions: array string
         *     The descriptions of the snapshots.
         *   -FromCreationDate: string
         *     The beginning of the time period, in ISO 8601 date-time format 
         *     (for example, `2020-06-14T00:00:00.000Z`).
         *   -PermissionsToCreateVolumeAccountIds: array string
         *     The account IDs which have permissions to create volumes.
         *   -PermissionsToCreateVolumeGlobalPermission: bool
         *     If true, lists all public volumes. If false, lists all private 
         *     volumes.
         *   -Progresses: array integer
         *     The progresses of the snapshots, as a percentage.
         *   -SnapshotIds: array string
         *     The IDs of the snapshots.
         *   -States: array string
         *     The states of the snapshots (`in-queue` \\| `completed` \\| 
         *     `error`).
         *   -TagKeys: array string
         *     The keys of the tags associated with the snapshots.
         *   -TagValues: array string
         *     The values of the tags associated with the snapshots.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     snapshots, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -ToCreationDate: string
         *     The end of the time period, in ISO 8601 date-time format (for 
         *     example, `2020-06-30T00:00:00.000Z`).
         *   -VolumeIds: array string
         *     The IDs of the volumes used to create the snapshots.
         *   -VolumeSizes: array integer
         *     The sizes of the volumes used to create the snapshots, in 
         *     gibibytes (GiB).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_snapshot filters; /* ref FiltersSnapshot */
};

struct osc_read_snapshot_export_tasks_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -TaskIds: array string
         *     The IDs of the export tasks.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_export_task filters; /* ref FiltersExportTask */
};

struct osc_read_server_certificates_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -Paths: array string
         *     The paths to the server certificates.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_server_certificate filters; /* ref FiltersServerCertificate */
};

struct osc_read_security_groups_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -Descriptions: array string
         *     The descriptions of the security groups.
         *   -InboundRuleAccountIds: array string
         *     The account IDs that have been granted permissions.
         *   -InboundRuleFromPortRanges: array integer
         *     The beginnings of the port ranges for the TCP and UDP 
         *     protocols, or the ICMP type numbers.
         *   -InboundRuleIpRanges: array string
         *     The IP ranges that have been granted permissions, in CIDR 
         *     notation (for example, `10.0.0.0/24`).
         *   -InboundRuleProtocols: array string
         *     The IP protocols for the permissions (`tcp` \\| `udp` \\| 
         *     `icmp`, or a protocol number, or `-1` for all protocols).
         *   -InboundRuleSecurityGroupIds: array string
         *     The IDs of the security groups that have been granted 
         *     permissions.
         *   -InboundRuleSecurityGroupNames: array string
         *     The names of the security groups that have been granted 
         *     permissions.
         *   -InboundRuleToPortRanges: array integer
         *     The ends of the port ranges for the TCP and UDP protocols, or 
         *     the ICMP code numbers.
         *   -NetIds: array string
         *     The IDs of the Nets specified when the security groups were 
         *     created.
         *   -OutboundRuleAccountIds: array string
         *     The account IDs that have been granted permissions.
         *   -OutboundRuleFromPortRanges: array integer
         *     The beginnings of the port ranges for the TCP and UDP 
         *     protocols, or the ICMP type numbers.
         *   -OutboundRuleIpRanges: array string
         *     The IP ranges that have been granted permissions, in CIDR 
         *     notation (for example, `10.0.0.0/24`).
         *   -OutboundRuleProtocols: array string
         *     The IP protocols for the permissions (`tcp` \\| `udp` \\| 
         *     `icmp`, or a protocol number, or `-1` for all protocols).
         *   -OutboundRuleSecurityGroupIds: array string
         *     The IDs of the security groups that have been granted 
         *     permissions.
         *   -OutboundRuleSecurityGroupNames: array string
         *     The names of the security groups that have been granted 
         *     permissions.
         *   -OutboundRuleToPortRanges: array integer
         *     The ends of the port ranges for the TCP and UDP protocols, or 
         *     the ICMP code numbers.
         *   -SecurityGroupIds: array string
         *     The IDs of the security groups.
         *   -SecurityGroupNames: array string
         *     The names of the security groups.
         *   -TagKeys: array string
         *     The keys of the tags associated with the security groups.
         *   -TagValues: array string
         *     The values of the tags associated with the security groups.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     security groups, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_security_group filters; /* ref FiltersSecurityGroup */
};

struct osc_read_secret_access_key_arg  {
        /* Required: access_key_id */
        /*
         * The ID of the access key.
         */
	char *access_key_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_route_tables_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -LinkRouteTableIds: array string
         *     The IDs of the route tables involved in the associations.
         *   -LinkRouteTableLinkRouteTableIds: array string
         *     The IDs of the associations between the route tables and the 
         *     Subnets.
         *   -LinkRouteTableMain: bool
         *     If true, the route tables are the main ones for their Nets.
         *   -LinkSubnetIds: array string
         *     The IDs of the Subnets involved in the associations.
         *   -NetIds: array string
         *     The IDs of the Nets for the route tables.
         *   -RouteCreationMethods: array string
         *     The methods used to create a route.
         *   -RouteDestinationIpRanges: array string
         *     The IP ranges specified in routes in the tables.
         *   -RouteDestinationServiceIds: array string
         *     The service IDs specified in routes in the tables.
         *   -RouteGatewayIds: array string
         *     The IDs of the gateways specified in routes in the tables.
         *   -RouteNatServiceIds: array string
         *     The IDs of the NAT services specified in routes in the tables.
         *   -RouteNetPeeringIds: array string
         *     The IDs of the Net peerings specified in routes in the tables.
         *   -RouteStates: array string
         *     The states of routes in the route tables (always `active`).
         *   -RouteTableIds: array string
         *     The IDs of the route tables.
         *   -RouteVmIds: array string
         *     The IDs of the VMs specified in routes in the tables.
         *   -TagKeys: array string
         *     The keys of the tags associated with the route tables.
         *   -TagValues: array string
         *     The values of the tags associated with the route tables.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     route tables, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_route_table filters; /* ref FiltersRouteTable */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_regions_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_quotas_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -Collections: array string
         *     The group names of the quotas.
         *   -QuotaNames: array string
         *     The names of the quotas.
         *   -QuotaTypes: array string
         *     The resource IDs if these are resource-specific quotas, 
         *     `global` if they are not.
         *   -ShortDescriptions: array string
         *     The description of the quotas.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_quota filters; /* ref FiltersQuota */
};

struct osc_read_public_ips_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -LinkPublicIpIds: array string
         *     The IDs representing the associations of public IPs with VMs 
         *     or NICs.
         *   -NicAccountIds: array string
         *     The account IDs of the owners of the NICs.
         *   -NicIds: array string
         *     The IDs of the NICs.
         *   -Placements: array string
         *     Whether the public IPs are for use in the public Cloud or in a 
         *     Net.
         *   -PrivateIps: array string
         *     The private IPs associated with the public IPs.
         *   -PublicIpIds: array string
         *     The IDs of the public IPs.
         *   -PublicIps: array string
         *     The public IPs.
         *   -TagKeys: array string
         *     The keys of the tags associated with the public IPs.
         *   -TagValues: array string
         *     The values of the tags associated with the public IPs.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     public IPs, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -VmIds: array string
         *     The IDs of the VMs.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_public_ip filters; /* ref FiltersPublicIp */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_public_ip_ranges_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_public_catalog_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_product_types_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -ProductTypeIds: array string
         *     The IDs of the product types.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_product_type filters; /* ref FiltersProductType */
};

struct osc_read_policy_versions_arg  {
        /* Required: policy_orn */
        /*
         * The item starting the list of policies requested.
         */
        int is_set_first_item;
	int first_item; /* int */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
        /*
         * The maximum number of items that can be returned in a single response 
         * (by default, 100).
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_policy_version_arg  {
        /* Required: policy_orn, version_id */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
        /*
         * The ID of the policy version.
         */
	char *version_id; /* string */
};

struct osc_read_policy_arg  {
        /* Required: policy_orn */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
};

struct osc_read_policies_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -OnlyLinked: bool
         *     If set to true, lists only the policies attached to a user.
         *   -PathPrefix: string
         *     The path prefix you can use to filter the results, set to a 
         *     slash (`/`) by default.
         *   -Scope: string
         *     The scope to filter policies (`ALL` \\| `OWS` \\| `local`).
         */
        char *filters_str;
        int is_set_filters;
	struct read_policies_filters filters; /* ref ReadPoliciesFilters */
        /*
         * The item starting the list of policies requested.
         */
        int is_set_first_item;
	int first_item; /* int */
        /*
         * The maximum number of items that can be returned in a single response 
         * (by default, 100).
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_nics_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -Descriptions: array string
         *     The descriptions of the NICs.
         *   -IsSourceDestCheck: bool
         *     Whether the source/destination checking is enabled (true) or 
         *     disabled (false).
         *   -LinkNicDeleteOnVmDeletion: bool
         *     Whether the NICs are deleted when the VMs they are attached to 
         *     are terminated.
         *   -LinkNicDeviceNumbers: array integer
         *     The device numbers the NICs are attached to.
         *   -LinkNicLinkNicIds: array string
         *     The attachment IDs of the NICs.
         *   -LinkNicStates: array string
         *     The states of the attachments.
         *   -LinkNicVmAccountIds: array string
         *     The account IDs of the owners of the VMs the NICs are attached 
         *     to.
         *   -LinkNicVmIds: array string
         *     The IDs of the VMs the NICs are attached to.
         *   -LinkPublicIpAccountIds: array string
         *     The account IDs of the owners of the public IPs associated 
         *     with the NICs.
         *   -LinkPublicIpLinkPublicIpIds: array string
         *     The association IDs returned when the public IPs were 
         *     associated with the NICs.
         *   -LinkPublicIpPublicIpIds: array string
         *     The allocation IDs returned when the public IPs were allocated 
         *     to their accounts.
         *   -LinkPublicIpPublicIps: array string
         *     The public IPs associated with the NICs.
         *   -MacAddresses: array string
         *     The Media Access Control (MAC) addresses of the NICs.
         *   -NetIds: array string
         *     The IDs of the Nets where the NICs are located.
         *   -NicIds: array string
         *     The IDs of the NICs.
         *   -PrivateDnsNames: array string
         *     The private DNS names associated with the primary private IPs.
         *   -PrivateIpsLinkPublicIpAccountIds: array string
         *     The account IDs of the owner of the public IPs associated with 
         *     the private IPs.
         *   -PrivateIpsLinkPublicIpPublicIps: array string
         *     The public IPs associated with the private IPs.
         *   -PrivateIpsPrimaryIp: bool
         *     Whether the private IP is the primary IP associated with the 
         *     NIC.
         *   -PrivateIpsPrivateIps: array string
         *     The private IPs of the NICs.
         *   -SecurityGroupIds: array string
         *     The IDs of the security groups associated with the NICs.
         *   -SecurityGroupNames: array string
         *     The names of the security groups associated with the NICs.
         *   -States: array string
         *     The states of the NICs.
         *   -SubnetIds: array string
         *     The IDs of the Subnets for the NICs.
         *   -SubregionNames: array string
         *     The Subregions where the NICs are located.
         *   -TagKeys: array string
         *     The keys of the tags associated with the NICs.
         *   -TagValues: array string
         *     The values of the tags associated with the NICs.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     NICs, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_nic filters; /* ref FiltersNic */
};

struct osc_read_nets_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -DhcpOptionsSetIds: array string
         *     The IDs of the DHCP options sets.
         *   -IpRanges: array string
         *     The IP ranges for the Nets, in CIDR notation (for example, 
         *     `10.0.0.0/16`).
         *   -IsDefault: bool
         *     If true, the Net used is the default one.
         *   -NetIds: array string
         *     The IDs of the Nets.
         *   -States: array string
         *     The states of the Nets (`pending` \\| `available` \\| 
         *     `deleting`).
         *   -TagKeys: array string
         *     The keys of the tags associated with the Nets.
         *   -TagValues: array string
         *     The values of the tags associated with the Nets.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     Nets, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_net filters; /* ref FiltersNet */
};

struct osc_read_net_peerings_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -AccepterNetAccountIds: array string
         *     The account IDs of the owners of the peer Nets.
         *   -AccepterNetIpRanges: array string
         *     The IP ranges of the peer Nets, in CIDR notation (for example, 
         *     `10.0.0.0/24`).
         *   -AccepterNetNetIds: array string
         *     The IDs of the peer Nets.
         *   -ExpirationDates: array string
         *     The dates and times at which the Net peerings expire, in ISO 
         *     8601 date-time format (for example, 
         *     `2020-06-14T00:00:00.000Z`).
         *   -NetPeeringIds: array string
         *     The IDs of the Net peerings.
         *   -SourceNetAccountIds: array string
         *     The account IDs of the owners of the peer Nets.
         *   -SourceNetIpRanges: array string
         *     The IP ranges of the peer Nets.
         *   -SourceNetNetIds: array string
         *     The IDs of the peer Nets.
         *   -StateMessages: array string
         *     Additional information about the states of the Net peerings.
         *   -StateNames: array string
         *     The states of the Net peerings (`pending-acceptance` \\| 
         *     `active` \\| `rejected` \\| `failed` \\| `expired` \\| 
         *     `deleted`).
         *   -TagKeys: array string
         *     The keys of the tags associated with the Net peerings.
         *   -TagValues: array string
         *     The values of the tags associated with the Net peerings.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the Net 
         *     peerings, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_net_peering filters; /* ref FiltersNetPeering */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_net_access_points_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -NetAccessPointIds: array string
         *     The IDs of the Net access points.
         *   -NetIds: array string
         *     The IDs of the Nets.
         *   -ServiceNames: array string
         *     The names of the services. For more information, see 
         *     [ReadNetAccessPointServices](#readnetaccesspointservices).
         *   -States: array string
         *     The states of the Net access points (`pending` \\| `available` 
         *     \\| `deleting` \\| `deleted`).
         *   -TagKeys: array string
         *     The keys of the tags associated with the Net access points.
         *   -TagValues: array string
         *     The values of the tags associated with the Net access points.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the Net 
         *     access points, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_net_access_point filters; /* ref FiltersNetAccessPoint */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_net_access_point_services_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -ServiceIds: array string
         *     The IDs of the services.
         *   -ServiceNames: array string
         *     The names of the services.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_service filters; /* ref FiltersService */
};

struct osc_read_nat_services_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -NatServiceIds: array string
         *     The IDs of the NAT services.
         *   -NetIds: array string
         *     The IDs of the Nets in which the NAT services are.
         *   -States: array string
         *     The states of the NAT services (`pending` \\| `available` \\| 
         *     `deleting` \\| `deleted`).
         *   -SubnetIds: array string
         *     The IDs of the Subnets in which the NAT services are.
         *   -TagKeys: array string
         *     The keys of the tags associated with the NAT services.
         *   -TagValues: array string
         *     The values of the tags associated with the NAT services.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the NAT 
         *     services, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_nat_service filters; /* ref FiltersNatService */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_locations_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_load_balancers_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -LoadBalancerNames: array string
         *     The names of the load balancers.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_load_balancer filters; /* ref FiltersLoadBalancer */
};

struct osc_read_load_balancer_tags_arg  {
        /* Required: load_balancer_names */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more load balancer names.
         */
        char *load_balancer_names_str;
	char **load_balancer_names; /* array string */
};

struct osc_read_listener_rules_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -ListenerRuleNames: array string
         *     The names of the listener rules.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_listener_rule filters; /* ref FiltersListenerRule */
};

struct osc_read_linked_policies_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -PathPrefix: string
         *     The path prefix of the policies, set to a slash (`/`) by 
         *     default.
         */
        char *filters_str;
        int is_set_filters;
	struct read_linked_policies_filters filters; /* ref ReadLinkedPoliciesFilters */
        /*
         * The item starting the list of policies requested.
         */
        int is_set_first_item;
	int first_item; /* int */
        /*
         * The maximum number of items that can be returned in a single response 
         * (by default, 100).
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
        /*
         * The name of the user the policies are linked to.
         */
	char *user_name; /* string */
};

struct osc_read_keypairs_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -KeypairFingerprints: array string
         *     The fingerprints of the keypairs.
         *   -KeypairNames: array string
         *     The names of the keypairs.
         *   -KeypairTypes: array string
         *     The types of the keypairs (`ssh-rsa`, `ssh-ed25519`, 
         *     `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or 
         *     `ecdsa-sha2-nistp521`).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_keypair filters; /* ref FiltersKeypair */
};

struct osc_read_internet_services_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -InternetServiceIds: array string
         *     The IDs of the Internet services.
         *   -LinkNetIds: array string
         *     The IDs of the Nets the Internet services are attached to.
         *   -LinkStates: array string
         *     The current states of the attachments between the Internet 
         *     services and the Nets (only `available`, if the Internet 
         *     gateway is attached to a Net).
         *   -TagKeys: array string
         *     The keys of the tags associated with the Internet services.
         *   -TagValues: array string
         *     The values of the tags associated with the Internet services.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     Internet services, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_internet_service filters; /* ref FiltersInternetService */
};

struct osc_read_images_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -AccountAliases: array string
         *     The account aliases of the owners of the OMIs.
         *   -AccountIds: array string
         *     The account IDs of the owners of the OMIs. By default, all the 
         *     OMIs for which you have launch permissions are described.
         *   -Architectures: array string
         *     The architectures of the OMIs (`i386` \\| `x86_64`).
         *   -BlockDeviceMappingDeleteOnVmDeletion: bool
         *     Whether the volumes are deleted or not when terminating the 
         *     VM.
         *   -BlockDeviceMappingDeviceNames: array string
         *     The device names for the volumes.
         *   -BlockDeviceMappingSnapshotIds: array string
         *     The IDs of the snapshots used to create the volumes.
         *   -BlockDeviceMappingVolumeSizes: array integer
         *     The sizes of the volumes, in gibibytes (GiB).
         *   -BlockDeviceMappingVolumeTypes: array string
         *     The types of volumes (`standard` \\| `gp2` \\| `io1`).
         *   -Descriptions: array string
         *     The descriptions of the OMIs, provided when they were created.
         *   -FileLocations: array string
         *     The locations of the buckets where the OMI files are stored.
         *   -Hypervisors: array string
         *     The hypervisor type of the OMI (always `xen`).
         *   -ImageIds: array string
         *     The IDs of the OMIs.
         *   -ImageNames: array string
         *     The names of the OMIs, provided when they were created.
         *   -PermissionsToLaunchAccountIds: array string
         *     The account IDs which have launch permissions for the OMIs.
         *   -PermissionsToLaunchGlobalPermission: bool
         *     If true, lists all public OMIs. If false, lists all private 
         *     OMIs.
         *   -ProductCodeNames: array string
         *     The names of the product codes associated with the OMI.
         *   -ProductCodes: array string
         *     The product codes associated with the OMI.
         *   -RootDeviceNames: array string
         *     The name of the root device. This value must be /dev/sda1.
         *   -RootDeviceTypes: array string
         *     The types of root device used by the OMIs (`bsu` or `ebs`).
         *   -States: array string
         *     The states of the OMIs (`pending` \\| `available` \\| 
         *     `failed`).
         *   -TagKeys: array string
         *     The keys of the tags associated with the OMIs.
         *   -TagValues: array string
         *     The values of the tags associated with the OMIs.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     OMIs, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         *   -VirtualizationTypes: array string
         *     The virtualization types (always `hvm`).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_image filters; /* ref FiltersImage */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_image_export_tasks_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -TaskIds: array string
         *     The IDs of the export tasks.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_export_task filters; /* ref FiltersExportTask */
};

struct osc_read_flexible_gpus_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -DeleteOnVmDeletion: bool
         *     Indicates whether the fGPU is deleted when terminating the VM.
         *   -FlexibleGpuIds: array string
         *     One or more IDs of fGPUs.
         *   -Generations: array string
         *     The processor generations that the fGPUs are compatible with.
         *   -ModelNames: array string
         *     One or more models of fGPUs. For more information, see [About 
         *     Flexible 
         *     GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs
         *     .html).
         *   -States: array string
         *     The states of the fGPUs (`allocated` \\| `attaching` \\| 
         *     `attached` \\| `detaching`).
         *   -SubregionNames: array string
         *     The Subregions where the fGPUs are located.
         *   -VmIds: array string
         *     One or more IDs of VMs.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_flexible_gpu filters; /* ref FiltersFlexibleGpu */
};

struct osc_read_flexible_gpu_catalog_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_direct_links_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -DirectLinkIds: array string
         *     The IDs of the DirectLinks.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_direct_link filters; /* ref FiltersDirectLink */
};

struct osc_read_direct_link_interfaces_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -DirectLinkIds: array string
         *     The IDs of the DirectLinks.
         *   -DirectLinkInterfaceIds: array string
         *     The IDs of the DirectLink interfaces.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_direct_link_interface filters; /* ref FiltersDirectLinkInterface */
};

struct osc_read_dhcp_options_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -Default: bool
         *     If true, lists all default DHCP options set. If false, lists 
         *     all non-default DHCP options set.
         *   -DhcpOptionsSetIds: array string
         *     The IDs of the DHCP options sets.
         *   -DomainNameServers: array string
         *     The IPs of the domain name servers used for the DHCP options 
         *     sets.
         *   -DomainNames: array string
         *     The domain names used for the DHCP options sets.
         *   -LogServers: array string
         *     The IPs of the log servers used for the DHCP options sets.
         *   -NtpServers: array string
         *     The IPs of the Network Time Protocol (NTP) servers used for 
         *     the DHCP options sets.
         *   -TagKeys: array string
         *     The keys of the tags associated with the DHCP options sets.
         *   -TagValues: array string
         *     The values of the tags associated with the DHCP options sets.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the DHCP 
         *     options sets, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_dhcp_options filters; /* ref FiltersDhcpOptions */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
};

struct osc_read_dedicated_groups_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -CpuGenerations: array integer
         *     The processor generation for the VMs in the dedicated group 
         *     (for example, `4`).
         *   -DedicatedGroupIds: array string
         *     The IDs of the dedicated groups.
         *   -Names: array string
         *     The names of the dedicated groups.
         *   -SubregionNames: array string
         *     The names of the Subregions in which the dedicated groups are 
         *     located.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_dedicated_group filters; /* ref FiltersDedicatedGroup */
};

struct osc_read_consumption_account_arg  {
        /* Required: from_date, to_date */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The beginning of the time period, in ISO 8601 date format (for 
         * example, `2020-06-14`). The date-time format is also accepted, but 
         * only with a time set to midnight (for example, 
         * `2020-06-14T00:00:00.000Z`).
         */
	char *from_date; /* string */
        /*
         * By default or if false, returns only the consumption of the specific 
         * account that sends this request. If true, returns either the overall 
         * consumption of your paying account and all linked accounts (if the 
         * account that sends this request is a paying account) or returns 
         * nothing (if the account that sends this request is a linked account).
         */
        int is_set_overall;
	int overall; /* bool */
        /*
         * By default or if false, returns only the consumption of the specific 
         * account that sends this request. If true, returns the unit price of 
         * the consumed resource, and the total price of the consumed resource 
         * during the specified time period in the currency of the catalog of 
         * the Region where the API method was used.
         */
        int is_set_show_price;
	int show_price; /* bool */
        /*
         * The end of the time period, in ISO 8601 date format (for example, 
         * `2020-06-30`). The date-time format is also accepted, but only with a 
         * time set to midnight (for example, `2020-06-30T00:00:00.000Z`).
         */
	char *to_date; /* string */
};

struct osc_read_console_output_arg  {
        /* Required: vm_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the VM.
         */
	char *vm_id; /* string */
};

struct osc_read_client_gateways_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -BgpAsns: array integer
         *     The Border Gateway Protocol (BGP) Autonomous System Numbers 
         *     (ASNs) of the connections.
         *   -ClientGatewayIds: array string
         *     The IDs of the client gateways.
         *   -ConnectionTypes: array string
         *     The types of communication tunnels used by the client gateways 
         *     (only `ipsec.1` is supported).
         *   -PublicIps: array string
         *     The public IPv4 addresses of the client gateways.
         *   -States: array string
         *     The states of the client gateways (`pending` \\| `available` 
         *     \\| `deleting` \\| `deleted`).
         *   -TagKeys: array string
         *     The keys of the tags associated with the client gateways.
         *   -TagValues: array string
         *     The values of the tags associated with the client gateways.
         *   -Tags: array string
         *     The key/value combination of the tags associated with the 
         *     client gateways, in the following format: 
         *     &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quo
         *     t;]}.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_client_gateway filters; /* ref FiltersClientGateway */
};

struct osc_read_catalogs_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -CurrentCatalogOnly: bool
         *     By default or if set to true, only returns the current 
         *     catalog. If false, returns the current catalog and past 
         *     catalogs.
         *   -FromDate: string
         *     The beginning of the time period, in ISO 8601 date format (for 
         *     example, `2020-06-14`). This date cannot be older than 3 years. 
         *     You must specify the parameters `FromDate` and `ToDate` 
         *     together.
         *   -ToDate: string
         *     The end of the time period, in ISO 8601 date format (for 
         *     example, `2020-06-30`). You must specify the parameters 
         *     `FromDate` and `ToDate` together.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_catalogs filters; /* ref FiltersCatalogs */
};

struct osc_read_catalog_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_cas_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -CaFingerprints: array string
         *     The fingerprints of the CAs.
         *   -CaIds: array string
         *     The IDs of the CAs.
         *   -Descriptions: array string
         *     The descriptions of the CAs.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_ca filters; /* ref FiltersCa */
};

struct osc_read_api_logs_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -QueryAccessKeys: array string
         *     The access keys used for the logged calls.
         *   -QueryApiNames: array string
         *     The names of the APIs of the logged calls (always `oapi` for 
         *     the OUTSCALE API).
         *   -QueryCallNames: array string
         *     The names of the logged calls.
         *   -QueryDateAfter: string
         *     The date and time, or the date, after which you want to 
         *     retrieve logged calls, in ISO 8601 format (for example, 
         *     `2020-06-14T00:00:00.000Z` or `2020-06-14`). By default, this 
         *     date is set to 48 hours before the `QueryDateBefore` parameter 
         *     value.
         *   -QueryDateBefore: string
         *     The date and time, or the date, before which you want to 
         *     retrieve logged calls, in ISO 8601 format (for example, 
         *     `2020-06-30T00:00:00.000Z` or `2020-06-14`). By default, this 
         *     date is set to now, or 48 hours after the `QueryDateAfter` 
         *     parameter value.
         *   -QueryIpAddresses: array string
         *     The IPs used for the logged calls.
         *   -QueryUserAgents: array string
         *     The user agents of the HTTP requests of the logged calls.
         *   -RequestIds: array string
         *     The request IDs provided in the responses of the logged calls.
         *   -ResponseStatusCodes: array integer
         *     The HTTP status codes of the logged calls.
         */
        char *filters_str;
        int is_set_filters;
	struct filters_api_log filters; /* ref FiltersApiLog */
        /*
         * The token to request the next page of results. Each token refers to a 
         * specific page.
         */
	char *next_page_token; /* string */
        /*
         * The maximum number of logs returned in a single response (between 
         * `1`and `1000`, both included). By default, `100`.
         */
        int is_set_results_per_page;
	int results_per_page; /* int */
        /*
         *   The information to display in each returned log.
         *   -AccountId: bool
         *     By default or if set to true, the account ID is displayed.
         *   -CallDuration: bool
         *     By default or if set to true, the duration of the call is 
         *     displayed.
         *   -QueryAccessKey: bool
         *     By default or if set to true, the access key is displayed.
         *   -QueryApiName: bool
         *     By default or if set to true, the name of the API is 
         *     displayed.
         *   -QueryApiVersion: bool
         *     By default or if set to true, the version of the API is 
         *     displayed.
         *   -QueryCallName: bool
         *     By default or if set to true, the name of the call is 
         *     displayed.
         *   -QueryDate: bool
         *     By default or if set to true, the date of the call is 
         *     displayed.
         *   -QueryHeaderRaw: bool
         *     By default or if set to true, the raw header of the HTTP 
         *     request is displayed.
         *   -QueryHeaderSize: bool
         *     By default or if set to true, the size of the raw header of 
         *     the HTTP request is displayed.
         *   -QueryIpAddress: bool
         *     By default or if set to true, the IP is displayed.
         *   -QueryPayloadRaw: bool
         *     By default or if set to true, the raw payload of the HTTP 
         *     request is displayed.
         *   -QueryPayloadSize: bool
         *     By default or if set to true, the size of the raw payload of 
         *     the HTTP request is displayed.
         *   -QueryUserAgent: bool
         *     By default or if set to true, the user agent of the HTTP 
         *     request is displayed.
         *   -RequestId: bool
         *     By default or if set to true, the request ID is displayed.
         *   -ResponseSize: bool
         *     By default or if set to true, the size of the response is 
         *     displayed.
         *   -ResponseStatusCode: bool
         *     By default or if set to true, the HTTP status code of the 
         *     response is displayed.
         */
        char *with_str;
        int is_set_with;
	struct with with; /* ref With */
};

struct osc_read_api_access_rules_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -ApiAccessRuleIds: array string
         *     One or more IDs of API access rules.
         *   -CaIds: array string
         *     One or more IDs of Client Certificate Authorities (CAs).
         *   -Cns: array string
         *     One or more Client Certificate Common Names (CNs).
         *   -Descriptions: array string
         *     One or more descriptions of API access rules.
         *   -IpRanges: array string
         *     One or more IP addresses or CIDR blocks (for example, 
         *     `192.0.2.0/16`).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_api_access_rule filters; /* ref FiltersApiAccessRule */
};

struct osc_read_api_access_policy_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_admin_password_arg  {
        /* Required: vm_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the VM.
         */
	char *vm_id; /* string */
};

struct osc_read_accounts_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_read_access_keys_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   One or more filters.
         *   -AccessKeyIds: array string
         *     The IDs of the access keys.
         *   -States: array string
         *     The states of the access keys (`ACTIVE` \\| `INACTIVE`).
         */
        char *filters_str;
        int is_set_filters;
	struct filters_access_keys filters; /* ref FiltersAccessKeys */
        /*
         * The name of the EIM user. By default, the user who sends the request 
         * (which can be the root account).
         */
	char *user_name; /* string */
};

struct osc_link_volume_arg  {
        /* Required: device_name, vm_id, volume_id */
        /*
         * The name of the device. For a root device, you must use `/dev/sda1`. 
         * For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, 
         * or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, 
         * and the second `X` is a letter between `a` and `z`).
         */
	char *device_name; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the VM you want to attach the volume to.
         */
	char *vm_id; /* string */
        /*
         * The ID of the volume you want to attach.
         */
	char *volume_id; /* string */
};

struct osc_link_virtual_gateway_arg  {
        /* Required: net_id, virtual_gateway_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net to which you want to attach the virtual gateway.
         */
	char *net_id; /* string */
        /*
         * The ID of the virtual gateway.
         */
	char *virtual_gateway_id; /* string */
};

struct osc_link_route_table_arg  {
        /* Required: route_table_id, subnet_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the route table.
         */
	char *route_table_id; /* string */
        /*
         * The ID of the Subnet.
         */
	char *subnet_id; /* string */
};

struct osc_link_public_ip_arg  {
        /* Required:none */
        /*
         * If true, allows the public IP to be associated with the VM or NIC 
         * that you specify even if it is already associated with another VM or 
         * NIC. If false, prevents the public IP from being associated with the 
         * VM or NIC that you specify if it is already associated with another 
         * VM or NIC. (By default, true in the public Cloud, false in a Net.)
         */
        int is_set_allow_relink;
	int allow_relink; /* bool */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * (Net only) The ID of the NIC. This parameter is required if the VM 
         * has more than one NIC attached. Otherwise, you need to specify the 
         * `VmId` parameter instead. You cannot specify both parameters at the 
         * same time.
         */
	char *nic_id; /* string */
        /*
         * (Net only) The primary or secondary private IP of the specified NIC. 
         * By default, the primary private IP.
         */
	char *private_ip; /* string */
        /*
         * The public IP. This parameter is required unless you use the 
         * `PublicIpId` parameter.
         */
	char *public_ip; /* string */
        /*
         * The allocation ID of the public IP. This parameter is required unless 
         * you use the `PublicIp` parameter.
         */
	char *public_ip_id; /* string */
        /*
         * The ID of the VM.<br />\n- In the public Cloud, this parameter is 
         * required.<br />\n- In a Net, this parameter is required if the VM has 
         * only one NIC. Otherwise, you need to specify the `NicId` parameter 
         * instead. You cannot specify both parameters at the same time.
         */
	char *vm_id; /* string */
};

struct osc_link_private_ips_arg  {
        /* Required: nic_id */
        /*
         * If true, allows an IP that is already assigned to another NIC in the 
         * same Subnet to be assigned to the NIC you specified.
         */
        int is_set_allow_relink;
	int allow_relink; /* bool */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the NIC.
         */
	char *nic_id; /* string */
        /*
         * The secondary private IP or IPs you want to assign to the NIC within 
         * the IP range of the Subnet.
         */
        char *private_ips_str;
	char **private_ips; /* array string */
        /*
         * The number of secondary private IPs to assign to the NIC.
         */
        int is_set_secondary_private_ip_count;
	int secondary_private_ip_count; /* int */
};

struct osc_link_policy_arg  {
        /* Required: policy_orn, user_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
        /*
         * The name of the user you want to link the policy to (between 1 and 64 
         * characters).
         */
	char *user_name; /* string */
};

struct osc_link_nic_arg  {
        /* Required: device_number, vm_id, nic_id */
        /*
         * The index of the VM device for the NIC attachment (between `1` and 
         * `7`, both included).
         */
        int is_set_device_number;
	int device_number; /* int */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the NIC you want to attach.
         */
	char *nic_id; /* string */
        /*
         * The ID of the VM to which you want to attach the NIC.
         */
	char *vm_id; /* string */
};

struct osc_link_load_balancer_backend_machines_arg  {
        /* Required: load_balancer_name */
        /*
         *  One or more public IPs of back-end VMs.
         */
        char *backend_ips_str;
	char **backend_ips; /* array string */
        /*
         *  One or more IDs of back-end VMs.
         */
        char *backend_vm_ids_str;
	char **backend_vm_ids; /* array string */
        /*
         *  If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *  The name of the load balancer. 
         */
	char *load_balancer_name; /* string */
};

struct osc_link_internet_service_arg  {
        /* Required: internet_service_id, net_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Internet service you want to attach.
         */
	char *internet_service_id; /* string */
        /*
         * The ID of the Net to which you want to attach the Internet service.
         */
	char *net_id; /* string */
};

struct osc_link_flexible_gpu_arg  {
        /* Required: flexible_gpu_id, vm_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the fGPU you want to attach.
         */
	char *flexible_gpu_id; /* string */
        /*
         * The ID of the VM you want to attach the fGPU to.
         */
	char *vm_id; /* string */
};

struct osc_deregister_vms_in_load_balancer_arg  {
        /* Required: backend_vm_ids, load_balancer_name */
        /*
         * One or more IDs of back-end VMs.
         */
        char *backend_vm_ids_str;
	char **backend_vm_ids; /* array string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the load balancer.
         */
	char *load_balancer_name; /* string */
};

struct osc_delete_vpn_connection_route_arg  {
        /* Required: destination_ip_range, vpn_connection_id */
        /*
         * The network prefix of the route to delete, in CIDR notation (for 
         * example, `10.12.0.0/16`).
         */
	char *destination_ip_range; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the target VPN connection of the static route to delete.
         */
	char *vpn_connection_id; /* string */
};

struct osc_delete_vpn_connection_arg  {
        /* Required: vpn_connection_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the VPN connection you want to delete.
         */
	char *vpn_connection_id; /* string */
};

struct osc_delete_volume_arg  {
        /* Required: volume_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the volume you want to delete.
         */
	char *volume_id; /* string */
};

struct osc_delete_vms_arg  {
        /* Required: vm_ids */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more IDs of VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct osc_delete_vm_template_arg  {
        /* Required: vm_template_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the VM template you want to delete. 
         */
	char *vm_template_id; /* string */
};

struct osc_delete_vm_group_arg  {
        /* Required: vm_group_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the VM group you want to delete.
         */
	char *vm_group_id; /* string */
};

struct osc_delete_virtual_gateway_arg  {
        /* Required: virtual_gateway_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the virtual gateway you want to delete.
         */
	char *virtual_gateway_id; /* string */
};

struct osc_delete_user_arg  {
        /* Required: user_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the EIM user you want to delete.
         */
	char *user_name; /* string */
};

struct osc_delete_tags_arg  {
        /* Required: resource_ids, tags */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more resource IDs.
         */
        char *resource_ids_str;
	char **resource_ids; /* array string */
        /*
         * One or more tags to delete (if you set a tag value, only the tags 
         * matching exactly this value are deleted).
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct osc_delete_subnet_arg  {
        /* Required: subnet_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Subnet you want to delete.
         */
	char *subnet_id; /* string */
};

struct osc_delete_snapshot_arg  {
        /* Required: snapshot_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the snapshot you want to delete.
         */
	char *snapshot_id; /* string */
};

struct osc_delete_server_certificate_arg  {
        /* Required: name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the server certificate you want to delete.
         */
	char *name; /* string */
};

struct osc_delete_security_group_rule_arg  {
        /* Required: security_group_id, flow */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The direction of the flow: `Inbound` or `Outbound`. You can specify 
         * `Outbound` for Nets only.
         */
	char *flow; /* string */
        /*
         * The beginning of the port range for the TCP and UDP protocols, or an 
         * ICMP type number.
         */
        int is_set_from_port_range;
	int from_port_range; /* int */
        /*
         * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all 
         * protocols). By default, `-1`. In a Net, this can also be an IP 
         * protocol number. For more information, see the [IANA.org 
         * website](https://www.iana.org/assignments/protocol-numbers/protocol-nu
         * mbers.xhtml).
         */
	char *ip_protocol; /* string */
        /*
         * The IP range for the security group rule, in CIDR notation (for 
         * example, `10.0.0.0/16`).
         */
	char *ip_range; /* string */
        /*
         * One or more rules you want to delete from the security group.
         *   Information about the security group rule.
         *   -FromPortRange: int
         *     The beginning of the port range for the TCP and UDP protocols, 
         *     or an ICMP type number.
         *   -IpProtocol: string
         *     The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all 
         *     protocols). By default, `-1`. In a Net, this can also be an IP 
         *     protocol number. For more information, see the [IANA.org 
         *     website](https://www.iana.org/assignments/protocol-numbers/proto
         *     col-numbers.xhtml).
         *   -IpRanges: array string
         *     One or more IP ranges for the security group rules, in CIDR 
         *     notation (for example, `10.0.0.0/16`).
         *   -SecurityGroupsMembers: array ref SecurityGroupsMember
         *     Information about one or more source or destination security 
         *     groups.
         *       Information about a source or destination security group.
         *       -AccountId: string
         *         The account ID that owns the source or destination security 
         *         group.
         *       -SecurityGroupId: string
         *         The ID of a source or destination security group that you 
         * want 
         *         to link to the security group of the rule.
         *       -SecurityGroupName: string
         *         (Public Cloud only) The name of a source or destination 
         *         security group that you want to link to the security group of 
         *         the rule.
         *   -ServiceIds: array string
         *     One or more service IDs to allow traffic from a Net to access 
         *     the corresponding OUTSCALE services. For more information, see 
         *     [ReadNetAccessPointServices](#readnetaccesspointservices).
         *   -ToPortRange: int
         *     The end of the port range for the TCP and UDP protocols, or an 
         *     ICMP code number.
         */
        char *rules_str;
        int nb_rules;
	struct security_group_rule *rules; /* array ref SecurityGroupRule */
        /*
         * The account ID of the owner of the security group you want to delete 
         * a rule from.
         */
	char *security_group_account_id_to_unlink; /* string */
        /*
         * The ID of the security group you want to delete a rule from.
         */
	char *security_group_id; /* string */
        /*
         * The ID of the source security group. If you are in the Public Cloud, 
         * you can also specify the name of the source security group.
         */
	char *security_group_name_to_unlink; /* string */
        /*
         * The end of the port range for the TCP and UDP protocols, or an ICMP 
         * code number.
         */
        int is_set_to_port_range;
	int to_port_range; /* int */
};

struct osc_delete_security_group_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the security group you want to delete.
         */
	char *security_group_id; /* string */
        /*
         * The name of the security group.
         */
	char *security_group_name; /* string */
};

struct osc_delete_route_table_arg  {
        /* Required: route_table_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the route table you want to delete.
         */
	char *route_table_id; /* string */
};

struct osc_delete_route_arg  {
        /* Required: route_table_id, destination_ip_range */
        /*
         * The exact IP range for the route.
         */
	char *destination_ip_range; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the route table from which you want to delete a route.
         */
	char *route_table_id; /* string */
};

struct osc_delete_public_ip_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The public IP. In the public Cloud, this parameter is required.
         */
	char *public_ip; /* string */
        /*
         * The ID representing the association of the public IP with the VM or 
         * the NIC. In a Net, this parameter is required.
         */
	char *public_ip_id; /* string */
};

struct osc_delete_policy_version_arg  {
        /* Required: policy_orn, version_id */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
        /*
         * The ID of the version of the policy you want to delete.
         */
	char *version_id; /* string */
};

struct osc_delete_policy_arg  {
        /* Required: policy_orn */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy you want to delete. 
         * For more information, see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
};

struct osc_delete_nic_arg  {
        /* Required: nic_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the NIC you want to delete.
         */
	char *nic_id; /* string */
};

struct osc_delete_net_peering_arg  {
        /* Required: net_peering_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net peering you want to delete.
         */
	char *net_peering_id; /* string */
};

struct osc_delete_net_access_point_arg  {
        /* Required: net_access_point_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net access point.
         */
	char *net_access_point_id; /* string */
};

struct osc_delete_net_arg  {
        /* Required: net_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net you want to delete.
         */
	char *net_id; /* string */
};

struct osc_delete_nat_service_arg  {
        /* Required: nat_service_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the NAT service you want to delete.
         */
	char *nat_service_id; /* string */
};

struct osc_delete_load_balancer_tags_arg  {
        /* Required: load_balancer_names, tags */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more load balancer names.
         */
        char *load_balancer_names_str;
	char **load_balancer_names; /* array string */
        /*
         * One or more tags to delete from the load balancers.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         */
        char *tags_str;
        int nb_tags;
	struct resource_load_balancer_tag *tags; /* array ref ResourceLoadBalancerTag */
};

struct osc_delete_load_balancer_policy_arg  {
        /* Required: load_balancer_name, policy_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the load balancer for which you want to delete a policy.
         */
	char *load_balancer_name; /* string */
        /*
         * The name of the policy you want to delete.
         */
	char *policy_name; /* string */
};

struct osc_delete_load_balancer_listeners_arg  {
        /* Required: load_balancer_name, load_balancer_ports */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the load balancer for which you want to delete listeners.
         */
	char *load_balancer_name; /* string */
        /*
         * One or more port numbers of the listeners you want to delete.
         */
        char *load_balancer_ports_str;
	int *load_balancer_ports; /* array integer */
};

struct osc_delete_load_balancer_arg  {
        /* Required: load_balancer_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the load balancer you want to delete.
         */
	char *load_balancer_name; /* string */
};

struct osc_delete_listener_rule_arg  {
        /* Required: listener_rule_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the rule you want to delete.
         */
	char *listener_rule_name; /* string */
};

struct osc_delete_keypair_arg  {
        /* Required: keypair_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the keypair you want to delete.
         */
	char *keypair_name; /* string */
};

struct osc_delete_internet_service_arg  {
        /* Required: internet_service_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Internet service you want to delete.
         */
	char *internet_service_id; /* string */
};

struct osc_delete_image_arg  {
        /* Required: image_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the OMI you want to delete.
         */
	char *image_id; /* string */
};

struct osc_delete_flexible_gpu_arg  {
        /* Required: flexible_gpu_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the fGPU you want to delete.
         */
	char *flexible_gpu_id; /* string */
};

struct osc_delete_export_task_arg  {
        /* Required: export_task_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the export task to delete.
         */
	char *export_task_id; /* string */
};

struct osc_delete_direct_link_interface_arg  {
        /* Required: direct_link_interface_id */
        /*
         * The ID of the DirectLink interface you want to delete.
         */
	char *direct_link_interface_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_delete_direct_link_arg  {
        /* Required: direct_link_id */
        /*
         * The ID of the DirectLink you want to delete.
         */
	char *direct_link_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_delete_dhcp_options_arg  {
        /* Required: dhcp_options_set_id */
        /*
         * The ID of the DHCP options set you want to delete.
         */
	char *dhcp_options_set_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_delete_dedicated_group_arg  {
        /* Required: dedicated_group_id */
        /*
         * The ID of the dedicated group you want to delete.
         */
	char *dedicated_group_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * If true, forces the deletion of the dedicated group and all its 
         * dependencies.
         */
        int is_set_force;
	int force; /* bool */
};

struct osc_delete_client_gateway_arg  {
        /* Required: client_gateway_id */
        /*
         * The ID of the client gateway you want to delete.
         */
	char *client_gateway_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_delete_ca_arg  {
        /* Required: ca_id */
        /*
         * The ID of the CA you want to delete.
         */
	char *ca_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_delete_api_access_rule_arg  {
        /* Required: api_access_rule_id */
        /*
         * The ID of the API access rule you want to delete.
         */
	char *api_access_rule_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_delete_access_key_arg  {
        /* Required: access_key_id */
        /*
         * The ID of the access key you want to delete.
         */
	char *access_key_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the EIM user the access key you want to delete is 
         * associated with. By default, the user who sends the request (which 
         * can be the root account).
         */
	char *user_name; /* string */
};

struct osc_create_vpn_connection_route_arg  {
        /* Required: destination_ip_range, vpn_connection_id */
        /*
         * The network prefix of the route, in CIDR notation (for example, 
         * `10.12.0.0/16`).
         */
	char *destination_ip_range; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the target VPN connection of the static route.
         */
	char *vpn_connection_id; /* string */
};

struct osc_create_vpn_connection_arg  {
        /* Required: client_gateway_id, connection_type, virtual_gateway_id */
        /*
         * The ID of the client gateway.
         */
	char *client_gateway_id; /* string */
        /*
         * The type of VPN connection (only `ipsec.1` is supported).
         */
	char *connection_type; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * By default or if false, the VPN connection uses dynamic routing with 
         * Border Gateway Protocol (BGP). If true, routing is controlled using 
         * static routes. For more information about how to create and delete 
         * static routes, see 
         * [CreateVpnConnectionRoute](#createvpnconnectionroute) and 
         * [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
         */
        int is_set_static_routes_only;
	int static_routes_only; /* bool */
        /*
         * The ID of the virtual gateway.
         */
	char *virtual_gateway_id; /* string */
};

struct osc_create_volume_arg  {
        /* Required: subregion_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The number of I/O operations per second (IOPS). This parameter must 
         * be specified only if you create an `io1` volume. The maximum number 
         * of IOPS allowed for `io1` volumes is `13000` with a maximum 
         * performance ratio of 300 IOPS per gibibyte.
         */
        int is_set_iops;
	int iops; /* int */
        /*
         * The size of the volume, in gibibytes (GiB). The maximum allowed size 
         * for a volume is 14901 GiB. This parameter is required if the volume 
         * is not created from a snapshot (`SnapshotId` unspecified). 
         */
        int is_set_size;
	int size; /* int */
        /*
         * The ID of the snapshot from which you want to create the volume.
         */
	char *snapshot_id; /* string */
        /*
         * The Subregion in which you want to create the volume.
         */
	char *subregion_name; /* string */
        /*
         * The type of volume you want to create (`io1` \\| `gp2` \\| 
         * `standard`). If not specified, a `standard` volume is created.<br 
         * />\nFor more information about volume types, see [About Volumes > 
         * Volume Types and 
         * IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volum
         * e_types_and_iops).
         */
	char *volume_type; /* string */
};

struct osc_create_vms_arg  {
        /* Required: image_id */
        /*
         * One or more block device mappings.
         *   Information about the block device mapping.
         *   -Bsu: ref BsuToCreate
         *       Information about the BSU volume to create.
         *       -DeleteOnVmDeletion: bool
         *         By default or if set to true, the volume is deleted when 
         *         terminating the VM. If false, the volume is not deleted when 
         *         terminating the VM.
         *       -Iops: int
         *         The number of I/O operations per second (IOPS). This 
         * parameter 
         *         must be specified only if you create an `io1` volume. The 
         *         maximum number of IOPS allowed for `io1` volumes is `13000` 
         *         with a maximum performance ratio of 300 IOPS per gibibyte.
         *       -SnapshotId: string
         *         The ID of the snapshot used to create the volume.
         *       -VolumeSize: int
         *         The size of the volume, in gibibytes (GiB).<br />\nIf you 
         *         specify a snapshot ID, the volume size must be at least equal 
         *         to the snapshot size.<br />\nIf you specify a snapshot ID but 
         *         no volume size, the volume is created with a size similar to 
         *         the snapshot one.
         *       -VolumeType: string
         *         The type of the volume (`standard` \\| `io1` \\| `gp2`). If 
         *         not specified in the request, a `standard` volume is 
         *         created.<br />\nFor more information about volume types, see 
         *         [About Volumes > Volume Types and 
         *         
         * IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#
         *         _volume_types_and_iops).
         *   -DeviceName: string
         *     The device name for the volume. For a root device, you must 
         *     use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, 
         *     `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` 
         *     is a letter between `b` and `z`, and the second `X` is a letter 
         *     between `a` and `z`).
         *   -NoDevice: string
         *     Removes the device which is included in the block device 
         *     mapping of the OMI.
         *   -VirtualDeviceName: string
         *     The name of the virtual device (`ephemeralN`).
         */
        char *block_device_mappings_str;
        int nb_block_device_mappings;
	struct block_device_mapping_vm_creation *block_device_mappings; /* array ref BlockDeviceMappingVmCreation */
        /*
         * By default or if true, the VM is started on creation. If false, the 
         * VM is stopped on creation.
         */
        int is_set_boot_on_creation;
	int boot_on_creation; /* bool */
        /*
         * This parameter is not available. It is present in our API for the 
         * sake of historical compatibility with AWS.
         */
        int is_set_bsu_optimized;
	int bsu_optimized; /* bool */
        /*
         * A unique identifier which enables you to manage the idempotency.
         */
	char *client_token; /* string */
        /*
         * If true, you cannot delete the VM unless you change this parameter 
         * back to false.
         */
        int is_set_deletion_protection;
	int deletion_protection; /* bool */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the OMI used to create the VM. You can find the list of 
         * OMIs by calling the [ReadImages](#readimages) method.
         */
	char *image_id; /* string */
        /*
         * The name of the keypair.
         */
	char *keypair_name; /* string */
        /*
         * The maximum number of VMs you want to create. If all the VMs cannot 
         * be created, the largest possible number of VMs above MinVmsCount is 
         * created.
         */
        int is_set_max_vms_count;
	int max_vms_count; /* int */
        /*
         * The minimum number of VMs you want to create. If this number of VMs 
         * cannot be created, no VMs are created.
         */
        int is_set_min_vms_count;
	int min_vms_count; /* int */
        /*
         * (dedicated tenancy only) If true, nested virtualization is enabled. 
         * If false, it is disabled.
         */
        int is_set_nested_virtualization;
	int nested_virtualization; /* bool */
        /*
         * One or more NICs. If you specify this parameter, you must not specify 
         * the `SubnetId` and `SubregionName` parameters. You also must define 
         * one NIC as the primary network interface of the VM with `0` as its 
         * device number.
         *   Information about the network interface card (NIC) when 
         *   creating a virtual machine (VM).
         *   -DeleteOnVmDeletion: bool
         *     If true, the NIC is deleted when the VM is terminated. You can 
         *     specify this parameter only for a new NIC. To modify this value 
         *     for an existing NIC, see [UpdateNic](#updatenic).
         *   -Description: string
         *     The description of the NIC, if you are creating a NIC when 
         *     creating the VM.
         *   -DeviceNumber: int
         *     The index of the VM device for the NIC attachment (between `0` 
         *     and `7`, both included). This parameter is required if you 
         *     create a NIC when creating the VM.
         *   -NicId: string
         *     The ID of the NIC, if you are attaching an existing NIC when 
         *     creating a VM.
         *   -PrivateIps: array ref PrivateIpLight
         *     One or more private IPs to assign to the NIC, if you create a 
         *     NIC when creating a VM. Only one private IP can be the primary 
         *     private IP.
         *       Information about the private IP.
         *       -IsPrimary: bool
         *         If true, the IP is the primary private IP of the NIC.
         *       -PrivateIp: string
         *         The private IP of the NIC.
         *   -SecondaryPrivateIpCount: int
         *     The number of secondary private IPs, if you create a NIC when 
         *     creating a VM. This parameter cannot be specified if you 
         *     specified more than one private IP in the `PrivateIps` 
         *     parameter.
         *   -SecurityGroupIds: array string
         *     One or more IDs of security groups for the NIC, if you create 
         *     a NIC when creating a VM.
         *   -SubnetId: string
         *     The ID of the Subnet for the NIC, if you create a NIC when 
         *     creating a VM. This parameter is required if you create a NIC 
         *     when creating the VM.
         */
        char *nics_str;
        int nb_nics;
	struct nic_for_vm_creation *nics; /* array ref NicForVmCreation */
        /*
         * The performance of the VM (`medium` \\| `high` \\| `highest`). By 
         * default, `high`. This parameter is ignored if you specify a 
         * performance flag directly in the `VmType` parameter.
         */
	char *performance; /* string */
        /*
         *   Information about the placement of the VM.
         *   -SubregionName: string
         *     The name of the Subregion. If you specify this parameter, you 
         *     must not specify the `Nics` parameter.
         *   -Tenancy: string
         *     The tenancy of the VM (`default`, `dedicated`, or a dedicated 
         *     group ID).
         */
        char *placement_str;
        int is_set_placement;
	struct placement placement; /* ref Placement */
        /*
         * One or more private IPs of the VM.
         */
        char *private_ips_str;
	char **private_ips; /* array string */
        /*
         * One or more IDs of security group for the VMs.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * One or more names of security groups for the VMs.
         */
        char *security_groups_str;
	char **security_groups; /* array string */
        /*
         * The ID of the Subnet in which you want to create the VM. If you 
         * specify this parameter, you must not specify the `Nics` parameter.
         */
	char *subnet_id; /* string */
        /*
         * Data or script used to add a specific configuration to the VM. It 
         * must be Base64-encoded and is limited to 500 kibibytes (KiB).
         */
	char *user_data; /* string */
        /*
         * The VM behavior when you stop it. By default or if set to `stop`, the 
         * VM stops. If set to `restart`, the VM stops then automatically 
         * restarts. If set to `terminate`, the VM stops and is terminated.
         */
	char *vm_initiated_shutdown_behavior; /* string */
        /*
         * The type of VM. You can specify a TINA type (in the `tinavW.cXrYpZ` 
         * or `tinavW.cXrY` format), or an AWS type (for example, `t2.small`, 
         * which is the default value).<br />\nIf you specify an AWS type, it is 
         * converted in the background to its corresponding TINA type, but the 
         * AWS type is still returned. If the specified or converted TINA type 
         * includes a performance flag, this performance flag is applied 
         * regardless of the value you may have provided in the `Performance` 
         * parameter. For more information, see [VM 
         * Types](https://docs.outscale.com/en/userguide/VM-Types.html).
         */
	char *vm_type; /* string */
};

struct osc_create_vm_template_arg  {
        /* Required: cpu_cores, cpu_generation, image_id, ram, vm_template_name */
        /*
         * The number of vCores to use for each VM.
         */
        int is_set_cpu_cores;
	int cpu_cores; /* int */
        /*
         * The processor generation to use for each VM (for example, `v4`).
         */
	char *cpu_generation; /* string */
        /*
         * The performance of the VMs (`medium` \\| `high` \\| `highest`). 
         */
	char *cpu_performance; /* string */
        /*
         * A description for the VM template.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the OMI to use for each VM. You can find a list of OMIs by 
         * calling the [ReadImages](#readimages) method.
         */
	char *image_id; /* string */
        /*
         * The name of the keypair to use for each VM.
         */
	char *keypair_name; /* string */
        /*
         * The amount of RAM to use for each VM.
         */
        int is_set_ram;
	int ram; /* int */
        /*
         * One or more tags to add to the VM template.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The name of the VM template.
         */
	char *vm_template_name; /* string */
};

struct osc_create_vm_group_arg  {
        /* Required: security_group_ids, subnet_id, vm_group_name, vm_template_id, vm_count */
        /*
         * A description for the VM group.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The positioning strategy of VMs on hypervisors. By default, or if set 
         * to `no-strategy` our orchestrator determines the most adequate 
         * position for your VMs. If set to `attract`, your VMs are deployed on 
         * the same hypervisor, which improves network performance. If set to 
         * `repulse`, your VMs are deployed on a different hypervisor, which 
         * improves fault tolerance.
         */
	char *positioning_strategy; /* string */
        /*
         * One or more IDs of security groups for the VM group.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The ID of the Subnet in which you want to create the VM group.
         */
	char *subnet_id; /* string */
        /*
         * One or more tags to add to the VM group.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
        /*
         * The number of VMs deployed in the VM group.
         */
        int is_set_vm_count;
	int vm_count; /* int */
        /*
         * The name of the VM group.
         */
	char *vm_group_name; /* string */
        /*
         * The ID of the VM template used to launch VMs in the VM group.
         */
	char *vm_template_id; /* string */
};

struct osc_create_virtual_gateway_arg  {
        /* Required: connection_type */
        /*
         * The type of VPN connection supported by the virtual gateway (only 
         * `ipsec.1` is supported).
         */
	char *connection_type; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_create_user_arg  {
        /* Required: user_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The path to the EIM user you want to create (by default, `/`). This 
         * path name must begin and end with a slash (/), and contain between 1 
         * and 512 alphanumeric characters and/or slashes (/), or underscores 
         * (_).
         */
	char *path; /* string */
        /*
         * The name of the EIM user you want to create. This user name must 
         * contain between 1 and 64 alphanumeric characters and/or pluses (+), 
         * equals (=), commas (,), periods (.), at signs (@), dashes (-), or 
         * underscores (_).
         */
	char *user_name; /* string */
};

struct osc_create_tags_arg  {
        /* Required: resource_ids, tags */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more resource IDs.
         */
        char *resource_ids_str;
	char **resource_ids; /* array string */
        /*
         * One or more tags to add to the specified resources.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct osc_create_subnet_arg  {
        /* Required: ip_range, net_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The IP range in the Subnet, in CIDR notation (for example, 
         * `10.0.0.0/16`).<br />\nThe IP range of the Subnet can be either the 
         * same as the Net one if you create only a single Subnet in this Net, 
         * or a subset of the Net one. In case of several Subnets in a Net, 
         * their IP ranges must not overlap. The smallest Subnet you can create 
         * uses a /29 netmask (eight IPs). For more information, see [About 
         * Nets](https://docs.outscale.com/en/userguide/About-Nets.html).
         */
	char *ip_range; /* string */
        /*
         * The ID of the Net for which you want to create a Subnet.
         */
	char *net_id; /* string */
        /*
         * The name of the Subregion in which you want to create the Subnet.
         */
	char *subregion_name; /* string */
};

struct osc_create_snapshot_export_task_arg  {
        /* Required: osu_export, snapshot_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   Information about the OOS export task to create.
         *   -DiskImageFormat: string
         *     The format of the export disk (`qcow2` \\| `raw`).
         *   -OsuApiKey: ref OsuApiKey
         *       Information about the OOS API key.
         *       -ApiKeyId: string
         *         The API key of the OOS account that enables you to access the 
         *         bucket.
         *       -SecretKey: string
         *         The secret key of the OOS account that enables you to access 
         *         the bucket.
         *   -OsuBucket: string
         *     The name of the OOS bucket where you want to export the 
         *     object.
         *   -OsuManifestUrl: string
         *     The URL of the manifest file.
         *   -OsuPrefix: string
         *     The prefix for the key of the OOS object.
         */
        char *osu_export_str;
        int is_set_osu_export;
	struct osu_export_to_create osu_export; /* ref OsuExportToCreate */
        /*
         * The ID of the snapshot to export.
         */
	char *snapshot_id; /* string */
};

struct osc_create_snapshot_arg  {
        /* Required:none */
        /*
         * A description for the snapshot.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * **(when importing from a bucket)** The pre-signed URL of the snapshot 
         * you want to import, or the normal URL of the snapshot if you have 
         * permission on the OOS bucket. For more information, see [Configuring 
         * a Pre-signed 
         * URL](https://docs.outscale.com/en/userguide/Configuring-a-Pre-signed-U
         * RL.html) or [Managing Access to Your Buckets and 
         * Objects](https://docs.outscale.com/en/userguide/Managing-Access-to-You
         * r-Buckets-and-Objects.html).
         */
	char *file_location; /* string */
        /*
         * **(when importing from a bucket)** The size of the snapshot you want 
         * to create in your account, in bytes. This size must be greater than 
         * or equal to the size of the original, uncompressed snapshot.
         */
        int is_set_snapshot_size;
	int snapshot_size; /* int */
        /*
         * **(when copying a snapshot)** The name of the source Region, which 
         * must be the same as the Region of your account.
         */
	char *source_region_name; /* string */
        /*
         * **(when copying a snapshot)** The ID of the snapshot you want to copy.
         */
	char *source_snapshot_id; /* string */
        /*
         * **(when creating from a volume)** The ID of the volume you want to 
         * create a snapshot of.
         */
	char *volume_id; /* string */
};

struct osc_create_server_certificate_arg  {
        /* Required: body, private_key, name */
        /*
         * The PEM-encoded X509 certificate.<br />With OSC CLI, use the 
         * following syntax to make sure your CA file is correctly parsed: 
         * `--CaPem=&quot;$(cat FILENAME)&quot;`.
         */
	char *body; /* string */
        /*
         * The PEM-encoded intermediate certification authorities.<br />With OSC 
         * CLI, use the following syntax to make sure your CA file is correctly 
         * parsed: `--CaPem=&quot;$(cat FILENAME)&quot;`.
         */
	char *chain; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * A unique name for the certificate. Constraints: 1-128 alphanumeric 
         * characters, pluses (+), equals (=), commas (,), periods (.), at signs 
         * (@), minuses (-), or underscores (_).
         */
	char *name; /* string */
        /*
         * The path to the server certificate, set to a slash (/) if not 
         * specified.
         */
	char *path; /* string */
        /*
         * The PEM-encoded private key matching the certificate.<br />With OSC 
         * CLI, use the following syntax to make sure your CA file is correctly 
         * parsed: `--CaPem=&quot;$(cat FILENAME)&quot;`.
         */
	char *private_key; /* string */
};

struct osc_create_security_group_rule_arg  {
        /* Required: security_group_id, flow */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The direction of the flow: `Inbound` or `Outbound`. You can specify 
         * `Outbound` for Nets only.
         */
	char *flow; /* string */
        /*
         * The beginning of the port range for the TCP and UDP protocols, or an 
         * ICMP type number. If you specify this parameter, you cannot specify 
         * the `Rules` parameter and its subparameters.
         */
        int is_set_from_port_range;
	int from_port_range; /* int */
        /*
         * The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all 
         * protocols). By default, `-1`. In a Net, this can also be an IP 
         * protocol number. For more information, see the [IANA.org 
         * website](https://www.iana.org/assignments/protocol-numbers/protocol-nu
         * mbers.xhtml). If you specify this parameter, you cannot specify the 
         * `Rules` parameter and its subparameters.
         */
	char *ip_protocol; /* string */
        /*
         * The IP range for the security group rule, in CIDR notation (for 
         * example, 10.0.0.0/16). If you specify this parameter, you cannot 
         * specify the `Rules` parameter and its subparameters.
         */
	char *ip_range; /* string */
        /*
         * Information about the security group rule to create. If you specify 
         * this parent parameter and its subparameters, you cannot specify the 
         * following parent parameters: `FromPortRange`, `IpProtocol`, 
         * `IpRange`, and `ToPortRange`.
         *   Information about the security group rule.
         *   -FromPortRange: int
         *     The beginning of the port range for the TCP and UDP protocols, 
         *     or an ICMP type number.
         *   -IpProtocol: string
         *     The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all 
         *     protocols). By default, `-1`. In a Net, this can also be an IP 
         *     protocol number. For more information, see the [IANA.org 
         *     website](https://www.iana.org/assignments/protocol-numbers/proto
         *     col-numbers.xhtml).
         *   -IpRanges: array string
         *     One or more IP ranges for the security group rules, in CIDR 
         *     notation (for example, `10.0.0.0/16`).
         *   -SecurityGroupsMembers: array ref SecurityGroupsMember
         *     Information about one or more source or destination security 
         *     groups.
         *       Information about a source or destination security group.
         *       -AccountId: string
         *         The account ID that owns the source or destination security 
         *         group.
         *       -SecurityGroupId: string
         *         The ID of a source or destination security group that you 
         * want 
         *         to link to the security group of the rule.
         *       -SecurityGroupName: string
         *         (Public Cloud only) The name of a source or destination 
         *         security group that you want to link to the security group of 
         *         the rule.
         *   -ServiceIds: array string
         *     One or more service IDs to allow traffic from a Net to access 
         *     the corresponding OUTSCALE services. For more information, see 
         *     [ReadNetAccessPointServices](#readnetaccesspointservices).
         *   -ToPortRange: int
         *     The end of the port range for the TCP and UDP protocols, or an 
         *     ICMP code number.
         */
        char *rules_str;
        int nb_rules;
	struct security_group_rule *rules; /* array ref SecurityGroupRule */
        /*
         * The account ID that owns the source or destination security group 
         * specified in the `SecurityGroupNameToLink` parameter.
         */
	char *security_group_account_id_to_link; /* string */
        /*
         * The ID of the security group for which you want to create a rule.
         */
	char *security_group_id; /* string */
        /*
         * The ID of a source or destination security group that you want to 
         * link to the security group of the rule.
         */
	char *security_group_name_to_link; /* string */
        /*
         * The end of the port range for the TCP and UDP protocols, or an ICMP 
         * code number. If you specify this parameter, you cannot specify the 
         * `Rules` parameter and its subparameters.
         */
        int is_set_to_port_range;
	int to_port_range; /* int */
};

struct osc_create_security_group_arg  {
        /* Required: description, security_group_name */
        /*
         * A description for the security group.<br />\nThis description can 
         * contain between 1 and 255 characters. Allowed characters are `a-z`, 
         * `A-Z`, `0-9`, accented letters, spaces, and `_.-:/()#,@[]+=&;{}!$*`.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net for the security group.
         */
	char *net_id; /* string */
        /*
         * The name of the security group.<br />\nThis name must not start with 
         * `sg-`.<br />\nThis name must be unique and contain between 1 and 255 
         * characters. Allowed characters are `a-z`, `A-Z`, `0-9`, spaces, and 
         * `_.-:/()#,@[]+=&;{}!$*`.
         */
	char *security_group_name; /* string */
};

struct osc_create_route_table_arg  {
        /* Required: net_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net for which you want to create a route table.
         */
	char *net_id; /* string */
};

struct osc_create_route_arg  {
        /* Required: destination_ip_range, route_table_id */
        /*
         * The IP range used for the destination match, in CIDR notation (for 
         * example, `10.0.0.0/24`).
         */
	char *destination_ip_range; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of an Internet service or virtual gateway attached to your Net.
         */
	char *gateway_id; /* string */
        /*
         * The ID of a NAT service.
         */
	char *nat_service_id; /* string */
        /*
         * The ID of a Net peering.
         */
	char *net_peering_id; /* string */
        /*
         * The ID of a NIC.
         */
	char *nic_id; /* string */
        /*
         * The ID of the route table for which you want to create a route.
         */
	char *route_table_id; /* string */
        /*
         * The ID of a NAT VM in your Net (attached to exactly one NIC).
         */
	char *vm_id; /* string */
};

struct osc_create_public_ip_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_create_product_type_arg  {
        /* Required: description */
        /*
         * The description of the product type.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The vendor of the product type.
         */
	char *vendor; /* string */
};

struct osc_create_policy_version_arg  {
        /* Required: document, policy_orn */
        /*
         * The policy document, corresponding to a JSON string that contains the 
         * policy. For more information, see [EIM Reference 
         * Information](https://docs.outscale.com/en/userguide/EIM-Reference-Info
         * rmation.html).
         */
	char *document; /* string */
        /*
         * The OUTSCALE Resource Name (ORN) of the policy. For more information, 
         * see [Resource 
         * Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifie
         * rs.html).
         */
	char *policy_orn; /* string */
        /*
         * If set to true, the new policy version is set as the default version 
         * and becomes the operative one.
         */
        int is_set_set_as_default;
	int set_as_default; /* bool */
};

struct osc_create_policy_arg  {
        /* Required: document, policy_name */
        /*
         * A description for the policy.
         */
	char *description; /* string */
        /*
         * The policy document, corresponding to a JSON string that contains the 
         * policy. For more information, see [EIM Reference 
         * Information](https://docs.outscale.com/en/userguide/EIM-Reference-Info
         * rmation.html).
         */
	char *document; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The path of the policy.
         */
	char *path; /* string */
        /*
         * The name of the policy.
         */
	char *policy_name; /* string */
};

struct osc_create_nic_arg  {
        /* Required: subnet_id */
        /*
         * A description for the NIC.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The primary private IP for the NIC.<br />\nThis IP must be within the 
         * IP range of the Subnet that you specify with the `SubnetId` 
         * attribute.<br />\nIf you do not specify this attribute, a random 
         * private IP is selected within the IP range of the Subnet.
         *   Information about the private IP.
         *   -IsPrimary: bool
         *     If true, the IP is the primary private IP of the NIC.
         *   -PrivateIp: string
         *     The private IP of the NIC.
         */
        char *private_ips_str;
        int nb_private_ips;
	struct private_ip_light *private_ips; /* array ref PrivateIpLight */
        /*
         * One or more IDs of security groups for the NIC.
         */
        char *security_group_ids_str;
	char **security_group_ids; /* array string */
        /*
         * The ID of the Subnet in which you want to create the NIC.
         */
	char *subnet_id; /* string */
};

struct osc_create_net_peering_arg  {
        /* Required: accepter_net_id, source_net_id */
        /*
         * The ID of the Net you want to connect with.
         */
	char *accepter_net_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net you send the peering request from.
         */
	char *source_net_id; /* string */
};

struct osc_create_net_access_point_arg  {
        /* Required: service_name, net_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net.
         */
	char *net_id; /* string */
        /*
         * One or more IDs of route tables to use for the connection.
         */
        char *route_table_ids_str;
	char **route_table_ids; /* array string */
        /*
         * The name of the service (in the format `com.outscale.region.service`).
         */
	char *service_name; /* string */
};

struct osc_create_net_arg  {
        /* Required: ip_range */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The IP range for the Net, in CIDR notation (for example, 
         * `10.0.0.0/16`).
         */
	char *ip_range; /* string */
        /*
         * The tenancy options for the VMs:<br />\n- `default` if a VM created 
         * in a Net can be launched with any tenancy.<br />\n- `dedicated` if it 
         * can be launched with dedicated tenancy VMs running on single-tenant 
         * hardware.<br />\n- `dedicated group ID`: if it can be launched in a 
         * dedicated group on single-tenant hardware.
         */
	char *tenancy; /* string */
};

struct osc_create_nat_service_arg  {
        /* Required: public_ip_id, subnet_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The allocation ID of the public IP to associate with the NAT 
         * service.<br />\nIf the public IP is already associated with another 
         * resource, you must first disassociate it.
         */
	char *public_ip_id; /* string */
        /*
         * The ID of the Subnet in which you want to create the NAT service.
         */
	char *subnet_id; /* string */
};

struct osc_create_load_balancer_tags_arg  {
        /* Required: load_balancer_names, tags */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more load balancer names.
         */
        char *load_balancer_names_str;
	char **load_balancer_names; /* array string */
        /*
         * One or more tags to add to the specified load balancers.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct osc_create_load_balancer_policy_arg  {
        /* Required: policy_type, load_balancer_name, policy_name */
        /*
         * The lifetime of the cookie, in seconds. If not specified, the default 
         * value of this parameter is `1`, which means that the sticky session 
         * lasts for the duration of the browser session.
         */
        int is_set_cookie_expiration_period;
	int cookie_expiration_period; /* int */
        /*
         * The name of the application cookie used for stickiness. This 
         * parameter is required if you create a stickiness policy based on an 
         * application-generated cookie.
         */
	char *cookie_name; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The name of the load balancer for which you want to create a policy.
         */
	char *load_balancer_name; /* string */
        /*
         * The name of the policy. This name must be unique and consist of 
         * alphanumeric characters and dashes (-).
         */
	char *policy_name; /* string */
        /*
         * The type of stickiness policy you want to create: `app` or 
         * `load_balancer`.
         */
	char *policy_type; /* string */
};

struct osc_create_load_balancer_listeners_arg  {
        /* Required: listeners, load_balancer_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more listeners for the load balancer.
         *   Information about the listener to create.
         *   -BackendPort: int
         *     The port on which the back-end VM is listening (between `1` 
         *     and `65535`, both included).
         *   -BackendProtocol: string
         *     The protocol for routing traffic to back-end VMs (`HTTP` \\| 
         *     `HTTPS` \\| `TCP` \\| `SSL`).
         *   -LoadBalancerPort: int
         *     The port on which the load balancer is listening (between `1` 
         *     and `65535`, both included).
         *   -LoadBalancerProtocol: string
         *     The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
         *   -ServerCertificateId: string
         *     The OUTSCALE Resource Name (ORN) of the server certificate. 
         *     For more information, see [Resource Identifiers > OUTSCALE 
         *     Resource Names 
         *     (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifi
         *     ers.html#_outscale_resource_names_orns).
         */
        char *listeners_str;
        int nb_listeners;
	struct listener_for_creation *listeners; /* array ref ListenerForCreation */
        /*
         * The name of the load balancer for which you want to create listeners.
         */
	char *load_balancer_name; /* string */
};

struct osc_create_load_balancer_arg  {
        /* Required: listeners, load_balancer_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more listeners to create.
         *   Information about the listener to create.
         *   -BackendPort: int
         *     The port on which the back-end VM is listening (between `1` 
         *     and `65535`, both included).
         *   -BackendProtocol: string
         *     The protocol for routing traffic to back-end VMs (`HTTP` \\| 
         *     `HTTPS` \\| `TCP` \\| `SSL`).
         *   -LoadBalancerPort: int
         *     The port on which the load balancer is listening (between `1` 
         *     and `65535`, both included).
         *   -LoadBalancerProtocol: string
         *     The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).
         *   -ServerCertificateId: string
         *     The OUTSCALE Resource Name (ORN) of the server certificate. 
         *     For more information, see [Resource Identifiers > OUTSCALE 
         *     Resource Names 
         *     (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifi
         *     ers.html#_outscale_resource_names_orns).
         */
        char *listeners_str;
        int nb_listeners;
	struct listener_for_creation *listeners; /* array ref ListenerForCreation */
        /*
         * The unique name of the load balancer (32 alphanumeric or hyphen 
         * characters maximum, but cannot start or end with a hyphen).
         */
	char *load_balancer_name; /* string */
        /*
         * The type of load balancer: `internet-facing` or `internal`. Use this 
         * parameter only for load balancers in a Net.
         */
	char *load_balancer_type; /* string */
        /*
         * (internet-facing only) The public IP you want to associate with the 
         * load balancer. If not specified, a public IP owned by 3DS OUTSCALE is 
         * associated.
         */
	char *public_ip; /* string */
        /*
         * (Net only) One or more IDs of security groups you want to assign to 
         * the load balancer. If not specified, the default security group of 
         * the Net is assigned to the load balancer.
         */
        char *security_groups_str;
	char **security_groups; /* array string */
        /*
         * (Net only) The ID of the Subnet in which you want to create the load 
         * balancer. Regardless of this Subnet, the load balancer can distribute 
         * traffic to all Subnets. This parameter is required in a Net.
         */
        char *subnets_str;
	char **subnets; /* array string */
        /*
         * (public Cloud only) The Subregion in which you want to create the 
         * load balancer. Regardless of this Subregion, the load balancer can 
         * distribute traffic to all Subregions. This parameter is required in 
         * the public Cloud.
         */
        char *subregion_names_str;
	char **subregion_names; /* array string */
        /*
         * One or more tags assigned to the load balancer.
         *   Information about the tag.
         *   -Key: string
         *     The key of the tag, with a minimum of 1 character.
         *   -Value: string
         *     The value of the tag, between 0 and 255 characters.
         */
        char *tags_str;
        int nb_tags;
	struct resource_tag *tags; /* array ref ResourceTag */
};

struct osc_create_listener_rule_arg  {
        /* Required: vm_ids, listener, listener_rule */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         *   Information about the load balancer.
         *   -LoadBalancerName: string
         *     The name of the load balancer to which the listener is 
         *     attached.
         *   -LoadBalancerPort: int
         *     The port of load balancer on which the load balancer is 
         *     listening (between `1` and `65535` both included).
         */
        char *listener_str;
        int is_set_listener;
	struct load_balancer_light listener; /* ref LoadBalancerLight */
        /*
         *   Information about the listener rule.
         *   -Action: string
         *     The type of action for the rule (always `forward`).
         *   -HostNamePattern: string
         *     A host-name pattern for the rule, with a maximum length of 128 
         *     characters. This host-name pattern supports maximum three 
         *     wildcards, and must not contain any special characters except 
         *     [-.?]. 
         *   -ListenerRuleName: string
         *     A human-readable name for the listener rule.
         *   -PathPattern: string
         *     A path pattern for the rule, with a maximum length of 128 
         *     characters. This path pattern supports maximum three wildcards, 
         *     and must not contain any special characters except 
         *     [_-.$/~&quot;'@:+?].
         *   -Priority: int
         *     The priority level of the listener rule, between `1` and 
         *     `19999` both included. Each rule must have a unique priority 
         *     level. Otherwise, an error is returned.
         */
        char *listener_rule_str;
        int is_set_listener_rule;
	struct listener_rule_for_creation listener_rule; /* ref ListenerRuleForCreation */
        /*
         * The IDs of the backend VMs.
         */
        char *vm_ids_str;
	char **vm_ids; /* array string */
};

struct osc_create_keypair_arg  {
        /* Required: keypair_name */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * A unique name for the keypair, with a maximum length of 255 [ASCII 
         * printable 
         * characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).
         */
	char *keypair_name; /* string */
        /*
         * The public key to import in your account, if you are importing an 
         * existing keypair. This value must be Base64-encoded.
         */
	char *public_key; /* string */
};

struct osc_create_internet_service_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_create_image_export_task_arg  {
        /* Required: osu_export, image_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the OMI to export.
         */
	char *image_id; /* string */
        /*
         *   Information about the OOS export task to create.
         *   -DiskImageFormat: string
         *     The format of the export disk (`qcow2` \\| `raw`).
         *   -OsuApiKey: ref OsuApiKey
         *       Information about the OOS API key.
         *       -ApiKeyId: string
         *         The API key of the OOS account that enables you to access the 
         *         bucket.
         *       -SecretKey: string
         *         The secret key of the OOS account that enables you to access 
         *         the bucket.
         *   -OsuBucket: string
         *     The name of the OOS bucket where you want to export the 
         *     object.
         *   -OsuManifestUrl: string
         *     The URL of the manifest file.
         *   -OsuPrefix: string
         *     The prefix for the key of the OOS object.
         */
        char *osu_export_str;
        int is_set_osu_export;
	struct osu_export_to_create osu_export; /* ref OsuExportToCreate */
};

struct osc_create_image_arg  {
        /* Required:none */
        /*
         * **(when registering from a snapshot, or from a bucket without using a 
         * manifest file)** The architecture of the OMI (`i386` or `x84_64`).
         */
	char *architecture; /* string */
        /*
         * **(when registering from a snapshot, or from a bucket without using a 
         * manifest file)** One or more block device mappings.
         *   One or more parameters used to automatically set up volumes 
         *   when the VM is created.
         *   -Bsu: ref BsuToCreate
         *       Information about the BSU volume to create.
         *       -DeleteOnVmDeletion: bool
         *         By default or if set to true, the volume is deleted when 
         *         terminating the VM. If false, the volume is not deleted when 
         *         terminating the VM.
         *       -Iops: int
         *         The number of I/O operations per second (IOPS). This 
         * parameter 
         *         must be specified only if you create an `io1` volume. The 
         *         maximum number of IOPS allowed for `io1` volumes is `13000` 
         *         with a maximum performance ratio of 300 IOPS per gibibyte.
         *       -SnapshotId: string
         *         The ID of the snapshot used to create the volume.
         *       -VolumeSize: int
         *         The size of the volume, in gibibytes (GiB).<br />\nIf you 
         *         specify a snapshot ID, the volume size must be at least equal 
         *         to the snapshot size.<br />\nIf you specify a snapshot ID but 
         *         no volume size, the volume is created with a size similar to 
         *         the snapshot one.
         *       -VolumeType: string
         *         The type of the volume (`standard` \\| `io1` \\| `gp2`). If 
         *         not specified in the request, a `standard` volume is 
         *         created.<br />\nFor more information about volume types, see 
         *         [About Volumes > Volume Types and 
         *         
         * IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#
         *         _volume_types_and_iops).
         *   -DeviceName: string
         *     The device name for the volume. For a root device, you must 
         *     use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, 
         *     `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` 
         *     is a letter between `b` and `z`, and the second `X` is a letter 
         *     between `a` and `z`).
         *   -VirtualDeviceName: string
         *     The name of the virtual device (`ephemeralN`).
         */
        char *block_device_mappings_str;
        int nb_block_device_mappings;
	struct block_device_mapping_image *block_device_mappings; /* array ref BlockDeviceMappingImage */
        /*
         * A description for the new OMI.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * **(when registering from a bucket by using a manifest file)** The 
         * pre-signed URL of the manifest file for the OMI you want to register. 
         * For more information, see [Configuring a Pre-signed 
         * URL](https://docs.outscale.com/en/userguide/Configuring-a-Pre-signed-U
         * RL.html) or [Managing Access to Your Buckets and 
         * Objects](https://docs.outscale.com/en/userguide/Managing-Access-to-You
         * r-Buckets-and-Objects.html).<br />\nYou can also specify the normal 
         * URL of the OMI if you have permission on the OOS bucket, without 
         * using the manifest file, but in that case, you need to manually 
         * specify through the other parameters all the information that would 
         * otherwise be read from the manifest file.
         */
	char *file_location; /* string */
        /*
         * A unique name for the new OMI.<br />\nConstraints: 3-128 alphanumeric 
         * characters, underscores (`_`), spaces (` `), parentheses (`()`), 
         * slashes (`/`), periods (`.`), or dashes (`-`).
         */
	char *image_name; /* string */
        /*
         * **(when creating from a VM)** If false, the VM shuts down before 
         * creating the OMI and then reboots. If true, the VM does not.
         */
        int is_set_no_reboot;
	int no_reboot; /* bool */
        /*
         * The product codes associated with the OMI.
         */
        char *product_codes_str;
	char **product_codes; /* array string */
        /*
         * **(when registering from a snapshot, or from a bucket without using a 
         * manifest file)** The name of the root device for the new OMI.
         */
	char *root_device_name; /* string */
        /*
         * **(when copying an OMI)** The ID of the OMI you want to copy.
         */
	char *source_image_id; /* string */
        /*
         * **(when copying an OMI)** The name of the source Region (always the 
         * same as the Region of your account).
         */
	char *source_region_name; /* string */
        /*
         * **(when creating from a VM)** The ID of the VM from which you want to 
         * create the OMI.
         */
	char *vm_id; /* string */
};

struct osc_create_flexible_gpu_arg  {
        /* Required: model_name, subregion_name */
        /*
         * If true, the fGPU is deleted when the VM is terminated.
         */
        int is_set_delete_on_vm_deletion;
	int delete_on_vm_deletion; /* bool */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The processor generation that the fGPU must be compatible with. If 
         * not specified, the oldest possible processor generation is selected 
         * (as provided by [ReadFlexibleGpuCatalog](#readflexiblegpucatalog) for 
         * the specified model of fGPU).
         */
	char *generation; /* string */
        /*
         * The model of fGPU you want to allocate. For more information, see 
         * [About Flexible 
         * GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html)
         * .
         */
	char *model_name; /* string */
        /*
         * The Subregion in which you want to create the fGPU.
         */
	char *subregion_name; /* string */
};

struct osc_create_direct_link_interface_arg  {
        /* Required: direct_link_id, direct_link_interface */
        /*
         * The ID of the existing DirectLink for which you want to create the 
         * DirectLink interface.
         */
	char *direct_link_id; /* string */
        /*
         *   Information about the DirectLink interface.
         *   -BgpAsn: int
         *     The BGP (Border Gateway Protocol) ASN (Autonomous System 
         *     Number) on the customer's side of the DirectLink interface. 
         *     This number must be between `64512` and `65534`.
         *   -BgpKey: string
         *     The BGP authentication key.
         *   -ClientPrivateIp: string
         *     The IP on the customer's side of the DirectLink interface.
         *   -DirectLinkInterfaceName: string
         *     The name of the DirectLink interface.
         *   -OutscalePrivateIp: string
         *     The IP on the OUTSCALE side of the DirectLink interface.
         *   -VirtualGatewayId: string
         *     The ID of the target virtual gateway.
         *   -Vlan: int
         *     The VLAN number associated with the DirectLink interface. This 
         *     number must be unique and be between `2` and `4094`.
         */
        char *direct_link_interface_str;
        int is_set_direct_link_interface;
	struct direct_link_interface direct_link_interface; /* ref DirectLinkInterface */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_create_direct_link_arg  {
        /* Required: bandwidth, direct_link_name, location */
        /*
         * The bandwidth of the DirectLink (`1Gbps` \\| `10Gbps`).
         */
	char *bandwidth; /* string */
        /*
         * The name of the DirectLink.
         */
	char *direct_link_name; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The code of the requested location for the DirectLink, returned by 
         * the [ReadLocations](#readlocations) method.
         */
	char *location; /* string */
};

struct osc_create_dhcp_options_arg  {
        /* Required:none */
        /*
         * Specify a domain name (for example, `MyCompany.com`). You can specify 
         * only one domain name. You must specify at least one of the following 
         * parameters: `DomainName`, `DomainNameServers`, `LogServers`, or 
         * `NtpServers`.
         */
	char *domain_name; /* string */
        /*
         * The IPs of domain name servers. If no IPs are specified, the 
         * `OutscaleProvidedDNS` value is set by default. You must specify at 
         * least one of the following parameters: `DomainName`, 
         * `DomainNameServers`, `LogServers`, or `NtpServers`.
         */
        char *domain_name_servers_str;
	char **domain_name_servers; /* array string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The IPs of the log servers. You must specify at least one of the 
         * following parameters: `DomainName`, `DomainNameServers`, 
         * `LogServers`, or `NtpServers`.
         */
        char *log_servers_str;
	char **log_servers; /* array string */
        /*
         * The IPs of the Network Time Protocol (NTP) servers. You must specify 
         * at least one of the following parameters: `DomainName`, 
         * `DomainNameServers`, `LogServers`, or `NtpServers`.
         */
        char *ntp_servers_str;
	char **ntp_servers; /* array string */
};

struct osc_create_dedicated_group_arg  {
        /* Required: cpu_generation, name, subregion_name */
        /*
         * The processor generation for the VMs in the dedicated group (for 
         * example, `4`).
         */
        int is_set_cpu_generation;
	int cpu_generation; /* int */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * A name for the dedicated group.
         */
	char *name; /* string */
        /*
         * The Subregion in which you want to create the dedicated group.
         */
	char *subregion_name; /* string */
};

struct osc_create_client_gateway_arg  {
        /* Required: bgp_asn, public_ip, connection_type */
        /*
         * The Autonomous System Number (ASN) used by the Border Gateway 
         * Protocol (BGP) to find the path to your client gateway through the 
         * Internet. <br/>\nThis number must be between `1` and `4294967295`. If 
         * you do not have an ASN, you can choose one between 64512 and 65534, 
         * or between 4200000000 and 4294967294.
         */
        int is_set_bgp_asn;
	int bgp_asn; /* int */
        /*
         * The communication protocol used to establish tunnel with your client 
         * gateway (only `ipsec.1` is supported).
         */
	char *connection_type; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The public fixed IPv4 address of your client gateway.
         */
	char *public_ip; /* string */
};

struct osc_create_ca_arg  {
        /* Required: ca_pem */
        /*
         * The CA in PEM format.<br />With OSC CLI, use the following syntax to 
         * make sure your CA file is correctly parsed: `--CaPem=&quot;$(cat 
         * FILENAME)&quot;`.
         */
	char *ca_pem; /* string */
        /*
         * The description of the CA.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
};

struct osc_create_api_access_rule_arg  {
        /* Required:none */
        /*
         *  One or more IDs of Client Certificate Authorities (CAs).
         */
        char *ca_ids_str;
	char **ca_ids; /* array string */
        /*
         * One or more Client Certificate Common Names (CNs). If this parameter 
         * is specified, you must also specify the `CaIds` parameter.
         */
        char *cns_str;
	char **cns; /* array string */
        /*
         * A description for the API access rule.
         */
	char *description; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * One or more IP addresses or CIDR blocks (for example, `192.0.2.0/16`).
         */
        char *ip_ranges_str;
	char **ip_ranges; /* array string */
};

struct osc_create_account_arg  {
        /* Required: city, company_name, country, customer_id, email, first_name, last_name, zip_code */
        /*
         * One or more additional email addresses for the account. These 
         * addresses are used for notifications only. If you already have a list 
         * of additional emails registered, you cannot add to it, only replace 
         * it. To remove all registered additional emails, specify an empty list.
         */
        char *additional_emails_str;
	char **additional_emails; /* array string */
        /*
         * The city of the account owner.
         */
	char *city; /* string */
        /*
         * The name of the company for the account.
         */
	char *company_name; /* string */
        /*
         * The country of the account owner.
         */
	char *country; /* string */
        /*
         * The ID of the customer. It must be 8 digits.
         */
	char *customer_id; /* string */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The main email address for the account. This address is used for your 
         * credentials and notifications.
         */
	char *email; /* string */
        /*
         * The first name of the account owner.
         */
	char *first_name; /* string */
        /*
         * The job title of the account owner.
         */
	char *job_title; /* string */
        /*
         * The last name of the account owner.
         */
	char *last_name; /* string */
        /*
         * The mobile phone number of the account owner.
         */
	char *mobile_number; /* string */
        /*
         * The landline phone number of the account owner.
         */
	char *phone_number; /* string */
        /*
         * The state/province of the account.
         */
	char *state_province; /* string */
        /*
         * The value added tax (VAT) number for the account.
         */
	char *vat_number; /* string */
        /*
         * The ZIP code of the city.
         */
	char *zip_code; /* string */
};

struct osc_create_access_key_arg  {
        /* Required:none */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The date and time, or the date, at which you want the access key to 
         * expire, in ISO 8601 format (for example, `2020-06-14T00:00:00.000Z`, 
         * or `2020-06-14`). To remove an existing expiration date, use the 
         * method without specifying this parameter.
         */
	char *expiration_date; /* string */
        /*
         * The name of the EIM user that owns the key to be created. If you do 
         * not specify a user name, this action creates an access key for the 
         * user who sends the request (which can be the root account).
         */
	char *user_name; /* string */
};

struct osc_check_authentication_arg  {
        /* Required: login, password */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The email address of the account.
         */
	char *login; /* string */
        /*
         * The password of the account.
         */
	char *password; /* string */
};

struct osc_accept_net_peering_arg  {
        /* Required: net_peering_id */
        /*
         * If true, checks whether you have the required permissions to perform 
         * the action.
         */
        int is_set_dry_run;
	int dry_run; /* bool */
        /*
         * The ID of the Net peering you want to accept.
         */
	char *net_peering_id; /* string */
};


int osc_load_ak_sk_from_conf(const char *profile, char **ak, char **sk);
int osc_load_region_from_conf(const char *profile, char **region);
int osc_load_loging_password_from_conf(const char *profile,
				       char **email, char **password);

/**
 * @brief parse osc config file, and store cred_path/key_path. key is optional.
 *
 * @return if < 0, an error, otherwise a flag contain OSC_ENV_FREE_CERT,
 *	OSC_ENV_FREE_SSLKEY, both or 0
 */
int osc_load_cert_from_conf(const char *profile, char **cert_path,
			    char **key_path);

void osc_init_str(struct osc_str *r);
void osc_deinit_str(struct osc_str *r);
int osc_init_sdk(struct osc_env *e, const char *profile, unsigned int flag);
int osc_init_sdk_ext(struct osc_env *e, const char *profile,
		     unsigned int flag, struct osc_env_conf *cfg);
void osc_deinit_sdk(struct osc_env *e);

/*
 * osc_new_sdk/str and osc_destroy_sdk/str where made so we can use
 * C++'s std::unique_ptr with the lib.
 * use it like
 * const std::unique_ptr<osc_env, decltype(&osc_destroy_sdk)>
 *	e(osc_new_sdk(NULL, 0), &osc_destroy_sdk);
 */
static struct osc_env *osc_new_sdk(const char *profile, unsigned int flag)
{
	struct osc_env *e = (struct osc_env *)malloc(sizeof *e);

	if (osc_init_sdk(e, profile, flag) < 0) {
		free(e);
		return NULL;
	}
	return e;
}

static void osc_destroy_sdk(struct osc_env *e)
{
	osc_deinit_sdk(e);
	free(e);
}

static struct osc_str *osc_new_str(void)
{
	struct osc_str *e = (struct osc_str *)malloc(sizeof *e);

	osc_init_str(e);
	return e;
}

static void osc_destroy_str(struct osc_str *e)
{
	osc_deinit_str(e);
	free(e);
}

int osc_sdk_set_useragent(struct osc_env *e, const char *str);

void *osc_realloc(void *buf, size_t l);

/* set/get config path, thread safe if -DWITH_C11_THREAD_LOCAL=1 is set */
void osc_set_cfg_path(const char *cfg);
const char *osc_set_get_path(void);

#ifdef WITH_DESCRIPTION

const char *osc_find_description(const char *call_name);
const char *osc_find_args_description(const char *call_name);

/* Return a list of all calls names, last elem is NULL  */
const char **osc_calls_name(void);

#endif /* WITH_DESCRIPTION */

int osc_update_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_update_vpn_connection_arg *args);
int osc_update_volume(struct osc_env *e, struct osc_str *out, struct osc_update_volume_arg *args);
int osc_update_vm_template(struct osc_env *e, struct osc_str *out, struct osc_update_vm_template_arg *args);
int osc_update_vm_group(struct osc_env *e, struct osc_str *out, struct osc_update_vm_group_arg *args);
int osc_update_vm(struct osc_env *e, struct osc_str *out, struct osc_update_vm_arg *args);
int osc_update_user(struct osc_env *e, struct osc_str *out, struct osc_update_user_arg *args);
int osc_update_subnet(struct osc_env *e, struct osc_str *out, struct osc_update_subnet_arg *args);
int osc_update_snapshot(struct osc_env *e, struct osc_str *out, struct osc_update_snapshot_arg *args);
int osc_update_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_update_server_certificate_arg *args);
int osc_update_route_table_link(struct osc_env *e, struct osc_str *out, struct osc_update_route_table_link_arg *args);
int osc_update_route_propagation(struct osc_env *e, struct osc_str *out, struct osc_update_route_propagation_arg *args);
int osc_update_route(struct osc_env *e, struct osc_str *out, struct osc_update_route_arg *args);
int osc_update_nic(struct osc_env *e, struct osc_str *out, struct osc_update_nic_arg *args);
int osc_update_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_update_net_access_point_arg *args);
int osc_update_net(struct osc_env *e, struct osc_str *out, struct osc_update_net_arg *args);
int osc_update_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_update_load_balancer_arg *args);
int osc_update_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_update_listener_rule_arg *args);
int osc_update_image(struct osc_env *e, struct osc_str *out, struct osc_update_image_arg *args);
int osc_update_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_update_flexible_gpu_arg *args);
int osc_update_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_update_direct_link_interface_arg *args);
int osc_update_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_update_dedicated_group_arg *args);
int osc_update_ca(struct osc_env *e, struct osc_str *out, struct osc_update_ca_arg *args);
int osc_update_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_update_api_access_rule_arg *args);
int osc_update_api_access_policy(struct osc_env *e, struct osc_str *out, struct osc_update_api_access_policy_arg *args);
int osc_update_account(struct osc_env *e, struct osc_str *out, struct osc_update_account_arg *args);
int osc_update_access_key(struct osc_env *e, struct osc_str *out, struct osc_update_access_key_arg *args);
int osc_unlink_volume(struct osc_env *e, struct osc_str *out, struct osc_unlink_volume_arg *args);
int osc_unlink_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_unlink_virtual_gateway_arg *args);
int osc_unlink_route_table(struct osc_env *e, struct osc_str *out, struct osc_unlink_route_table_arg *args);
int osc_unlink_public_ip(struct osc_env *e, struct osc_str *out, struct osc_unlink_public_ip_arg *args);
int osc_unlink_private_ips(struct osc_env *e, struct osc_str *out, struct osc_unlink_private_ips_arg *args);
int osc_unlink_policy(struct osc_env *e, struct osc_str *out, struct osc_unlink_policy_arg *args);
int osc_unlink_nic(struct osc_env *e, struct osc_str *out, struct osc_unlink_nic_arg *args);
int osc_unlink_load_balancer_backend_machines(struct osc_env *e, struct osc_str *out, struct osc_unlink_load_balancer_backend_machines_arg *args);
int osc_unlink_internet_service(struct osc_env *e, struct osc_str *out, struct osc_unlink_internet_service_arg *args);
int osc_unlink_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_unlink_flexible_gpu_arg *args);
int osc_stop_vms(struct osc_env *e, struct osc_str *out, struct osc_stop_vms_arg *args);
int osc_start_vms(struct osc_env *e, struct osc_str *out, struct osc_start_vms_arg *args);
int osc_set_default_policy_version(struct osc_env *e, struct osc_str *out, struct osc_set_default_policy_version_arg *args);
int osc_scale_up_vm_group(struct osc_env *e, struct osc_str *out, struct osc_scale_up_vm_group_arg *args);
int osc_scale_down_vm_group(struct osc_env *e, struct osc_str *out, struct osc_scale_down_vm_group_arg *args);
int osc_reject_net_peering(struct osc_env *e, struct osc_str *out, struct osc_reject_net_peering_arg *args);
int osc_register_vms_in_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_register_vms_in_load_balancer_arg *args);
int osc_reboot_vms(struct osc_env *e, struct osc_str *out, struct osc_reboot_vms_arg *args);
int osc_read_vpn_connections(struct osc_env *e, struct osc_str *out, struct osc_read_vpn_connections_arg *args);
int osc_read_volumes(struct osc_env *e, struct osc_str *out, struct osc_read_volumes_arg *args);
int osc_read_vms_state(struct osc_env *e, struct osc_str *out, struct osc_read_vms_state_arg *args);
int osc_read_vms_health(struct osc_env *e, struct osc_str *out, struct osc_read_vms_health_arg *args);
int osc_read_vms(struct osc_env *e, struct osc_str *out, struct osc_read_vms_arg *args);
int osc_read_vm_types(struct osc_env *e, struct osc_str *out, struct osc_read_vm_types_arg *args);
int osc_read_vm_templates(struct osc_env *e, struct osc_str *out, struct osc_read_vm_templates_arg *args);
int osc_read_vm_groups(struct osc_env *e, struct osc_str *out, struct osc_read_vm_groups_arg *args);
int osc_read_virtual_gateways(struct osc_env *e, struct osc_str *out, struct osc_read_virtual_gateways_arg *args);
int osc_read_users(struct osc_env *e, struct osc_str *out, struct osc_read_users_arg *args);
int osc_read_tags(struct osc_env *e, struct osc_str *out, struct osc_read_tags_arg *args);
int osc_read_subregions(struct osc_env *e, struct osc_str *out, struct osc_read_subregions_arg *args);
int osc_read_subnets(struct osc_env *e, struct osc_str *out, struct osc_read_subnets_arg *args);
int osc_read_snapshots(struct osc_env *e, struct osc_str *out, struct osc_read_snapshots_arg *args);
int osc_read_snapshot_export_tasks(struct osc_env *e, struct osc_str *out, struct osc_read_snapshot_export_tasks_arg *args);
int osc_read_server_certificates(struct osc_env *e, struct osc_str *out, struct osc_read_server_certificates_arg *args);
int osc_read_security_groups(struct osc_env *e, struct osc_str *out, struct osc_read_security_groups_arg *args);
int osc_read_secret_access_key(struct osc_env *e, struct osc_str *out, struct osc_read_secret_access_key_arg *args);
int osc_read_route_tables(struct osc_env *e, struct osc_str *out, struct osc_read_route_tables_arg *args);
int osc_read_regions(struct osc_env *e, struct osc_str *out, struct osc_read_regions_arg *args);
int osc_read_quotas(struct osc_env *e, struct osc_str *out, struct osc_read_quotas_arg *args);
int osc_read_public_ips(struct osc_env *e, struct osc_str *out, struct osc_read_public_ips_arg *args);
int osc_read_public_ip_ranges(struct osc_env *e, struct osc_str *out, struct osc_read_public_ip_ranges_arg *args);
int osc_read_public_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_public_catalog_arg *args);
int osc_read_product_types(struct osc_env *e, struct osc_str *out, struct osc_read_product_types_arg *args);
int osc_read_policy_versions(struct osc_env *e, struct osc_str *out, struct osc_read_policy_versions_arg *args);
int osc_read_policy_version(struct osc_env *e, struct osc_str *out, struct osc_read_policy_version_arg *args);
int osc_read_policy(struct osc_env *e, struct osc_str *out, struct osc_read_policy_arg *args);
int osc_read_policies(struct osc_env *e, struct osc_str *out, struct osc_read_policies_arg *args);
int osc_read_nics(struct osc_env *e, struct osc_str *out, struct osc_read_nics_arg *args);
int osc_read_nets(struct osc_env *e, struct osc_str *out, struct osc_read_nets_arg *args);
int osc_read_net_peerings(struct osc_env *e, struct osc_str *out, struct osc_read_net_peerings_arg *args);
int osc_read_net_access_points(struct osc_env *e, struct osc_str *out, struct osc_read_net_access_points_arg *args);
int osc_read_net_access_point_services(struct osc_env *e, struct osc_str *out, struct osc_read_net_access_point_services_arg *args);
int osc_read_nat_services(struct osc_env *e, struct osc_str *out, struct osc_read_nat_services_arg *args);
int osc_read_locations(struct osc_env *e, struct osc_str *out, struct osc_read_locations_arg *args);
int osc_read_load_balancers(struct osc_env *e, struct osc_str *out, struct osc_read_load_balancers_arg *args);
int osc_read_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_read_load_balancer_tags_arg *args);
int osc_read_listener_rules(struct osc_env *e, struct osc_str *out, struct osc_read_listener_rules_arg *args);
int osc_read_linked_policies(struct osc_env *e, struct osc_str *out, struct osc_read_linked_policies_arg *args);
int osc_read_keypairs(struct osc_env *e, struct osc_str *out, struct osc_read_keypairs_arg *args);
int osc_read_internet_services(struct osc_env *e, struct osc_str *out, struct osc_read_internet_services_arg *args);
int osc_read_images(struct osc_env *e, struct osc_str *out, struct osc_read_images_arg *args);
int osc_read_image_export_tasks(struct osc_env *e, struct osc_str *out, struct osc_read_image_export_tasks_arg *args);
int osc_read_flexible_gpus(struct osc_env *e, struct osc_str *out, struct osc_read_flexible_gpus_arg *args);
int osc_read_flexible_gpu_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_flexible_gpu_catalog_arg *args);
int osc_read_direct_links(struct osc_env *e, struct osc_str *out, struct osc_read_direct_links_arg *args);
int osc_read_direct_link_interfaces(struct osc_env *e, struct osc_str *out, struct osc_read_direct_link_interfaces_arg *args);
int osc_read_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_read_dhcp_options_arg *args);
int osc_read_dedicated_groups(struct osc_env *e, struct osc_str *out, struct osc_read_dedicated_groups_arg *args);
int osc_read_consumption_account(struct osc_env *e, struct osc_str *out, struct osc_read_consumption_account_arg *args);
int osc_read_console_output(struct osc_env *e, struct osc_str *out, struct osc_read_console_output_arg *args);
int osc_read_client_gateways(struct osc_env *e, struct osc_str *out, struct osc_read_client_gateways_arg *args);
int osc_read_catalogs(struct osc_env *e, struct osc_str *out, struct osc_read_catalogs_arg *args);
int osc_read_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_catalog_arg *args);
int osc_read_cas(struct osc_env *e, struct osc_str *out, struct osc_read_cas_arg *args);
int osc_read_api_logs(struct osc_env *e, struct osc_str *out, struct osc_read_api_logs_arg *args);
int osc_read_api_access_rules(struct osc_env *e, struct osc_str *out, struct osc_read_api_access_rules_arg *args);
int osc_read_api_access_policy(struct osc_env *e, struct osc_str *out, struct osc_read_api_access_policy_arg *args);
int osc_read_admin_password(struct osc_env *e, struct osc_str *out, struct osc_read_admin_password_arg *args);
int osc_read_accounts(struct osc_env *e, struct osc_str *out, struct osc_read_accounts_arg *args);
int osc_read_access_keys(struct osc_env *e, struct osc_str *out, struct osc_read_access_keys_arg *args);
int osc_link_volume(struct osc_env *e, struct osc_str *out, struct osc_link_volume_arg *args);
int osc_link_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_link_virtual_gateway_arg *args);
int osc_link_route_table(struct osc_env *e, struct osc_str *out, struct osc_link_route_table_arg *args);
int osc_link_public_ip(struct osc_env *e, struct osc_str *out, struct osc_link_public_ip_arg *args);
int osc_link_private_ips(struct osc_env *e, struct osc_str *out, struct osc_link_private_ips_arg *args);
int osc_link_policy(struct osc_env *e, struct osc_str *out, struct osc_link_policy_arg *args);
int osc_link_nic(struct osc_env *e, struct osc_str *out, struct osc_link_nic_arg *args);
int osc_link_load_balancer_backend_machines(struct osc_env *e, struct osc_str *out, struct osc_link_load_balancer_backend_machines_arg *args);
int osc_link_internet_service(struct osc_env *e, struct osc_str *out, struct osc_link_internet_service_arg *args);
int osc_link_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_link_flexible_gpu_arg *args);
int osc_deregister_vms_in_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_deregister_vms_in_load_balancer_arg *args);
int osc_delete_vpn_connection_route(struct osc_env *e, struct osc_str *out, struct osc_delete_vpn_connection_route_arg *args);
int osc_delete_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_delete_vpn_connection_arg *args);
int osc_delete_volume(struct osc_env *e, struct osc_str *out, struct osc_delete_volume_arg *args);
int osc_delete_vms(struct osc_env *e, struct osc_str *out, struct osc_delete_vms_arg *args);
int osc_delete_vm_template(struct osc_env *e, struct osc_str *out, struct osc_delete_vm_template_arg *args);
int osc_delete_vm_group(struct osc_env *e, struct osc_str *out, struct osc_delete_vm_group_arg *args);
int osc_delete_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_delete_virtual_gateway_arg *args);
int osc_delete_user(struct osc_env *e, struct osc_str *out, struct osc_delete_user_arg *args);
int osc_delete_tags(struct osc_env *e, struct osc_str *out, struct osc_delete_tags_arg *args);
int osc_delete_subnet(struct osc_env *e, struct osc_str *out, struct osc_delete_subnet_arg *args);
int osc_delete_snapshot(struct osc_env *e, struct osc_str *out, struct osc_delete_snapshot_arg *args);
int osc_delete_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_delete_server_certificate_arg *args);
int osc_delete_security_group_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_security_group_rule_arg *args);
int osc_delete_security_group(struct osc_env *e, struct osc_str *out, struct osc_delete_security_group_arg *args);
int osc_delete_route_table(struct osc_env *e, struct osc_str *out, struct osc_delete_route_table_arg *args);
int osc_delete_route(struct osc_env *e, struct osc_str *out, struct osc_delete_route_arg *args);
int osc_delete_public_ip(struct osc_env *e, struct osc_str *out, struct osc_delete_public_ip_arg *args);
int osc_delete_policy_version(struct osc_env *e, struct osc_str *out, struct osc_delete_policy_version_arg *args);
int osc_delete_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_policy_arg *args);
int osc_delete_nic(struct osc_env *e, struct osc_str *out, struct osc_delete_nic_arg *args);
int osc_delete_net_peering(struct osc_env *e, struct osc_str *out, struct osc_delete_net_peering_arg *args);
int osc_delete_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_delete_net_access_point_arg *args);
int osc_delete_net(struct osc_env *e, struct osc_str *out, struct osc_delete_net_arg *args);
int osc_delete_nat_service(struct osc_env *e, struct osc_str *out, struct osc_delete_nat_service_arg *args);
int osc_delete_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_tags_arg *args);
int osc_delete_load_balancer_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_policy_arg *args);
int osc_delete_load_balancer_listeners(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_listeners_arg *args);
int osc_delete_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_arg *args);
int osc_delete_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_listener_rule_arg *args);
int osc_delete_keypair(struct osc_env *e, struct osc_str *out, struct osc_delete_keypair_arg *args);
int osc_delete_internet_service(struct osc_env *e, struct osc_str *out, struct osc_delete_internet_service_arg *args);
int osc_delete_image(struct osc_env *e, struct osc_str *out, struct osc_delete_image_arg *args);
int osc_delete_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_delete_flexible_gpu_arg *args);
int osc_delete_export_task(struct osc_env *e, struct osc_str *out, struct osc_delete_export_task_arg *args);
int osc_delete_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_delete_direct_link_interface_arg *args);
int osc_delete_direct_link(struct osc_env *e, struct osc_str *out, struct osc_delete_direct_link_arg *args);
int osc_delete_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_delete_dhcp_options_arg *args);
int osc_delete_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_delete_dedicated_group_arg *args);
int osc_delete_client_gateway(struct osc_env *e, struct osc_str *out, struct osc_delete_client_gateway_arg *args);
int osc_delete_ca(struct osc_env *e, struct osc_str *out, struct osc_delete_ca_arg *args);
int osc_delete_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_api_access_rule_arg *args);
int osc_delete_access_key(struct osc_env *e, struct osc_str *out, struct osc_delete_access_key_arg *args);
int osc_create_vpn_connection_route(struct osc_env *e, struct osc_str *out, struct osc_create_vpn_connection_route_arg *args);
int osc_create_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_create_vpn_connection_arg *args);
int osc_create_volume(struct osc_env *e, struct osc_str *out, struct osc_create_volume_arg *args);
int osc_create_vms(struct osc_env *e, struct osc_str *out, struct osc_create_vms_arg *args);
int osc_create_vm_template(struct osc_env *e, struct osc_str *out, struct osc_create_vm_template_arg *args);
int osc_create_vm_group(struct osc_env *e, struct osc_str *out, struct osc_create_vm_group_arg *args);
int osc_create_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_create_virtual_gateway_arg *args);
int osc_create_user(struct osc_env *e, struct osc_str *out, struct osc_create_user_arg *args);
int osc_create_tags(struct osc_env *e, struct osc_str *out, struct osc_create_tags_arg *args);
int osc_create_subnet(struct osc_env *e, struct osc_str *out, struct osc_create_subnet_arg *args);
int osc_create_snapshot_export_task(struct osc_env *e, struct osc_str *out, struct osc_create_snapshot_export_task_arg *args);
int osc_create_snapshot(struct osc_env *e, struct osc_str *out, struct osc_create_snapshot_arg *args);
int osc_create_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_create_server_certificate_arg *args);
int osc_create_security_group_rule(struct osc_env *e, struct osc_str *out, struct osc_create_security_group_rule_arg *args);
int osc_create_security_group(struct osc_env *e, struct osc_str *out, struct osc_create_security_group_arg *args);
int osc_create_route_table(struct osc_env *e, struct osc_str *out, struct osc_create_route_table_arg *args);
int osc_create_route(struct osc_env *e, struct osc_str *out, struct osc_create_route_arg *args);
int osc_create_public_ip(struct osc_env *e, struct osc_str *out, struct osc_create_public_ip_arg *args);
int osc_create_product_type(struct osc_env *e, struct osc_str *out, struct osc_create_product_type_arg *args);
int osc_create_policy_version(struct osc_env *e, struct osc_str *out, struct osc_create_policy_version_arg *args);
int osc_create_policy(struct osc_env *e, struct osc_str *out, struct osc_create_policy_arg *args);
int osc_create_nic(struct osc_env *e, struct osc_str *out, struct osc_create_nic_arg *args);
int osc_create_net_peering(struct osc_env *e, struct osc_str *out, struct osc_create_net_peering_arg *args);
int osc_create_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_create_net_access_point_arg *args);
int osc_create_net(struct osc_env *e, struct osc_str *out, struct osc_create_net_arg *args);
int osc_create_nat_service(struct osc_env *e, struct osc_str *out, struct osc_create_nat_service_arg *args);
int osc_create_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_tags_arg *args);
int osc_create_load_balancer_policy(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_policy_arg *args);
int osc_create_load_balancer_listeners(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_listeners_arg *args);
int osc_create_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_arg *args);
int osc_create_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_create_listener_rule_arg *args);
int osc_create_keypair(struct osc_env *e, struct osc_str *out, struct osc_create_keypair_arg *args);
int osc_create_internet_service(struct osc_env *e, struct osc_str *out, struct osc_create_internet_service_arg *args);
int osc_create_image_export_task(struct osc_env *e, struct osc_str *out, struct osc_create_image_export_task_arg *args);
int osc_create_image(struct osc_env *e, struct osc_str *out, struct osc_create_image_arg *args);
int osc_create_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_create_flexible_gpu_arg *args);
int osc_create_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_create_direct_link_interface_arg *args);
int osc_create_direct_link(struct osc_env *e, struct osc_str *out, struct osc_create_direct_link_arg *args);
int osc_create_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_create_dhcp_options_arg *args);
int osc_create_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_create_dedicated_group_arg *args);
int osc_create_client_gateway(struct osc_env *e, struct osc_str *out, struct osc_create_client_gateway_arg *args);
int osc_create_ca(struct osc_env *e, struct osc_str *out, struct osc_create_ca_arg *args);
int osc_create_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_create_api_access_rule_arg *args);
int osc_create_account(struct osc_env *e, struct osc_str *out, struct osc_create_account_arg *args);
int osc_create_access_key(struct osc_env *e, struct osc_str *out, struct osc_create_access_key_arg *args);
int osc_check_authentication(struct osc_env *e, struct osc_str *out, struct osc_check_authentication_arg *args);
int osc_accept_net_peering(struct osc_env *e, struct osc_str *out, struct osc_accept_net_peering_arg *args);

#ifdef __cplusplus
}
#endif

#endif /* __SDK_C__ */
