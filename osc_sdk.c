/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, Outscale SAS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

 /*
  * This code is autogenerated, don't edit it directely
  */

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "curl/curl.h"
#include <time.h>
#include "osc_sdk.h"
#include "json.h"

#define AK_SIZE 20
#define SK_SIZE 40
#define TIMESTAMP_SIZE 17
#define TIME_HDR_KEY "X-Osc-Date: "
#define TIME_HDR_KEY_L (sizeof TIME_HDR_KEY)

#define CFG_FILE "/.osc/config.json"

#ifdef _WIN32


static inline char* stpcpy(char *dest, const char *src)
{
	for (; *src; ++src) {
		*dest++ = *src;
	}
	*dest = 0;
	return dest;
}

#endif

#ifdef WITH_DESCRIPTION

static const char *calls_name[] = {
	"UpdateVpnConnection",
	"UpdateVolume",
	"UpdateVm",
	"UpdateSubnet",
	"UpdateSnapshot",
	"UpdateServerCertificate",
	"UpdateRoutePropagation",
	"UpdateRoute",
	"UpdateNic",
	"UpdateNetAccessPoint",
	"UpdateNet",
	"UpdateLoadBalancer",
	"UpdateListenerRule",
	"UpdateImage",
	"UpdateFlexibleGpu",
	"UpdateDirectLinkInterface",
	"UpdateCa",
	"UpdateApiAccessRule",
	"UpdateApiAccessPolicy",
	"UpdateAccount",
	"UpdateAccessKey",
	"UnlinkVolume",
	"UnlinkVirtualGateway",
	"UnlinkRouteTable",
	"UnlinkPublicIp",
	"UnlinkPrivateIps",
	"UnlinkNic",
	"UnlinkLoadBalancerBackendMachines",
	"UnlinkInternetService",
	"UnlinkFlexibleGpu",
	"StopVms",
	"StartVms",
	"SendResetPasswordEmail",
	"ResetAccountPassword",
	"RejectNetPeering",
	"RegisterVmsInLoadBalancer",
	"RebootVms",
	"ReadVpnConnections",
	"ReadVolumes",
	"ReadVmsState",
	"ReadVmsHealth",
	"ReadVms",
	"ReadVmTypes",
	"ReadVirtualGateways",
	"ReadTags",
	"ReadSubregions",
	"ReadSubnets",
	"ReadSnapshots",
	"ReadSnapshotExportTasks",
	"ReadServerCertificates",
	"ReadSecurityGroups",
	"ReadSecretAccessKey",
	"ReadRouteTables",
	"ReadRegions",
	"ReadQuotas",
	"ReadPublicIps",
	"ReadPublicIpRanges",
	"ReadPublicCatalog",
	"ReadProductTypes",
	"ReadNics",
	"ReadNets",
	"ReadNetPeerings",
	"ReadNetAccessPoints",
	"ReadNetAccessPointServices",
	"ReadNatServices",
	"ReadLocations",
	"ReadLoadBalancers",
	"ReadLoadBalancerTags",
	"ReadListenerRules",
	"ReadKeypairs",
	"ReadInternetServices",
	"ReadImages",
	"ReadImageExportTasks",
	"ReadFlexibleGpus",
	"ReadFlexibleGpuCatalog",
	"ReadDirectLinks",
	"ReadDirectLinkInterfaces",
	"ReadDhcpOptions",
	"ReadConsumptionAccount",
	"ReadConsoleOutput",
	"ReadClientGateways",
	"ReadCatalog",
	"ReadCas",
	"ReadApiLogs",
	"ReadApiAccessRules",
	"ReadApiAccessPolicy",
	"ReadAdminPassword",
	"ReadAccounts",
	"ReadAccessKeys",
	"LinkVolume",
	"LinkVirtualGateway",
	"LinkRouteTable",
	"LinkPublicIp",
	"LinkPrivateIps",
	"LinkNic",
	"LinkLoadBalancerBackendMachines",
	"LinkInternetService",
	"LinkFlexibleGpu",
	"DeregisterVmsInLoadBalancer",
	"DeleteVpnConnectionRoute",
	"DeleteVpnConnection",
	"DeleteVolume",
	"DeleteVms",
	"DeleteVirtualGateway",
	"DeleteTags",
	"DeleteSubnet",
	"DeleteSnapshot",
	"DeleteServerCertificate",
	"DeleteSecurityGroupRule",
	"DeleteSecurityGroup",
	"DeleteRouteTable",
	"DeleteRoute",
	"DeletePublicIp",
	"DeleteNic",
	"DeleteNetPeering",
	"DeleteNetAccessPoint",
	"DeleteNet",
	"DeleteNatService",
	"DeleteLoadBalancerTags",
	"DeleteLoadBalancerPolicy",
	"DeleteLoadBalancerListeners",
	"DeleteLoadBalancer",
	"DeleteListenerRule",
	"DeleteKeypair",
	"DeleteInternetService",
	"DeleteImage",
	"DeleteFlexibleGpu",
	"DeleteExportTask",
	"DeleteDirectLinkInterface",
	"DeleteDirectLink",
	"DeleteDhcpOptions",
	"DeleteClientGateway",
	"DeleteCa",
	"DeleteApiAccessRule",
	"DeleteAccessKey",
	"CreateVpnConnectionRoute",
	"CreateVpnConnection",
	"CreateVolume",
	"CreateVms",
	"CreateVirtualGateway",
	"CreateTags",
	"CreateSubnet",
	"CreateSnapshotExportTask",
	"CreateSnapshot",
	"CreateServerCertificate",
	"CreateSecurityGroupRule",
	"CreateSecurityGroup",
	"CreateRouteTable",
	"CreateRoute",
	"CreatePublicIp",
	"CreateNic",
	"CreateNetPeering",
	"CreateNetAccessPoint",
	"CreateNet",
	"CreateNatService",
	"CreateLoadBalancerTags",
	"CreateLoadBalancerPolicy",
	"CreateLoadBalancerListeners",
	"CreateLoadBalancer",
	"CreateListenerRule",
	"CreateKeypair",
	"CreateInternetService",
	"CreateImageExportTask",
	"CreateImage",
	"CreateFlexibleGpu",
	"CreateDirectLinkInterface",
	"CreateDirectLink",
	"CreateDhcpOptions",
	"CreateClientGateway",
	"CreateCa",
	"CreateApiAccessRule",
	"CreateAccount",
	"CreateAccessKey",
	"CheckAuthentication",
	"AcceptNetPeering",
	NULL
};

static const char *calls_descriptions[] = {
	"Usage: oapi-cli UpdateVpnConnection [options]\n" "Modifies the specified attributes of a VPN connection.\n" "\nRequired Argument: VpnConnectionId \n"
,
	"Usage: oapi-cli UpdateVolume [options]\n" "Modifies the specified attributes of a volume. Cold volumes are volumes that \n" "are attached to stopped VMs or that are detached. Hot volumes are volumes that \n" "are attached to running VMs.\n\n**[NOTE]**\nWhen the modification is not \n" "instantaneous, the response displays the previous value. You can use the \n" "[ReadVolumes](#readvolumes) method to see the new value.\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli UpdateVm [options]\n" "Modifies the specified attributes of a virtual machine (VM).\nYou must stop the \n" "VM before modifying the following attributes:\n* `NestedVirtualization`\n* \n" "`Performance`\n* `UserData`\n* `VmType`\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli UpdateSubnet [options]\n" "Modifies the specified attribute of a Subnet.\n" "\nRequired Argument: SubnetId, MapPublicIpOnLaunch \n"
,
	"Usage: oapi-cli UpdateSnapshot [options]\n" "Modifies the permissions for a specified snapshot.\nYou can add or remove \n" "permissions for specified account IDs or groups. You can share a snapshot with \n" "a user that is in the same Region. The user can create a copy of the snapshot \n" "you shared, obtaining all the rights for the copy of the snapshot.\n" "\nRequired Argument: SnapshotId, PermissionsToCreateVolume \n"
,
	"Usage: oapi-cli UpdateServerCertificate [options]\n" "Modifies the name and/or the path of a specified server certificate.\n" "\nRequired Argument: Name \n"
,
	"Usage: oapi-cli UpdateRoutePropagation [options]\n" "Configures the propagation of routes to a specified route table of a Net by a \n" "virtual gateway.\n" "\nRequired Argument: Enable, RouteTableId, VirtualGatewayId \n"
,
	"Usage: oapi-cli UpdateRoute [options]\n" "Replaces an existing route within a route table in a Net.\nYou must specify one \n" "of the following elements as the target:\n\n* Net peering\n* NAT virtual \n" "machine (VM)\n* Internet service\n* Virtual gateway\n* NAT service\n* Network \n" "interface card (NIC)\n\nThe routing algorithm is based on the most specific \n" "match.\n" "\nRequired Argument: RouteTableId, DestinationIpRange \n"
,
	"Usage: oapi-cli UpdateNic [options]\n" "Modifies the specified network interface card (NIC). You can specify only one \n" "attribute at a time.\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli UpdateNetAccessPoint [options]\n" "Modifies the attributes of a Net access point.\nThis action enables you to add \n" "or remove route tables associated with the specified Net access point.\n" "\nRequired Argument: NetAccessPointId \n"
,
	"Usage: oapi-cli UpdateNet [options]\n" "Associates a DHCP options set with a specified Net.\n" "\nRequired Argument: DhcpOptionsSetId, NetId \n"
,
	"Usage: oapi-cli UpdateLoadBalancer [options]\n" "Modifies the specified attribute of a load balancer. You can specify only one \n" "attribute at a time.\n\nYou can set a new SSL certificate to an SSL or HTTPS \n" "listener of a load balancer.\nThis certificate replaces any certificate used on \n" "the same load balancer and port.\n\nYou can also replace the currently enabled \n" "policy for the load balancer with another one.\nIf the `PolicyNames` parameter \n" "is empty, the currently enabled policy is disabled.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli UpdateListenerRule [options]\n" "Updates the pattern of the listener rule.\nThis call updates the pattern \n" "matching algorithm for incoming traffic.\n" "\nRequired Argument: ListenerRuleName \n"
,
	"Usage: oapi-cli UpdateImage [options]\n" "Modifies the specified attribute of an OUTSCALE machine image (OMI).\nYou can \n" "specify only one attribute at a time. You can modify the permissions to access \n" "the OMI by adding or removing account IDs or groups. You can share an OMI with \n" "a user that is in the same Region. The user can create a copy of the OMI you \n" "shared, obtaining all the rights for the copy of the OMI. For more information, \n" "see [CreateImage](#createimage).\n" "\nRequired Argument: ImageId, PermissionsToLaunch \n"
,
	"Usage: oapi-cli UpdateFlexibleGpu [options]\n" "Modifies a flexible GPU (fGPU) behavior.\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli UpdateDirectLinkInterface [options]\n" "Modifies the maximum transmission unit (MTU) of a DirectLink interface.\n" "\nRequired Argument: DirectLinkInterfaceId, Mtu \n"
,
	"Usage: oapi-cli UpdateCa [options]\n" "Modifies the specified attribute of a Client Certificate Authority (CA).\n" "\nRequired Argument: CaId \n"
,
	"Usage: oapi-cli UpdateApiAccessRule [options]\n" "Modifies a specified API access rule.\n\n**[NOTE]** \n- The new rule you \n" "specify fully replaces the old rule. Therefore, for a parameter that is not \n" "specified, any previously set value is deleted.\n- If, as result of your \n" "modification, you no longer have access to the APIs, you will need to contact \n" "the Support team to regain access. For more information, see [Technical \n" "Support](https://docs.outscale.com/en/userguide/Technical-Support.html).\n" "\nRequired Argument: ApiAccessRuleId \n"
,
	"Usage: oapi-cli UpdateApiAccessPolicy [options]\n" "Updates the API access policy of your account.\n\n**[NOTE]**\nOnly one API \n" "access policy can be associated with your account.\n" "\nRequired Argument: MaxAccessKeyExpirationSeconds, RequireTrustedEnv \n"
,
	"Usage: oapi-cli UpdateAccount [options]\n" "Updates the account information for the account that sends the request.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli UpdateAccessKey [options]\n" "Modifies the attributes of the specified access key of your \n" "account.\n\n**[NOTE]**\nTo protect against brute force attacks, the number of \n" "requests allowed for this method in a given time period is limited.\n" "\nRequired Argument: AccessKeyId, State \n"
,
	"Usage: oapi-cli UnlinkVolume [options]\n" "Detaches a Block Storage Unit (BSU) volume from a virtual machine (VM).\nTo \n" "detach the root device of a VM, this VM must be stopped.\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli UnlinkVirtualGateway [options]\n" "Detaches a virtual gateway from a Net.\nYou must wait until the virtual gateway \n" "is in the detached state before you can attach another Net to it or delete the \n" "Net it was previously attached to.\n" "\nRequired Argument: NetId, VirtualGatewayId \n"
,
	"Usage: oapi-cli UnlinkRouteTable [options]\n" "Disassociates a Subnet from a route table.\nAfter disassociation, the Subnet \n" "can no longer use the routes in this route table, but uses the routes in the \n" "main route table of the Net instead.\n" "\nRequired Argument: LinkRouteTableId \n"
,
	"Usage: oapi-cli UnlinkPublicIp [options]\n" "Disassociates a public IP from the virtual machine (VM) or network interface \n" "card (NIC) it is associated with.\n\n**[NOTE]**\nTo disassociate the public IP \n" "from a NAT service, you need to delete the NAT service. For more information, \n" "see the [DeleteNatService](#deletenatservice) method.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli UnlinkPrivateIps [options]\n" "Unassigns one or more secondary private IPs from a network interface card (NIC).\n" "\nRequired Argument: NicId, PrivateIps \n"
,
	"Usage: oapi-cli UnlinkNic [options]\n" "Detaches a network interface card (NIC) from a virtual machine (VM).\nThe \n" "primary NIC cannot be detached.\n" "\nRequired Argument: LinkNicId \n"
,
	"Usage: oapi-cli UnlinkLoadBalancerBackendMachines [options]\n" "Detaches one or more back-end virtual machines (VMs) from a load balancer. You \n" "need to specify at least the `BackendIps` or the `BackendVmIds` parameter.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli UnlinkInternetService [options]\n" "Detaches an Internet service from a Net.\nThis action disables and detaches an \n" "Internet service from a Net. The Net must not contain virtual machines (VMs) \n" "using public IPs nor internet-facing load balancers.\n" "\nRequired Argument: InternetServiceId, NetId \n"
,
	"Usage: oapi-cli UnlinkFlexibleGpu [options]\n" "Detaches a flexible GPU (fGPU) from a virtual machine (VM).\nThe fGPU is in the \n" "`detaching` state until the VM is stopped, after which it becomes available for \n" "allocation again.\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli StopVms [options]\n" "Stops one or more running virtual machines (VMs).\nYou can stop only VMs that \n" "are valid and that belong to you. Data stored in the VM RAM is lost.\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli StartVms [options]\n" "Start one or more virtual machines (VMs).\nYou can start only VMs that are \n" "valid and that belong to you.\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli SendResetPasswordEmail [options]\n" "Sends an email to the email address provided for the account with a token to \n" "reset your password.\nYou need to provide this token when updating the account \n" "password using the ResetAccountPassword method.\n**[NOTE]**\nTo protect against \n" "brute force attacks, the number of requests allowed for this method in a given \n" "time period is limited.\n" "\nRequired Argument: Email \n"
,
	"Usage: oapi-cli ResetAccountPassword [options]\n" "Replaces the account password with the new one you provide.\nYou must also \n" "provide the token you received by email when asking for a password reset using \n" "the SendResetPasswordEmail method.\nPassword strength is tested through \n" "heuristic algorithms. For more information, see the [zxcvbn \n" "GitHub](https://github.com/dropbox/zxcvbn).\n**[NOTE]**\nTo protect against \n" "brute force attacks, the number of requests allowed for this method in a given \n" "time period is limited.\n" "\nRequired Argument: Password, Token \n"
,
	"Usage: oapi-cli RejectNetPeering [options]\n" "Rejects a Net peering request.\nThe Net peering must be in the \n" "`pending-acceptance` state to be rejected. The rejected Net peering is then in \n" "the `rejected` state.\n" "\nRequired Argument: NetPeeringId \n"
,
	"Usage: oapi-cli RegisterVmsInLoadBalancer [options]\n" "Registers one or more virtual machines (VMs) with a specified load \n" "balancer.\nThe VMs can be in different Subnets and different Subregions than \n" "the load balancer, as long as the VMs and load balancers are all in the public \n" "Cloud or all in the same Net. It may take a little time for a VM to be \n" "registered with the load balancer. Once the VM is registered with a load \n" "balancer, it receives traffic and requests from this load balancer and is \n" "called a back-end VM.\n" "\nRequired Argument: BackendVmIds, LoadBalancerName \n"
,
	"Usage: oapi-cli RebootVms [options]\n" "Reboots one or more virtual machines (VMs).\nThis operation sends a reboot \n" "request to one or more specified VMs. This is an asynchronous action that \n" "queues this reboot request. This action only reboots VMs that are valid and \n" "that belong to you.\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli ReadVpnConnections [options]\n" "Lists one or more VPN connections.\n\n**[NOTE]**\nIf you exceed the number of \n" "identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadVolumes [options]\n" "Lists one or more specified Block Storage Unit (BSU) volumes.\n\n**[NOTE]**\nIf \n" "you exceed the number of identical requests allowed for a configured time \n" "period, the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadVmsState [options]\n" "Lists the status of one or more virtual machines (VMs).\n\n**[NOTE]**\nIf you \n" "exceed the number of identical requests allowed for a configured time period, \n" "the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadVmsHealth [options]\n" "Lists the state of one or more back-end virtual machines (VMs) registered with \n" "a specified load balancer.\n\n**[NOTE]**\nIf you exceed the number of identical \n" "requests allowed for a configured time period, the `Throttling` error message \n" "is returned.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli ReadVms [options]\n" "Lists one or more of your virtual machines (VMs).\nIf you provide one or more \n" "VM IDs, this action returns a description for all of these VMs. If you do not \n" "provide any VM ID, this action returns a description for all of the VMs that \n" "belong to you. If you provide an invalid VM ID, an error is returned. If you \n" "provide the ID of a VM that does not belong to you, the description of this VM \n" "is not included in the response. The refresh interval for data returned by this \n" "action is one hour, meaning that a terminated VM may appear in the \n" "response.\n\n**[NOTE]**\nIf you exceed the number of identical requests allowed \n" "for a configured time period, the `RequestLimitExceeded` error message is \n" "returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadVmTypes [options]\n" "Lists one or more predefined VM types.\n\n**[NOTE]**\nIf you exceed the number \n" "of identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadVirtualGateways [options]\n" "Lists one or more virtual gateways.\n\n**[NOTE]**\nIf you exceed the number of \n" "identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadTags [options]\n" "Lists one or more tags for your resources.\n\n**[NOTE]**\nIf you exceed the \n" "number of identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadSubregions [options]\n" "Lists one or more of the enabled Subregions that you can access in the current \n" "Region.\n\n**[NOTE]**\n- If you exceed the number of identical requests allowed \n" "for a configured time period, the `RequestLimitExceeded` error message is \n" "returned.\n- You can use this command to get information about Subregions only \n" "in a Region for which you have an account. Otherwise, the `AuthFailure` error \n" "message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadSubnets [options]\n" "Lists one or more of your Subnets.\nIf you do not specify any Subnet ID, this \n" "action describes all of your Subnets.\n\n**[NOTE]**\nIf you exceed the number \n" "of identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadSnapshots [options]\n" "Lists one or more snapshots that are available to you and the permissions to \n" "create volumes from them.\n\n**[NOTE]**\nIf you exceed the number of identical \n" "requests allowed for a configured time period, the `RequestLimitExceeded` error \n" "message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadSnapshotExportTasks [options]\n" "Lists one or more snapshot export tasks.\n\n**[NOTE]**\nIf you exceed the \n" "number of identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadServerCertificates [options]\n" "Lists your server certificates.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadSecurityGroups [options]\n" "Lists one or more security groups.\nYou can specify either the name of the \n" "security groups or their IDs.\n\n**[NOTE]**\nIf you exceed the number of \n" "identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadSecretAccessKey [options]\n" "Lists information about the specified access key of your account, including its \n" "secret key.\n" "\nRequired Argument: AccessKeyId \n"
,
	"Usage: oapi-cli ReadRouteTables [options]\n" "Lists one or more of your route tables.\nIn your Net, each Subnet must be \n" "associated with a route table. If a Subnet is not explicitly associated with a \n" "route table, it is implicitly associated with the main route table of the \n" "Net.\n\n**[NOTE]**\nIf you exceed the number of identical requests allowed for \n" "a configured time period, the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadRegions [options]\n" "Lists one or more Regions of the OUTSCALE Cloud.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadQuotas [options]\n" "Lists one or more of your quotas.\n\n**[NOTE]**\nIf you exceed the number of \n" "identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadPublicIps [options]\n" "Lists one or more public IPs allocated to your account.\nBy default, this \n" "action returns information about all your public IPs: available or associated \n" "with a virtual machine (VM), a network interface card (NIC) or a NAT \n" "service.\n\n**[NOTE]**\nIf you exceed the number of identical requests allowed \n" "for a configured time period, the `RequestLimitExceeded` error message is \n" "returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadPublicIpRanges [options]\n" "Gets the public IPv4 addresses in CIDR notation for the Region specified in the \n" "endpoint of the request. For more information, see [Regions, Endpoints and \n" "Availability Zones \n" "Reference](https://docs.outscale.com/en/userguide/Regions-Endpoints-and-Availabi\n" "lity-Zones-Reference.html).\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadPublicCatalog [options]\n" "Returns the price list of OUTSCALE products and services for the Region \n" "specified in the endpoint of the request. For more information, see [Regions, \n" "Endpoints and Availability Zones \n" "Reference](https://docs.outscale.com/en/userguide/Regions-Endpoints-and-Availabi\n" "lity-Zones-Reference.html).\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadProductTypes [options]\n" "Lists one or more product types.\n\n**[NOTE]**\nIf you exceed the number of \n" "identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadNics [options]\n" "Lists one or more network interface cards (NICs).\nA NIC is a virtual network \n" "interface that you can attach to a virtual machine (VM) in a \n" "Net.\n\n**[NOTE]**\nIf you exceed the number of identical requests allowed for \n" "a configured time period, the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadNets [options]\n" "Lists one or more Nets.\n\n**[NOTE]**\nIf you exceed the number of identical \n" "requests allowed for a configured time period, the `RequestLimitExceeded` error \n" "message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadNetPeerings [options]\n" "Lists one or more peering connections between two Nets.\n\n**[NOTE]**\nIf you \n" "exceed the number of identical requests allowed for a configured time period, \n" "the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadNetAccessPoints [options]\n" "Lists one or more Net access points.\n\n**[NOTE]**\nIf you exceed the number of \n" "identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadNetAccessPointServices [options]\n" "Lists OUTSCALE services available to create Net access points.\nFor more \n" "information, see \n" "[CreateNetAccessPoint](#createnetaccesspoint).\n\n**[NOTE]**\nIf you exceed the \n" "number of identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadNatServices [options]\n" "Lists one or more network address translation (NAT) services.\n\n**[NOTE]**\nIf \n" "you exceed the number of identical requests allowed for a configured time \n" "period, the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadLocations [options]\n" "Lists the locations, corresponding to datacenters, where you can set up a \n" "DirectLink.\n\n**[NOTE]**\nIf you exceed the number of identical requests \n" "allowed for a configured time period, the `Throttling` error message is \n" "returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadLoadBalancers [options]\n" "Lists one or more load balancers and their attributes.\n\n**[NOTE]**\nIf you \n" "exceed the number of identical requests allowed for a configured time period, \n" "the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadLoadBalancerTags [options]\n" "Lists the tags associated with one or more specified load \n" "balancers.\n\n**[NOTE]**\nIf you exceed the number of identical requests \n" "allowed for a configured time period, the `Throttling` error message is \n" "returned.\n" "\nRequired Argument: LoadBalancerNames \n"
,
	"Usage: oapi-cli ReadListenerRules [options]\n" "Lists one or more listener rules. By default, this action returns the full list \n" "of listener rules for the account.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadKeypairs [options]\n" "Lists one or more of your keypairs.\n\n**[NOTE]**\nIf you exceed the number of \n" "identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadInternetServices [options]\n" "Lists one or more of your Internet services.\nAn Internet service enables your \n" "virtual machines (VMs) launched in a Net to connect to the Internet. By \n" "default, a Net includes an Internet service, and each Subnet is public. Every \n" "VM launched within a default Subnet has a private IP and a public \n" "IP.\n\n**[NOTE]**\nIf you exceed the number of identical requests allowed for a \n" "configured time period, the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadImages [options]\n" "Lists one or more OUTSCALE machine images (OMIs) you can use.\n\n**[NOTE]**\nIf \n" "you exceed the number of identical requests allowed for a configured time \n" "period, the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadImageExportTasks [options]\n" "Lists one or more image export tasks.\n\n**[NOTE]**\nIf you exceed the number \n" "of identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadFlexibleGpus [options]\n" "Lists one or more flexible GPUs (fGPUs) allocated to your \n" "account.\n\n**[NOTE]**\nIf you exceed the number of identical requests allowed \n" "for a configured time period, the `RequestLimitExceeded` error message is \n" "returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadFlexibleGpuCatalog [options]\n" "Lists all flexible GPUs available in the public catalog.\n\n**[NOTE]**\nIf you \n" "exceed the number of identical requests allowed for a configured time period, \n" "the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadDirectLinks [options]\n" "Lists all DirectLinks in the Region.\n\n**[NOTE]**\nIf you exceed the number of \n" "identical requests allowed for a configured time period, the `Throttling` error \n" "message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadDirectLinkInterfaces [options]\n" "Lists one or more of your DirectLink interfaces.\n\n**[NOTE]**\nIf you exceed \n" "the number of identical requests allowed for a configured time period, the \n" "`Throttling` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadDhcpOptions [options]\n" "Gets information about the content of one or more DHCP options \n" "sets.\n\n**[NOTE]**\nIf you exceed the number of identical requests allowed for \n" "a configured time period, the `RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadConsumptionAccount [options]\n" "Gets information about the consumption of your account for each billable \n" "resource within the specified time period.\n\n**[NOTE]**\nIf you exceed the \n" "number of identical requests allowed for a configured time period, the \n" "`Throttling` error message is returned.\n" "\nRequired Argument: FromDate, ToDate \n"
,
	"Usage: oapi-cli ReadConsoleOutput [options]\n" "Gets the console output for a virtual machine (VM). This console provides the \n" "most recent 64 KiB output.\n\n**[NOTE]**\nOn Windows VMs, the console is \n" "handled only on the first boot. It returns no output after the first boot.\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli ReadClientGateways [options]\n" "Lists one or more of your client gateways.\n\n**[NOTE]**\nIf you exceed the \n" "number of identical requests allowed for a configured time period, the \n" "`RequestLimitExceeded` error message is returned.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadCatalog [options]\n" "Returns the price list of OUTSCALE products and services for the current Region.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadCas [options]\n" "Gets information about one or more of your Client Certificate Authorities (CAs).\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadApiLogs [options]\n" "Lists the logs of the API calls you have performed with this account. For more \n" "information, see [About OUTSCALE Monitoring Services \n" "(OMS)](https://docs.outscale.com/en/userguide/About-OUTSCALE-Monitoring-Services\n" "-(OMS).html).\n\n**[NOTE]**\nPast logs are accessible for up to 32 days.\nBy \n" "default, the retrieved interval is 48 hours. If neither of the \n" "`QueryDateBefore` nor `QueryDateAfter` parameters are specified, logs from the \n" "past 48 hours are retrieved. If you only specify one of two, logs are retrieved \n" "from a 2-day interval based on the date you provided. To retrieve logs beyond a \n" "2-day interval, specify both parameters.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadApiAccessRules [options]\n" "Lists one or more API access rules.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadApiAccessPolicy [options]\n" "Gets information about the API access policy of your account.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadAdminPassword [options]\n" "Gets the administrator password for a Windows running virtual machine \n" "(VM).\nThe administrator password is encrypted using the keypair you specified \n" "when launching the VM.\n\n**[NOTE]**\nThe administrator password is generated \n" "only on the first boot of the Windows VM. It is not returned after the first \n" "boot.\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli ReadAccounts [options]\n" "Gets information about the account that sent the request.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli ReadAccessKeys [options]\n" "Lists the access key IDs of your account.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli LinkVolume [options]\n" "Attaches a Block Storage Unit (BSU) volume to a virtual machine (VM).\nThe \n" "volume and the VM must be in the same Subregion. The VM can be running or \n" "stopped. The volume is attached to the specified VM device.\n" "\nRequired Argument: DeviceName, VmId, VolumeId \n"
,
	"Usage: oapi-cli LinkVirtualGateway [options]\n" "Attaches a virtual gateway to a Net.\n" "\nRequired Argument: NetId, VirtualGatewayId \n"
,
	"Usage: oapi-cli LinkRouteTable [options]\n" "Associates a Subnet with a route table.\nThe Subnet and the route table must be \n" "in the same Net. The traffic is routed according to the route table defined \n" "within this Net. You can associate a route table with several Subnets.\n" "\nRequired Argument: RouteTableId, SubnetId \n"
,
	"Usage: oapi-cli LinkPublicIp [options]\n" "Associates a public IP with a virtual machine (VM) or a network interface card \n" "(NIC), in the public Cloud or in a Net. You can associate a public IP with only \n" "one VM or network interface at a time.\nTo associate a public IP in a Net, \n" "ensure that the Net has an Internet service attached. For more information, see \n" "the [LinkInternetService](#linkinternetservice) method.\nBy default, the public \n" "IP is disassociated every time you stop and start the VM. For a persistent \n" "association, you can add the `osc.fcu.eip.auto-attach` tag to the VM with the \n" "public IP as value. For more information, see the [CreateTags](#createtags) \n" "method.\n\n**[NOTE]**\nYou can associate a public IP with a network address \n" "translation (NAT) service only when creating the NAT service. To modify its \n" "public IP, you need to delete the NAT service and re-create it with the new \n" "public IP. For more information, see the [CreateNatService](#createnatservice) \n" "method.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli LinkPrivateIps [options]\n" "Assigns one or more secondary private IPs to a specified network interface card \n" "(NIC). This action is only available in a Net. The private IPs to be assigned \n" "can be added individually using the `PrivateIps` parameter, or you can specify \n" "the number of private IPs to be automatically chosen within the Subnet range \n" "using the `SecondaryPrivateIpCount` parameter. You can specify only one of \n" "these two parameters. If none of these parameters are specified, a private IP \n" "is chosen within the Subnet range.\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli LinkNic [options]\n" "Attaches a network interface card (NIC) to a virtual machine (VM).\nThe \n" "interface and the VM must be in the same Subregion. The VM can be either \n" "`running` or `stopped`. The NIC must be in the `available` state. For more \n" "information, see [Attaching an FNI to an \n" "Instance](https://docs.outscale.com/en/userguide/Attaching-an-FNI-to-an-Instance\n" ".html).\n" "\nRequired Argument: DeviceNumber, VmId, NicId \n"
,
	"Usage: oapi-cli LinkLoadBalancerBackendMachines [options]\n" "Attaches one or more virtual machines (VMs) to a specified load balancer. You \n" "need to specify at least the `BackendIps` or the `BackendVmIds` parameter.\nThe \n" "VMs can be in different Subnets and different Subregions than the load \n" "balancer, as long as the VMs and load balancers are all in the public Cloud or \n" "all in the same Net. It may take a little time for a VM to be registered with \n" "the load balancer. Once the VM is registered with a load balancer, it receives \n" "traffic and requests from this load balancer and is called a back-end VM.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli LinkInternetService [options]\n" "Attaches an Internet service to a Net.\nTo enable the connection between the \n" "Internet and a Net, you must attach an Internet service to this Net.\n" "\nRequired Argument: InternetServiceId, NetId \n"
,
	"Usage: oapi-cli LinkFlexibleGpu [options]\n" "Attaches one of your allocated flexible GPUs (fGPUs) to one of your virtual \n" "machines (VMs).\nThe fGPU is in the `attaching` state until the VM is stopped, \n" "after which it becomes `attached`.\n" "\nRequired Argument: FlexibleGpuId, VmId \n"
,
	"Usage: oapi-cli DeregisterVmsInLoadBalancer [options]\n" "Deregisters a specified virtual machine (VM) from a load balancer.\n" "\nRequired Argument: BackendVmIds, LoadBalancerName \n"
,
	"Usage: oapi-cli DeleteVpnConnectionRoute [options]\n" "Deletes a static route to a VPN connection previously created using the \n" "CreateVpnConnectionRoute method.\n" "\nRequired Argument: DestinationIpRange, VpnConnectionId \n"
,
	"Usage: oapi-cli DeleteVpnConnection [options]\n" "Deletes a specified VPN connection.\nIf you want to delete a Net and all its \n" "dependencies, we recommend to detach the virtual gateway from the Net and \n" "delete the Net before deleting the VPN connection. This enables you to delete \n" "the Net without waiting for the VPN connection to be deleted.\n" "\nRequired Argument: VpnConnectionId \n"
,
	"Usage: oapi-cli DeleteVolume [options]\n" "Deletes a specified Block Storage Unit (BSU) volume.\nYou can delete available \n" "volumes only, that is, volumes that are not attached to a virtual machine (VM).\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli DeleteVms [options]\n" "Terminates one or more virtual machines (VMs).\nThis operation is idempotent, \n" "that means that all calls succeed if you terminate a VM more than once.\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli DeleteVirtualGateway [options]\n" "Deletes a specified virtual gateway.\nBefore deleting a virtual gateway, we \n" "recommend to detach it from the Net and delete the VPN connection.\n" "\nRequired Argument: VirtualGatewayId \n"
,
	"Usage: oapi-cli DeleteTags [options]\n" "Deletes one or more tags from the specified resources.\n" "\nRequired Argument: ResourceIds, Tags \n"
,
	"Usage: oapi-cli DeleteSubnet [options]\n" "Deletes a specified Subnet.\nBefore deleting the Subnet, you need to delete all \n" "resources associated with the Subnet:\n\n* Virtual machines (VMs)\n* Network \n" "Interface Cards (NICs)\n* Network Address Translation (NAT) gateways\n* Load \n" "balancers\n" "\nRequired Argument: SubnetId \n"
,
	"Usage: oapi-cli DeleteSnapshot [options]\n" "Deletes a specified snapshot.\nYou cannot delete a snapshot that is currently \n" "used by an OUTSCALE machine image (OMI). To do so, you first need to delete the \n" "corresponding OMI. For more information, see the [DeleteImage](#deleteimage) \n" "method.\n" "\nRequired Argument: SnapshotId \n"
,
	"Usage: oapi-cli DeleteServerCertificate [options]\n" "Deletes a specified server certificate.\n" "\nRequired Argument: Name \n"
,
	"Usage: oapi-cli DeleteSecurityGroupRule [options]\n" "Deletes one or more inbound or outbound rules from a security group. For the \n" "rule to be deleted, the values specified in the deletion request must exactly \n" "match the value of the existing rule.\nIn case of TCP and UDP protocols, you \n" "have to indicate the destination port or range of ports. In case of ICMP \n" "protocol, you have to specify the ICMP type and code numbers.\nRules (IP \n" "permissions) consist of the protocol, IP range or source security group.\nTo \n" "remove outbound access to a destination security group, we recommend to use a \n" "set of IP permissions. We also recommend to specify the protocol in a set of IP \n" "permissions.\n" "\nRequired Argument: SecurityGroupId, Flow \n"
,
	"Usage: oapi-cli DeleteSecurityGroup [options]\n" "Deletes a specified security group.\nYou can specify either the name of the \n" "security group or its ID.\nThis action fails if the specified group is \n" "associated with a virtual machine (VM) or referenced by another security group.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli DeleteRouteTable [options]\n" "Deletes a specified route table.\nBefore deleting a route table, you must \n" "disassociate it from any Subnet. You cannot delete the main route table.\n" "\nRequired Argument: RouteTableId \n"
,
	"Usage: oapi-cli DeleteRoute [options]\n" "Deletes a route from a specified route table.\n" "\nRequired Argument: RouteTableId, DestinationIpRange \n"
,
	"Usage: oapi-cli DeletePublicIp [options]\n" "Releases a public IP.\nYou can release a public IP associated with your \n" "account. This address is released in the public IP pool and can be used by \n" "someone else. Before releasing a public IP, ensure you updated all your \n" "resources communicating with this address.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli DeleteNic [options]\n" "Deletes the specified network interface card (NIC).\nThe network interface must \n" "not be attached to any virtual machine (VM).\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli DeleteNetPeering [options]\n" "Deletes a Net peering.\nIf the Net peering is in the `active` state, it can be \n" "deleted either by the owner of the requester Net or the owner of the peer \n" "Net.\nIf it is in the `pending-acceptance` state, it can be deleted only by the \n" "owner of the requester Net.\nIf it is in the `rejected`, `failed`, or `expired` \n" "states, it cannot be deleted.\n" "\nRequired Argument: NetPeeringId \n"
,
	"Usage: oapi-cli DeleteNetAccessPoint [options]\n" "Deletes a specified Net access point.\nThis action also deletes the \n" "corresponding routes added to the route tables you specified for the Net access \n" "point.\n" "\nRequired Argument: NetAccessPointId \n"
,
	"Usage: oapi-cli DeleteNet [options]\n" "Deletes a specified Net.\nBefore deleting the Net, you need to delete or detach \n" "all the resources associated with the Net:\n\n* Virtual machines (VMs)\n* Net \n" "peerings\n* Custom route tables\n* Public IPs allocated to resources in the \n" "Net\n* Network Interface Cards (NICs) created in the Subnets\n* Virtual \n" "gateways, Internet services and NAT services\n* Load balancers\n* Security \n" "groups\n* Subnets\n" "\nRequired Argument: NetId \n"
,
	"Usage: oapi-cli DeleteNatService [options]\n" "Deletes a specified network address translation (NAT) service.\nThis action \n" "disassociates the public IP from the NAT service, but does not release this \n" "public IP from your account. However, it does not delete any NAT service routes \n" "in your route tables.\n" "\nRequired Argument: NatServiceId \n"
,
	"Usage: oapi-cli DeleteLoadBalancerTags [options]\n" "Deletes one or more tags from the specified load balancers.\n" "\nRequired Argument: LoadBalancerNames, Tags \n"
,
	"Usage: oapi-cli DeleteLoadBalancerPolicy [options]\n" "Deletes a specified policy from a load balancer.\nIn order to be deleted, the \n" "policy must not be enabled for any listener.\n" "\nRequired Argument: LoadBalancerName, PolicyName \n"
,
	"Usage: oapi-cli DeleteLoadBalancerListeners [options]\n" "Deletes listeners of a specified load balancer.\n" "\nRequired Argument: LoadBalancerName, LoadBalancerPorts \n"
,
	"Usage: oapi-cli DeleteLoadBalancer [options]\n" "Deletes a specified load balancer.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli DeleteListenerRule [options]\n" "Deletes a listener rule.\nThe previously active rule is disabled after deletion.\n" "\nRequired Argument: ListenerRuleName \n"
,
	"Usage: oapi-cli DeleteKeypair [options]\n" "Deletes the specified keypair.\nThis action deletes the public key stored by \n" "3DS OUTSCALE, thus deleting the keypair.\n" "\nRequired Argument: KeypairName \n"
,
	"Usage: oapi-cli DeleteInternetService [options]\n" "Deletes an Internet service.\nBefore deleting an Internet service, you must \n" "detach it from any Net it is attached to.\n" "\nRequired Argument: InternetServiceId \n"
,
	"Usage: oapi-cli DeleteImage [options]\n" "Deletes an OUTSCALE machine image (OMI) so that you cannot use it anymore to \n" "launch virtual machines (VMs). However, you can still use VMs already launched \n" "from this OMI.\n" "\nRequired Argument: ImageId \n"
,
	"Usage: oapi-cli DeleteFlexibleGpu [options]\n" "Releases a flexible GPU (fGPU) from your account.\nThe fGPU becomes free to be \n" "used by someone else.\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli DeleteExportTask [options]\n" "Deletes an export task.\nIf the export task is not running, the command fails \n" "and an error is returned.\n" "\nRequired Argument: ExportTaskId \n"
,
	"Usage: oapi-cli DeleteDirectLinkInterface [options]\n" "Deletes a specified DirectLink interface.\n" "\nRequired Argument: DirectLinkInterfaceId \n"
,
	"Usage: oapi-cli DeleteDirectLink [options]\n" "Deletes a specified DirectLink.\nBefore deleting a DirectLink, ensure that all \n" "your DirectLink interfaces related to this DirectLink are deleted.\n" "\nRequired Argument: DirectLinkId \n"
,
	"Usage: oapi-cli DeleteDhcpOptions [options]\n" "Deletes a specified DHCP options set.\nBefore deleting a DHCP options set, you \n" "must disassociate it from the Nets you associated it with. To do so, you need \n" "to associate with each Net a new set of DHCP options, or the `default` one if \n" "you do not want to associate any DHCP options with the Net.\n\n**[NOTE]**\nYou \n" "cannot delete the `default` set.\n" "\nRequired Argument: DhcpOptionsSetId \n"
,
	"Usage: oapi-cli DeleteClientGateway [options]\n" "Deletes a client gateway.\nYou must delete the VPN connection before deleting \n" "the client gateway.\n" "\nRequired Argument: ClientGatewayId \n"
,
	"Usage: oapi-cli DeleteCa [options]\n" "Deletes a specified Client Certificate Authority (CA).\n" "\nRequired Argument: CaId \n"
,
	"Usage: oapi-cli DeleteApiAccessRule [options]\n" "Deletes a specified API access rule.\n\n**[NOTE]** \nYou cannot delete the last \n" "remaining API access rule. However, if you delete all the API access rules that \n" "allow you to access the APIs, you need to contact the Support team to regain \n" "access. For more information, see [Technical \n" "Support](https://docs.outscale.com/en/userguide/Technical-Support.html).\n" "\nRequired Argument: ApiAccessRuleId \n"
,
	"Usage: oapi-cli DeleteAccessKey [options]\n" "Deletes the specified access key of your account.\n\n**[NOTE]**\nTo protect \n" "against brute force attacks, the number of requests allowed for this method in \n" "a given time period is limited.\n" "\nRequired Argument: AccessKeyId \n"
,
	"Usage: oapi-cli CreateVpnConnectionRoute [options]\n" "Creates a static route to a VPN connection.\nThis enables you to select the \n" "network flows sent by the virtual gateway to the target VPN connection.\n" "\nRequired Argument: DestinationIpRange, VpnConnectionId \n"
,
	"Usage: oapi-cli CreateVpnConnection [options]\n" "Creates a VPN connection between a specified virtual gateway and a specified \n" "client gateway.\nYou can create only one VPN connection between a virtual \n" "gateway and a client gateway.\n" "\nRequired Argument: ClientGatewayId, ConnectionType, VirtualGatewayId \n"
,
	"Usage: oapi-cli CreateVolume [options]\n" "Creates a Block Storage Unit (BSU) volume in a specified Region.\nBSU volumes \n" "can be attached to a virtual machine (VM) in the same Subregion. You can create \n" "an empty volume or restore a volume from an existing snapshot.\nYou can create \n" "the following volume types: Enterprise (`io1`) for provisioned IOPS SSD \n" "volumes, Performance (`gp2`) for general purpose SSD volumes, or Magnetic \n" "(`standard`) volumes.\n" "\nRequired Argument: SubregionName \n"
,
	"Usage: oapi-cli CreateVms [options]\n" "Creates virtual machines (VMs), and then launches them.\nThis action enables \n" "you to create a specified number of VMs using an OUTSCALE machine image (OMI) \n" "that you are allowed to use, and then to automatically launch them.\nThe VMs \n" "remain in the `pending` state until they are created and ready to be used. Once \n" "automatically launched, they are in the `running` state.\nTo check the state of \n" "your VMs, call the [ReadVms](#readvms) method.\nIf not specified, the security \n" "group used by the service is the default one.\nThe metadata server enables you \n" "to get the public key provided when the VM is launched. Official OMIs contain a \n" "script to get this public key and put it inside the VM to provide secure access \n" "without password.\n" "\nRequired Argument: ImageId \n"
,
	"Usage: oapi-cli CreateVirtualGateway [options]\n" "Creates a virtual gateway.\nA virtual gateway is the access point on the Net \n" "side of a VPN connection.\n" "\nRequired Argument: ConnectionType \n"
,
	"Usage: oapi-cli CreateTags [options]\n" "Adds one or more tags to the specified resources.\nIf a tag with the same key \n" "already exists for the resource, the tag value is replaced.\nYou can tag the \n" "following resources using their IDs:\n\n* Virtual machines (VMs) \n" "(i-xxxxxxxx)\n* OMIs (ami-xxxxxxxx)\n* Volumes (vol-xxxxxxxx)\n* Snapshots \n" "(snap-xxxxxxxx)\n* Public IPs (eipalloc-xxxxxxxx)\n* Security groups \n" "(sg-xxxxxxxx)\n* Route tables (rtb-xxxxxxxx)\n* Network interface cards (NIC) \n" "(eni-xxxxxxxx)\n* Nets (vpc-xxxxxxxx)\n* Subnets (subnet-xxxxxxxx)\n* Net \n" "peerings (vpcx-xxxxxxxx)\n* Net endpoints (vpce-xxxxxxxx)\n* NAT services \n" "(nat-xxxxxxxx)\n* Internet services (igw-xxxxxxxx)\n* Client gateways \n" "(cgw-xxxxxxxx)\n* Virtual gateways (vgw-xxxxxxxx)\n* VPN connections \n" "(vpn-xxxxxxxx)\n* DHCP options (dopt-xxxxxxxx)\n* OMI export tasks \n" "(image-export-xxxxxxxx)\n* Snapshot export tasks (snap-export-xxxxxxxx)\n" "\nRequired Argument: ResourceIds, Tags \n"
,
	"Usage: oapi-cli CreateSubnet [options]\n" "Creates a Subnet in an existing Net.\nTo create a Subnet in a Net, you have to \n" "provide the ID of the Net and the IP range for the Subnet (its network range). \n" "Once the Subnet is created, you cannot modify its IP range.\n" "\nRequired Argument: IpRange, NetId \n"
,
	"Usage: oapi-cli CreateSnapshotExportTask [options]\n" "Exports a snapshot to an OUTSCALE Object Storage (OOS) bucket.\nThis action \n" "enables you to create a backup of your snapshot or to copy it to another \n" "account. You, or other users you send a pre-signed URL to, can then download \n" "this snapshot from the bucket using the [CreateSnapshot](#createsnapshot) \n" "method.\nThis procedure enables you to copy a snapshot between accounts within \n" "the same Region or in different Regions. To copy a snapshot within the same \n" "Region, you can also use the [CreateSnapshot](#createsnapshot) direct method. \n" "The copy of the source snapshot is independent and belongs to you.\n" "\nRequired Argument: OsuExport, SnapshotId \n"
,
	"Usage: oapi-cli CreateSnapshot [options]\n" "Creates a snapshot. Snapshots are point-in-time images of a volume that you can \n" "use to back up your data or to create replicas of this volume.\nYou can use \n" "this method in three different ways:\n* **Creating**: You create a snapshot \n" "from one of your volumes.<br></li>\n* **Copying**: You copy an existing \n" "snapshot. The source snapshot can be one of your own snapshots, or a snapshot \n" "owned by another account that has granted you permission via the \n" "[UpdateSnapshot](#updatesnapshot) method.<br></li>\n* **Importing**: You import \n" "a snapshot located in an OUTSCALE Object Storage (OOS) bucket. First, the owner \n" "of the source snapshot must export it to the bucket by using the \n" "[CreateSnapshotExportTask](#createsnapshotexporttask) method. Then, they must \n" "grant you read permission on the bucket via a pre-signed URL or Access Control \n" "Lists. For more information, see [Managing Access to Your Buckets and \n" "Objects](https://docs.outscale.com/en/userguide/Managing-Access-to-Your-Buckets-\n" "and-Objects.html).\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli CreateServerCertificate [options]\n" "Creates a server certificate and its matching private key.\nThese elements can \n" "be used with other services (for example, to configure SSL termination on load \n" "balancers).\nYou can also specify the chain of intermediate certification \n" "authorities if your certificate is not directly signed by a root one. You can \n" "specify multiple intermediate certification authorities in the \n" "`CertificateChain` parameter. To do so, concatenate all certificates in the \n" "correct order (the first certificate must be the authority of your certificate, \n" "the second must the the authority of the first one, and so on).\nThe private \n" "key must be a RSA key in PKCS1 form. To check this, open the PEM file and \n" "ensure its header reads as follows: BEGIN RSA PRIVATE KEY.\n[IMPORTANT]\nThis \n" "private key must not be protected by a password or a passphrase.\n" "\nRequired Argument: Body, PrivateKey, Name \n"
,
	"Usage: oapi-cli CreateSecurityGroupRule [options]\n" "Configures the rules for a security group.\nThe modifications are effective at \n" "virtual machine (VM) level as quickly as possible, but a small delay may \n" "occur.\n\nYou can add one or more egress rules to a security group for use with \n" "a Net.\nIt allows VMs to send traffic to either one or more destination IP \n" "ranges or destination security groups for the same Net.\nWe recommend using a \n" "set of IP permissions to authorize outbound access to a destination security \n" "group. We also recommended this method to create a rule with a specific IP \n" "protocol and a specific port range. In a set of IP permissions, we recommend to \n" "specify the the protocol.\n\nYou can also add one or more ingress rules to a \n" "security group.\nIn the public Cloud, this action allows one or more IP ranges \n" "to access a security group for your account, or allows one or more security \n" "groups (source groups) to access a security group for your own OUTSCALE account \n" "or another one.\nIn a Net, this action allows one or more IP ranges to access a \n" "security group for your Net, or allows one or more other security groups \n" "(source groups) to access a security group for your Net. All the security \n" "groups must be for the same Net.\n\n**[NOTE]**\nBy default, traffic between two \n" "security groups is allowed through both public and private IPs. To restrict it \n" "to private IPs only, contact our Support team: support@outscale.com.\n" "\nRequired Argument: SecurityGroupId, Flow \n"
,
	"Usage: oapi-cli CreateSecurityGroup [options]\n" "Creates a security group.\nThis action creates a security group either in the \n" "public Cloud or in a specified Net. By default, a default security group for \n" "use in the public Cloud and a default security group for use in a Net are \n" "created.\nWhen launching a virtual machine (VM), if no security group is \n" "explicitly specified, the appropriate default security group is assigned to the \n" "VM. Default security groups include a default rule granting VMs network access \n" "to each other.\nWhen creating a security group, you specify a name. Two \n" "security groups for use in the public Cloud or for use in a Net cannot have the \n" "same name.\nYou can have up to 500 security groups in the public Cloud. You can \n" "create up to 500 security groups per Net.\nTo add or remove rules, use the \n" "[CreateSecurityGroupRule](#createsecuritygrouprule) method.\n" "\nRequired Argument: Description, SecurityGroupName \n"
,
	"Usage: oapi-cli CreateRouteTable [options]\n" "Creates a route table for a specified Net.\nYou can then add routes and \n" "associate this route table with a Subnet.\n" "\nRequired Argument: NetId \n"
,
	"Usage: oapi-cli CreateRoute [options]\n" "Creates a route in a specified route table within a specified Net.\nYou must \n" "specify one of the following elements as the target:\n\n* Net peering\n* NAT \n" "VM\n* Internet service\n* Virtual gateway\n* NAT service\n* Network interface \n" "card (NIC)\n\nThe routing algorithm is based on the most specific match.\n" "\nRequired Argument: DestinationIpRange, RouteTableId \n"
,
	"Usage: oapi-cli CreatePublicIp [options]\n" "Acquires a public IP for your account.\nA public IP is a static IP designed for \n" "dynamic Cloud computing. It can be associated with a virtual machine (VM) in \n" "the public Cloud or in a Net, a network interface card (NIC), a NAT service.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli CreateNic [options]\n" "Creates a network interface card (NIC) in the specified Subnet.\n" "\nRequired Argument: SubnetId \n"
,
	"Usage: oapi-cli CreateNetPeering [options]\n" "Requests a Net peering between a Net you own and a peer Net that belongs to you \n" "or another account.\nThis action creates a Net peering that remains in the \n" "`pending-acceptance` state until it is accepted by the owner of the peer Net. \n" "If the owner of the peer Net does not accept the request within 7 days, the \n" "state of the Net peering becomes `expired`. For more information, see \n" "[AcceptNetPeering](#acceptnetpeering).\n\n**[NOTE]**\n* Peered Nets must \n" "contain at least one virtual machine (VM) each before the creation of the Net \n" "peering.\n* The two Nets must not have overlapping IP ranges. Otherwise, the \n" "Net peering is in the `failed` state.\n* A peering connection between two Nets \n" "works both ways. Therefore, you do not need to create a B-to-A connection if an \n" "A-to-B connection is created and accepted.\n" "\nRequired Argument: AccepterNetId, SourceNetId \n"
,
	"Usage: oapi-cli CreateNetAccessPoint [options]\n" "Creates a Net access point to access an OUTSCALE service from this Net without \n" "using the Internet and public IPs.\nYou specify the service using its name. For \n" "more information about the available services, see \n" "[ReadNetAccessPointServices](#readnetaccesspointservices).\nTo control the \n" "routing of traffic between the Net and the specified service, you can specify \n" "one or more route tables. Virtual machines placed in Subnets associated with \n" "the specified route table thus use the Net access point to access the service. \n" "When you specify a route table, a route is automatically added to it with the \n" "destination set to the prefix list ID of the service, and the target set to the \n" "ID of the access point.\n" "\nRequired Argument: ServiceName, NetId \n"
,
	"Usage: oapi-cli CreateNet [options]\n" "Creates a Net with a specified IP range.\nThe IP range (network range) of your \n" "Net must be between a /28 netmask (16 IPs) and a /16 netmask (65536 IPs).\n" "\nRequired Argument: IpRange \n"
,
	"Usage: oapi-cli CreateNatService [options]\n" "Creates a network address translation (NAT) service in the specified public \n" "Subnet of a Net.\nA NAT service enables virtual machines (VMs) placed in the \n" "private Subnet of this Net to connect to the Internet, without being accessible \n" "from the Internet.\nWhen creating a NAT service, you specify the allocation ID \n" "of the public IP you want to use as public IP for the NAT service. Once the NAT \n" "service is created, you need to create a route in the route table of the \n" "private Subnet, with 0.0.0.0/0 as destination and the ID of the NAT service as \n" "target. For more information, see [LinkPublicIP](#linkpublicip) and \n" "[CreateRoute](#createroute).\nThis action also enables you to create multiple \n" "NAT services in the same Net (one per public Subnet).\n\n**[NOTE]**\nYou cannot \n" "modify the public IP associated with a NAT service after its creation. To do \n" "so, you need to delete the NAT service and create a new one with another public \n" "IP.\n" "\nRequired Argument: PublicIpId, SubnetId \n"
,
	"Usage: oapi-cli CreateLoadBalancerTags [options]\n" "Adds one or more tags to the specified load balancers.\nIf a tag with the same \n" "key already exists for the load balancer, the tag value is replaced.\n" "\nRequired Argument: LoadBalancerNames, Tags \n"
,
	"Usage: oapi-cli CreateLoadBalancerPolicy [options]\n" "Creates a stickiness policy with sticky session lifetimes defined by the \n" "browser lifetime.\nThe created policy can be used with HTTP or HTTPS listeners \n" "only.\nIf this policy is implemented by a load balancer, this load balancer \n" "uses this cookie in all incoming requests to direct them to the specified \n" "back-end server virtual machine (VM). If this cookie is not present, the load \n" "balancer sends the request to any other server according to its load-balancing \n" "algorithm.\n\nYou can also create a stickiness policy with sticky session \n" "lifetimes following the lifetime of an application-generated cookie.\nUnlike \n" "the other type of stickiness policy, the lifetime of the special Load Balancer \n" "Unit (LBU) cookie follows the lifetime of the application-generated cookie \n" "specified in the policy configuration. The load balancer inserts a new \n" "stickiness cookie only when the application response includes a new application \n" "cookie.\nThe session stops being sticky if the application cookie is removed or \n" "expires, until a new application cookie is issued.\n" "\nRequired Argument: PolicyType, LoadBalancerName, PolicyName \n"
,
	"Usage: oapi-cli CreateLoadBalancerListeners [options]\n" "Creates one or more listeners for a specified load balancer.\n" "\nRequired Argument: Listeners, LoadBalancerName \n"
,
	"Usage: oapi-cli CreateLoadBalancer [options]\n" "Creates a load balancer.\nThe load balancer is created with a unique Domain \n" "Name Service (DNS) name. It receives the incoming traffic and routes it to its \n" "registered virtual machines (VMs).\nBy default, this action creates an \n" "Internet-facing load balancer, resolving to public IPs. To create an internal \n" "load balancer in a Net, resolving to private IPs, use the `LoadBalancerType` \n" "parameter.\nYou must specify either the `Subnets` or the `SubregionNames` \n" "parameters.\n" "\nRequired Argument: Listeners, LoadBalancerName \n"
,
	"Usage: oapi-cli CreateListenerRule [options]\n" "Creates a rule for traffic redirection for the specified listener. Each rule \n" "must have either the `HostNamePattern` or `PathPattern` parameter specified. \n" "Rules are treated in priority order, from the highest value to the lowest \n" "value.\nOnce the rule is created, you need to register backend VMs with it. For \n" "more information, see the \n" "[RegisterVmsInLoadBalancer](#registervmsinloadbalancer) method.\n" "\nRequired Argument: VmIds, Listener, ListenerRule \n"
,
	"Usage: oapi-cli CreateKeypair [options]\n" "Creates a 2048-bit RSA keypair with a specified name.\nThis action returns the \n" "private key that you need to save. The public key is stored by 3DS \n" "OUTSCALE.\n\nYou can also import a public key. The following types of key can \n" "be imported: RSA (minimum 2048 bits, recommended 4096 bits), ECDSA (minimum and \n" "recommended 256 bits), and Ed25519. The following formats can be used: PEM, \n" "PKCS8, RFC4716, and OpenSSH.\nThis action imports the public key of a keypair \n" "created by a third-party tool and uses it to create a keypair. The private key \n" "is never provided to 3DS OUTSCALE.\n" "\nRequired Argument: KeypairName \n"
,
	"Usage: oapi-cli CreateInternetService [options]\n" "Creates an Internet service you can use with a Net.\nAn Internet service \n" "enables your virtual machines (VMs) launched in a Net to connect to the \n" "Internet. By default, a Net includes an Internet service, and each Subnet is \n" "public. Every VM launched within a default Subnet has a private IP and a public \n" "IP.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli CreateImageExportTask [options]\n" "Exports an Outscale machine image (OMI) to an OUTSCALE Object Storage (OOS) \n" "bucket.\nThis action enables you to copy an OMI between accounts in different \n" "Regions. To copy an OMI in the same Region, you can also use the \n" "[CreateImage](#createimage) method.\nThe copy of the OMI belongs to you and is \n" "independent from the source OMI.\n\n**[NOTE]**\nYou cannot export a shared or \n" "public OMI, as they do not belong to you. To do so, you must first copy it to \n" "your account. The copy then belongs to you and you can export it.\n" "\nRequired Argument: OsuExport, ImageId \n"
,
	"Usage: oapi-cli CreateImage [options]\n" "Creates an OUTSCALE machine image (OMI) from an existing virtual machine (VM) \n" "which is either running or stopped.\nThis action also creates a snapshot of the \n" "root volume of the VM, as well as a snapshot of each Block Storage Unit (BSU) \n" "volume attached to the VM. For more information, see [About \n" "OMIs](https://docs.outscale.com/en/userguide/About-OMIs.html).\n\nYou can also \n" "use this method to copy an OMI to your account, from an account in the same \n" "Region. To do so, the owner of the source OMI must share it with your account. \n" "For more information about how to share an OMI with another account in the same \n" "Region, see [UpdateImage](#updateimage).\nTo copy an OMI between accounts in \n" "different Regions, the owner of the source OMI must first export it to an \n" "OUTSCALE Object Storage (OOS) bucket using the \n" "[CreateImageExportTask](#createimageexporttask) method, and then you need to \n" "create a copy of the image in your account.\nThe copy of the source OMI is \n" "independent and belongs to you.\n\nYou can also use this method to register an \n" "OMI to finalize its creation process.\nYou can register an OMI from a snapshot \n" "of a root device to create an OMI based on this snapshot. You can also register \n" "an OMI that has been exported to an S3-compatible bucket to create a copy of it \n" "in your account. For more information about OMI export to an OOS bucket, see \n" "[CreateImageExportTask](#createimageexporttask).\nYou can register an OMI using \n" "a pre-signed URL of the manifest file of the OMI. You do not need any \n" "permission for this OMI, or the bucket in which it is contained. The manifest \n" "file is obsolete seven days after a completed export as it contains pre-signed \n" "URLs to the appropriate snapshots (pre-signed URLs are valid for only seven \n" "days).\nOnce the OMI is registered, you can launch a VM from this OMI. The copy \n" "of the source OMI is independent and belongs to you.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli CreateFlexibleGpu [options]\n" "Allocates a flexible GPU (fGPU) to your account.\nYou can then attach this fGPU \n" "to a virtual machine (VM).\n" "\nRequired Argument: ModelName, SubregionName \n"
,
	"Usage: oapi-cli CreateDirectLinkInterface [options]\n" "Creates a DirectLink interface.\nDirectLink interfaces enable you to reach one \n" "of your Nets through a virtual gateway.\n" "\nRequired Argument: DirectLinkId, DirectLinkInterface \n"
,
	"Usage: oapi-cli CreateDirectLink [options]\n" "Creates a DirectLink between a customer network and a specified DirectLink \n" "location.\n" "\nRequired Argument: Bandwidth, DirectLinkName, Location \n"
,
	"Usage: oapi-cli CreateDhcpOptions [options]\n" "Creates a set of DHCP options, that you can then associate with a Net using the \n" "[UpdateNet](#updatenet) method.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli CreateClientGateway [options]\n" "Provides information about your client gateway.\nThis action registers \n" "information to identify the client gateway that you deployed in your \n" "network.\nTo open a tunnel to the client gateway, you must provide the \n" "communication protocol type, the fixed public IP of the gateway, and an \n" "Autonomous System Number (ASN).\n" "\nRequired Argument: BgpAsn, PublicIp, ConnectionType \n"
,
	"Usage: oapi-cli CreateCa [options]\n" "Creates a Client Certificate Authority (CA).\n" "\nRequired Argument: CaPem \n"
,
	"Usage: oapi-cli CreateApiAccessRule [options]\n" "Creates a rule to allow access to the API from your account.\nYou need to \n" "specify at least the `CaIds` or the `IpRanges` parameter.\n\n**[NOTE]**\nBy \n" "default, your account has a set of rules allowing global access that you can \n" "delete. For more information, see [About API Access \n" "Rules](https://docs.outscale.com/en/userguide/About-API-Access-Rules.html).\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli CreateAccount [options]\n" "Creates an OUTSCALE account.\n\n**[NOTE]**\n* You need OUTSCALE credentials and \n" "the appropriate quotas to create an account via API. To get quotas, you can \n" "send an email to sales@outscale.com.\n* If you want to pass a numeral value as \n" "a string instead of an integer, you must wrap your string in additional quotes \n" "(for example, `'&quot;92000&quot;'`).\n" "\nRequired Argument: City, CompanyName, Country, CustomerId, Email, FirstName, LastName, ZipCode \n"
,
	"Usage: oapi-cli CreateAccessKey [options]\n" "Creates an access key for your account. The new key is automatically set to \n" "`ACTIVE`.\n" "\nRequired Argument: none \n"
,
	"Usage: oapi-cli CheckAuthentication [options]\n" "Validates the authenticity of the account.\n" "\nRequired Argument: Login, Password \n"
,
	"Usage: oapi-cli AcceptNetPeering [options]\n" "Accepts a Net peering request.\nTo accept this request, you must be the owner \n" "of the peer Net. If you do not accept the request within 7 days, the state of \n" "the Net peering becomes `expired`.\n**[NOTE]**\nA peering connection between \n" "two Nets works both ways. Therefore, when an A-to-B peering connection is \n" "accepted, any pending B-to-A peering connection is automatically rejected as \n" "redundant.\n" "\nRequired Argument: NetPeeringId \n"
,
	NULL
};

static const char *calls_args_descriptions[] = {
	"ClientGatewayId: string\n"
	"	The ID of the client gateway.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VirtualGatewayId: string\n"
	"	The ID of the virtual gateway.\n"
"VpnConnectionId: string\n"
	"	The ID of the VPN connection you want to modify.\n"
"VpnOptions: ref VpnOptions\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Iops: int\n"
	"	The new number of I/O operations per second (IOPS). This parameter \n"
	"	can be specified only if you update an `io1` volume. The maximum \n"
	"	number of IOPS allowed for `io1` volumes is `13000` with a maximum \n"
	"	performance ratio of 300 IOPS per gibibyte. This modification is \n"
	"	instantaneous on a cold volume, not on a hot one.\n"
"Size: int\n"
	"	(cold volume only) The new size of the volume, in gibibytes (GiB). \n"
	"	This value must be equal to or greater than the current size of the \n"
	"	volume. This modification is not instantaneous.\n"
"VolumeId: string\n"
	"	The ID of the volume you want to update.\n"
"VolumeType: string\n"
	"	(cold volume only) The new type of the volume (`standard` \\| `io1` \n"
	"	\\| `gp2`). This modification is instantaneous. If you update to an \n"
	"	`io1` volume, you must also specify the `Iops` parameter.\n"
,
	"BlockDeviceMappings: array ref BlockDeviceMappingVmUpdate\n"
	"	One or more block device mappings of the VM.\n"
"BsuOptimized: bool\n"
	"	This parameter is not available. It is present in our API for the \n"
	"	sake of historical compatibility with AWS.\n"
"DeletionProtection: bool\n"
	"	If true, you cannot delete the VM unless you change this parameter \n"
	"	back to false.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"IsSourceDestChecked: bool\n"
	"	(Net only) If true, the source/destination check is enabled. If \n"
	"	false, it is disabled. This value must be false for a NAT VM to \n"
	"	perform network address translation (NAT) in a Net.\n"
"KeypairName: string\n"
	"	The name of the keypair.\nTo complete the replacement, manually \n"
	"	replace the old public key with the new public key in the \n"
	"	~/.ssh/authorized_keys file located in the VM. Restart the VM to \n"
	"	apply the change.\n"
"NestedVirtualization: bool\n"
	"	(dedicated tenancy only) If true, nested virtualization is enabled. \n"
	"	If false, it is disabled.\n"
"Performance: string\n"
	"	The performance of the VM (`medium` \\| `high` \\|  `highest`).\n"
"SecurityGroupIds: array string\n"
	"	One or more IDs of security groups for the VM.\n"
"UserData: string\n"
	"	The Base64-encoded MIME user data, limited to 500 kibibytes (KiB).\n"
"VmId: string\n"
	"	The ID of the VM.\n"
"VmInitiatedShutdownBehavior: string\n"
	"	The VM behavior when you stop it. If set to `stop`, the VM stops. If \n"
	"	set to `restart`, the VM stops then automatically restarts. If set to \n"
	"	`terminate`, the VM stops and is terminated.\n"
"VmType: string\n"
	"	The type of VM. For more information, see [Instance \n"
	"	Types](https://docs.outscale.com/en/userguide/Instance-Types.html).\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"MapPublicIpOnLaunch: bool\n"
	"	If true, a public IP is assigned to the network interface cards \n"
	"	(NICs) created in the specified Subnet.\n"
"SubnetId: string\n"
	"	The ID of the Subnet.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"PermissionsToCreateVolume: ref PermissionsOnResourceCreation\n"
	"	null\n"
"SnapshotId: string\n"
	"	The ID of the snapshot.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Name: string\n"
	"	The name of the server certificate you want to modify.\n"
"NewName: string\n"
	"	A new name for the server certificate.\n"
"NewPath: string\n"
	"	A new path for the server certificate.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Enable: bool\n"
	"	If true, a virtual gateway can propagate routes to a specified route \n"
	"	table of a Net. If false, the propagation is disabled.\n"
"RouteTableId: string\n"
	"	The ID of the route table.\n"
"VirtualGatewayId: string\n"
	"	The ID of the virtual gateway.\n"
,
	"DestinationIpRange: string\n"
	"	The IP range used for the destination match, in CIDR notation (for \n"
	"	example, `10.0.0.0/24`).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"GatewayId: string\n"
	"	The ID of an Internet service or virtual gateway attached to your Net.\n"
"NatServiceId: string\n"
	"	The ID of a NAT service.\n"
"NetPeeringId: string\n"
	"	The ID of a Net peering.\n"
"NicId: string\n"
	"	The ID of a network interface card (NIC).\n"
"RouteTableId: string\n"
	"	The ID of the route table.\n"
"VmId: string\n"
	"	The ID of a NAT VM in your Net.\n"
,
	"Description: string\n"
	"	A new description for the NIC.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LinkNic: ref LinkNicToUpdate\n"
	"	null\n"
"NicId: string\n"
	"	The ID of the NIC you want to modify.\n"
"SecurityGroupIds: array string\n"
	"	One or more IDs of security groups for the NIC.\nYou must specify at \n"
	"	least one group, even if you use the default security group in the \n"
	"	Net.\n"
,
	"AddRouteTableIds: array string\n"
	"	One or more IDs of route tables to associate with the specified Net \n"
	"	access point.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetAccessPointId: string\n"
	"	The ID of the Net access point.\n"
"RemoveRouteTableIds: array string\n"
	"	One or more IDs of route tables to disassociate from the specified \n"
	"	Net access point.\n"
,
	"DhcpOptionsSetId: string\n"
	"	The ID of the DHCP options set (or `default` if you want to associate \n"
	"	the default one).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetId: string\n"
	"	The ID of the Net.\n"
,
	"AccessLog: ref AccessLog\n"
	"	null\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"HealthCheck: ref HealthCheck\n"
	"	null\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer.\n"
"LoadBalancerPort: int\n"
	"	The port on which the load balancer is listening (between `1` and \n"
	"	`65535`, both included). This parameter is required if you want to \n"
	"	update the server certificate.\n"
"PolicyNames: array string\n"
	"	The name of the policy you want to enable for the listener.\n"
"PublicIp: string\n"
	"	(internet-facing only) The public IP you want to associate with the \n"
	"	load balancer. The former public IP of the load balancer is then \n"
	"	disassociated. If you specify an empty string and the former public \n"
	"	IP belonged to you, it is disassociated and replaced by a public IP \n"
	"	owned by 3DS OUTSCALE.\n"
"SecuredCookies: bool\n"
	"	If true, secure cookies are enabled for the load balancer.\n"
"SecurityGroups: array string\n"
	"	(Net only) One or more IDs of security groups you want to assign to \n"
	"	the load balancer. You need to specify the already assigned security \n"
	"	groups that you want to keep along with the new ones you are \n"
	"	assigning. If the list is empty, the default security group of the \n"
	"	Net is assigned to the load balancer.\n"
"ServerCertificateId: string\n"
	"	The Outscale Resource Name (ORN) of the server certificate. For more \n"
	"	information, see [Resource Identifiers > Outscale Resource Names \n"
	"	(ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.ht\n"
	"	ml#_outscale_resource_names_orns). If this parameter is specified, \n"
	"	you must also specify the `LoadBalancerPort` parameter.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"HostPattern: string\n"
	"	A host-name pattern for the rule, with a maximum length of 128 \n"
	"	characters. This host-name pattern supports maximum three wildcards, \n"
	"	and must not contain any special characters except [-.?].\n"
"ListenerRuleName: string\n"
	"	The name of the listener rule.\n"
"PathPattern: string\n"
	"	A path pattern for the rule, with a maximum length of 128 characters. \n"
	"	This path pattern supports maximum three wildcards, and must not \n"
	"	contain any special characters except [_-.$/~&quot;'@:+?].\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ImageId: string\n"
	"	The ID of the OMI you want to modify.\n"
"PermissionsToLaunch: ref PermissionsOnResourceCreation\n"
	"	null\n"
,
	"DeleteOnVmDeletion: bool\n"
	"	If true, the fGPU is deleted when the VM is terminated.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"FlexibleGpuId: string\n"
	"	The ID of the fGPU you want to modify.\n"
,
	"DirectLinkInterfaceId: string\n"
	"	The ID of the DirectLink interface you want to update.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Mtu: int\n"
	"	The maximum transmission unit (MTU) of the DirectLink interface, in \n"
	"	bytes (either `1500` or `9000`).\n"
,
	"CaId: string\n"
	"	The ID of the CA.\n"
"Description: string\n"
	"	The description of the CA.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"ApiAccessRuleId: string\n"
	"	The ID of the API access rule you want to update.\n"
"CaIds: array string\n"
	"	One or more IDs of Client Certificate Authorities (CAs).\n"
"Cns: array string\n"
	"	One or more Client Certificate Common Names (CNs).\n"
"Description: string\n"
	"	A new description for the API access rule.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"IpRanges: array string\n"
	"	One or more IP addresses or CIDR blocks (for example, `192.0.2.0/16`).\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"MaxAccessKeyExpirationSeconds: int\n"
	"	The maximum possible lifetime for your access keys, in seconds \n"
	"	(between `0` and `3153600000`, both included). If set to `O`, your \n"
	"	access keys can have unlimited lifetimes, but a trusted session \n"
	"	cannot be activated. Otherwise, all your access keys must have an \n"
	"	expiration date. This value must be greater than the remaining \n"
	"	lifetime of each access key of your account.\n"
"RequireTrustedEnv: bool\n"
	"	If true, a trusted session is activated, provided that you specify \n"
	"	the `MaxAccessKeyExpirationSeconds` parameter with a value greater \n"
	"	than `0`.\n"
,
	"AdditionalEmails: array string\n"
	"	One or more additional email addresses for the account. These \n"
	"	addresses are used for notifications only. If you already have a list \n"
	"	of additional emails registered, you cannot add to it, only replace \n"
	"	it. To remove all registered additional emails, specify an empty list.\n"
"City: string\n"
	"	The new city of the account owner.\n"
"CompanyName: string\n"
	"	The new name of the company for the account.\n"
"Country: string\n"
	"	The new country of the account owner.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Email: string\n"
	"	The main email address for the account. This address is used for your \n"
	"	credentials and notifications.\n"
"FirstName: string\n"
	"	The new first name of the account owner.\n"
"JobTitle: string\n"
	"	The new job title of the account owner.\n"
"LastName: string\n"
	"	The new last name of the account owner.\n"
"MobileNumber: string\n"
	"	The new mobile phone number of the account owner.\n"
"PhoneNumber: string\n"
	"	The new landline phone number of the account owner.\n"
"StateProvince: string\n"
	"	The new state/province of the account owner.\n"
"VatNumber: string\n"
	"	The new value added tax (VAT) number for the account.\n"
"ZipCode: string\n"
	"	The new ZIP code of the city.\n"
,
	"AccessKeyId: string\n"
	"	The ID of the access key.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ExpirationDate: string\n"
	"	The date and time at which you want the access key to expire, in ISO \n"
	"	8601 format (for example, `2017-06-14` or `2017-06-14T00:00:00Z`). If \n"
	"	not specified, the access key is set to not expire.\n"
"State: string\n"
	"	The new state for the access key (`ACTIVE` \\| `INACTIVE`). When set \n"
	"	to `ACTIVE`, the access key is enabled and can be used to send \n"
	"	requests. When set to `INACTIVE`, the access key is disabled.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ForceUnlink: bool\n"
	"	Forces the detachment of the volume in case of previous failure. \n"
	"	Important: This action may damage your data or file systems.\n"
"VolumeId: string\n"
	"	The ID of the volume you want to detach.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetId: string\n"
	"	The ID of the Net from which you want to detach the virtual gateway.\n"
"VirtualGatewayId: string\n"
	"	The ID of the virtual gateway.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LinkRouteTableId: string\n"
	"	The ID of the association between the route table and the Subnet.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LinkPublicIpId: string\n"
	"	The ID representing the association of the public IP with the VM or \n"
	"	the NIC. This parameter is required unless you use the `PublicIp` \n"
	"	parameter.\n"
"PublicIp: string\n"
	"	The public IP. This parameter is required unless you use the \n"
	"	`LinkPublicIpId` parameter.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NicId: string\n"
	"	The ID of the NIC.\n"
"PrivateIps: array string\n"
	"	One or more secondary private IPs you want to unassign from the NIC.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LinkNicId: string\n"
	"	The ID of the attachment operation.\n"
,
	"BackendIps: array string\n"
	"	 One or more public IPs of back-end VMs.\n"
"BackendVmIds: array string\n"
	"	 One or more IDs of back-end VMs.\n"
"DryRun: bool\n"
	"	 If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	 The name of the load balancer.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"InternetServiceId: string\n"
	"	The ID of the Internet service you want to detach.\n"
"NetId: string\n"
	"	The ID of the Net from which you want to detach the Internet service.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"FlexibleGpuId: string\n"
	"	The ID of the fGPU you want to detach from your VM.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ForceStop: bool\n"
	"	Forces the VM to stop.\n"
"VmIds: array string\n"
	"	One or more IDs of VMs.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VmIds: array string\n"
	"	One or more IDs of VMs.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Email: string\n"
	"	The email address provided for the account.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Password: string\n"
	"	The new password for the account.\n"
"Token: string\n"
	"	The token you received at the email address provided for the account.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetPeeringId: string\n"
	"	The ID of the Net peering you want to reject.\n"
,
	"BackendVmIds: array string\n"
	"	One or more IDs of back-end VMs.\nSpecifying the same ID several \n"
	"	times has no effect as each back-end VM has equal weight.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VmIds: array string\n"
	"	One or more IDs of the VMs you want to reboot.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersVpnConnection\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersVolume\n"
	"	null\n"
,
	"AllVms: bool\n"
	"	If true, includes the status of all VMs. By default or if set to \n"
	"	false, only includes the status of running VMs.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersVmsState\n"
	"	null\n"
,
	"BackendVmIds: array string\n"
	"	One or more IDs of back-end VMs.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersVm\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersVmType\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersVirtualGateway\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersTag\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersSubregion\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersSubnet\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersSnapshot\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersExportTask\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersServerCertificate\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersSecurityGroup\n"
	"	null\n"
,
	"AccessKeyId: string\n"
	"	The ID of the access key.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersRouteTable\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersQuota\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersPublicIp\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersProductType\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersNic\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersNet\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersNetPeering\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersNetAccessPoint\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersService\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersNatService\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersLoadBalancer\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerNames: array string\n"
	"	One or more load balancer names.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersListenerRule\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersKeypair\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersInternetService\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersImage\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersExportTask\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersFlexibleGpu\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersDirectLink\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersDirectLinkInterface\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersDhcpOptions\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"FromDate: string\n"
	"	The beginning of the time period, in ISO 8601 date-time format (for \n"
	"	example, `2017-06-14` or `2017-06-14T00:00:00Z`).\n"
"Overall: bool\n"
	"	By default or if false, returns only the consumption of the specific \n"
	"	account that sends this request. If true, returns either the overall \n"
	"	consumption of your paying account and all linked accounts (if the \n"
	"	account that sends this request is a paying account) or returns \n"
	"	nothing (if the account that sends this request is a linked account).\n"
"ToDate: string\n"
	"	The end of the time period, in ISO 8601 date-time format (for \n"
	"	example, `2017-06-30` or `2017-06-30T00:00:00Z`).\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VmId: string\n"
	"	The ID of the VM.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersClientGateway\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersCa\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersApiLog\n"
	"	null\n"
"NextPageToken: string\n"
	"	The token to request the next page of results. Each token refers to a \n"
	"	specific page.\n"
"ResultsPerPage: int\n"
	"	The maximum number of logs returned in a single response (between \n"
	"	`1`and `1000`, both included). By default, `100`.\n"
"With: ref With\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersApiAccessRule\n"
	"	null\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VmId: string\n"
	"	The ID of the VM.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Filters: ref FiltersAccessKeys\n"
	"	null\n"
,
	"DeviceName: string\n"
	"	The name of the device. For a root device, you must use `/dev/sda1`. \n"
	"	For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, \n"
	"	or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, \n"
	"	and the second `X` is a letter between `a` and `z`).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VmId: string\n"
	"	The ID of the VM you want to attach the volume to.\n"
"VolumeId: string\n"
	"	The ID of the volume you want to attach.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetId: string\n"
	"	The ID of the Net to which you want to attach the virtual gateway.\n"
"VirtualGatewayId: string\n"
	"	The ID of the virtual gateway.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"RouteTableId: string\n"
	"	The ID of the route table.\n"
"SubnetId: string\n"
	"	The ID of the Subnet.\n"
,
	"AllowRelink: bool\n"
	"	If true, allows the public IP to be associated with the VM or NIC \n"
	"	that you specify even if it is already associated with another VM or \n"
	"	NIC. If false, prevents the EIP from being associated with the VM or \n"
	"	NIC that you specify if it is already associated with another VM or \n"
	"	NIC. (By default, true in the public Cloud, false in a Net.)\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NicId: string\n"
	"	(Net only) The ID of the NIC. This parameter is required if the VM \n"
	"	has more than one NIC attached. Otherwise, you need to specify the \n"
	"	`VmId` parameter instead. You cannot specify both parameters at the \n"
	"	same time.\n"
"PrivateIp: string\n"
	"	(Net only) The primary or secondary private IP of the specified NIC. \n"
	"	By default, the primary private IP.\n"
"PublicIp: string\n"
	"	The public IP. This parameter is required unless you use the \n"
	"	`PublicIpId` parameter.\n"
"PublicIpId: string\n"
	"	The allocation ID of the public IP. This parameter is required unless \n"
	"	you use the `PublicIp` parameter.\n"
"VmId: string\n"
	"	The ID of the VM.\n- In the public Cloud, this parameter is \n"
	"	required.\n- In a Net, this parameter is required if the VM has only \n"
	"	one NIC. Otherwise, you need to specify the `NicId` parameter \n"
	"	instead. You cannot specify both parameters at the same time.\n"
,
	"AllowRelink: bool\n"
	"	If true, allows an IP that is already assigned to another NIC in the \n"
	"	same Subnet to be assigned to the NIC you specified.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NicId: string\n"
	"	The ID of the NIC.\n"
"PrivateIps: array string\n"
	"	The secondary private IP or IPs you want to assign to the NIC within \n"
	"	the IP range of the Subnet.\n"
"SecondaryPrivateIpCount: int\n"
	"	The number of secondary private IPs to assign to the NIC.\n"
,
	"DeviceNumber: int\n"
	"	The index of the VM device for the NIC attachment (between `1` and \n"
	"	`7`, both included).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NicId: string\n"
	"	The ID of the NIC you want to attach.\n"
"VmId: string\n"
	"	The ID of the VM to which you want to attach the NIC.\n"
,
	"BackendIps: array string\n"
	"	 One or more public IPs of back-end VMs.\n"
"BackendVmIds: array string\n"
	"	 One or more IDs of back-end VMs.\n"
"DryRun: bool\n"
	"	 If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	 The name of the load balancer. \n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"InternetServiceId: string\n"
	"	The ID of the Internet service you want to attach.\n"
"NetId: string\n"
	"	The ID of the Net to which you want to attach the Internet service.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"FlexibleGpuId: string\n"
	"	The ID of the fGPU you want to attach.\n"
"VmId: string\n"
	"	The ID of the VM you want to attach the fGPU to.\n"
,
	"BackendVmIds: array string\n"
	"	One or more IDs of back-end VMs.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer.\n"
,
	"DestinationIpRange: string\n"
	"	The network prefix of the route to delete, in CIDR notation (for \n"
	"	example, `10.12.0.0/16`).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VpnConnectionId: string\n"
	"	The ID of the target VPN connection of the static route to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VpnConnectionId: string\n"
	"	The ID of the VPN connection you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VolumeId: string\n"
	"	The ID of the volume you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VmIds: array string\n"
	"	One or more IDs of VMs.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VirtualGatewayId: string\n"
	"	The ID of the virtual gateway you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ResourceIds: array string\n"
	"	One or more resource IDs.\n"
"Tags: array ref ResourceTag\n"
	"	One or more tags to delete (if you set a tag value, only the tags \n"
	"	matching exactly this value are deleted).\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"SubnetId: string\n"
	"	The ID of the Subnet you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"SnapshotId: string\n"
	"	The ID of the snapshot you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Name: string\n"
	"	The name of the server certificate you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Flow: string\n"
	"	The direction of the flow: `Inbound` or `Outbound`. You can specify \n"
	"	`Outbound` for Nets only.\n"
"FromPortRange: int\n"
	"	The beginning of the port range for the TCP and UDP protocols, or an \n"
	"	ICMP type number.\n"
"IpProtocol: string\n"
	"	The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all \n"
	"	protocols). By default, `-1`. In a Net, this can also be an IP \n"
	"	protocol number. For more information, see the [IANA.org \n"
	"	website](https://www.iana.org/assignments/protocol-numbers/protocol-nu\n"
	"	mbers.xhtml).\n"
"IpRange: string\n"
	"	The IP range for the security group rule, in CIDR notation (for \n"
	"	example, `10.0.0.0/16`).\n"
"Rules: array ref SecurityGroupRule\n"
	"	One or more rules you want to delete from the security group.\n"
"SecurityGroupAccountIdToUnlink: string\n"
	"	The account ID of the owner of the security group you want to delete \n"
	"	a rule from.\n"
"SecurityGroupId: string\n"
	"	The ID of the security group you want to delete a rule from.\n"
"SecurityGroupNameToUnlink: string\n"
	"	The ID of the source security group. If you are in the Public Cloud, \n"
	"	you can also specify the name of the source security group.\n"
"ToPortRange: int\n"
	"	The end of the port range for the TCP and UDP protocols, or an ICMP \n"
	"	code number.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"SecurityGroupId: string\n"
	"	The ID of the security group you want to delete.\n"
"SecurityGroupName: string\n"
	"	The name of the security group.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"RouteTableId: string\n"
	"	The ID of the route table you want to delete.\n"
,
	"DestinationIpRange: string\n"
	"	The exact IP range for the route.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"RouteTableId: string\n"
	"	The ID of the route table from which you want to delete a route.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"PublicIp: string\n"
	"	The public IP. In the public Cloud, this parameter is required.\n"
"PublicIpId: string\n"
	"	The ID representing the association of the public IP with the VM or \n"
	"	the NIC. In a Net, this parameter is required.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NicId: string\n"
	"	The ID of the NIC you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetPeeringId: string\n"
	"	The ID of the Net peering you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetAccessPointId: string\n"
	"	The ID of the Net access point.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetId: string\n"
	"	The ID of the Net you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NatServiceId: string\n"
	"	The ID of the NAT service you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerNames: array string\n"
	"	One or more load balancer names.\n"
"Tags: array ref ResourceLoadBalancerTag\n"
	"	One or more tags to delete from the load balancers.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer for which you want to delete a policy.\n"
"PolicyName: string\n"
	"	The name of the policy you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer for which you want to delete listeners.\n"
"LoadBalancerPorts: array integer\n"
	"	One or more port numbers of the listeners you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ListenerRuleName: string\n"
	"	The name of the rule you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"KeypairName: string\n"
	"	The name of the keypair you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"InternetServiceId: string\n"
	"	The ID of the Internet service you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ImageId: string\n"
	"	The ID of the OMI you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"FlexibleGpuId: string\n"
	"	The ID of the fGPU you want to delete.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ExportTaskId: string\n"
	"	The ID of the export task to delete.\n"
,
	"DirectLinkInterfaceId: string\n"
	"	The ID of the DirectLink interface you want to delete.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DirectLinkId: string\n"
	"	The ID of the DirectLink you want to delete.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DhcpOptionsSetId: string\n"
	"	The ID of the DHCP options set you want to delete.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"ClientGatewayId: string\n"
	"	The ID of the client gateway you want to delete.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"CaId: string\n"
	"	The ID of the CA you want to delete.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"ApiAccessRuleId: string\n"
	"	The ID of the API access rule you want to delete.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"AccessKeyId: string\n"
	"	The ID of the access key you want to delete.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DestinationIpRange: string\n"
	"	The network prefix of the route, in CIDR notation (for example, \n"
	"	`10.12.0.0/16`).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"VpnConnectionId: string\n"
	"	The ID of the target VPN connection of the static route.\n"
,
	"ClientGatewayId: string\n"
	"	The ID of the client gateway.\n"
"ConnectionType: string\n"
	"	The type of VPN connection (only `ipsec.1` is supported).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"StaticRoutesOnly: bool\n"
	"	If false, the VPN connection uses dynamic routing with Border Gateway \n"
	"	Protocol (BGP). If true, routing is controlled using static routes. \n"
	"	For more information about how to create and delete static routes, \n"
	"	see [CreateVpnConnectionRoute](#createvpnconnectionroute) and \n"
	"	[DeleteVpnConnectionRoute](#deletevpnconnectionroute).\n"
"VirtualGatewayId: string\n"
	"	The ID of the virtual gateway.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Iops: int\n"
	"	The number of I/O operations per second (IOPS). This parameter must \n"
	"	be specified only if you create an `io1` volume. The maximum number \n"
	"	of IOPS allowed for `io1` volumes is `13000` with a maximum \n"
	"	performance ratio of 300 IOPS per gibibyte.\n"
"Size: int\n"
	"	The size of the volume, in gibibytes (GiB). The maximum allowed size \n"
	"	for a volume is 14901 GiB. This parameter is required if the volume \n"
	"	is not created from a snapshot (`SnapshotId` unspecified). \n"
"SnapshotId: string\n"
	"	The ID of the snapshot from which you want to create the volume.\n"
"SubregionName: string\n"
	"	The Subregion in which you want to create the volume.\n"
"VolumeType: string\n"
	"	The type of volume you want to create (`io1` \\| `gp2` \\| \n"
	"	`standard`). If not specified, a `standard` volume is created.\nFor \n"
	"	more information about volume types, see [About Volumes > Volume \n"
	"	Types and \n"
	"	IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volum\n"
	"	e_types_and_iops).\n"
,
	"BlockDeviceMappings: array ref BlockDeviceMappingVmCreation\n"
	"	One or more block device mappings.\n"
"BootOnCreation: bool\n"
	"	By default or if true, the VM is started on creation. If false, the \n"
	"	VM is stopped on creation.\n"
"BsuOptimized: bool\n"
	"	This parameter is not available. It is present in our API for the \n"
	"	sake of historical compatibility with AWS.\n"
"ClientToken: string\n"
	"	A unique identifier which enables you to manage the idempotency.\n"
"DeletionProtection: bool\n"
	"	If true, you cannot delete the VM unless you change this parameter \n"
	"	back to false.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ImageId: string\n"
	"	The ID of the OMI used to create the VM. You can find the list of \n"
	"	OMIs by calling the [ReadImages](#readimages) method.\n"
"KeypairName: string\n"
	"	The name of the keypair.\n"
"MaxVmsCount: int\n"
	"	The maximum number of VMs you want to create. If all the VMs cannot \n"
	"	be created, the largest possible number of VMs above MinVmsCount is \n"
	"	created.\n"
"MinVmsCount: int\n"
	"	The minimum number of VMs you want to create. If this number of VMs \n"
	"	cannot be created, no VMs are created.\n"
"NestedVirtualization: bool\n"
	"	(dedicated tenancy only) If true, nested virtualization is enabled. \n"
	"	If false, it is disabled.\n"
"Nics: array ref NicForVmCreation\n"
	"	One or more NICs. If you specify this parameter, you must not specify \n"
	"	the `SubnetId` and `SubregionName` parameters. You also must define \n"
	"	one NIC as the primary network interface of the VM with `0` as its \n"
	"	device number.\n"
"Performance: string\n"
	"	The performance of the VM (`medium` \\| `high` \\|  `highest`). By \n"
	"	default, `high`. This parameter is ignored if you specify a \n"
	"	performance flag directly in the `VmType` parameter.\n"
"Placement: ref Placement\n"
	"	null\n"
"PrivateIps: array string\n"
	"	One or more private IPs of the VM.\n"
"SecurityGroupIds: array string\n"
	"	One or more IDs of security group for the VMs.\n"
"SecurityGroups: array string\n"
	"	One or more names of security groups for the VMs.\n"
"SubnetId: string\n"
	"	The ID of the Subnet in which you want to create the VM. If you \n"
	"	specify this parameter, you must not specify the `Nics` parameter.\n"
"UserData: string\n"
	"	Data or script used to add a specific configuration to the VM. It \n"
	"	must be Base64-encoded and is limited to 500 kibibytes (KiB).\n"
"VmInitiatedShutdownBehavior: string\n"
	"	The VM behavior when you stop it. By default or if set to `stop`, the \n"
	"	VM stops. If set to `restart`, the VM stops then automatically \n"
	"	restarts. If set to `terminate`, the VM stops and is terminated.\n"
"VmType: string\n"
	"	The type of VM. You can specify a TINA type (in the `tinavW.cXrYpZ` \n"
	"	or `tinavW.cXrY` format), or an AWS type (for example, `t2.small`, \n"
	"	which is the default value).\nIf you specify an AWS type, it is \n"
	"	converted in the background to its corresponding TINA type, but the \n"
	"	AWS type is still returned. If the specified or converted TINA type \n"
	"	includes a performance flag, this performance flag is applied \n"
	"	regardless of the value you may have provided in the `Performance` \n"
	"	parameter. For more information, see [Instance \n"
	"	Types](https://docs.outscale.com/en/userguide/Instance-Types.html).\n"
,
	"ConnectionType: string\n"
	"	The type of VPN connection supported by the virtual gateway (only \n"
	"	`ipsec.1` is supported).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ResourceIds: array string\n"
	"	One or more resource IDs.\n"
"Tags: array ref ResourceTag\n"
	"	One or more tags to add to the specified resources.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"IpRange: string\n"
	"	The IP range in the Subnet, in CIDR notation (for example, \n"
	"	`10.0.0.0/16`).\nThe IP range of the Subnet can be either the same as \n"
	"	the Net one if you create only a single Subnet in this Net, or a \n"
	"	subset of the Net one. In case of several Subnets in a Net, their IP \n"
	"	ranges must not overlap. The smallest Subnet you can create uses a \n"
	"	/29 netmask (eight IPs). For more information, see [About \n"
	"	VPCs](https://docs.outscale.com/en/userguide/About-VPCs.html).\n"
"NetId: string\n"
	"	The ID of the Net for which you want to create a Subnet.\n"
"SubregionName: string\n"
	"	The name of the Subregion in which you want to create the Subnet.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"OsuExport: ref OsuExportToCreate\n"
	"	null\n"
"SnapshotId: string\n"
	"	The ID of the snapshot to export.\n"
,
	"Description: string\n"
	"	A description for the snapshot.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"FileLocation: string\n"
	"	(When importing) The pre-signed URL of the snapshot you want to \n"
	"	import, or the normal URL of the snapshot if you have permission on \n"
	"	the OOS bucket. For more information, see [Configuring a Pre-signed \n"
	"	URL](https://docs.outscale.com/en/userguide/Configuring-a-Pre-signed-U\n"
	"	RL.html) or [Managing Access to Your Buckets and \n"
	"	Objects](https://docs.outscale.com/en/userguide/Managing-Access-to-You\n"
	"	r-Buckets-and-Objects.html).\n"
"SnapshotSize: int\n"
	"	(When importing) The size of the snapshot you want to create in your \n"
	"	account, in bytes. This size must be greater than or equal to the \n"
	"	size of the original, uncompressed snapshot.\n"
"SourceRegionName: string\n"
	"	(When copying) The name of the source Region, which must be the same \n"
	"	as the Region of your account.\n"
"SourceSnapshotId: string\n"
	"	(When copying) The ID of the snapshot you want to copy.\n"
"VolumeId: string\n"
	"	(When creating) The ID of the volume you want to create a snapshot of.\n"
,
	"Body: string\n"
	"	The PEM-encoded X509 certificate.With OSC CLI, use the following \n"
	"	syntax to make sure your CA file is correctly parsed: \n"
	"	`--CaPem=&quot;$(cat FILENAME)&quot;`.\n"
"Chain: string\n"
	"	The PEM-encoded intermediate certification authorities.With OSC CLI, \n"
	"	use the following syntax to make sure your CA file is correctly \n"
	"	parsed: `--CaPem=&quot;$(cat FILENAME)&quot;`.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Name: string\n"
	"	A unique name for the certificate. Constraints: 1-128 alphanumeric \n"
	"	characters, pluses (+), equals (=), commas (,), periods (.), at signs \n"
	"	(@), minuses (-), or underscores (_).\n"
"Path: string\n"
	"	The path to the server certificate, set to a slash (/) if not \n"
	"	specified.\n"
"PrivateKey: string\n"
	"	The PEM-encoded private key matching the certificate.With OSC CLI, \n"
	"	use the following syntax to make sure your CA file is correctly \n"
	"	parsed: `--CaPem=&quot;$(cat FILENAME)&quot;`.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Flow: string\n"
	"	The direction of the flow: `Inbound` or `Outbound`. You can specify \n"
	"	`Outbound` for Nets only.\n"
"FromPortRange: int\n"
	"	The beginning of the port range for the TCP and UDP protocols, or an \n"
	"	ICMP type number. If you specify this parameter, you cannot specify \n"
	"	the `Rules` parameter and its subparameters.\n"
"IpProtocol: string\n"
	"	The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all \n"
	"	protocols). By default, `-1`. In a Net, this can also be an IP \n"
	"	protocol number. For more information, see the [IANA.org \n"
	"	website](https://www.iana.org/assignments/protocol-numbers/protocol-nu\n"
	"	mbers.xhtml). If you specify this parameter, you cannot specify the \n"
	"	`Rules` parameter and its subparameters.\n"
"IpRange: string\n"
	"	The IP range for the security group rule, in CIDR notation (for \n"
	"	example, 10.0.0.0/16). If you specify this parameter, you cannot \n"
	"	specify the `Rules` parameter and its subparameters.\n"
"Rules: array ref SecurityGroupRule\n"
	"	Information about the security group rule to create. If you specify \n"
	"	this parent parameter and its subparameters, you cannot specify the \n"
	"	following parent parameters: `FromPortRange`, `IpProtocol`, \n"
	"	`IpRange`, and `ToPortRange`.\n"
"SecurityGroupAccountIdToLink: string\n"
	"	The account ID of the owner of the security group for which you want \n"
	"	to create a rule.\n"
"SecurityGroupId: string\n"
	"	The ID of the security group for which you want to create a rule.\n"
"SecurityGroupNameToLink: string\n"
	"	The ID of the source security group. If you are in the Public Cloud, \n"
	"	you can also specify the name of the source security group.\n"
"ToPortRange: int\n"
	"	The end of the port range for the TCP and UDP protocols, or an ICMP \n"
	"	code number. If you specify this parameter, you cannot specify the \n"
	"	`Rules` parameter and its subparameters.\n"
,
	"Description: string\n"
	"	A description for the security group, with a maximum length of 255 \n"
	"	[ASCII printable \n"
	"	characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetId: string\n"
	"	The ID of the Net for the security group.\n"
"SecurityGroupName: string\n"
	"	The name of the security group.\nThis name must not start with \n"
	"	`sg-`.</br>\nThis name must be unique and contain between 1 and 255 \n"
	"	ASCII characters. Accented letters are not allowed.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetId: string\n"
	"	The ID of the Net for which you want to create a route table.\n"
,
	"DestinationIpRange: string\n"
	"	The IP range used for the destination match, in CIDR notation (for \n"
	"	example, `10.0.0.0/24`).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"GatewayId: string\n"
	"	The ID of an Internet service or virtual gateway attached to your Net.\n"
"NatServiceId: string\n"
	"	The ID of a NAT service.\n"
"NetPeeringId: string\n"
	"	The ID of a Net peering.\n"
"NicId: string\n"
	"	The ID of a NIC.\n"
"RouteTableId: string\n"
	"	The ID of the route table for which you want to create a route.\n"
"VmId: string\n"
	"	The ID of a NAT VM in your Net (attached to exactly one NIC).\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"Description: string\n"
	"	A description for the NIC.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"PrivateIps: array ref PrivateIpLight\n"
	"	The primary private IP for the NIC.\nThis IP must be within the IP \n"
	"	range of the Subnet that you specify with the `SubnetId` \n"
	"	attribute.\nIf you do not specify this attribute, a random private IP \n"
	"	is selected within the IP range of the Subnet.\n"
"SecurityGroupIds: array string\n"
	"	One or more IDs of security groups for the NIC.\n"
"SubnetId: string\n"
	"	The ID of the Subnet in which you want to create the NIC.\n"
,
	"AccepterNetId: string\n"
	"	The ID of the Net you want to connect with.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"SourceNetId: string\n"
	"	The ID of the Net you send the peering request from.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetId: string\n"
	"	The ID of the Net.\n"
"RouteTableIds: array string\n"
	"	One or more IDs of route tables to use for the connection.\n"
"ServiceName: string\n"
	"	The name of the service (in the format `com.outscale.region.service`).\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"IpRange: string\n"
	"	The IP range for the Net, in CIDR notation (for example, \n"
	"	`10.0.0.0/16`).\n"
"Tenancy: string\n"
	"	The tenancy options for the VMs (`default` if a VM created in a Net \n"
	"	can be launched with any tenancy, `dedicated` if it can be launched \n"
	"	with dedicated tenancy VMs running on single-tenant hardware).\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"PublicIpId: string\n"
	"	The allocation ID of the public IP to associate with the NAT \n"
	"	service.\nIf the public IP is already associated with another \n"
	"	resource, you must first disassociate it.\n"
"SubnetId: string\n"
	"	The ID of the Subnet in which you want to create the NAT service.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerNames: array string\n"
	"	One or more load balancer names.\n"
"Tags: array ref ResourceTag\n"
	"	One or more tags to add to the specified load balancers.\n"
,
	"CookieExpirationPeriod: int\n"
	"	The lifetime of the cookie, in seconds. If not specified, the default \n"
	"	value of this parameter is `1`, which means that the sticky session \n"
	"	lasts for the duration of the browser session.\n"
"CookieName: string\n"
	"	The name of the application cookie used for stickiness. This \n"
	"	parameter is required if you create a stickiness policy based on an \n"
	"	application-generated cookie.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer for which you want to create a policy.\n"
"PolicyName: string\n"
	"	The name of the policy. This name must be unique and consist of \n"
	"	alphanumeric characters and dashes (-).\n"
"PolicyType: string\n"
	"	The type of stickiness policy you want to create: `app` or \n"
	"	`load_balancer`.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Listeners: array ref ListenerForCreation\n"
	"	One or more listeners for the load balancer.\n"
"LoadBalancerName: string\n"
	"	The name of the load balancer for which you want to create listeners.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Listeners: array ref ListenerForCreation\n"
	"	One or more listeners to create.\n"
"LoadBalancerName: string\n"
	"	The unique name of the load balancer (32 alphanumeric or hyphen \n"
	"	characters maximum, but cannot start or end with a hyphen).\n"
"LoadBalancerType: string\n"
	"	The type of load balancer: `internet-facing` or `internal`. Use this \n"
	"	parameter only for load balancers in a Net.\n"
"PublicIp: string\n"
	"	(internet-facing only) The public IP you want to associate with the \n"
	"	load balancer. If not specified, a public IP owned by 3DS OUTSCALE is \n"
	"	associated.\n"
"SecurityGroups: array string\n"
	"	(Net only) One or more IDs of security groups you want to assign to \n"
	"	the load balancer. If not specified, the default security group of \n"
	"	the Net is assigned to the load balancer.\n"
"Subnets: array string\n"
	"	(Net only) The ID of the Subnet in which you want to create the load \n"
	"	balancer. Regardless of this Subnet, the load balancer can distribute \n"
	"	traffic to all Subnets. This parameter is required in a Net.\n"
"SubregionNames: array string\n"
	"	(public Cloud only) The Subregion in which you want to create the \n"
	"	load balancer. Regardless of this Subregion, the load balancer can \n"
	"	distribute traffic to all Subregions. This parameter is required in \n"
	"	the public Cloud.\n"
"Tags: array ref ResourceTag\n"
	"	One or more tags assigned to the load balancer.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Listener: ref LoadBalancerLight\n"
	"	null\n"
"ListenerRule: ref ListenerRuleForCreation\n"
	"	null\n"
"VmIds: array string\n"
	"	The IDs of the backend VMs.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"KeypairName: string\n"
	"	A unique name for the keypair, with a maximum length of 255 [ASCII \n"
	"	printable \n"
	"	characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\n"
"PublicKey: string\n"
	"	The public key. It must be Base64-encoded.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ImageId: string\n"
	"	The ID of the OMI to export.\n"
"OsuExport: ref OsuExportToCreate\n"
	"	null\n"
,
	"Architecture: string\n"
	"	The architecture of the OMI (by default, `i386` if you specified the \n"
	"	`FileLocation` or `RootDeviceName` parameter).\n"
"BlockDeviceMappings: array ref BlockDeviceMappingImage\n"
	"	One or more block device mappings.\n"
"Description: string\n"
	"	A description for the new OMI.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"FileLocation: string\n"
	"	The pre-signed URL of the OMI manifest file, or the full path to the \n"
	"	OMI stored in a bucket. If you specify this parameter, a copy of the \n"
	"	OMI is created in your account. You must specify only one of the \n"
	"	following parameters: `FileLocation`, `RootDeviceName`, \n"
	"	`SourceImageId` or `VmId`.\n"
"ImageName: string\n"
	"	A unique name for the new OMI.\nConstraints: 3-128 alphanumeric \n"
	"	characters, underscores (_), spaces ( ), parentheses (()), slashes \n"
	"	(/), periods (.), or dashes (-).\n"
"NoReboot: bool\n"
	"	If false, the VM shuts down before creating the OMI and then reboots. \n"
	"	If true, the VM does not.\n"
"RootDeviceName: string\n"
	"	The name of the root device. You must specify only one of the \n"
	"	following parameters: `FileLocation`, `RootDeviceName`, \n"
	"	`SourceImageId` or `VmId`.\n"
"SourceImageId: string\n"
	"	The ID of the OMI you want to copy. You must specify only one of the \n"
	"	following parameters: `FileLocation`, `RootDeviceName`, \n"
	"	`SourceImageId` or `VmId`.\n"
"SourceRegionName: string\n"
	"	The name of the source Region, which must be the same as the Region \n"
	"	of your account.\n"
"VmId: string\n"
	"	The ID of the VM from which you want to create the OMI. You must \n"
	"	specify only one of the following parameters: `FileLocation`, \n"
	"	`RootDeviceName`, `SourceImageId` or `VmId`.\n"
,
	"DeleteOnVmDeletion: bool\n"
	"	If true, the fGPU is deleted when the VM is terminated.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Generation: string\n"
	"	The processor generation that the fGPU must be compatible with. If \n"
	"	not specified, the oldest possible processor generation is selected \n"
	"	(as provided by [ReadFlexibleGpuCatalog](#readflexiblegpucatalog) for \n"
	"	the specified model of fGPU).\n"
"ModelName: string\n"
	"	The model of fGPU you want to allocate. For more information, see \n"
	"	[About Flexible \n"
	"	GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html)\n"
	"	.\n"
"SubregionName: string\n"
	"	The Subregion in which you want to create the fGPU.\n"
,
	"DirectLinkId: string\n"
	"	The ID of the existing DirectLink for which you want to create the \n"
	"	DirectLink interface.\n"
"DirectLinkInterface: ref DirectLinkInterface\n"
	"	null\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"Bandwidth: string\n"
	"	The bandwidth of the DirectLink (`1Gbps` \\| `10Gbps`).\n"
"DirectLinkName: string\n"
	"	The name of the DirectLink.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Location: string\n"
	"	The code of the requested location for the DirectLink, returned by \n"
	"	the [ReadLocations](#readlocations) method.\n"
,
	"DomainName: string\n"
	"	Specify a domain name (for example, `MyCompany.com`). You can specify \n"
	"	only one domain name. You must specify at least one of the following \n"
	"	parameters: `DomainName`, `DomainNameServers`, `LogServers`, or \n"
	"	`NtpServers`.\n"
"DomainNameServers: array string\n"
	"	The IPs of domain name servers. If no IPs are specified, the \n"
	"	`OutscaleProvidedDNS` value is set by default. You must specify at \n"
	"	least one of the following parameters: `DomainName`, \n"
	"	`DomainNameServers`, `LogServers`, or `NtpServers`.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"LogServers: array string\n"
	"	The IPs of the log servers. You must specify at least one of the \n"
	"	following parameters: `DomainName`, `DomainNameServers`, \n"
	"	`LogServers`, or `NtpServers`.\n"
"NtpServers: array string\n"
	"	The IPs of the Network Time Protocol (NTP) servers. You must specify \n"
	"	at least one of the following parameters: `DomainName`, \n"
	"	`DomainNameServers`, `LogServers`, or `NtpServers`.\n"
,
	"BgpAsn: int\n"
	"	The Autonomous System Number (ASN) used by the Border Gateway \n"
	"	Protocol (BGP) to find the path to your client gateway through the \n"
	"	Internet. This number must be between `1` and `4294967295`.\n"
"ConnectionType: string\n"
	"	The communication protocol used to establish tunnel with your client \n"
	"	gateway (only `ipsec.1` is supported).\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"PublicIp: string\n"
	"	The public fixed IPv4 address of your client gateway.\n"
,
	"CaPem: string\n"
	"	The CA in PEM format.With OSC CLI, use the following syntax to make \n"
	"	sure your CA file is correctly parsed: `--CaPem=&quot;$(cat \n"
	"	FILENAME)&quot;`.\n"
"Description: string\n"
	"	The description of the CA.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
,
	"CaIds: array string\n"
	"	 One or more IDs of Client Certificate Authorities (CAs).\n"
"Cns: array string\n"
	"	One or more Client Certificate Common Names (CNs). If this parameter \n"
	"	is specified, you must also specify the `CaIds` parameter.\n"
"Description: string\n"
	"	A description for the API access rule.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"IpRanges: array string\n"
	"	One or more IP addresses or CIDR blocks (for example, `192.0.2.0/16`).\n"
,
	"AdditionalEmails: array string\n"
	"	One or more additional email addresses for the account. These \n"
	"	addresses are used for notifications only. If you already have a list \n"
	"	of additional emails registered, you cannot add to it, only replace \n"
	"	it. To remove all registered additional emails, specify an empty list.\n"
"City: string\n"
	"	The city of the account owner.\n"
"CompanyName: string\n"
	"	The name of the company for the account.\n"
"Country: string\n"
	"	The country of the account owner.\n"
"CustomerId: string\n"
	"	The ID of the customer. It must be 8 digits.\n"
"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Email: string\n"
	"	The main email address for the account. This address is used for your \n"
	"	credentials and notifications.\n"
"FirstName: string\n"
	"	The first name of the account owner.\n"
"JobTitle: string\n"
	"	The job title of the account owner.\n"
"LastName: string\n"
	"	The last name of the account owner.\n"
"MobileNumber: string\n"
	"	The mobile phone number of the account owner.\n"
"PhoneNumber: string\n"
	"	The landline phone number of the account owner.\n"
"StateProvince: string\n"
	"	The state/province of the account.\n"
"VatNumber: string\n"
	"	The value added tax (VAT) number for the account.\n"
"ZipCode: string\n"
	"	The ZIP code of the city.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"ExpirationDate: string\n"
	"	The date and time at which you want the access key to expire, in ISO \n"
	"	8601 format (for example, `2017-06-14` or `2017-06-14T00:00:00Z`). To \n"
	"	remove an existing expiration date, use the method without specifying \n"
	"	this parameter.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"Login: string\n"
	"	The email address of the account.\n"
"Password: string\n"
	"	The password of the account.\n"
,
	"DryRun: bool\n"
	"	If true, checks whether you have the required permissions to perform \n"
	"	the action.\n"
"NetPeeringId: string\n"
	"	The ID of the Net peering you want to accept.\n"
,
	NULL
};

const char *osc_find_description(const char *call_name)
{
	const char **c;
	int i = 0;

	for (c = calls_name; c; ++c) {
		if (!strcmp(*c, call_name))
			return calls_descriptions[i];
		++i;
	}
	return NULL;
}

const char *osc_find_args_description(const char *call_name)
{
	const char **c;
	int i = 0;

	for (c = calls_name; c; ++c) {
		if (!strcmp(*c, call_name))
			return calls_args_descriptions[i];
		++i;
	}
	return NULL;
}

#endif  /* WITH_DESCRIPTION */

void *osc_realloc(void *buf, size_t l)
{
	void *ret = realloc(buf, l);

	if (!ret)
		free(buf);
	return ret;
}

/* We don't use _Bool as we try to be C89 compatible */
int osc_str_append_bool(struct osc_str *osc_str, int bool)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->len = len + (bool ? 4 : 5);
	osc_str->buf = osc_realloc(osc_str->buf, osc_str->len + 1);
	if (!osc_str->buf)
		return -1;
	strcpy(osc_str->buf + len, (bool ? "true" : "false"));
	return 0;
}

int osc_str_append_int(struct osc_str *osc_str, int i)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->buf = osc_realloc(osc_str->buf, len + 64);
	if (!osc_str->buf)
		return -1;
	osc_str->len = len + snprintf(osc_str->buf + len, 64, "%d", i);
	osc_str->buf[osc_str->len] = 0;
	return 0;
}

int osc_str_append_double(struct osc_str *osc_str, double i)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->buf = osc_realloc(osc_str->buf, len + 64);
	if (!osc_str->buf)
		return -1;
	osc_str->len = len + snprintf(osc_str->buf + len, 64, "%f", i);
	osc_str->buf[osc_str->len] = 0;
	return 0;
}

int osc_str_append_string(struct osc_str *osc_str, const char *str)
{
	if (!str)
		return 0;
	assert(osc_str);

	int len = osc_str->len;
	int dlen = strlen(str);

	osc_str->len = osc_str->len + dlen;
	osc_str->buf = osc_realloc(osc_str->buf, osc_str->len + 1);
	if (!osc_str->buf)
		return -1;
	memcpy(osc_str->buf + len, str, dlen + 1);
	return 0;
}

#define LOAD_CFG_TRY(test,  ...)				\
	if (test) fprintf(stderr, __VA_ARGS__); return -1;

#define LOAD_CFG_GET_HOME(buf)						\
	{								\
		const char *dest = CFG_FILE;				\
		char *home = getenv("HOME");				\
									\
		LOAD_CFG_TRY(strlen(home) + sizeof CFG_FILE > sizeof buf, \
			     "home path too big");			\
		strcpy(stpcpy(buf, home), dest);			\
	}


int osc_load_ak_sk_from_conf(const char *profile, char **ak, char **sk)
{
	char buf[1024];
	struct json_object *js, *ak_js, *sk_js;

	LOAD_CFG_GET_HOME(buf);
	*sk = NULL;
	*ak = NULL;
	js = json_object_from_file(buf);
	LOAD_CFG_TRY(!js, "can't open %s\n", buf);
	js = json_object_object_get(js, profile);
	LOAD_CFG_TRY(!js, "can't find profile %s\n", profile);
	ak_js = json_object_object_get(js, "access_key");
	LOAD_CFG_TRY(!ak_js, "can't find 'access_key' in profile '%s'\n", profile);
	sk_js = json_object_object_get(js, "secret_key");
	LOAD_CFG_TRY(!sk_js, "can't find 'secret_key' in profile '%s'\n", profile);

	*ak = strdup(json_object_get_string(json_object_object_get(js, "access_key")));
	*sk = strdup(json_object_get_string(json_object_object_get(js, "secret_key")));
	return 0;
}

int osc_load_loging_password_from_conf(const char *profile,
				       char **email, char **password)
{
	char buf[1024];
	struct json_object *js, *login_js, *pass_js;

	LOAD_CFG_GET_HOME(buf)
	*password = NULL;
	*email = NULL;
	js = json_object_from_file(buf);
	LOAD_CFG_TRY(!js, "can't open %s\n", buf);
	js = json_object_object_get(js, profile);
	LOAD_CFG_TRY(!js, "can't find profile '%s'\n", profile);
	login_js = json_object_object_get(js, "login");
	LOAD_CFG_TRY(!login_js, "can't find 'login' in profile '%s'\n", profile);
	*email = strdup(json_object_get_string(login_js));

	pass_js = json_object_object_get(js, "password");
	if (!pass_js) {
		return 0; /* is optional */
	}
	*password = strdup(json_object_get_string(pass_js));
	return 0;
}

int osc_load_region_from_conf(const char *profile, char **region)
{
	struct json_object *region_obj;
	char buf[1024];
	struct json_object *js;

	LOAD_CFG_GET_HOME(buf)
	js = json_object_from_file(buf);
	LOAD_CFG_TRY(!js, "can't open %s\n", buf);
	js = json_object_object_get(js, profile);
	if (!js)
		return -1;

	region_obj = json_object_object_get(js, "region");
	if (!region_obj) {
		return -1;
	}
	*region = strdup(json_object_get_string(region_obj));
	return 0;
}

int osc_load_cert_from_conf(const char *profile, char **cert, char **key)
{
	struct json_object *cert_obj, *key_obj, *js;
	char buf[1024];
	int ret = 0;

	LOAD_CFG_GET_HOME(buf)
	js = json_object_from_file(buf);
	LOAD_CFG_TRY(!js, "can't open %s\n", buf);
	js = json_object_object_get(js, profile);
	if (!js)
		return 0;

	cert_obj = json_object_object_get(js, "x509_client_cert");
	if (!cert_obj)
		cert_obj = json_object_object_get(js, "client_certificate");
	if (cert_obj) {
		*cert = strdup(json_object_get_string(cert_obj));
		ret |= OSC_ENV_FREE_CERT;
	}

	key_obj = json_object_object_get(js, "x509_client_sslkey");
	if (key_obj) {
		*key = strdup(json_object_get_string(key_obj));
		ret |= OSC_ENV_FREE_SSLKEY;
	}

	return 0;
}

/* Function that will write the data inside a variable */
static size_t write_data(void *data, size_t size, size_t nmemb, void *userp)
{
	size_t bufsize = size * nmemb;
	struct osc_str *response = userp;
	int olen = response->len;

	response->len = response->len + bufsize;
	response->buf = osc_realloc(response->buf, response->len + 1);
	memcpy(response->buf + olen, data, bufsize);
	response->buf[response->len] = 0;
	return bufsize;
}

void osc_init_str(struct osc_str *r)
{
	r->len = 0;
	r->buf = NULL;
}

void osc_deinit_str(struct osc_str *r)
{
	free(r->buf);
	osc_init_str(r);
}

static int accepter_net_setter(struct accepter_net *args, struct osc_str *data);
static int access_key_setter(struct access_key *args, struct osc_str *data);
static int access_key_secret_key_setter(struct access_key_secret_key *args, struct osc_str *data);
static int access_log_setter(struct access_log *args, struct osc_str *data);
static int account_setter(struct account *args, struct osc_str *data);
static int api_access_policy_setter(struct api_access_policy *args, struct osc_str *data);
static int api_access_rule_setter(struct api_access_rule *args, struct osc_str *data);
static int application_sticky_cookie_policy_setter(struct application_sticky_cookie_policy *args, struct osc_str *data);
static int backend_vm_health_setter(struct backend_vm_health *args, struct osc_str *data);
static int block_device_mapping_created_setter(struct block_device_mapping_created *args, struct osc_str *data);
static int block_device_mapping_image_setter(struct block_device_mapping_image *args, struct osc_str *data);
static int block_device_mapping_vm_creation_setter(struct block_device_mapping_vm_creation *args, struct osc_str *data);
static int block_device_mapping_vm_update_setter(struct block_device_mapping_vm_update *args, struct osc_str *data);
static int bsu_created_setter(struct bsu_created *args, struct osc_str *data);
static int bsu_to_create_setter(struct bsu_to_create *args, struct osc_str *data);
static int bsu_to_update_vm_setter(struct bsu_to_update_vm *args, struct osc_str *data);
static int ca_setter(struct ca *args, struct osc_str *data);
static int catalog_setter(struct catalog *args, struct osc_str *data);
static int catalog_entry_setter(struct catalog_entry *args, struct osc_str *data);
static int client_gateway_setter(struct client_gateway *args, struct osc_str *data);
static int consumption_entry_setter(struct consumption_entry *args, struct osc_str *data);
static int dhcp_options_set_setter(struct dhcp_options_set *args, struct osc_str *data);
static int direct_link_setter(struct direct_link *args, struct osc_str *data);
static int direct_link_interface_setter(struct direct_link_interface *args, struct osc_str *data);
static int direct_link_interfaces_setter(struct direct_link_interfaces *args, struct osc_str *data);
static int errors_setter(struct errors *args, struct osc_str *data);
static int filters_access_keys_setter(struct filters_access_keys *args, struct osc_str *data);
static int filters_api_access_rule_setter(struct filters_api_access_rule *args, struct osc_str *data);
static int filters_api_log_setter(struct filters_api_log *args, struct osc_str *data);
static int filters_ca_setter(struct filters_ca *args, struct osc_str *data);
static int filters_client_gateway_setter(struct filters_client_gateway *args, struct osc_str *data);
static int filters_dhcp_options_setter(struct filters_dhcp_options *args, struct osc_str *data);
static int filters_direct_link_setter(struct filters_direct_link *args, struct osc_str *data);
static int filters_direct_link_interface_setter(struct filters_direct_link_interface *args, struct osc_str *data);
static int filters_export_task_setter(struct filters_export_task *args, struct osc_str *data);
static int filters_flexible_gpu_setter(struct filters_flexible_gpu *args, struct osc_str *data);
static int filters_image_setter(struct filters_image *args, struct osc_str *data);
static int filters_internet_service_setter(struct filters_internet_service *args, struct osc_str *data);
static int filters_keypair_setter(struct filters_keypair *args, struct osc_str *data);
static int filters_listener_rule_setter(struct filters_listener_rule *args, struct osc_str *data);
static int filters_load_balancer_setter(struct filters_load_balancer *args, struct osc_str *data);
static int filters_nat_service_setter(struct filters_nat_service *args, struct osc_str *data);
static int filters_net_setter(struct filters_net *args, struct osc_str *data);
static int filters_net_access_point_setter(struct filters_net_access_point *args, struct osc_str *data);
static int filters_net_peering_setter(struct filters_net_peering *args, struct osc_str *data);
static int filters_nic_setter(struct filters_nic *args, struct osc_str *data);
static int filters_product_type_setter(struct filters_product_type *args, struct osc_str *data);
static int filters_public_ip_setter(struct filters_public_ip *args, struct osc_str *data);
static int filters_quota_setter(struct filters_quota *args, struct osc_str *data);
static int filters_route_table_setter(struct filters_route_table *args, struct osc_str *data);
static int filters_security_group_setter(struct filters_security_group *args, struct osc_str *data);
static int filters_server_certificate_setter(struct filters_server_certificate *args, struct osc_str *data);
static int filters_service_setter(struct filters_service *args, struct osc_str *data);
static int filters_snapshot_setter(struct filters_snapshot *args, struct osc_str *data);
static int filters_subnet_setter(struct filters_subnet *args, struct osc_str *data);
static int filters_subregion_setter(struct filters_subregion *args, struct osc_str *data);
static int filters_tag_setter(struct filters_tag *args, struct osc_str *data);
static int filters_virtual_gateway_setter(struct filters_virtual_gateway *args, struct osc_str *data);
static int filters_vm_setter(struct filters_vm *args, struct osc_str *data);
static int filters_vm_type_setter(struct filters_vm_type *args, struct osc_str *data);
static int filters_vms_state_setter(struct filters_vms_state *args, struct osc_str *data);
static int filters_volume_setter(struct filters_volume *args, struct osc_str *data);
static int filters_vpn_connection_setter(struct filters_vpn_connection *args, struct osc_str *data);
static int flexible_gpu_setter(struct flexible_gpu *args, struct osc_str *data);
static int flexible_gpu_catalog_setter(struct flexible_gpu_catalog *args, struct osc_str *data);
static int health_check_setter(struct health_check *args, struct osc_str *data);
static int image_setter(struct image *args, struct osc_str *data);
static int image_export_task_setter(struct image_export_task *args, struct osc_str *data);
static int internet_service_setter(struct internet_service *args, struct osc_str *data);
static int keypair_setter(struct keypair *args, struct osc_str *data);
static int keypair_created_setter(struct keypair_created *args, struct osc_str *data);
static int link_nic_setter(struct link_nic *args, struct osc_str *data);
static int link_nic_light_setter(struct link_nic_light *args, struct osc_str *data);
static int link_nic_to_update_setter(struct link_nic_to_update *args, struct osc_str *data);
static int link_public_ip_setter(struct link_public_ip *args, struct osc_str *data);
static int link_public_ip_light_for_vm_setter(struct link_public_ip_light_for_vm *args, struct osc_str *data);
static int link_route_table_setter(struct link_route_table *args, struct osc_str *data);
static int linked_volume_setter(struct linked_volume *args, struct osc_str *data);
static int listener_setter(struct listener *args, struct osc_str *data);
static int listener_for_creation_setter(struct listener_for_creation *args, struct osc_str *data);
static int listener_rule_setter(struct listener_rule *args, struct osc_str *data);
static int listener_rule_for_creation_setter(struct listener_rule_for_creation *args, struct osc_str *data);
static int load_balancer_setter(struct load_balancer *args, struct osc_str *data);
static int load_balancer_light_setter(struct load_balancer_light *args, struct osc_str *data);
static int load_balancer_sticky_cookie_policy_setter(struct load_balancer_sticky_cookie_policy *args, struct osc_str *data);
static int load_balancer_tag_setter(struct load_balancer_tag *args, struct osc_str *data);
static int location_setter(struct location *args, struct osc_str *data);
static int log_setter(struct log *args, struct osc_str *data);
static int maintenance_event_setter(struct maintenance_event *args, struct osc_str *data);
static int nat_service_setter(struct nat_service *args, struct osc_str *data);
static int net_setter(struct net *args, struct osc_str *data);
static int net_access_point_setter(struct net_access_point *args, struct osc_str *data);
static int net_peering_setter(struct net_peering *args, struct osc_str *data);
static int net_peering_state_setter(struct net_peering_state *args, struct osc_str *data);
static int net_to_virtual_gateway_link_setter(struct net_to_virtual_gateway_link *args, struct osc_str *data);
static int nic_setter(struct nic *args, struct osc_str *data);
static int nic_for_vm_creation_setter(struct nic_for_vm_creation *args, struct osc_str *data);
static int nic_light_setter(struct nic_light *args, struct osc_str *data);
static int osu_api_key_setter(struct osu_api_key *args, struct osc_str *data);
static int osu_export_image_export_task_setter(struct osu_export_image_export_task *args, struct osc_str *data);
static int osu_export_snapshot_export_task_setter(struct osu_export_snapshot_export_task *args, struct osc_str *data);
static int osu_export_to_create_setter(struct osu_export_to_create *args, struct osc_str *data);
static int permissions_on_resource_setter(struct permissions_on_resource *args, struct osc_str *data);
static int permissions_on_resource_creation_setter(struct permissions_on_resource_creation *args, struct osc_str *data);
static int phase1_options_setter(struct phase1_options *args, struct osc_str *data);
static int phase2_options_setter(struct phase2_options *args, struct osc_str *data);
static int placement_setter(struct placement *args, struct osc_str *data);
static int private_ip_setter(struct private_ip *args, struct osc_str *data);
static int private_ip_light_setter(struct private_ip_light *args, struct osc_str *data);
static int private_ip_light_for_vm_setter(struct private_ip_light_for_vm *args, struct osc_str *data);
static int product_type_setter(struct product_type *args, struct osc_str *data);
static int public_ip_setter(struct public_ip *args, struct osc_str *data);
static int public_ip_light_setter(struct public_ip_light *args, struct osc_str *data);
static int quota_setter(struct quota *args, struct osc_str *data);
static int quota_types_setter(struct quota_types *args, struct osc_str *data);
static int region_setter(struct region *args, struct osc_str *data);
static int resource_load_balancer_tag_setter(struct resource_load_balancer_tag *args, struct osc_str *data);
static int resource_tag_setter(struct resource_tag *args, struct osc_str *data);
static int route_setter(struct route *args, struct osc_str *data);
static int route_light_setter(struct route_light *args, struct osc_str *data);
static int route_propagating_virtual_gateway_setter(struct route_propagating_virtual_gateway *args, struct osc_str *data);
static int route_table_setter(struct route_table *args, struct osc_str *data);
static int security_group_setter(struct security_group *args, struct osc_str *data);
static int security_group_light_setter(struct security_group_light *args, struct osc_str *data);
static int security_group_rule_setter(struct security_group_rule *args, struct osc_str *data);
static int security_groups_member_setter(struct security_groups_member *args, struct osc_str *data);
static int server_certificate_setter(struct server_certificate *args, struct osc_str *data);
static int service_setter(struct service *args, struct osc_str *data);
static int snapshot_setter(struct snapshot *args, struct osc_str *data);
static int snapshot_export_task_setter(struct snapshot_export_task *args, struct osc_str *data);
static int source_net_setter(struct source_net *args, struct osc_str *data);
static int source_security_group_setter(struct source_security_group *args, struct osc_str *data);
static int state_comment_setter(struct state_comment *args, struct osc_str *data);
static int subnet_setter(struct subnet *args, struct osc_str *data);
static int subregion_setter(struct subregion *args, struct osc_str *data);
static int tag_setter(struct tag *args, struct osc_str *data);
static int vgw_telemetry_setter(struct vgw_telemetry *args, struct osc_str *data);
static int virtual_gateway_setter(struct virtual_gateway *args, struct osc_str *data);
static int vm_setter(struct vm *args, struct osc_str *data);
static int vm_state_setter(struct vm_state *args, struct osc_str *data);
static int vm_states_setter(struct vm_states *args, struct osc_str *data);
static int vm_type_setter(struct vm_type *args, struct osc_str *data);
static int volume_setter(struct volume *args, struct osc_str *data);
static int vpn_connection_setter(struct vpn_connection *args, struct osc_str *data);
static int vpn_options_setter(struct vpn_options *args, struct osc_str *data);
static int with_setter(struct with *args, struct osc_str *data);
static int accepter_net_setter(struct accepter_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int access_key_setter(struct access_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessKeyId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->access_key_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->creation_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->creation_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->expiration_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ExpirationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->expiration_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->last_modification_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LastModificationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->last_modification_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int access_key_secret_key_setter(struct access_key_secret_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessKeyId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->access_key_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->creation_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->creation_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->expiration_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ExpirationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->expiration_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->last_modification_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LastModificationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->last_modification_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->secret_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecretKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->secret_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int access_log_setter(struct access_log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_enabled) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsEnabled\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_enabled))
			return -1;
	   	ret += 1;
	}
	if (args->osu_bucket_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuBucketName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_bucket_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_bucket_prefix) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuBucketPrefix\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_bucket_prefix))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_publication_interval || args->publication_interval) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicationInterval\":" ))
			return -1;
                if (osc_str_append_int(data, args->publication_interval))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int account_setter(struct account *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->additional_emails) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AdditionalEmails\":[" ))
			return -1;
		for (as = args->additional_emails; *as > 0; ++as) {
			if (as != args->additional_emails)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->additional_emails_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AdditionalEmails\":" ))
			return -1;
                if (osc_str_append_string(data, args->additional_emails_str))
			return -1;
		ret += 1;
	}
	if (args->city) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"City\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->city))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->company_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CompanyName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->company_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->country) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Country\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->country))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->customer_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CustomerId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->customer_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->email) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Email\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->email))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->first_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FirstName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->first_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->job_title) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"JobTitle\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->job_title))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->last_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LastName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->last_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->mobile_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MobileNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->mobile_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->phone_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PhoneNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->phone_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state_province) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateProvince\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state_province))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vat_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VatNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vat_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->zip_code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ZipCode\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->zip_code))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int api_access_policy_setter(struct api_access_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_max_access_key_expiration_seconds || args->max_access_key_expiration_seconds) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaxAccessKeyExpirationSeconds\":" ))
			return -1;
                if (osc_str_append_int(data, args->max_access_key_expiration_seconds))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_require_trusted_env) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RequireTrustedEnv\":" ))
			return -1;
                if (osc_str_append_bool(data, args->require_trusted_env))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int api_access_rule_setter(struct api_access_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_access_rule_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ApiAccessRuleId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->api_access_rule_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ca_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":[" ))
			return -1;
		for (as = args->ca_ids; *as > 0; ++as) {
			if (as != args->ca_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ca_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->ca_ids_str))
			return -1;
		ret += 1;
	}
	if (args->cns) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Cns\":[" ))
			return -1;
		for (as = args->cns; *as > 0; ++as) {
			if (as != args->cns)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->cns_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Cns\":" ))
			return -1;
                if (osc_str_append_string(data, args->cns_str))
			return -1;
		ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":[" ))
			return -1;
		for (as = args->ip_ranges; *as > 0; ++as) {
			if (as != args->ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->ip_ranges_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int application_sticky_cookie_policy_setter(struct application_sticky_cookie_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->cookie_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CookieName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->cookie_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->policy_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->policy_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int backend_vm_health_setter(struct backend_vm_health *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state_reason) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateReason\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state_reason))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int block_device_mapping_created_setter(struct block_device_mapping_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Bsu\":" ))
			return -1;
                if (osc_str_append_string(data, args->bsu_str))
			return -1;
		ret += 1;
	} else if (args->is_set_bsu) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Bsu\": { " ))
			return -1;
	       if (bsu_created_setter(&args->bsu, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int block_device_mapping_image_setter(struct block_device_mapping_image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Bsu\":" ))
			return -1;
                if (osc_str_append_string(data, args->bsu_str))
			return -1;
		ret += 1;
	} else if (args->is_set_bsu) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Bsu\": { " ))
			return -1;
	       if (bsu_to_create_setter(&args->bsu, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualDeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int block_device_mapping_vm_creation_setter(struct block_device_mapping_vm_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Bsu\":" ))
			return -1;
                if (osc_str_append_string(data, args->bsu_str))
			return -1;
		ret += 1;
	} else if (args->is_set_bsu) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Bsu\": { " ))
			return -1;
	       if (bsu_to_create_setter(&args->bsu, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->no_device) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NoDevice\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->no_device))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualDeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int block_device_mapping_vm_update_setter(struct block_device_mapping_vm_update *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Bsu\":" ))
			return -1;
                if (osc_str_append_string(data, args->bsu_str))
			return -1;
		ret += 1;
	} else if (args->is_set_bsu) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Bsu\": { " ))
			return -1;
	       if (bsu_to_update_vm_setter(&args->bsu, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->no_device) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NoDevice\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->no_device))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualDeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int bsu_created_setter(struct bsu_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->link_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int bsu_to_create_setter(struct bsu_to_create *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Iops\":" ))
			return -1;
                if (osc_str_append_int(data, args->iops))
			return -1;
	   	ret += 1;
	}
	if (args->snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSize\":" ))
			return -1;
                if (osc_str_append_int(data, args->volume_size))
			return -1;
	   	ret += 1;
	}
	if (args->volume_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int bsu_to_update_vm_setter(struct bsu_to_update_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int ca_setter(struct ca *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ca_fingerprint) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaFingerprint\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ca_fingerprint))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ca_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ca_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int catalog_setter(struct catalog *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->entries) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Entries\":[" ))
			return -1;
		for (int i = 0; i < args->nb_entries; ++i) {
	       	    struct catalog_entry *p = &args->entries[i];
		    if (p != args->entries)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (catalog_entry_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->entries_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Entries\":" ))
			return -1;
                if (osc_str_append_string(data, args->entries_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int catalog_entry_setter(struct catalog_entry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->category) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Category\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->category))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->flags) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Flags\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->flags))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->operation) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Operation\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->operation))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->service) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Service\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->service))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->title) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Title\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->title))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Type\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_unit_price || args->unit_price) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"UnitPrice\":" ))
			return -1;
                if (osc_str_append_double(data, args->unit_price))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int client_gateway_setter(struct client_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bgp_asn || args->bgp_asn) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpAsn\":" ))
			return -1;
                if (osc_str_append_int(data, args->bgp_asn))
			return -1;
	   	ret += 1;
	}
	if (args->client_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->connection_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->connection_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int consumption_entry_setter(struct consumption_entry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->category) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Category\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->category))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->from_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FromDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->from_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->operation) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Operation\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->operation))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->paying_account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PayingAccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->paying_account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->service) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Service\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->service))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->title) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Title\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->title))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->to_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ToDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->to_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Type\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_value || args->value) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Value\":" ))
			return -1;
                if (osc_str_append_double(data, args->value))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int dhcp_options_set_setter(struct dhcp_options_set *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_default_arg) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Default\":" ))
			return -1;
                if (osc_str_append_bool(data, args->default_arg))
			return -1;
	   	ret += 1;
	}
	if (args->dhcp_options_set_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DhcpOptionsSetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->dhcp_options_set_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->domain_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->domain_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainNameServers\":[" ))
			return -1;
		for (as = args->domain_name_servers; *as > 0; ++as) {
			if (as != args->domain_name_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->domain_name_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainNameServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->domain_name_servers_str))
			return -1;
		ret += 1;
	}
	if (args->log_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LogServers\":[" ))
			return -1;
		for (as = args->log_servers; *as > 0; ++as) {
			if (as != args->log_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->log_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LogServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->log_servers_str))
			return -1;
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NtpServers\":[" ))
			return -1;
		for (as = args->ntp_servers; *as > 0; ++as) {
			if (as != args->ntp_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ntp_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NtpServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->ntp_servers_str))
			return -1;
		ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int direct_link_setter(struct direct_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->bandwidth) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Bandwidth\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->bandwidth))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->direct_link_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->direct_link_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->location) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Location\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->location))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->region_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RegionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->region_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int direct_link_interface_setter(struct direct_link_interface *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bgp_asn || args->bgp_asn) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpAsn\":" ))
			return -1;
                if (osc_str_append_int(data, args->bgp_asn))
			return -1;
	   	ret += 1;
	}
	if (args->bgp_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->bgp_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->client_private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientPrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->direct_link_interface_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkInterfaceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_interface_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->outscale_private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutscalePrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->outscale_private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_vlan || args->vlan) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Vlan\":" ))
			return -1;
                if (osc_str_append_int(data, args->vlan))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int direct_link_interfaces_setter(struct direct_link_interfaces *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_bgp_asn || args->bgp_asn) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpAsn\":" ))
			return -1;
                if (osc_str_append_int(data, args->bgp_asn))
			return -1;
	   	ret += 1;
	}
	if (args->bgp_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->bgp_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->client_private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientPrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->direct_link_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->direct_link_interface_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkInterfaceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_interface_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->direct_link_interface_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkInterfaceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_interface_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->interface_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InterfaceType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->interface_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->location) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Location\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->location))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_mtu || args->mtu) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Mtu\":" ))
			return -1;
                if (osc_str_append_int(data, args->mtu))
			return -1;
	   	ret += 1;
	}
	if (args->outscale_private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutscalePrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->outscale_private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_vlan || args->vlan) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Vlan\":" ))
			return -1;
                if (osc_str_append_int(data, args->vlan))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int errors_setter(struct errors *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Code\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->code))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->details) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Details\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->details))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Type\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int filters_access_keys_setter(struct filters_access_keys *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessKeyIds\":[" ))
			return -1;
		for (as = args->access_key_ids; *as > 0; ++as) {
			if (as != args->access_key_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->access_key_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessKeyIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->access_key_ids_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_api_access_rule_setter(struct filters_api_access_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_access_rule_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ApiAccessRuleIds\":[" ))
			return -1;
		for (as = args->api_access_rule_ids; *as > 0; ++as) {
			if (as != args->api_access_rule_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->api_access_rule_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ApiAccessRuleIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->api_access_rule_ids_str))
			return -1;
		ret += 1;
	}
	if (args->ca_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":[" ))
			return -1;
		for (as = args->ca_ids; *as > 0; ++as) {
			if (as != args->ca_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ca_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->ca_ids_str))
			return -1;
		ret += 1;
	}
	if (args->cns) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Cns\":[" ))
			return -1;
		for (as = args->cns; *as > 0; ++as) {
			if (as != args->cns)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->cns_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Cns\":" ))
			return -1;
                if (osc_str_append_string(data, args->cns_str))
			return -1;
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":[" ))
			return -1;
		for (as = args->descriptions; *as > 0; ++as) {
			if (as != args->descriptions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->descriptions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->descriptions_str))
			return -1;
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":[" ))
			return -1;
		for (as = args->ip_ranges; *as > 0; ++as) {
			if (as != args->ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->ip_ranges_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_api_log_setter(struct filters_api_log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->query_access_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryAccessKeys\":[" ))
			return -1;
		for (as = args->query_access_keys; *as > 0; ++as) {
			if (as != args->query_access_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->query_access_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryAccessKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->query_access_keys_str))
			return -1;
		ret += 1;
	}
	if (args->query_api_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryApiNames\":[" ))
			return -1;
		for (as = args->query_api_names; *as > 0; ++as) {
			if (as != args->query_api_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->query_api_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryApiNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->query_api_names_str))
			return -1;
		ret += 1;
	}
	if (args->query_call_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryCallNames\":[" ))
			return -1;
		for (as = args->query_call_names; *as > 0; ++as) {
			if (as != args->query_call_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->query_call_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryCallNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->query_call_names_str))
			return -1;
		ret += 1;
	}
	if (args->query_date_after) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryDateAfter\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_date_after))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->query_date_before) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryDateBefore\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_date_before))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->query_ip_addresses) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryIpAddresses\":[" ))
			return -1;
		for (as = args->query_ip_addresses; *as > 0; ++as) {
			if (as != args->query_ip_addresses)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->query_ip_addresses_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryIpAddresses\":" ))
			return -1;
                if (osc_str_append_string(data, args->query_ip_addresses_str))
			return -1;
		ret += 1;
	}
	if (args->query_user_agents) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryUserAgents\":[" ))
			return -1;
		for (as = args->query_user_agents; *as > 0; ++as) {
			if (as != args->query_user_agents)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->query_user_agents_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryUserAgents\":" ))
			return -1;
                if (osc_str_append_string(data, args->query_user_agents_str))
			return -1;
		ret += 1;
	}
	if (args->request_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RequestIds\":[" ))
			return -1;
		for (as = args->request_ids; *as > 0; ++as) {
			if (as != args->request_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->request_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RequestIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->request_ids_str))
			return -1;
		ret += 1;
	}
	if (args->response_status_codes) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResponseStatusCodes\":[" ))
			return -1;
		for (ip = args->response_status_codes; *ip > 0; ++ip) {
			if (ip != args->response_status_codes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->response_status_codes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResponseStatusCodes\":" ))
			return -1;
                if (osc_str_append_string(data, args->response_status_codes_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_ca_setter(struct filters_ca *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ca_fingerprints) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaFingerprints\":[" ))
			return -1;
		for (as = args->ca_fingerprints; *as > 0; ++as) {
			if (as != args->ca_fingerprints)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ca_fingerprints_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaFingerprints\":" ))
			return -1;
                if (osc_str_append_string(data, args->ca_fingerprints_str))
			return -1;
		ret += 1;
	}
	if (args->ca_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":[" ))
			return -1;
		for (as = args->ca_ids; *as > 0; ++as) {
			if (as != args->ca_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ca_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->ca_ids_str))
			return -1;
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":[" ))
			return -1;
		for (as = args->descriptions; *as > 0; ++as) {
			if (as != args->descriptions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->descriptions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->descriptions_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_client_gateway_setter(struct filters_client_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bgp_asns) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpAsns\":[" ))
			return -1;
		for (ip = args->bgp_asns; *ip > 0; ++ip) {
			if (ip != args->bgp_asns)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->bgp_asns_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpAsns\":" ))
			return -1;
                if (osc_str_append_string(data, args->bgp_asns_str))
			return -1;
		ret += 1;
	}
	if (args->client_gateway_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayIds\":[" ))
			return -1;
		for (as = args->client_gateway_ids; *as > 0; ++as) {
			if (as != args->client_gateway_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->client_gateway_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->client_gateway_ids_str))
			return -1;
		ret += 1;
	}
	if (args->connection_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionTypes\":[" ))
			return -1;
		for (as = args->connection_types; *as > 0; ++as) {
			if (as != args->connection_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->connection_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->connection_types_str))
			return -1;
		ret += 1;
	}
	if (args->public_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIps\":[" ))
			return -1;
		for (as = args->public_ips; *as > 0; ++as) {
			if (as != args->public_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->public_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->public_ips_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_dhcp_options_setter(struct filters_dhcp_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_default_arg) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Default\":" ))
			return -1;
                if (osc_str_append_bool(data, args->default_arg))
			return -1;
	   	ret += 1;
	}
	if (args->dhcp_options_set_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DhcpOptionsSetIds\":[" ))
			return -1;
		for (as = args->dhcp_options_set_ids; *as > 0; ++as) {
			if (as != args->dhcp_options_set_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->dhcp_options_set_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DhcpOptionsSetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->dhcp_options_set_ids_str))
			return -1;
		ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainNameServers\":[" ))
			return -1;
		for (as = args->domain_name_servers; *as > 0; ++as) {
			if (as != args->domain_name_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->domain_name_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainNameServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->domain_name_servers_str))
			return -1;
		ret += 1;
	}
	if (args->domain_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainNames\":[" ))
			return -1;
		for (as = args->domain_names; *as > 0; ++as) {
			if (as != args->domain_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->domain_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->domain_names_str))
			return -1;
		ret += 1;
	}
	if (args->log_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LogServers\":[" ))
			return -1;
		for (as = args->log_servers; *as > 0; ++as) {
			if (as != args->log_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->log_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LogServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->log_servers_str))
			return -1;
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NtpServers\":[" ))
			return -1;
		for (as = args->ntp_servers; *as > 0; ++as) {
			if (as != args->ntp_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ntp_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NtpServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->ntp_servers_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_direct_link_setter(struct filters_direct_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->direct_link_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkIds\":[" ))
			return -1;
		for (as = args->direct_link_ids; *as > 0; ++as) {
			if (as != args->direct_link_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->direct_link_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_direct_link_interface_setter(struct filters_direct_link_interface *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->direct_link_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkIds\":[" ))
			return -1;
		for (as = args->direct_link_ids; *as > 0; ++as) {
			if (as != args->direct_link_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->direct_link_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_ids_str))
			return -1;
		ret += 1;
	}
	if (args->direct_link_interface_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkInterfaceIds\":[" ))
			return -1;
		for (as = args->direct_link_interface_ids; *as > 0; ++as) {
			if (as != args->direct_link_interface_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->direct_link_interface_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkInterfaceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_interface_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_export_task_setter(struct filters_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->task_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TaskIds\":[" ))
			return -1;
		for (as = args->task_ids; *as > 0; ++as) {
			if (as != args->task_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->task_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TaskIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->task_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_flexible_gpu_setter(struct filters_flexible_gpu *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->flexible_gpu_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FlexibleGpuIds\":[" ))
			return -1;
		for (as = args->flexible_gpu_ids; *as > 0; ++as) {
			if (as != args->flexible_gpu_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->flexible_gpu_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FlexibleGpuIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->flexible_gpu_ids_str))
			return -1;
		ret += 1;
	}
	if (args->generations) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Generations\":[" ))
			return -1;
		for (as = args->generations; *as > 0; ++as) {
			if (as != args->generations)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->generations_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Generations\":" ))
			return -1;
                if (osc_str_append_string(data, args->generations_str))
			return -1;
		ret += 1;
	}
	if (args->model_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ModelNames\":[" ))
			return -1;
		for (as = args->model_names; *as > 0; ++as) {
			if (as != args->model_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->model_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ModelNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->model_names_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":[" ))
			return -1;
		for (as = args->subregion_names; *as > 0; ++as) {
			if (as != args->subregion_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subregion_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_names_str))
			return -1;
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_image_setter(struct filters_image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_aliases) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountAliases\":[" ))
			return -1;
		for (as = args->account_aliases; *as > 0; ++as) {
			if (as != args->account_aliases)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->account_aliases_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountAliases\":" ))
			return -1;
                if (osc_str_append_string(data, args->account_aliases_str))
			return -1;
		ret += 1;
	}
	if (args->account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountIds\":[" ))
			return -1;
		for (as = args->account_ids; *as > 0; ++as) {
			if (as != args->account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->architectures) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Architectures\":[" ))
			return -1;
		for (as = args->architectures; *as > 0; ++as) {
			if (as != args->architectures)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->architectures_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Architectures\":" ))
			return -1;
                if (osc_str_append_string(data, args->architectures_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_block_device_mapping_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingDeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->block_device_mapping_delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->block_device_mapping_device_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingDeviceNames\":[" ))
			return -1;
		for (as = args->block_device_mapping_device_names; *as > 0; ++as) {
			if (as != args->block_device_mapping_device_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->block_device_mapping_device_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingDeviceNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mapping_device_names_str))
			return -1;
		ret += 1;
	}
	if (args->block_device_mapping_snapshot_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingSnapshotIds\":[" ))
			return -1;
		for (as = args->block_device_mapping_snapshot_ids; *as > 0; ++as) {
			if (as != args->block_device_mapping_snapshot_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->block_device_mapping_snapshot_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingSnapshotIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mapping_snapshot_ids_str))
			return -1;
		ret += 1;
	}
	if (args->block_device_mapping_volume_sizes) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingVolumeSizes\":[" ))
			return -1;
		for (ip = args->block_device_mapping_volume_sizes; *ip > 0; ++ip) {
			if (ip != args->block_device_mapping_volume_sizes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->block_device_mapping_volume_sizes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingVolumeSizes\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mapping_volume_sizes_str))
			return -1;
		ret += 1;
	}
	if (args->block_device_mapping_volume_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingVolumeTypes\":[" ))
			return -1;
		for (as = args->block_device_mapping_volume_types; *as > 0; ++as) {
			if (as != args->block_device_mapping_volume_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->block_device_mapping_volume_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappingVolumeTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mapping_volume_types_str))
			return -1;
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":[" ))
			return -1;
		for (as = args->descriptions; *as > 0; ++as) {
			if (as != args->descriptions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->descriptions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->descriptions_str))
			return -1;
		ret += 1;
	}
	if (args->file_locations) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FileLocations\":[" ))
			return -1;
		for (as = args->file_locations; *as > 0; ++as) {
			if (as != args->file_locations)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->file_locations_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FileLocations\":" ))
			return -1;
                if (osc_str_append_string(data, args->file_locations_str))
			return -1;
		ret += 1;
	}
	if (args->hypervisors) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Hypervisors\":[" ))
			return -1;
		for (as = args->hypervisors; *as > 0; ++as) {
			if (as != args->hypervisors)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->hypervisors_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Hypervisors\":" ))
			return -1;
                if (osc_str_append_string(data, args->hypervisors_str))
			return -1;
		ret += 1;
	}
	if (args->image_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageIds\":[" ))
			return -1;
		for (as = args->image_ids; *as > 0; ++as) {
			if (as != args->image_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->image_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->image_ids_str))
			return -1;
		ret += 1;
	}
	if (args->image_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageNames\":[" ))
			return -1;
		for (as = args->image_names; *as > 0; ++as) {
			if (as != args->image_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->image_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->image_names_str))
			return -1;
		ret += 1;
	}
	if (args->permissions_to_launch_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToLaunchAccountIds\":[" ))
			return -1;
		for (as = args->permissions_to_launch_account_ids; *as > 0; ++as) {
			if (as != args->permissions_to_launch_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->permissions_to_launch_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToLaunchAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->permissions_to_launch_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_permissions_to_launch_global_permission) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToLaunchGlobalPermission\":" ))
			return -1;
                if (osc_str_append_bool(data, args->permissions_to_launch_global_permission))
			return -1;
	   	ret += 1;
	}
	if (args->product_codes) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductCodes\":[" ))
			return -1;
		for (as = args->product_codes; *as > 0; ++as) {
			if (as != args->product_codes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->product_codes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductCodes\":" ))
			return -1;
                if (osc_str_append_string(data, args->product_codes_str))
			return -1;
		ret += 1;
	}
	if (args->root_device_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceNames\":[" ))
			return -1;
		for (as = args->root_device_names; *as > 0; ++as) {
			if (as != args->root_device_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->root_device_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->root_device_names_str))
			return -1;
		ret += 1;
	}
	if (args->root_device_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceTypes\":[" ))
			return -1;
		for (as = args->root_device_types; *as > 0; ++as) {
			if (as != args->root_device_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->root_device_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->root_device_types_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->virtualization_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualizationTypes\":[" ))
			return -1;
		for (as = args->virtualization_types; *as > 0; ++as) {
			if (as != args->virtualization_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->virtualization_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualizationTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->virtualization_types_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_internet_service_setter(struct filters_internet_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->internet_service_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InternetServiceIds\":[" ))
			return -1;
		for (as = args->internet_service_ids; *as > 0; ++as) {
			if (as != args->internet_service_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->internet_service_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InternetServiceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->internet_service_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNetIds\":[" ))
			return -1;
		for (as = args->link_net_ids; *as > 0; ++as) {
			if (as != args->link_net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkStates\":[" ))
			return -1;
		for (as = args->link_states; *as > 0; ++as) {
			if (as != args->link_states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkStates\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_states_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_keypair_setter(struct filters_keypair *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprints) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairFingerprints\":[" ))
			return -1;
		for (as = args->keypair_fingerprints; *as > 0; ++as) {
			if (as != args->keypair_fingerprints)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->keypair_fingerprints_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairFingerprints\":" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_fingerprints_str))
			return -1;
		ret += 1;
	}
	if (args->keypair_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairNames\":[" ))
			return -1;
		for (as = args->keypair_names; *as > 0; ++as) {
			if (as != args->keypair_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->keypair_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_names_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_listener_rule_setter(struct filters_listener_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->listener_rule_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerRuleNames\":[" ))
			return -1;
		for (as = args->listener_rule_names; *as > 0; ++as) {
			if (as != args->listener_rule_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->listener_rule_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerRuleNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->listener_rule_names_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_load_balancer_setter(struct filters_load_balancer *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->load_balancer_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerNames\":[" ))
			return -1;
		for (as = args->load_balancer_names; *as > 0; ++as) {
			if (as != args->load_balancer_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->load_balancer_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_names_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_nat_service_setter(struct filters_nat_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->nat_service_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NatServiceIds\":[" ))
			return -1;
		for (as = args->nat_service_ids; *as > 0; ++as) {
			if (as != args->nat_service_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->nat_service_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NatServiceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->nat_service_ids_str))
			return -1;
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":[" ))
			return -1;
		for (as = args->net_ids; *as > 0; ++as) {
			if (as != args->net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetIds\":[" ))
			return -1;
		for (as = args->subnet_ids; *as > 0; ++as) {
			if (as != args->subnet_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subnet_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_ids_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_net_setter(struct filters_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dhcp_options_set_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DhcpOptionsSetIds\":[" ))
			return -1;
		for (as = args->dhcp_options_set_ids; *as > 0; ++as) {
			if (as != args->dhcp_options_set_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->dhcp_options_set_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DhcpOptionsSetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->dhcp_options_set_ids_str))
			return -1;
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":[" ))
			return -1;
		for (as = args->ip_ranges; *as > 0; ++as) {
			if (as != args->ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_is_default_arg) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsDefault\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_default_arg))
			return -1;
	   	ret += 1;
	}
	if (args->net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":[" ))
			return -1;
		for (as = args->net_ids; *as > 0; ++as) {
			if (as != args->net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_net_access_point_setter(struct filters_net_access_point *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_access_point_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetAccessPointIds\":[" ))
			return -1;
		for (as = args->net_access_point_ids; *as > 0; ++as) {
			if (as != args->net_access_point_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_access_point_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetAccessPointIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_access_point_ids_str))
			return -1;
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":[" ))
			return -1;
		for (as = args->net_ids; *as > 0; ++as) {
			if (as != args->net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->service_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceNames\":[" ))
			return -1;
		for (as = args->service_names; *as > 0; ++as) {
			if (as != args->service_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->service_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->service_names_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_net_peering_setter(struct filters_net_peering *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->accepter_net_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccepterNetAccountIds\":[" ))
			return -1;
		for (as = args->accepter_net_account_ids; *as > 0; ++as) {
			if (as != args->accepter_net_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->accepter_net_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccepterNetAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->accepter_net_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->accepter_net_ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccepterNetIpRanges\":[" ))
			return -1;
		for (as = args->accepter_net_ip_ranges; *as > 0; ++as) {
			if (as != args->accepter_net_ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->accepter_net_ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccepterNetIpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->accepter_net_ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->accepter_net_net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccepterNetNetIds\":[" ))
			return -1;
		for (as = args->accepter_net_net_ids; *as > 0; ++as) {
			if (as != args->accepter_net_net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->accepter_net_net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccepterNetNetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->accepter_net_net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->net_peering_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringIds\":[" ))
			return -1;
		for (as = args->net_peering_ids; *as > 0; ++as) {
			if (as != args->net_peering_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_peering_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_peering_ids_str))
			return -1;
		ret += 1;
	}
	if (args->source_net_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceNetAccountIds\":[" ))
			return -1;
		for (as = args->source_net_account_ids; *as > 0; ++as) {
			if (as != args->source_net_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->source_net_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceNetAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->source_net_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->source_net_ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceNetIpRanges\":[" ))
			return -1;
		for (as = args->source_net_ip_ranges; *as > 0; ++as) {
			if (as != args->source_net_ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->source_net_ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceNetIpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->source_net_ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->source_net_net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceNetNetIds\":[" ))
			return -1;
		for (as = args->source_net_net_ids; *as > 0; ++as) {
			if (as != args->source_net_net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->source_net_net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceNetNetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->source_net_net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->state_messages) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateMessages\":[" ))
			return -1;
		for (as = args->state_messages; *as > 0; ++as) {
			if (as != args->state_messages)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->state_messages_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateMessages\":" ))
			return -1;
                if (osc_str_append_string(data, args->state_messages_str))
			return -1;
		ret += 1;
	}
	if (args->state_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateNames\":[" ))
			return -1;
		for (as = args->state_names; *as > 0; ++as) {
			if (as != args->state_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->state_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->state_names_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_nic_setter(struct filters_nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->descriptions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":[" ))
			return -1;
		for (as = args->descriptions; *as > 0; ++as) {
			if (as != args->descriptions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->descriptions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->descriptions_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_is_source_dest_check) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsSourceDestCheck\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_source_dest_check))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_link_nic_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicDeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->link_nic_delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->link_nic_device_numbers) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicDeviceNumbers\":[" ))
			return -1;
		for (ip = args->link_nic_device_numbers; *ip > 0; ++ip) {
			if (ip != args->link_nic_device_numbers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_nic_device_numbers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicDeviceNumbers\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_device_numbers_str))
			return -1;
		ret += 1;
	}
	if (args->link_nic_link_nic_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicLinkNicIds\":[" ))
			return -1;
		for (as = args->link_nic_link_nic_ids; *as > 0; ++as) {
			if (as != args->link_nic_link_nic_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_nic_link_nic_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicLinkNicIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_link_nic_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_nic_states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicStates\":[" ))
			return -1;
		for (as = args->link_nic_states; *as > 0; ++as) {
			if (as != args->link_nic_states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_nic_states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicStates\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_states_str))
			return -1;
		ret += 1;
	}
	if (args->link_nic_vm_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicVmAccountIds\":[" ))
			return -1;
		for (as = args->link_nic_vm_account_ids; *as > 0; ++as) {
			if (as != args->link_nic_vm_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_nic_vm_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicVmAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_vm_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_nic_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicVmIds\":[" ))
			return -1;
		for (as = args->link_nic_vm_ids; *as > 0; ++as) {
			if (as != args->link_nic_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_nic_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_public_ip_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpAccountIds\":[" ))
			return -1;
		for (as = args->link_public_ip_account_ids; *as > 0; ++as) {
			if (as != args->link_public_ip_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_public_ip_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_public_ip_link_public_ip_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpLinkPublicIpIds\":[" ))
			return -1;
		for (as = args->link_public_ip_link_public_ip_ids; *as > 0; ++as) {
			if (as != args->link_public_ip_link_public_ip_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_public_ip_link_public_ip_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpLinkPublicIpIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_link_public_ip_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_public_ip_public_ip_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpPublicIpIds\":[" ))
			return -1;
		for (as = args->link_public_ip_public_ip_ids; *as > 0; ++as) {
			if (as != args->link_public_ip_public_ip_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_public_ip_public_ip_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpPublicIpIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_public_ip_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_public_ip_public_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpPublicIps\":[" ))
			return -1;
		for (as = args->link_public_ip_public_ips; *as > 0; ++as) {
			if (as != args->link_public_ip_public_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_public_ip_public_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpPublicIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_public_ips_str))
			return -1;
		ret += 1;
	}
	if (args->mac_addresses) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MacAddresses\":[" ))
			return -1;
		for (as = args->mac_addresses; *as > 0; ++as) {
			if (as != args->mac_addresses)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->mac_addresses_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MacAddresses\":" ))
			return -1;
                if (osc_str_append_string(data, args->mac_addresses_str))
			return -1;
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":[" ))
			return -1;
		for (as = args->net_ids; *as > 0; ++as) {
			if (as != args->net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->nic_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicIds\":[" ))
			return -1;
		for (as = args->nic_ids; *as > 0; ++as) {
			if (as != args->nic_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->nic_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->nic_ids_str))
			return -1;
		ret += 1;
	}
	if (args->private_dns_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateDnsNames\":[" ))
			return -1;
		for (as = args->private_dns_names; *as > 0; ++as) {
			if (as != args->private_dns_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->private_dns_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateDnsNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_dns_names_str))
			return -1;
		ret += 1;
	}
	if (args->private_ips_link_public_ip_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIpsLinkPublicIpAccountIds\":[" ))
			return -1;
		for (as = args->private_ips_link_public_ip_account_ids; *as > 0; ++as) {
			if (as != args->private_ips_link_public_ip_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->private_ips_link_public_ip_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIpsLinkPublicIpAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_link_public_ip_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->private_ips_link_public_ip_public_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIpsLinkPublicIpPublicIps\":[" ))
			return -1;
		for (as = args->private_ips_link_public_ip_public_ips; *as > 0; ++as) {
			if (as != args->private_ips_link_public_ip_public_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->private_ips_link_public_ip_public_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIpsLinkPublicIpPublicIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_link_public_ip_public_ips_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_private_ips_primary_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIpsPrimaryIp\":" ))
			return -1;
                if (osc_str_append_bool(data, args->private_ips_primary_ip))
			return -1;
	   	ret += 1;
	}
	if (args->private_ips_private_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIpsPrivateIps\":[" ))
			return -1;
		for (as = args->private_ips_private_ips; *as > 0; ++as) {
			if (as != args->private_ips_private_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->private_ips_private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIpsPrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_private_ips_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":[" ))
			return -1;
		for (as = args->security_group_ids; *as > 0; ++as) {
			if (as != args->security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_ids_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupNames\":[" ))
			return -1;
		for (as = args->security_group_names; *as > 0; ++as) {
			if (as != args->security_group_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_names_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetIds\":[" ))
			return -1;
		for (as = args->subnet_ids; *as > 0; ++as) {
			if (as != args->subnet_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subnet_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_ids_str))
			return -1;
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":[" ))
			return -1;
		for (as = args->subregion_names; *as > 0; ++as) {
			if (as != args->subregion_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subregion_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_names_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_product_type_setter(struct filters_product_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->product_type_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductTypeIds\":[" ))
			return -1;
		for (as = args->product_type_ids; *as > 0; ++as) {
			if (as != args->product_type_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->product_type_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductTypeIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->product_type_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_public_ip_setter(struct filters_public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpIds\":[" ))
			return -1;
		for (as = args->link_public_ip_ids; *as > 0; ++as) {
			if (as != args->link_public_ip_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_public_ip_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_ids_str))
			return -1;
		ret += 1;
	}
	if (args->nic_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicAccountIds\":[" ))
			return -1;
		for (as = args->nic_account_ids; *as > 0; ++as) {
			if (as != args->nic_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->nic_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->nic_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->nic_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicIds\":[" ))
			return -1;
		for (as = args->nic_ids; *as > 0; ++as) {
			if (as != args->nic_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->nic_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->nic_ids_str))
			return -1;
		ret += 1;
	}
	if (args->placements) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Placements\":[" ))
			return -1;
		for (as = args->placements; *as > 0; ++as) {
			if (as != args->placements)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->placements_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Placements\":" ))
			return -1;
                if (osc_str_append_string(data, args->placements_str))
			return -1;
		ret += 1;
	}
	if (args->private_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":[" ))
			return -1;
		for (as = args->private_ips; *as > 0; ++as) {
			if (as != args->private_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_str))
			return -1;
		ret += 1;
	}
	if (args->public_ip_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpIds\":[" ))
			return -1;
		for (as = args->public_ip_ids; *as > 0; ++as) {
			if (as != args->public_ip_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->public_ip_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_ids_str))
			return -1;
		ret += 1;
	}
	if (args->public_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIps\":[" ))
			return -1;
		for (as = args->public_ips; *as > 0; ++as) {
			if (as != args->public_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->public_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->public_ips_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_quota_setter(struct filters_quota *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->collections) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Collections\":[" ))
			return -1;
		for (as = args->collections; *as > 0; ++as) {
			if (as != args->collections)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->collections_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Collections\":" ))
			return -1;
                if (osc_str_append_string(data, args->collections_str))
			return -1;
		ret += 1;
	}
	if (args->quota_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QuotaNames\":[" ))
			return -1;
		for (as = args->quota_names; *as > 0; ++as) {
			if (as != args->quota_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->quota_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QuotaNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->quota_names_str))
			return -1;
		ret += 1;
	}
	if (args->quota_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QuotaTypes\":[" ))
			return -1;
		for (as = args->quota_types; *as > 0; ++as) {
			if (as != args->quota_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->quota_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QuotaTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->quota_types_str))
			return -1;
		ret += 1;
	}
	if (args->short_descriptions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ShortDescriptions\":[" ))
			return -1;
		for (as = args->short_descriptions; *as > 0; ++as) {
			if (as != args->short_descriptions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->short_descriptions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ShortDescriptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->short_descriptions_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_route_table_setter(struct filters_route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_route_table_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTableIds\":[" ))
			return -1;
		for (as = args->link_route_table_ids; *as > 0; ++as) {
			if (as != args->link_route_table_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_route_table_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTableIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_route_table_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_route_table_link_route_table_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTableLinkRouteTableIds\":[" ))
			return -1;
		for (as = args->link_route_table_link_route_table_ids; *as > 0; ++as) {
			if (as != args->link_route_table_link_route_table_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_route_table_link_route_table_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTableLinkRouteTableIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_route_table_link_route_table_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_link_route_table_main) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTableMain\":" ))
			return -1;
                if (osc_str_append_bool(data, args->link_route_table_main))
			return -1;
	   	ret += 1;
	}
	if (args->link_subnet_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkSubnetIds\":[" ))
			return -1;
		for (as = args->link_subnet_ids; *as > 0; ++as) {
			if (as != args->link_subnet_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_subnet_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkSubnetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_subnet_ids_str))
			return -1;
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":[" ))
			return -1;
		for (as = args->net_ids; *as > 0; ++as) {
			if (as != args->net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->route_creation_methods) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteCreationMethods\":[" ))
			return -1;
		for (as = args->route_creation_methods; *as > 0; ++as) {
			if (as != args->route_creation_methods)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_creation_methods_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteCreationMethods\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_creation_methods_str))
			return -1;
		ret += 1;
	}
	if (args->route_destination_ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteDestinationIpRanges\":[" ))
			return -1;
		for (as = args->route_destination_ip_ranges; *as > 0; ++as) {
			if (as != args->route_destination_ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_destination_ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteDestinationIpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_destination_ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->route_destination_service_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteDestinationServiceIds\":[" ))
			return -1;
		for (as = args->route_destination_service_ids; *as > 0; ++as) {
			if (as != args->route_destination_service_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_destination_service_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteDestinationServiceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_destination_service_ids_str))
			return -1;
		ret += 1;
	}
	if (args->route_gateway_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteGatewayIds\":[" ))
			return -1;
		for (as = args->route_gateway_ids; *as > 0; ++as) {
			if (as != args->route_gateway_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_gateway_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteGatewayIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_gateway_ids_str))
			return -1;
		ret += 1;
	}
	if (args->route_nat_service_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteNatServiceIds\":[" ))
			return -1;
		for (as = args->route_nat_service_ids; *as > 0; ++as) {
			if (as != args->route_nat_service_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_nat_service_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteNatServiceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_nat_service_ids_str))
			return -1;
		ret += 1;
	}
	if (args->route_net_peering_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteNetPeeringIds\":[" ))
			return -1;
		for (as = args->route_net_peering_ids; *as > 0; ++as) {
			if (as != args->route_net_peering_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_net_peering_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteNetPeeringIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_net_peering_ids_str))
			return -1;
		ret += 1;
	}
	if (args->route_states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteStates\":[" ))
			return -1;
		for (as = args->route_states; *as > 0; ++as) {
			if (as != args->route_states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteStates\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_states_str))
			return -1;
		ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableIds\":[" ))
			return -1;
		for (as = args->route_table_ids; *as > 0; ++as) {
			if (as != args->route_table_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_table_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_ids_str))
			return -1;
		ret += 1;
	}
	if (args->route_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteVmIds\":[" ))
			return -1;
		for (as = args->route_vm_ids; *as > 0; ++as) {
			if (as != args->route_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_security_group_setter(struct filters_security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountIds\":[" ))
			return -1;
		for (as = args->account_ids; *as > 0; ++as) {
			if (as != args->account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":[" ))
			return -1;
		for (as = args->descriptions; *as > 0; ++as) {
			if (as != args->descriptions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->descriptions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->descriptions_str))
			return -1;
		ret += 1;
	}
	if (args->inbound_rule_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleAccountIds\":[" ))
			return -1;
		for (as = args->inbound_rule_account_ids; *as > 0; ++as) {
			if (as != args->inbound_rule_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->inbound_rule_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->inbound_rule_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->inbound_rule_from_port_ranges) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleFromPortRanges\":[" ))
			return -1;
		for (ip = args->inbound_rule_from_port_ranges; *ip > 0; ++ip) {
			if (ip != args->inbound_rule_from_port_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->inbound_rule_from_port_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleFromPortRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->inbound_rule_from_port_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->inbound_rule_ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleIpRanges\":[" ))
			return -1;
		for (as = args->inbound_rule_ip_ranges; *as > 0; ++as) {
			if (as != args->inbound_rule_ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->inbound_rule_ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleIpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->inbound_rule_ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->inbound_rule_protocols) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleProtocols\":[" ))
			return -1;
		for (as = args->inbound_rule_protocols; *as > 0; ++as) {
			if (as != args->inbound_rule_protocols)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->inbound_rule_protocols_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleProtocols\":" ))
			return -1;
                if (osc_str_append_string(data, args->inbound_rule_protocols_str))
			return -1;
		ret += 1;
	}
	if (args->inbound_rule_security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleSecurityGroupIds\":[" ))
			return -1;
		for (as = args->inbound_rule_security_group_ids; *as > 0; ++as) {
			if (as != args->inbound_rule_security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->inbound_rule_security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleSecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->inbound_rule_security_group_ids_str))
			return -1;
		ret += 1;
	}
	if (args->inbound_rule_security_group_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleSecurityGroupNames\":[" ))
			return -1;
		for (as = args->inbound_rule_security_group_names; *as > 0; ++as) {
			if (as != args->inbound_rule_security_group_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->inbound_rule_security_group_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleSecurityGroupNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->inbound_rule_security_group_names_str))
			return -1;
		ret += 1;
	}
	if (args->inbound_rule_to_port_ranges) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleToPortRanges\":[" ))
			return -1;
		for (ip = args->inbound_rule_to_port_ranges; *ip > 0; ++ip) {
			if (ip != args->inbound_rule_to_port_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->inbound_rule_to_port_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRuleToPortRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->inbound_rule_to_port_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":[" ))
			return -1;
		for (as = args->net_ids; *as > 0; ++as) {
			if (as != args->net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->outbound_rule_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleAccountIds\":[" ))
			return -1;
		for (as = args->outbound_rule_account_ids; *as > 0; ++as) {
			if (as != args->outbound_rule_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->outbound_rule_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->outbound_rule_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->outbound_rule_from_port_ranges) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleFromPortRanges\":[" ))
			return -1;
		for (ip = args->outbound_rule_from_port_ranges; *ip > 0; ++ip) {
			if (ip != args->outbound_rule_from_port_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->outbound_rule_from_port_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleFromPortRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->outbound_rule_from_port_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->outbound_rule_ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleIpRanges\":[" ))
			return -1;
		for (as = args->outbound_rule_ip_ranges; *as > 0; ++as) {
			if (as != args->outbound_rule_ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->outbound_rule_ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleIpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->outbound_rule_ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->outbound_rule_protocols) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleProtocols\":[" ))
			return -1;
		for (as = args->outbound_rule_protocols; *as > 0; ++as) {
			if (as != args->outbound_rule_protocols)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->outbound_rule_protocols_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleProtocols\":" ))
			return -1;
                if (osc_str_append_string(data, args->outbound_rule_protocols_str))
			return -1;
		ret += 1;
	}
	if (args->outbound_rule_security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleSecurityGroupIds\":[" ))
			return -1;
		for (as = args->outbound_rule_security_group_ids; *as > 0; ++as) {
			if (as != args->outbound_rule_security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->outbound_rule_security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleSecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->outbound_rule_security_group_ids_str))
			return -1;
		ret += 1;
	}
	if (args->outbound_rule_security_group_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleSecurityGroupNames\":[" ))
			return -1;
		for (as = args->outbound_rule_security_group_names; *as > 0; ++as) {
			if (as != args->outbound_rule_security_group_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->outbound_rule_security_group_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleSecurityGroupNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->outbound_rule_security_group_names_str))
			return -1;
		ret += 1;
	}
	if (args->outbound_rule_to_port_ranges) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleToPortRanges\":[" ))
			return -1;
		for (ip = args->outbound_rule_to_port_ranges; *ip > 0; ++ip) {
			if (ip != args->outbound_rule_to_port_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->outbound_rule_to_port_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRuleToPortRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->outbound_rule_to_port_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":[" ))
			return -1;
		for (as = args->security_group_ids; *as > 0; ++as) {
			if (as != args->security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_ids_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupNames\":[" ))
			return -1;
		for (as = args->security_group_names; *as > 0; ++as) {
			if (as != args->security_group_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_names_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_server_certificate_setter(struct filters_server_certificate *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->paths) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Paths\":[" ))
			return -1;
		for (as = args->paths; *as > 0; ++as) {
			if (as != args->paths)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->paths_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Paths\":" ))
			return -1;
                if (osc_str_append_string(data, args->paths_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_service_setter(struct filters_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->service_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceIds\":[" ))
			return -1;
		for (as = args->service_ids; *as > 0; ++as) {
			if (as != args->service_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->service_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->service_ids_str))
			return -1;
		ret += 1;
	}
	if (args->service_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceNames\":[" ))
			return -1;
		for (as = args->service_names; *as > 0; ++as) {
			if (as != args->service_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->service_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->service_names_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_snapshot_setter(struct filters_snapshot *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_aliases) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountAliases\":[" ))
			return -1;
		for (as = args->account_aliases; *as > 0; ++as) {
			if (as != args->account_aliases)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->account_aliases_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountAliases\":" ))
			return -1;
                if (osc_str_append_string(data, args->account_aliases_str))
			return -1;
		ret += 1;
	}
	if (args->account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountIds\":[" ))
			return -1;
		for (as = args->account_ids; *as > 0; ++as) {
			if (as != args->account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":[" ))
			return -1;
		for (as = args->descriptions; *as > 0; ++as) {
			if (as != args->descriptions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->descriptions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Descriptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->descriptions_str))
			return -1;
		ret += 1;
	}
	if (args->permissions_to_create_volume_account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToCreateVolumeAccountIds\":[" ))
			return -1;
		for (as = args->permissions_to_create_volume_account_ids; *as > 0; ++as) {
			if (as != args->permissions_to_create_volume_account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->permissions_to_create_volume_account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToCreateVolumeAccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->permissions_to_create_volume_account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_permissions_to_create_volume_global_permission) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToCreateVolumeGlobalPermission\":" ))
			return -1;
                if (osc_str_append_bool(data, args->permissions_to_create_volume_global_permission))
			return -1;
	   	ret += 1;
	}
	if (args->progresses) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Progresses\":[" ))
			return -1;
		for (ip = args->progresses; *ip > 0; ++ip) {
			if (ip != args->progresses)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->progresses_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Progresses\":" ))
			return -1;
                if (osc_str_append_string(data, args->progresses_str))
			return -1;
		ret += 1;
	}
	if (args->snapshot_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotIds\":[" ))
			return -1;
		for (as = args->snapshot_ids; *as > 0; ++as) {
			if (as != args->snapshot_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->snapshot_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_ids_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->volume_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeIds\":[" ))
			return -1;
		for (as = args->volume_ids; *as > 0; ++as) {
			if (as != args->volume_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->volume_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->volume_ids_str))
			return -1;
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSizes\":[" ))
			return -1;
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->volume_sizes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSizes\":" ))
			return -1;
                if (osc_str_append_string(data, args->volume_sizes_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_subnet_setter(struct filters_subnet *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->available_ips_counts) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AvailableIpsCounts\":[" ))
			return -1;
		for (ip = args->available_ips_counts; *ip > 0; ++ip) {
			if (ip != args->available_ips_counts)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->available_ips_counts_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AvailableIpsCounts\":" ))
			return -1;
                if (osc_str_append_string(data, args->available_ips_counts_str))
			return -1;
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":[" ))
			return -1;
		for (as = args->ip_ranges; *as > 0; ++as) {
			if (as != args->ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":[" ))
			return -1;
		for (as = args->net_ids; *as > 0; ++as) {
			if (as != args->net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetIds\":[" ))
			return -1;
		for (as = args->subnet_ids; *as > 0; ++as) {
			if (as != args->subnet_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subnet_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_ids_str))
			return -1;
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":[" ))
			return -1;
		for (as = args->subregion_names; *as > 0; ++as) {
			if (as != args->subregion_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subregion_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_names_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_subregion_setter(struct filters_subregion *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->subregion_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":[" ))
			return -1;
		for (as = args->subregion_names; *as > 0; ++as) {
			if (as != args->subregion_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subregion_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_names_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_tag_setter(struct filters_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Keys\":[" ))
			return -1;
		for (as = args->keys; *as > 0; ++as) {
			if (as != args->keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Keys\":" ))
			return -1;
                if (osc_str_append_string(data, args->keys_str))
			return -1;
		ret += 1;
	}
	if (args->resource_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceIds\":[" ))
			return -1;
		for (as = args->resource_ids; *as > 0; ++as) {
			if (as != args->resource_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->resource_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->resource_ids_str))
			return -1;
		ret += 1;
	}
	if (args->resource_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceTypes\":[" ))
			return -1;
		for (as = args->resource_types; *as > 0; ++as) {
			if (as != args->resource_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->resource_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->resource_types_str))
			return -1;
		ret += 1;
	}
	if (args->values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Values\":[" ))
			return -1;
		for (as = args->values; *as > 0; ++as) {
			if (as != args->values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Values\":" ))
			return -1;
                if (osc_str_append_string(data, args->values_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_virtual_gateway_setter(struct filters_virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->connection_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionTypes\":[" ))
			return -1;
		for (as = args->connection_types; *as > 0; ++as) {
			if (as != args->connection_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->connection_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->connection_types_str))
			return -1;
		ret += 1;
	}
	if (args->link_net_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNetIds\":[" ))
			return -1;
		for (as = args->link_net_ids; *as > 0; ++as) {
			if (as != args->link_net_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_net_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNetIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_net_ids_str))
			return -1;
		ret += 1;
	}
	if (args->link_states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkStates\":[" ))
			return -1;
		for (as = args->link_states; *as > 0; ++as) {
			if (as != args->link_states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkStates\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_states_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->virtual_gateway_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayIds\":[" ))
			return -1;
		for (as = args->virtual_gateway_ids; *as > 0; ++as) {
			if (as != args->virtual_gateway_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->virtual_gateway_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_vm_setter(struct filters_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_vm_type_setter(struct filters_vm_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bsu_optimized) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BsuOptimized\":" ))
			return -1;
                if (osc_str_append_bool(data, args->bsu_optimized))
			return -1;
	   	ret += 1;
	}
	if (args->memory_sizes) {
		double *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MemorySizes\":[" ))
			return -1;
		for (ip = args->memory_sizes; *ip > 0; ++ip) {
			if (ip != args->memory_sizes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_double(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->memory_sizes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MemorySizes\":" ))
			return -1;
                if (osc_str_append_string(data, args->memory_sizes_str))
			return -1;
		ret += 1;
	}
	if (args->vcore_counts) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VcoreCounts\":[" ))
			return -1;
		for (ip = args->vcore_counts; *ip > 0; ++ip) {
			if (ip != args->vcore_counts)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vcore_counts_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VcoreCounts\":" ))
			return -1;
                if (osc_str_append_string(data, args->vcore_counts_str))
			return -1;
		ret += 1;
	}
	if (args->vm_type_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmTypeNames\":[" ))
			return -1;
		for (as = args->vm_type_names; *as > 0; ++as) {
			if (as != args->vm_type_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_type_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmTypeNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_type_names_str))
			return -1;
		ret += 1;
	}
	if (args->volume_counts) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeCounts\":[" ))
			return -1;
		for (ip = args->volume_counts; *ip > 0; ++ip) {
			if (ip != args->volume_counts)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->volume_counts_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeCounts\":" ))
			return -1;
                if (osc_str_append_string(data, args->volume_counts_str))
			return -1;
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSizes\":[" ))
			return -1;
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->volume_sizes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSizes\":" ))
			return -1;
                if (osc_str_append_string(data, args->volume_sizes_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_vms_state_setter(struct filters_vms_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->maintenance_event_codes) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEventCodes\":[" ))
			return -1;
		for (as = args->maintenance_event_codes; *as > 0; ++as) {
			if (as != args->maintenance_event_codes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->maintenance_event_codes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEventCodes\":" ))
			return -1;
                if (osc_str_append_string(data, args->maintenance_event_codes_str))
			return -1;
		ret += 1;
	}
	if (args->maintenance_event_descriptions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEventDescriptions\":[" ))
			return -1;
		for (as = args->maintenance_event_descriptions; *as > 0; ++as) {
			if (as != args->maintenance_event_descriptions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->maintenance_event_descriptions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEventDescriptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->maintenance_event_descriptions_str))
			return -1;
		ret += 1;
	}
	if (args->maintenance_events_not_after) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEventsNotAfter\":[" ))
			return -1;
		for (as = args->maintenance_events_not_after; *as > 0; ++as) {
			if (as != args->maintenance_events_not_after)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->maintenance_events_not_after_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEventsNotAfter\":" ))
			return -1;
                if (osc_str_append_string(data, args->maintenance_events_not_after_str))
			return -1;
		ret += 1;
	}
	if (args->maintenance_events_not_before) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEventsNotBefore\":[" ))
			return -1;
		for (as = args->maintenance_events_not_before; *as > 0; ++as) {
			if (as != args->maintenance_events_not_before)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->maintenance_events_not_before_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEventsNotBefore\":" ))
			return -1;
                if (osc_str_append_string(data, args->maintenance_events_not_before_str))
			return -1;
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":[" ))
			return -1;
		for (as = args->subregion_names; *as > 0; ++as) {
			if (as != args->subregion_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subregion_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_names_str))
			return -1;
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->vm_states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmStates\":[" ))
			return -1;
		for (as = args->vm_states; *as > 0; ++as) {
			if (as != args->vm_states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmStates\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_states_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_volume_setter(struct filters_volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_dates) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationDates\":[" ))
			return -1;
		for (as = args->creation_dates; *as > 0; ++as) {
			if (as != args->creation_dates)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->creation_dates_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationDates\":" ))
			return -1;
                if (osc_str_append_string(data, args->creation_dates_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_link_volume_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeDeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->link_volume_delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->link_volume_device_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeDeviceNames\":[" ))
			return -1;
		for (as = args->link_volume_device_names; *as > 0; ++as) {
			if (as != args->link_volume_device_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_volume_device_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeDeviceNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_volume_device_names_str))
			return -1;
		ret += 1;
	}
	if (args->link_volume_link_dates) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeLinkDates\":[" ))
			return -1;
		for (as = args->link_volume_link_dates; *as > 0; ++as) {
			if (as != args->link_volume_link_dates)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_volume_link_dates_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeLinkDates\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_volume_link_dates_str))
			return -1;
		ret += 1;
	}
	if (args->link_volume_link_states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeLinkStates\":[" ))
			return -1;
		for (as = args->link_volume_link_states; *as > 0; ++as) {
			if (as != args->link_volume_link_states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_volume_link_states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeLinkStates\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_volume_link_states_str))
			return -1;
		ret += 1;
	}
	if (args->link_volume_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeVmIds\":[" ))
			return -1;
		for (as = args->link_volume_vm_ids; *as > 0; ++as) {
			if (as != args->link_volume_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->link_volume_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkVolumeVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_volume_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->snapshot_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotIds\":[" ))
			return -1;
		for (as = args->snapshot_ids; *as > 0; ++as) {
			if (as != args->snapshot_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->snapshot_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_ids_str))
			return -1;
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":[" ))
			return -1;
		for (as = args->subregion_names; *as > 0; ++as) {
			if (as != args->subregion_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subregion_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_names_str))
			return -1;
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->volume_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeIds\":[" ))
			return -1;
		for (as = args->volume_ids; *as > 0; ++as) {
			if (as != args->volume_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->volume_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->volume_ids_str))
			return -1;
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSizes\":[" ))
			return -1;
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->volume_sizes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSizes\":" ))
			return -1;
                if (osc_str_append_string(data, args->volume_sizes_str))
			return -1;
		ret += 1;
	}
	if (args->volume_states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeStates\":[" ))
			return -1;
		for (as = args->volume_states; *as > 0; ++as) {
			if (as != args->volume_states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->volume_states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeStates\":" ))
			return -1;
                if (osc_str_append_string(data, args->volume_states_str))
			return -1;
		ret += 1;
	}
	if (args->volume_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeTypes\":[" ))
			return -1;
		for (as = args->volume_types; *as > 0; ++as) {
			if (as != args->volume_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->volume_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->volume_types_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int filters_vpn_connection_setter(struct filters_vpn_connection *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bgp_asns) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpAsns\":[" ))
			return -1;
		for (ip = args->bgp_asns; *ip > 0; ++ip) {
			if (ip != args->bgp_asns)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->bgp_asns_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpAsns\":" ))
			return -1;
                if (osc_str_append_string(data, args->bgp_asns_str))
			return -1;
		ret += 1;
	}
	if (args->client_gateway_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayIds\":[" ))
			return -1;
		for (as = args->client_gateway_ids; *as > 0; ++as) {
			if (as != args->client_gateway_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->client_gateway_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->client_gateway_ids_str))
			return -1;
		ret += 1;
	}
	if (args->connection_types) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionTypes\":[" ))
			return -1;
		for (as = args->connection_types; *as > 0; ++as) {
			if (as != args->connection_types)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->connection_types_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionTypes\":" ))
			return -1;
                if (osc_str_append_string(data, args->connection_types_str))
			return -1;
		ret += 1;
	}
	if (args->route_destination_ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteDestinationIpRanges\":[" ))
			return -1;
		for (as = args->route_destination_ip_ranges; *as > 0; ++as) {
			if (as != args->route_destination_ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_destination_ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteDestinationIpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_destination_ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->states) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":[" ))
			return -1;
		for (as = args->states; *as > 0; ++as) {
			if (as != args->states)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->states_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"States\":" ))
			return -1;
                if (osc_str_append_string(data, args->states_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_static_routes_only) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StaticRoutesOnly\":" ))
			return -1;
                if (osc_str_append_bool(data, args->static_routes_only))
			return -1;
	   	ret += 1;
	}
	if (args->tag_keys) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":[" ))
			return -1;
		for (as = args->tag_keys; *as > 0; ++as) {
			if (as != args->tag_keys)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_keys_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagKeys\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_keys_str))
			return -1;
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":[" ))
			return -1;
		for (as = args->tag_values; *as > 0; ++as) {
			if (as != args->tag_values)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tag_values_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TagValues\":" ))
			return -1;
                if (osc_str_append_string(data, args->tag_values_str))
			return -1;
		ret += 1;
	}
	if (args->tags) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (as = args->tags; *as > 0; ++as) {
			if (as != args->tags)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->virtual_gateway_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayIds\":[" ))
			return -1;
		for (as = args->virtual_gateway_ids; *as > 0; ++as) {
			if (as != args->virtual_gateway_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->virtual_gateway_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_ids_str))
			return -1;
		ret += 1;
	}
	if (args->vpn_connection_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnConnectionIds\":[" ))
			return -1;
		for (as = args->vpn_connection_ids; *as > 0; ++as) {
			if (as != args->vpn_connection_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vpn_connection_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnConnectionIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vpn_connection_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int flexible_gpu_setter(struct flexible_gpu *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FlexibleGpuId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->flexible_gpu_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->generation) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Generation\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->generation))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->model_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ModelName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->model_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int flexible_gpu_catalog_setter(struct flexible_gpu_catalog *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->generations) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Generations\":[" ))
			return -1;
		for (as = args->generations; *as > 0; ++as) {
			if (as != args->generations)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->generations_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Generations\":" ))
			return -1;
                if (osc_str_append_string(data, args->generations_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_max_cpu || args->max_cpu) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaxCpu\":" ))
			return -1;
                if (osc_str_append_int(data, args->max_cpu))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_max_ram || args->max_ram) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaxRam\":" ))
			return -1;
                if (osc_str_append_int(data, args->max_ram))
			return -1;
	   	ret += 1;
	}
	if (args->model_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ModelName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->model_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_vram || args->vram) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VRam\":" ))
			return -1;
                if (osc_str_append_int(data, args->vram))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int health_check_setter(struct health_check *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_check_interval || args->check_interval) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CheckInterval\":" ))
			return -1;
                if (osc_str_append_int(data, args->check_interval))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_healthy_threshold || args->healthy_threshold) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"HealthyThreshold\":" ))
			return -1;
                if (osc_str_append_int(data, args->healthy_threshold))
			return -1;
	   	ret += 1;
	}
	if (args->path) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Path\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->path))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_port || args->port) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Port\":" ))
			return -1;
                if (osc_str_append_int(data, args->port))
			return -1;
	   	ret += 1;
	}
	if (args->protocol) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Protocol\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->protocol))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_timeout || args->timeout) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Timeout\":" ))
			return -1;
                if (osc_str_append_int(data, args->timeout))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_unhealthy_threshold || args->unhealthy_threshold) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"UnhealthyThreshold\":" ))
			return -1;
                if (osc_str_append_int(data, args->unhealthy_threshold))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int image_setter(struct image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_alias) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountAlias\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_alias))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->architecture) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Architecture\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->architecture))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":[" ))
			return -1;
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_image *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (block_device_mapping_image_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mappings_str))
			return -1;
		ret += 1;
	}
	if (args->creation_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->creation_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->file_location) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FileLocation\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->file_location))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->image_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->image_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->image_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->permissions_to_launch_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToLaunch\":" ))
			return -1;
                if (osc_str_append_string(data, args->permissions_to_launch_str))
			return -1;
		ret += 1;
	} else if (args->is_set_permissions_to_launch) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"PermissionsToLaunch\": { " ))
			return -1;
	       if (permissions_on_resource_setter(&args->permissions_to_launch, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->product_codes) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductCodes\":[" ))
			return -1;
		for (as = args->product_codes; *as > 0; ++as) {
			if (as != args->product_codes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->product_codes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductCodes\":" ))
			return -1;
                if (osc_str_append_string(data, args->product_codes_str))
			return -1;
		ret += 1;
	}
	if (args->root_device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->root_device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->root_device_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->root_device_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state_comment_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateComment\":" ))
			return -1;
                if (osc_str_append_string(data, args->state_comment_str))
			return -1;
		ret += 1;
	} else if (args->is_set_state_comment) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"StateComment\": { " ))
			return -1;
	       if (state_comment_setter(&args->state_comment, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int image_export_task_setter(struct image_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->comment) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Comment\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->comment))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->image_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_export_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuExport\":" ))
			return -1;
                if (osc_str_append_string(data, args->osu_export_str))
			return -1;
		ret += 1;
	} else if (args->is_set_osu_export) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"OsuExport\": { " ))
			return -1;
	       if (osu_export_image_export_task_setter(&args->osu_export, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Progress\":" ))
			return -1;
                if (osc_str_append_int(data, args->progress))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->task_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TaskId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->task_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int internet_service_setter(struct internet_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->internet_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InternetServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->internet_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int keypair_setter(struct keypair *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprint) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairFingerprint\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_fingerprint))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->keypair_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int keypair_created_setter(struct keypair_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprint) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairFingerprint\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_fingerprint))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->keypair_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int link_nic_setter(struct link_nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceNumber\":" ))
			return -1;
                if (osc_str_append_int(data, args->device_number))
			return -1;
	   	ret += 1;
	}
	if (args->link_nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmAccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int link_nic_light_setter(struct link_nic_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceNumber\":" ))
			return -1;
                if (osc_str_append_int(data, args->device_number))
			return -1;
	   	ret += 1;
	}
	if (args->link_nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int link_nic_to_update_setter(struct link_nic_to_update *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->link_nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int link_public_ip_setter(struct link_public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicDnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip_account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpAccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int link_public_ip_light_for_vm_setter(struct link_public_ip_light_for_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->public_dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicDnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip_account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpAccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int link_route_table_setter(struct link_route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_main) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Main\":" ))
			return -1;
                if (osc_str_append_bool(data, args->main))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int linked_volume_setter(struct linked_volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int listener_setter(struct listener *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_backend_port || args->backend_port) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendPort\":" ))
			return -1;
                if (osc_str_append_int(data, args->backend_port))
			return -1;
	   	ret += 1;
	}
	if (args->backend_protocol) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendProtocol\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->backend_protocol))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerPort\":" ))
			return -1;
                if (osc_str_append_int(data, args->load_balancer_port))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_protocol) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerProtocol\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_protocol))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->policy_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyNames\":[" ))
			return -1;
		for (as = args->policy_names; *as > 0; ++as) {
			if (as != args->policy_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->policy_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->policy_names_str))
			return -1;
		ret += 1;
	}
	if (args->server_certificate_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServerCertificateId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->server_certificate_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int listener_for_creation_setter(struct listener_for_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_backend_port || args->backend_port) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendPort\":" ))
			return -1;
                if (osc_str_append_int(data, args->backend_port))
			return -1;
	   	ret += 1;
	}
	if (args->backend_protocol) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendProtocol\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->backend_protocol))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerPort\":" ))
			return -1;
                if (osc_str_append_int(data, args->load_balancer_port))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_protocol) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerProtocol\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_protocol))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->server_certificate_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServerCertificateId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->server_certificate_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int listener_rule_setter(struct listener_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->action) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Action\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->action))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->host_name_pattern) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"HostNamePattern\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->host_name_pattern))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_listener_id || args->listener_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerId\":" ))
			return -1;
                if (osc_str_append_int(data, args->listener_id))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_listener_rule_id || args->listener_rule_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerRuleId\":" ))
			return -1;
                if (osc_str_append_int(data, args->listener_rule_id))
			return -1;
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerRuleName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->listener_rule_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->path_pattern) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PathPattern\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->path_pattern))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_priority || args->priority) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Priority\":" ))
			return -1;
                if (osc_str_append_int(data, args->priority))
			return -1;
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int listener_rule_for_creation_setter(struct listener_rule_for_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->action) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Action\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->action))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->host_name_pattern) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"HostNamePattern\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->host_name_pattern))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerRuleName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->listener_rule_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->path_pattern) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PathPattern\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->path_pattern))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_priority || args->priority) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Priority\":" ))
			return -1;
                if (osc_str_append_int(data, args->priority))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int load_balancer_setter(struct load_balancer *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_log_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessLog\":" ))
			return -1;
                if (osc_str_append_string(data, args->access_log_str))
			return -1;
		ret += 1;
	} else if (args->is_set_access_log) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"AccessLog\": { " ))
			return -1;
	       if (access_log_setter(&args->access_log, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
        if (args->application_sticky_cookie_policies) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ApplicationStickyCookiePolicies\":[" ))
			return -1;
		for (int i = 0; i < args->nb_application_sticky_cookie_policies; ++i) {
	       	    struct application_sticky_cookie_policy *p = &args->application_sticky_cookie_policies[i];
		    if (p != args->application_sticky_cookie_policies)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (application_sticky_cookie_policy_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->application_sticky_cookie_policies_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ApplicationStickyCookiePolicies\":" ))
			return -1;
                if (osc_str_append_string(data, args->application_sticky_cookie_policies_str))
			return -1;
		ret += 1;
	}
	if (args->backend_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendIps\":[" ))
			return -1;
		for (as = args->backend_ips; *as > 0; ++as) {
			if (as != args->backend_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_ips_str))
			return -1;
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":[" ))
			return -1;
		for (as = args->backend_vm_ids; *as > 0; ++as) {
			if (as != args->backend_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->health_check_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"HealthCheck\":" ))
			return -1;
                if (osc_str_append_string(data, args->health_check_str))
			return -1;
		ret += 1;
	} else if (args->is_set_health_check) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"HealthCheck\": { " ))
			return -1;
	       if (health_check_setter(&args->health_check, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
        if (args->listeners) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Listeners\":[" ))
			return -1;
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener *p = &args->listeners[i];
		    if (p != args->listeners)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (listener_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->listeners_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Listeners\":" ))
			return -1;
                if (osc_str_append_string(data, args->listeners_str))
			return -1;
		ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->load_balancer_sticky_cookie_policies) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerStickyCookiePolicies\":[" ))
			return -1;
		for (int i = 0; i < args->nb_load_balancer_sticky_cookie_policies; ++i) {
	       	    struct load_balancer_sticky_cookie_policy *p = &args->load_balancer_sticky_cookie_policies[i];
		    if (p != args->load_balancer_sticky_cookie_policies)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (load_balancer_sticky_cookie_policy_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->load_balancer_sticky_cookie_policies_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerStickyCookiePolicies\":" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_sticky_cookie_policies_str))
			return -1;
		ret += 1;
	}
	if (args->load_balancer_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_secured_cookies) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecuredCookies\":" ))
			return -1;
                if (osc_str_append_bool(data, args->secured_cookies))
			return -1;
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":[" ))
			return -1;
		for (as = args->security_groups; *as > 0; ++as) {
			if (as != args->security_groups)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_groups_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_groups_str))
			return -1;
		ret += 1;
	}
	if (args->source_security_group_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceSecurityGroup\":" ))
			return -1;
                if (osc_str_append_string(data, args->source_security_group_str))
			return -1;
		ret += 1;
	} else if (args->is_set_source_security_group) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"SourceSecurityGroup\": { " ))
			return -1;
	       if (source_security_group_setter(&args->source_security_group, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->subnets) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Subnets\":[" ))
			return -1;
		for (as = args->subnets; *as > 0; ++as) {
			if (as != args->subnets)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subnets_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Subnets\":" ))
			return -1;
                if (osc_str_append_string(data, args->subnets_str))
			return -1;
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":[" ))
			return -1;
		for (as = args->subregion_names; *as > 0; ++as) {
			if (as != args->subregion_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subregion_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_names_str))
			return -1;
		ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int load_balancer_light_setter(struct load_balancer_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerPort\":" ))
			return -1;
                if (osc_str_append_int(data, args->load_balancer_port))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int load_balancer_sticky_cookie_policy_setter(struct load_balancer_sticky_cookie_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_cookie_expiration_period || args->cookie_expiration_period) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CookieExpirationPeriod\":" ))
			return -1;
                if (osc_str_append_int(data, args->cookie_expiration_period))
			return -1;
	   	ret += 1;
	}
	if (args->policy_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->policy_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int load_balancer_tag_setter(struct load_balancer_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Key\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->value) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Value\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->value))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int location_setter(struct location *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Code\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->code))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Name\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int log_setter(struct log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_call_duration || args->call_duration) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CallDuration\":" ))
			return -1;
                if (osc_str_append_int(data, args->call_duration))
			return -1;
	   	ret += 1;
	}
	if (args->query_access_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryAccessKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_access_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->query_api_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryApiName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_api_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->query_api_version) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryApiVersion\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_api_version))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->query_call_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryCallName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_call_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->query_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->query_header_raw) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryHeaderRaw\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_header_raw))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_header_size || args->query_header_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryHeaderSize\":" ))
			return -1;
                if (osc_str_append_int(data, args->query_header_size))
			return -1;
	   	ret += 1;
	}
	if (args->query_ip_address) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryIpAddress\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_ip_address))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->query_payload_raw) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryPayloadRaw\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_payload_raw))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_payload_size || args->query_payload_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryPayloadSize\":" ))
			return -1;
                if (osc_str_append_int(data, args->query_payload_size))
			return -1;
	   	ret += 1;
	}
	if (args->query_user_agent) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryUserAgent\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->query_user_agent))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->request_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RequestId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->request_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_response_size || args->response_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResponseSize\":" ))
			return -1;
                if (osc_str_append_int(data, args->response_size))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_response_status_code || args->response_status_code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResponseStatusCode\":" ))
			return -1;
                if (osc_str_append_int(data, args->response_status_code))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int maintenance_event_setter(struct maintenance_event *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Code\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->code))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->not_after) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NotAfter\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->not_after))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->not_before) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NotBefore\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->not_before))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int nat_service_setter(struct nat_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->nat_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NatServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nat_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->public_ips) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIps\":[" ))
			return -1;
		for (int i = 0; i < args->nb_public_ips; ++i) {
	       	    struct public_ip_light *p = &args->public_ips[i];
		    if (p != args->public_ips)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (public_ip_light_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->public_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->public_ips_str))
			return -1;
		ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int net_setter(struct net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dhcp_options_set_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DhcpOptionsSetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->dhcp_options_set_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->tenancy) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tenancy\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->tenancy))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int net_access_point_setter(struct net_access_point *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_access_point_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetAccessPointId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_access_point_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableIds\":[" ))
			return -1;
		for (as = args->route_table_ids; *as > 0; ++as) {
			if (as != args->route_table_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_table_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_ids_str))
			return -1;
		ret += 1;
	}
	if (args->service_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->service_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int net_peering_setter(struct net_peering *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->accepter_net_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccepterNet\":" ))
			return -1;
                if (osc_str_append_string(data, args->accepter_net_str))
			return -1;
		ret += 1;
	} else if (args->is_set_accepter_net) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"AccepterNet\": { " ))
			return -1;
	       if (accepter_net_setter(&args->accepter_net, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->net_peering_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_peering_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->source_net_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceNet\":" ))
			return -1;
                if (osc_str_append_string(data, args->source_net_str))
			return -1;
		ret += 1;
	} else if (args->is_set_source_net) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"SourceNet\": { " ))
			return -1;
	       if (source_net_setter(&args->source_net, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->state_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":" ))
			return -1;
                if (osc_str_append_string(data, args->state_str))
			return -1;
		ret += 1;
	} else if (args->is_set_state) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"State\": { " ))
			return -1;
	       if (net_peering_state_setter(&args->state, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int net_peering_state_setter(struct net_peering_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->message) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Message\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->message))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Name\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int net_to_virtual_gateway_link_setter(struct net_to_virtual_gateway_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int nic_setter(struct nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsSourceDestChecked\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_source_dest_checked))
			return -1;
	   	ret += 1;
	}
	if (args->link_nic_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNic\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_str))
			return -1;
		ret += 1;
	} else if (args->is_set_link_nic) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"LinkNic\": { " ))
			return -1;
	       if (link_nic_setter(&args->link_nic, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->link_public_ip_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIp\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_str))
			return -1;
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"LinkPublicIp\": { " ))
			return -1;
	       if (link_public_ip_setter(&args->link_public_ip, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->mac_address) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MacAddress\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->mac_address))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateDnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->private_ips) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":[" ))
			return -1;
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (private_ip_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_str))
			return -1;
		ret += 1;
	}
        if (args->security_groups) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":[" ))
			return -1;
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (security_group_light_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->security_groups_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_groups_str))
			return -1;
		ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int nic_for_vm_creation_setter(struct nic_for_vm_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceNumber\":" ))
			return -1;
                if (osc_str_append_int(data, args->device_number))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->private_ips) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":[" ))
			return -1;
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (private_ip_light_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_secondary_private_ip_count || args->secondary_private_ip_count) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecondaryPrivateIpCount\":" ))
			return -1;
                if (osc_str_append_int(data, args->secondary_private_ip_count))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":[" ))
			return -1;
		for (as = args->security_group_ids; *as > 0; ++as) {
			if (as != args->security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_ids_str))
			return -1;
		ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int nic_light_setter(struct nic_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsSourceDestChecked\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_source_dest_checked))
			return -1;
	   	ret += 1;
	}
	if (args->link_nic_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNic\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_str))
			return -1;
		ret += 1;
	} else if (args->is_set_link_nic) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"LinkNic\": { " ))
			return -1;
	       if (link_nic_light_setter(&args->link_nic, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->link_public_ip_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIp\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_str))
			return -1;
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"LinkPublicIp\": { " ))
			return -1;
	       if (link_public_ip_light_for_vm_setter(&args->link_public_ip, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->mac_address) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MacAddress\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->mac_address))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateDnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->private_ips) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":[" ))
			return -1;
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light_for_vm *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (private_ip_light_for_vm_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_str))
			return -1;
		ret += 1;
	}
        if (args->security_groups) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":[" ))
			return -1;
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (security_group_light_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->security_groups_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_groups_str))
			return -1;
		ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int osu_api_key_setter(struct osu_api_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_key_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ApiKeyId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->api_key_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->secret_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecretKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->secret_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int osu_export_image_export_task_setter(struct osu_export_image_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DiskImageFormat\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->disk_image_format))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_bucket) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuBucket\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_bucket))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_manifest_url) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuManifestUrl\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_manifest_url))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_prefix) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuPrefix\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_prefix))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int osu_export_snapshot_export_task_setter(struct osu_export_snapshot_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DiskImageFormat\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->disk_image_format))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_bucket) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuBucket\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_bucket))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_prefix) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuPrefix\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_prefix))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int osu_export_to_create_setter(struct osu_export_to_create *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DiskImageFormat\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->disk_image_format))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_api_key_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuApiKey\":" ))
			return -1;
                if (osc_str_append_string(data, args->osu_api_key_str))
			return -1;
		ret += 1;
	} else if (args->is_set_osu_api_key) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"OsuApiKey\": { " ))
			return -1;
	       if (osu_api_key_setter(&args->osu_api_key, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->osu_bucket) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuBucket\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_bucket))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_manifest_url) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuManifestUrl\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_manifest_url))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_prefix) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuPrefix\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->osu_prefix))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int permissions_on_resource_setter(struct permissions_on_resource *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountIds\":[" ))
			return -1;
		for (as = args->account_ids; *as > 0; ++as) {
			if (as != args->account_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->account_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->account_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_global_permission) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"GlobalPermission\":" ))
			return -1;
                if (osc_str_append_bool(data, args->global_permission))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int permissions_on_resource_creation_setter(struct permissions_on_resource_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->additions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Additions\":" ))
			return -1;
                if (osc_str_append_string(data, args->additions_str))
			return -1;
		ret += 1;
	} else if (args->is_set_additions) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Additions\": { " ))
			return -1;
	       if (permissions_on_resource_setter(&args->additions, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->removals_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Removals\":" ))
			return -1;
                if (osc_str_append_string(data, args->removals_str))
			return -1;
		ret += 1;
	} else if (args->is_set_removals) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Removals\": { " ))
			return -1;
	       if (permissions_on_resource_setter(&args->removals, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	return !!ret;
}
static int phase1_options_setter(struct phase1_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dpd_timeout_action) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DpdTimeoutAction\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->dpd_timeout_action))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dpd_timeout_seconds || args->dpd_timeout_seconds) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DpdTimeoutSeconds\":" ))
			return -1;
                if (osc_str_append_int(data, args->dpd_timeout_seconds))
			return -1;
	   	ret += 1;
	}
	if (args->ike_versions) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IkeVersions\":[" ))
			return -1;
		for (as = args->ike_versions; *as > 0; ++as) {
			if (as != args->ike_versions)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ike_versions_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IkeVersions\":" ))
			return -1;
                if (osc_str_append_string(data, args->ike_versions_str))
			return -1;
		ret += 1;
	}
	if (args->phase1_dh_group_numbers) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase1DhGroupNumbers\":[" ))
			return -1;
		for (ip = args->phase1_dh_group_numbers; *ip > 0; ++ip) {
			if (ip != args->phase1_dh_group_numbers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->phase1_dh_group_numbers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase1DhGroupNumbers\":" ))
			return -1;
                if (osc_str_append_string(data, args->phase1_dh_group_numbers_str))
			return -1;
		ret += 1;
	}
	if (args->phase1_encryption_algorithms) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase1EncryptionAlgorithms\":[" ))
			return -1;
		for (as = args->phase1_encryption_algorithms; *as > 0; ++as) {
			if (as != args->phase1_encryption_algorithms)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->phase1_encryption_algorithms_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase1EncryptionAlgorithms\":" ))
			return -1;
                if (osc_str_append_string(data, args->phase1_encryption_algorithms_str))
			return -1;
		ret += 1;
	}
	if (args->phase1_integrity_algorithms) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase1IntegrityAlgorithms\":[" ))
			return -1;
		for (as = args->phase1_integrity_algorithms; *as > 0; ++as) {
			if (as != args->phase1_integrity_algorithms)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->phase1_integrity_algorithms_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase1IntegrityAlgorithms\":" ))
			return -1;
                if (osc_str_append_string(data, args->phase1_integrity_algorithms_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_phase1_lifetime_seconds || args->phase1_lifetime_seconds) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase1LifetimeSeconds\":" ))
			return -1;
                if (osc_str_append_int(data, args->phase1_lifetime_seconds))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_replay_window_size || args->replay_window_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ReplayWindowSize\":" ))
			return -1;
                if (osc_str_append_int(data, args->replay_window_size))
			return -1;
	   	ret += 1;
	}
	if (args->startup_action) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StartupAction\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->startup_action))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int phase2_options_setter(struct phase2_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->phase2_dh_group_numbers) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase2DhGroupNumbers\":[" ))
			return -1;
		for (ip = args->phase2_dh_group_numbers; *ip > 0; ++ip) {
			if (ip != args->phase2_dh_group_numbers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->phase2_dh_group_numbers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase2DhGroupNumbers\":" ))
			return -1;
                if (osc_str_append_string(data, args->phase2_dh_group_numbers_str))
			return -1;
		ret += 1;
	}
	if (args->phase2_encryption_algorithms) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase2EncryptionAlgorithms\":[" ))
			return -1;
		for (as = args->phase2_encryption_algorithms; *as > 0; ++as) {
			if (as != args->phase2_encryption_algorithms)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->phase2_encryption_algorithms_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase2EncryptionAlgorithms\":" ))
			return -1;
                if (osc_str_append_string(data, args->phase2_encryption_algorithms_str))
			return -1;
		ret += 1;
	}
	if (args->phase2_integrity_algorithms) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase2IntegrityAlgorithms\":[" ))
			return -1;
		for (as = args->phase2_integrity_algorithms; *as > 0; ++as) {
			if (as != args->phase2_integrity_algorithms)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->phase2_integrity_algorithms_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase2IntegrityAlgorithms\":" ))
			return -1;
                if (osc_str_append_string(data, args->phase2_integrity_algorithms_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_phase2_lifetime_seconds || args->phase2_lifetime_seconds) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase2LifetimeSeconds\":" ))
			return -1;
                if (osc_str_append_int(data, args->phase2_lifetime_seconds))
			return -1;
	   	ret += 1;
	}
	if (args->pre_shared_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PreSharedKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->pre_shared_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int placement_setter(struct placement *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->tenancy) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tenancy\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->tenancy))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int private_ip_setter(struct private_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsPrimary\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_primary))
			return -1;
	   	ret += 1;
	}
	if (args->link_public_ip_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIp\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_str))
			return -1;
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"LinkPublicIp\": { " ))
			return -1;
	       if (link_public_ip_setter(&args->link_public_ip, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->private_dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateDnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int private_ip_light_setter(struct private_ip_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsPrimary\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_primary))
			return -1;
	   	ret += 1;
	}
	if (args->private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int private_ip_light_for_vm_setter(struct private_ip_light_for_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsPrimary\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_primary))
			return -1;
	   	ret += 1;
	}
	if (args->link_public_ip_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIp\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_str))
			return -1;
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"LinkPublicIp\": { " ))
			return -1;
	       if (link_public_ip_light_for_vm_setter(&args->link_public_ip, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->private_dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateDnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int product_type_setter(struct product_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->product_type_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductTypeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->product_type_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vendor) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Vendor\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vendor))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int public_ip_setter(struct public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nic_account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicAccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int public_ip_light_setter(struct public_ip_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int quota_setter(struct quota *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_max_value || args->max_value) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaxValue\":" ))
			return -1;
                if (osc_str_append_int(data, args->max_value))
			return -1;
	   	ret += 1;
	}
	if (args->name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Name\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->quota_collection) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QuotaCollection\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->quota_collection))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->short_description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ShortDescription\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->short_description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_used_value || args->used_value) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"UsedValue\":" ))
			return -1;
                if (osc_str_append_int(data, args->used_value))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int quota_types_setter(struct quota_types *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->quota_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QuotaType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->quota_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->quotas) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Quotas\":[" ))
			return -1;
		for (int i = 0; i < args->nb_quotas; ++i) {
	       	    struct quota *p = &args->quotas[i];
		    if (p != args->quotas)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (quota_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->quotas_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Quotas\":" ))
			return -1;
                if (osc_str_append_string(data, args->quotas_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int region_setter(struct region *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->endpoint) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Endpoint\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->endpoint))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->region_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RegionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->region_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int resource_load_balancer_tag_setter(struct resource_load_balancer_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Key\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int resource_tag_setter(struct resource_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Key\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->value) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Value\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->value))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int route_setter(struct route *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_method) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationMethod\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->creation_method))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->destination_ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DestinationIpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->destination_ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->destination_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DestinationServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->destination_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"GatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nat_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NatServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nat_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetAccessPointId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_access_point_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_peering_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_peering_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmAccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int route_light_setter(struct route_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->destination_ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DestinationIpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->destination_ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->route_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int route_propagating_virtual_gateway_setter(struct route_propagating_virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int route_table_setter(struct route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->link_route_tables) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTables\":[" ))
			return -1;
		for (int i = 0; i < args->nb_link_route_tables; ++i) {
	       	    struct link_route_table *p = &args->link_route_tables[i];
		    if (p != args->link_route_tables)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (link_route_table_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->link_route_tables_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTables\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_route_tables_str))
			return -1;
		ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->route_propagating_virtual_gateways) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RoutePropagatingVirtualGateways\":[" ))
			return -1;
		for (int i = 0; i < args->nb_route_propagating_virtual_gateways; ++i) {
	       	    struct route_propagating_virtual_gateway *p = &args->route_propagating_virtual_gateways[i];
		    if (p != args->route_propagating_virtual_gateways)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (route_propagating_virtual_gateway_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->route_propagating_virtual_gateways_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RoutePropagatingVirtualGateways\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_propagating_virtual_gateways_str))
			return -1;
		ret += 1;
	}
	if (args->route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->routes) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Routes\":[" ))
			return -1;
		for (int i = 0; i < args->nb_routes; ++i) {
	       	    struct route *p = &args->routes[i];
		    if (p != args->routes)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (route_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->routes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Routes\":" ))
			return -1;
                if (osc_str_append_string(data, args->routes_str))
			return -1;
		ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int security_group_setter(struct security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->inbound_rules) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRules\":[" ))
			return -1;
		for (int i = 0; i < args->nb_inbound_rules; ++i) {
	       	    struct security_group_rule *p = &args->inbound_rules[i];
		    if (p != args->inbound_rules)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (security_group_rule_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->inbound_rules_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InboundRules\":" ))
			return -1;
                if (osc_str_append_string(data, args->inbound_rules_str))
			return -1;
		ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->outbound_rules) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRules\":[" ))
			return -1;
		for (int i = 0; i < args->nb_outbound_rules; ++i) {
	       	    struct security_group_rule *p = &args->outbound_rules[i];
		    if (p != args->outbound_rules)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (security_group_rule_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->outbound_rules_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutboundRules\":" ))
			return -1;
                if (osc_str_append_string(data, args->outbound_rules_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int security_group_light_setter(struct security_group_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->security_group_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int security_group_rule_setter(struct security_group_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_from_port_range || args->from_port_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FromPortRange\":" ))
			return -1;
                if (osc_str_append_int(data, args->from_port_range))
			return -1;
	   	ret += 1;
	}
	if (args->ip_protocol) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpProtocol\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_protocol))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":[" ))
			return -1;
		for (as = args->ip_ranges; *as > 0; ++as) {
			if (as != args->ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->ip_ranges_str))
			return -1;
		ret += 1;
	}
        if (args->security_groups_members) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupsMembers\":[" ))
			return -1;
		for (int i = 0; i < args->nb_security_groups_members; ++i) {
	       	    struct security_groups_member *p = &args->security_groups_members[i];
		    if (p != args->security_groups_members)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (security_groups_member_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->security_groups_members_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupsMembers\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_groups_members_str))
			return -1;
		ret += 1;
	}
	if (args->service_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceIds\":[" ))
			return -1;
		for (as = args->service_ids; *as > 0; ++as) {
			if (as != args->service_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->service_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->service_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ToPortRange\":" ))
			return -1;
                if (osc_str_append_int(data, args->to_port_range))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int security_groups_member_setter(struct security_groups_member *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int server_certificate_setter(struct server_certificate *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->expiration_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ExpirationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->expiration_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Id\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Name\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->orn) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Orn\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->orn))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->path) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Path\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->path))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->upload_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"UploadDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->upload_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int service_setter(struct service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":[" ))
			return -1;
		for (as = args->ip_ranges; *as > 0; ++as) {
			if (as != args->ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->ip_ranges_str))
			return -1;
		ret += 1;
	}
	if (args->service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->service_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->service_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int snapshot_setter(struct snapshot *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_alias) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountAlias\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_alias))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->creation_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->creation_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->permissions_to_create_volume_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToCreateVolume\":" ))
			return -1;
                if (osc_str_append_string(data, args->permissions_to_create_volume_str))
			return -1;
		ret += 1;
	} else if (args->is_set_permissions_to_create_volume) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"PermissionsToCreateVolume\": { " ))
			return -1;
	       if (permissions_on_resource_setter(&args->permissions_to_create_volume, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Progress\":" ))
			return -1;
                if (osc_str_append_int(data, args->progress))
			return -1;
	   	ret += 1;
	}
	if (args->snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSize\":" ))
			return -1;
                if (osc_str_append_int(data, args->volume_size))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int snapshot_export_task_setter(struct snapshot_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->comment) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Comment\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->comment))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_export_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuExport\":" ))
			return -1;
                if (osc_str_append_string(data, args->osu_export_str))
			return -1;
		ret += 1;
	} else if (args->is_set_osu_export) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"OsuExport\": { " ))
			return -1;
	       if (osu_export_snapshot_export_task_setter(&args->osu_export, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Progress\":" ))
			return -1;
                if (osc_str_append_int(data, args->progress))
			return -1;
	   	ret += 1;
	}
	if (args->snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->task_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TaskId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->task_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int source_net_setter(struct source_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int source_security_group_setter(struct source_security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->security_group_account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupAccountId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_account_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int state_comment_setter(struct state_comment *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->state_code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateCode\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state_code))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state_message) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateMessage\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state_message))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int subnet_setter(struct subnet *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_available_ips_count || args->available_ips_count) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AvailableIpsCount\":" ))
			return -1;
                if (osc_str_append_int(data, args->available_ips_count))
			return -1;
	   	ret += 1;
	}
	if (args->ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_map_public_ip_on_launch) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MapPublicIpOnLaunch\":" ))
			return -1;
                if (osc_str_append_bool(data, args->map_public_ip_on_launch))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	return !!ret;
}
static int subregion_setter(struct subregion *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->location_code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LocationCode\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->location_code))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->region_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RegionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->region_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int tag_setter(struct tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Key\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->resource_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->resource_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->resource_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->resource_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->value) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Value\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->value))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int vgw_telemetry_setter(struct vgw_telemetry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_accepted_route_count || args->accepted_route_count) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AcceptedRouteCount\":" ))
			return -1;
                if (osc_str_append_int(data, args->accepted_route_count))
			return -1;
	   	ret += 1;
	}
	if (args->last_state_change_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LastStateChangeDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->last_state_change_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->outside_ip_address) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OutsideIpAddress\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->outside_ip_address))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state_description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateDescription\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state_description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int virtual_gateway_setter(struct virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->connection_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->connection_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->net_to_virtual_gateway_links) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetToVirtualGatewayLinks\":[" ))
			return -1;
		for (int i = 0; i < args->nb_net_to_virtual_gateway_links; ++i) {
	       	    struct net_to_virtual_gateway_link *p = &args->net_to_virtual_gateway_links[i];
		    if (p != args->net_to_virtual_gateway_links)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (net_to_virtual_gateway_link_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->net_to_virtual_gateway_links_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetToVirtualGatewayLinks\":" ))
			return -1;
                if (osc_str_append_string(data, args->net_to_virtual_gateway_links_str))
			return -1;
		ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int vm_setter(struct vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->architecture) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Architecture\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->architecture))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":[" ))
			return -1;
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_created *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (block_device_mapping_created_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mappings_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BsuOptimized\":" ))
			return -1;
                if (osc_str_append_bool(data, args->bsu_optimized))
			return -1;
	   	ret += 1;
	}
	if (args->client_token) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientToken\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_token))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->creation_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->creation_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeletionProtection\":" ))
			return -1;
                if (osc_str_append_bool(data, args->deletion_protection))
			return -1;
	   	ret += 1;
	}
	if (args->hypervisor) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Hypervisor\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->hypervisor))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->image_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsSourceDestChecked\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_source_dest_checked))
			return -1;
	   	ret += 1;
	}
	if (args->keypair_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_launch_number || args->launch_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LaunchNumber\":" ))
			return -1;
                if (osc_str_append_int(data, args->launch_number))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NestedVirtualization\":" ))
			return -1;
                if (osc_str_append_bool(data, args->nested_virtualization))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->nics) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Nics\":[" ))
			return -1;
		for (int i = 0; i < args->nb_nics; ++i) {
	       	    struct nic_light *p = &args->nics[i];
		    if (p != args->nics)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (nic_light_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->nics_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Nics\":" ))
			return -1;
                if (osc_str_append_string(data, args->nics_str))
			return -1;
		ret += 1;
	}
	if (args->os_family) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsFamily\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->os_family))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->performance) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Performance\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->performance))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->placement_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Placement\":" ))
			return -1;
                if (osc_str_append_string(data, args->placement_str))
			return -1;
		ret += 1;
	} else if (args->is_set_placement) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Placement\": { " ))
			return -1;
	       if (placement_setter(&args->placement, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->private_dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateDnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->product_codes) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductCodes\":[" ))
			return -1;
		for (as = args->product_codes; *as > 0; ++as) {
			if (as != args->product_codes)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->product_codes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ProductCodes\":" ))
			return -1;
                if (osc_str_append_string(data, args->product_codes_str))
			return -1;
		ret += 1;
	}
	if (args->public_dns_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicDnsName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_dns_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->reservation_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ReservationId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->reservation_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->root_device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->root_device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->root_device_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->root_device_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->security_groups) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":[" ))
			return -1;
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (security_group_light_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->security_groups_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_groups_str))
			return -1;
		ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state_reason) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateReason\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state_reason))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->user_data) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"UserData\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->user_data))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmInitiatedShutdownBehavior\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_initiated_shutdown_behavior))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int vm_state_setter(struct vm_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->current_state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CurrentState\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->current_state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->previous_state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PreviousState\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->previous_state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int vm_states_setter(struct vm_states *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->maintenance_events) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEvents\":[" ))
			return -1;
		for (int i = 0; i < args->nb_maintenance_events; ++i) {
	       	    struct maintenance_event *p = &args->maintenance_events[i];
		    if (p != args->maintenance_events)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (maintenance_event_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->maintenance_events_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaintenanceEvents\":" ))
			return -1;
                if (osc_str_append_string(data, args->maintenance_events_str))
			return -1;
		ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmState\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int vm_type_setter(struct vm_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bsu_optimized) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BsuOptimized\":" ))
			return -1;
                if (osc_str_append_bool(data, args->bsu_optimized))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_max_private_ips || args->max_private_ips) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaxPrivateIps\":" ))
			return -1;
                if (osc_str_append_int(data, args->max_private_ips))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_memory_size || args->memory_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MemorySize\":" ))
			return -1;
                if (osc_str_append_double(data, args->memory_size))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_vcore_count || args->vcore_count) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VcoreCount\":" ))
			return -1;
                if (osc_str_append_int(data, args->vcore_count))
			return -1;
	   	ret += 1;
	}
	if (args->vm_type_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmTypeName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_type_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_volume_count || args->volume_count) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeCount\":" ))
			return -1;
                if (osc_str_append_int(data, args->volume_count))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeSize\":" ))
			return -1;
                if (osc_str_append_int(data, args->volume_size))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int volume_setter(struct volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CreationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->creation_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Iops\":" ))
			return -1;
                if (osc_str_append_int(data, args->iops))
			return -1;
	   	ret += 1;
	}
        if (args->linked_volumes) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkedVolumes\":[" ))
			return -1;
		for (int i = 0; i < args->nb_linked_volumes; ++i) {
	       	    struct linked_volume *p = &args->linked_volumes[i];
		    if (p != args->linked_volumes)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (linked_volume_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->linked_volumes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkedVolumes\":" ))
			return -1;
                if (osc_str_append_string(data, args->linked_volumes_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_size || args->size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Size\":" ))
			return -1;
                if (osc_str_append_int(data, args->size))
			return -1;
	   	ret += 1;
	}
	if (args->snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->volume_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int vpn_connection_setter(struct vpn_connection *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->client_gateway_configuration) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayConfiguration\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_gateway_configuration))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->client_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->connection_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->connection_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->routes) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Routes\":[" ))
			return -1;
		for (int i = 0; i < args->nb_routes; ++i) {
	       	    struct route_light *p = &args->routes[i];
		    if (p != args->routes)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (route_light_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->routes_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Routes\":" ))
			return -1;
                if (osc_str_append_string(data, args->routes_str))
			return -1;
		ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_static_routes_only) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StaticRoutesOnly\":" ))
			return -1;
                if (osc_str_append_bool(data, args->static_routes_only))
			return -1;
	   	ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
        if (args->vgw_telemetries) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VgwTelemetries\":[" ))
			return -1;
		for (int i = 0; i < args->nb_vgw_telemetries; ++i) {
	       	    struct vgw_telemetry *p = &args->vgw_telemetries[i];
		    if (p != args->vgw_telemetries)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (vgw_telemetry_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->vgw_telemetries_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VgwTelemetries\":" ))
			return -1;
                if (osc_str_append_string(data, args->vgw_telemetries_str))
			return -1;
		ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnConnectionId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vpn_connection_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vpn_options_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnOptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->vpn_options_str))
			return -1;
		ret += 1;
	} else if (args->is_set_vpn_options) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"VpnOptions\": { " ))
			return -1;
	       if (vpn_options_setter(&args->vpn_options, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	return !!ret;
}
static int vpn_options_setter(struct vpn_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->phase1_options_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase1Options\":" ))
			return -1;
                if (osc_str_append_string(data, args->phase1_options_str))
			return -1;
		ret += 1;
	} else if (args->is_set_phase1_options) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Phase1Options\": { " ))
			return -1;
	       if (phase1_options_setter(&args->phase1_options, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->phase2_options_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Phase2Options\":" ))
			return -1;
                if (osc_str_append_string(data, args->phase2_options_str))
			return -1;
		ret += 1;
	} else if (args->is_set_phase2_options) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Phase2Options\": { " ))
			return -1;
	       if (phase2_options_setter(&args->phase2_options, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->tunnel_inside_ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"TunnelInsideIpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->tunnel_inside_ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}
static int with_setter(struct with *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_account_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccountId\":" ))
			return -1;
                if (osc_str_append_bool(data, args->account_id))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_call_duration) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CallDuration\":" ))
			return -1;
                if (osc_str_append_bool(data, args->call_duration))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_access_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryAccessKey\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_access_key))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_api_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryApiName\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_api_name))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_api_version) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryApiVersion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_api_version))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_call_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryCallName\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_call_name))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryDate\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_date))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_header_raw) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryHeaderRaw\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_header_raw))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_header_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryHeaderSize\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_header_size))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_ip_address) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryIpAddress\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_ip_address))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_payload_raw) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryPayloadRaw\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_payload_raw))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_payload_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryPayloadSize\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_payload_size))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_query_user_agent) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"QueryUserAgent\":" ))
			return -1;
                if (osc_str_append_bool(data, args->query_user_agent))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_request_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RequestId\":" ))
			return -1;
                if (osc_str_append_bool(data, args->request_id))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_response_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResponseSize\":" ))
			return -1;
                if (osc_str_append_bool(data, args->response_size))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_response_status_code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResponseStatusCode\":" ))
			return -1;
                if (osc_str_append_bool(data, args->response_status_code))
			return -1;
	   	ret += 1;
	}
	return !!ret;
}

static  int update_vpn_connection_data(struct osc_update_vpn_connection_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnConnectionId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vpn_connection_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vpn_options_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnOptions\":" ))
			return -1;
                if (osc_str_append_string(data, args->vpn_options_str))
			return -1;
		ret += 1;
	} else if (args->is_set_vpn_options) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"VpnOptions\": { " ))
			return -1;
	       if (vpn_options_setter(&args->vpn_options, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_update_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_vpn_connection_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_volume_data(struct osc_update_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Iops\":" ))
			return -1;
                if (osc_str_append_int(data, args->iops))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_size || args->size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Size\":" ))
			return -1;
                if (osc_str_append_int(data, args->size))
			return -1;
	   	ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->volume_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_volume(struct osc_env *e, struct osc_str *out, struct osc_update_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_vm_data(struct osc_update_vm_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
        if (args->block_device_mappings) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":[" ))
			return -1;
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_vm_update *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (block_device_mapping_vm_update_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mappings_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BsuOptimized\":" ))
			return -1;
                if (osc_str_append_bool(data, args->bsu_optimized))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeletionProtection\":" ))
			return -1;
                if (osc_str_append_bool(data, args->deletion_protection))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IsSourceDestChecked\":" ))
			return -1;
                if (osc_str_append_bool(data, args->is_source_dest_checked))
			return -1;
	   	ret += 1;
	}
	if (args->keypair_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NestedVirtualization\":" ))
			return -1;
                if (osc_str_append_bool(data, args->nested_virtualization))
			return -1;
	   	ret += 1;
	}
	if (args->performance) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Performance\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->performance))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":[" ))
			return -1;
		for (as = args->security_group_ids; *as > 0; ++as) {
			if (as != args->security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_ids_str))
			return -1;
		ret += 1;
	}
	if (args->user_data) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"UserData\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->user_data))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmInitiatedShutdownBehavior\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_initiated_shutdown_behavior))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_vm(struct osc_env *e, struct osc_str *out, struct osc_update_vm_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_vm_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateVm");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_subnet_data(struct osc_update_subnet_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_map_public_ip_on_launch) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MapPublicIpOnLaunch\":" ))
			return -1;
                if (osc_str_append_bool(data, args->map_public_ip_on_launch))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_subnet(struct osc_env *e, struct osc_str *out, struct osc_update_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_subnet_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_snapshot_data(struct osc_update_snapshot_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->permissions_to_create_volume_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToCreateVolume\":" ))
			return -1;
                if (osc_str_append_string(data, args->permissions_to_create_volume_str))
			return -1;
		ret += 1;
	} else if (args->is_set_permissions_to_create_volume) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"PermissionsToCreateVolume\": { " ))
			return -1;
	       if (permissions_on_resource_creation_setter(&args->permissions_to_create_volume, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_snapshot(struct osc_env *e, struct osc_str *out, struct osc_update_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_snapshot_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_server_certificate_data(struct osc_update_server_certificate_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Name\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->new_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NewName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->new_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->new_path) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NewPath\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->new_path))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_update_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_server_certificate_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_route_propagation_data(struct osc_update_route_propagation_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_enable) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Enable\":" ))
			return -1;
                if (osc_str_append_bool(data, args->enable))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_route_propagation(struct osc_env *e, struct osc_str *out, struct osc_update_route_propagation_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_route_propagation_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateRoutePropagation");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_route_data(struct osc_update_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DestinationIpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->destination_ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"GatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nat_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NatServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nat_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_peering_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_peering_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_route(struct osc_env *e, struct osc_str *out, struct osc_update_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_nic_data(struct osc_update_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->link_nic_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNic\":" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_str))
			return -1;
		ret += 1;
	} else if (args->is_set_link_nic) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"LinkNic\": { " ))
			return -1;
	       if (link_nic_to_update_setter(&args->link_nic, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":[" ))
			return -1;
		for (as = args->security_group_ids; *as > 0; ++as) {
			if (as != args->security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_ids_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_nic(struct osc_env *e, struct osc_str *out, struct osc_update_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_net_access_point_data(struct osc_update_net_access_point_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->add_route_table_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AddRouteTableIds\":[" ))
			return -1;
		for (as = args->add_route_table_ids; *as > 0; ++as) {
			if (as != args->add_route_table_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->add_route_table_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AddRouteTableIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->add_route_table_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetAccessPointId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_access_point_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->remove_route_table_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RemoveRouteTableIds\":[" ))
			return -1;
		for (as = args->remove_route_table_ids; *as > 0; ++as) {
			if (as != args->remove_route_table_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->remove_route_table_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RemoveRouteTableIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->remove_route_table_ids_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_update_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_net_access_point_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_net_data(struct osc_update_net_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->dhcp_options_set_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DhcpOptionsSetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->dhcp_options_set_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_net(struct osc_env *e, struct osc_str *out, struct osc_update_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_net_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_load_balancer_data(struct osc_update_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->access_log_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessLog\":" ))
			return -1;
                if (osc_str_append_string(data, args->access_log_str))
			return -1;
		ret += 1;
	} else if (args->is_set_access_log) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"AccessLog\": { " ))
			return -1;
	       if (access_log_setter(&args->access_log, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->health_check_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"HealthCheck\":" ))
			return -1;
                if (osc_str_append_string(data, args->health_check_str))
			return -1;
		ret += 1;
	} else if (args->is_set_health_check) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"HealthCheck\": { " ))
			return -1;
	       if (health_check_setter(&args->health_check, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerPort\":" ))
			return -1;
                if (osc_str_append_int(data, args->load_balancer_port))
			return -1;
	   	ret += 1;
	}
	if (args->policy_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyNames\":[" ))
			return -1;
		for (as = args->policy_names; *as > 0; ++as) {
			if (as != args->policy_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->policy_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->policy_names_str))
			return -1;
		ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_secured_cookies) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecuredCookies\":" ))
			return -1;
                if (osc_str_append_bool(data, args->secured_cookies))
			return -1;
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":[" ))
			return -1;
		for (as = args->security_groups; *as > 0; ++as) {
			if (as != args->security_groups)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_groups_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_groups_str))
			return -1;
		ret += 1;
	}
	if (args->server_certificate_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServerCertificateId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->server_certificate_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_update_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_listener_rule_data(struct osc_update_listener_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->host_pattern) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"HostPattern\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->host_pattern))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerRuleName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->listener_rule_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->path_pattern) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PathPattern\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->path_pattern))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_update_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_listener_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_image_data(struct osc_update_image_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->image_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->permissions_to_launch_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PermissionsToLaunch\":" ))
			return -1;
                if (osc_str_append_string(data, args->permissions_to_launch_str))
			return -1;
		ret += 1;
	} else if (args->is_set_permissions_to_launch) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"PermissionsToLaunch\": { " ))
			return -1;
	       if (permissions_on_resource_creation_setter(&args->permissions_to_launch, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_image(struct osc_env *e, struct osc_str *out, struct osc_update_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_image_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_flexible_gpu_data(struct osc_update_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FlexibleGpuId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->flexible_gpu_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_update_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_direct_link_interface_data(struct osc_update_direct_link_interface_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->direct_link_interface_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkInterfaceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_interface_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_mtu || args->mtu) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Mtu\":" ))
			return -1;
                if (osc_str_append_int(data, args->mtu))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_update_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_direct_link_interface_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_ca_data(struct osc_update_ca_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->ca_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ca_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_ca(struct osc_env *e, struct osc_str *out, struct osc_update_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_ca_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_api_access_rule_data(struct osc_update_api_access_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->api_access_rule_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ApiAccessRuleId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->api_access_rule_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ca_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":[" ))
			return -1;
		for (as = args->ca_ids; *as > 0; ++as) {
			if (as != args->ca_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ca_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->ca_ids_str))
			return -1;
		ret += 1;
	}
	if (args->cns) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Cns\":[" ))
			return -1;
		for (as = args->cns; *as > 0; ++as) {
			if (as != args->cns)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->cns_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Cns\":" ))
			return -1;
                if (osc_str_append_string(data, args->cns_str))
			return -1;
		ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":[" ))
			return -1;
		for (as = args->ip_ranges; *as > 0; ++as) {
			if (as != args->ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->ip_ranges_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_update_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_api_access_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_api_access_policy_data(struct osc_update_api_access_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_max_access_key_expiration_seconds || args->max_access_key_expiration_seconds) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaxAccessKeyExpirationSeconds\":" ))
			return -1;
                if (osc_str_append_int(data, args->max_access_key_expiration_seconds))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_require_trusted_env) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RequireTrustedEnv\":" ))
			return -1;
                if (osc_str_append_bool(data, args->require_trusted_env))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_api_access_policy(struct osc_env *e, struct osc_str *out, struct osc_update_api_access_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_api_access_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateApiAccessPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_account_data(struct osc_update_account_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->additional_emails) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AdditionalEmails\":[" ))
			return -1;
		for (as = args->additional_emails; *as > 0; ++as) {
			if (as != args->additional_emails)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->additional_emails_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AdditionalEmails\":" ))
			return -1;
                if (osc_str_append_string(data, args->additional_emails_str))
			return -1;
		ret += 1;
	}
	if (args->city) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"City\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->city))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->company_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CompanyName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->company_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->country) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Country\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->country))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->email) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Email\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->email))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->first_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FirstName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->first_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->job_title) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"JobTitle\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->job_title))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->last_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LastName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->last_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->mobile_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MobileNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->mobile_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->phone_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PhoneNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->phone_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state_province) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateProvince\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state_province))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vat_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VatNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vat_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->zip_code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ZipCode\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->zip_code))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_account(struct osc_env *e, struct osc_str *out, struct osc_update_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_account_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_access_key_data(struct osc_update_access_key_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->access_key_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessKeyId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->access_key_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->expiration_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ExpirationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->expiration_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"State\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_access_key(struct osc_env *e, struct osc_str *out, struct osc_update_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_access_key_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_volume_data(struct osc_unlink_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_force_unlink) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ForceUnlink\":" ))
			return -1;
                if (osc_str_append_bool(data, args->force_unlink))
			return -1;
	   	ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_volume(struct osc_env *e, struct osc_str *out, struct osc_unlink_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_virtual_gateway_data(struct osc_unlink_virtual_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_unlink_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_virtual_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_route_table_data(struct osc_unlink_route_table_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->link_route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkRouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_route_table(struct osc_env *e, struct osc_str *out, struct osc_unlink_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_route_table_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_public_ip_data(struct osc_unlink_public_ip_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->link_public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkPublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_public_ip(struct osc_env *e, struct osc_str *out, struct osc_unlink_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_public_ip_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkPublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_private_ips_data(struct osc_unlink_private_ips_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":[" ))
			return -1;
		for (as = args->private_ips; *as > 0; ++as) {
			if (as != args->private_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_private_ips(struct osc_env *e, struct osc_str *out, struct osc_unlink_private_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_private_ips_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkPrivateIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_nic_data(struct osc_unlink_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->link_nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LinkNicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->link_nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_nic(struct osc_env *e, struct osc_str *out, struct osc_unlink_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_load_balancer_backend_machines_data(struct osc_unlink_load_balancer_backend_machines_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendIps\":[" ))
			return -1;
		for (as = args->backend_ips; *as > 0; ++as) {
			if (as != args->backend_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_ips_str))
			return -1;
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":[" ))
			return -1;
		for (as = args->backend_vm_ids; *as > 0; ++as) {
			if (as != args->backend_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_load_balancer_backend_machines(struct osc_env *e, struct osc_str *out, struct osc_unlink_load_balancer_backend_machines_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_load_balancer_backend_machines_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkLoadBalancerBackendMachines");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_internet_service_data(struct osc_unlink_internet_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->internet_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InternetServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->internet_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_internet_service(struct osc_env *e, struct osc_str *out, struct osc_unlink_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_internet_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_flexible_gpu_data(struct osc_unlink_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FlexibleGpuId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->flexible_gpu_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_unlink_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int stop_vms_data(struct osc_stop_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_force_stop) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ForceStop\":" ))
			return -1;
                if (osc_str_append_bool(data, args->force_stop))
			return -1;
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_stop_vms(struct osc_env *e, struct osc_str *out, struct osc_stop_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = stop_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/StopVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int start_vms_data(struct osc_start_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_start_vms(struct osc_env *e, struct osc_str *out, struct osc_start_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = start_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/StartVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int send_reset_password_email_data(struct osc_send_reset_password_email_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->email) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Email\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->email))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_send_reset_password_email(struct osc_env *e, struct osc_str *out, struct osc_send_reset_password_email_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = send_reset_password_email_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/SendResetPasswordEmail");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int reset_account_password_data(struct osc_reset_account_password_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->password) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Password\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->password))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->token) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Token\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->token))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_reset_account_password(struct osc_env *e, struct osc_str *out, struct osc_reset_account_password_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = reset_account_password_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ResetAccountPassword");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int reject_net_peering_data(struct osc_reject_net_peering_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_peering_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_peering_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_reject_net_peering(struct osc_env *e, struct osc_str *out, struct osc_reject_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = reject_net_peering_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/RejectNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int register_vms_in_load_balancer_data(struct osc_register_vms_in_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":[" ))
			return -1;
		for (as = args->backend_vm_ids; *as > 0; ++as) {
			if (as != args->backend_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_register_vms_in_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_register_vms_in_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = register_vms_in_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/RegisterVmsInLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int reboot_vms_data(struct osc_reboot_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_reboot_vms(struct osc_env *e, struct osc_str *out, struct osc_reboot_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = reboot_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/RebootVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vpn_connections_data(struct osc_read_vpn_connections_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_vpn_connection_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vpn_connections(struct osc_env *e, struct osc_str *out, struct osc_read_vpn_connections_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vpn_connections_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVpnConnections");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_volumes_data(struct osc_read_volumes_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_volume_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_volumes(struct osc_env *e, struct osc_str *out, struct osc_read_volumes_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_volumes_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVolumes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_state_data(struct osc_read_vms_state_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_all_vms) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AllVms\":" ))
			return -1;
                if (osc_str_append_bool(data, args->all_vms))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_vms_state_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vms_state(struct osc_env *e, struct osc_str *out, struct osc_read_vms_state_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vms_state_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVmsState");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_health_data(struct osc_read_vms_health_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":[" ))
			return -1;
		for (as = args->backend_vm_ids; *as > 0; ++as) {
			if (as != args->backend_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vms_health(struct osc_env *e, struct osc_str *out, struct osc_read_vms_health_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vms_health_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVmsHealth");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_data(struct osc_read_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_vm_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vms(struct osc_env *e, struct osc_str *out, struct osc_read_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vm_types_data(struct osc_read_vm_types_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_vm_type_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vm_types(struct osc_env *e, struct osc_str *out, struct osc_read_vm_types_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vm_types_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVmTypes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_virtual_gateways_data(struct osc_read_virtual_gateways_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_virtual_gateway_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_virtual_gateways(struct osc_env *e, struct osc_str *out, struct osc_read_virtual_gateways_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_virtual_gateways_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVirtualGateways");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_tags_data(struct osc_read_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_tag_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_tags(struct osc_env *e, struct osc_str *out, struct osc_read_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_subregions_data(struct osc_read_subregions_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_subregion_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_subregions(struct osc_env *e, struct osc_str *out, struct osc_read_subregions_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_subregions_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSubregions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_subnets_data(struct osc_read_subnets_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_subnet_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_subnets(struct osc_env *e, struct osc_str *out, struct osc_read_subnets_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_subnets_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSubnets");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_snapshots_data(struct osc_read_snapshots_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_snapshot_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_snapshots(struct osc_env *e, struct osc_str *out, struct osc_read_snapshots_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_snapshots_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSnapshots");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_snapshot_export_tasks_data(struct osc_read_snapshot_export_tasks_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_export_task_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_snapshot_export_tasks(struct osc_env *e, struct osc_str *out, struct osc_read_snapshot_export_tasks_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_snapshot_export_tasks_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSnapshotExportTasks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_server_certificates_data(struct osc_read_server_certificates_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_server_certificate_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_server_certificates(struct osc_env *e, struct osc_str *out, struct osc_read_server_certificates_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_server_certificates_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadServerCertificates");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_security_groups_data(struct osc_read_security_groups_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_security_group_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_security_groups(struct osc_env *e, struct osc_str *out, struct osc_read_security_groups_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_security_groups_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSecurityGroups");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_secret_access_key_data(struct osc_read_secret_access_key_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->access_key_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessKeyId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->access_key_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_secret_access_key(struct osc_env *e, struct osc_str *out, struct osc_read_secret_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_secret_access_key_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSecretAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_route_tables_data(struct osc_read_route_tables_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_route_table_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_route_tables(struct osc_env *e, struct osc_str *out, struct osc_read_route_tables_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_route_tables_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadRouteTables");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_regions_data(struct osc_read_regions_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_regions(struct osc_env *e, struct osc_str *out, struct osc_read_regions_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_regions_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadRegions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_quotas_data(struct osc_read_quotas_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_quota_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_quotas(struct osc_env *e, struct osc_str *out, struct osc_read_quotas_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_quotas_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadQuotas");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_public_ips_data(struct osc_read_public_ips_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_public_ip_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_public_ips(struct osc_env *e, struct osc_str *out, struct osc_read_public_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_public_ips_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPublicIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_public_ip_ranges_data(struct osc_read_public_ip_ranges_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_public_ip_ranges(struct osc_env *e, struct osc_str *out, struct osc_read_public_ip_ranges_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_public_ip_ranges_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPublicIpRanges");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_public_catalog_data(struct osc_read_public_catalog_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_public_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_public_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_public_catalog_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPublicCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_product_types_data(struct osc_read_product_types_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_product_type_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_product_types(struct osc_env *e, struct osc_str *out, struct osc_read_product_types_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_product_types_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadProductTypes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_nics_data(struct osc_read_nics_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_nic_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_nics(struct osc_env *e, struct osc_str *out, struct osc_read_nics_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_nics_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNics");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_nets_data(struct osc_read_nets_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_net_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_nets(struct osc_env *e, struct osc_str *out, struct osc_read_nets_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_nets_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNets");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_net_peerings_data(struct osc_read_net_peerings_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_net_peering_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_net_peerings(struct osc_env *e, struct osc_str *out, struct osc_read_net_peerings_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_net_peerings_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNetPeerings");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_net_access_points_data(struct osc_read_net_access_points_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_net_access_point_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_net_access_points(struct osc_env *e, struct osc_str *out, struct osc_read_net_access_points_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_net_access_points_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNetAccessPoints");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_net_access_point_services_data(struct osc_read_net_access_point_services_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_service_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_net_access_point_services(struct osc_env *e, struct osc_str *out, struct osc_read_net_access_point_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_net_access_point_services_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNetAccessPointServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_nat_services_data(struct osc_read_nat_services_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_nat_service_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_nat_services(struct osc_env *e, struct osc_str *out, struct osc_read_nat_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_nat_services_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNatServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_locations_data(struct osc_read_locations_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_locations(struct osc_env *e, struct osc_str *out, struct osc_read_locations_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_locations_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadLocations");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_load_balancers_data(struct osc_read_load_balancers_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_load_balancer_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_load_balancers(struct osc_env *e, struct osc_str *out, struct osc_read_load_balancers_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_load_balancers_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadLoadBalancers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_load_balancer_tags_data(struct osc_read_load_balancer_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerNames\":[" ))
			return -1;
		for (as = args->load_balancer_names; *as > 0; ++as) {
			if (as != args->load_balancer_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->load_balancer_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_names_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_read_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_load_balancer_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_listener_rules_data(struct osc_read_listener_rules_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_listener_rule_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_listener_rules(struct osc_env *e, struct osc_str *out, struct osc_read_listener_rules_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_listener_rules_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadListenerRules");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_keypairs_data(struct osc_read_keypairs_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_keypair_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_keypairs(struct osc_env *e, struct osc_str *out, struct osc_read_keypairs_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_keypairs_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadKeypairs");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_internet_services_data(struct osc_read_internet_services_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_internet_service_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_internet_services(struct osc_env *e, struct osc_str *out, struct osc_read_internet_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_internet_services_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadInternetServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_images_data(struct osc_read_images_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_image_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_images(struct osc_env *e, struct osc_str *out, struct osc_read_images_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_images_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadImages");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_image_export_tasks_data(struct osc_read_image_export_tasks_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_export_task_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_image_export_tasks(struct osc_env *e, struct osc_str *out, struct osc_read_image_export_tasks_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_image_export_tasks_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadImageExportTasks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_flexible_gpus_data(struct osc_read_flexible_gpus_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_flexible_gpu_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_flexible_gpus(struct osc_env *e, struct osc_str *out, struct osc_read_flexible_gpus_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_flexible_gpus_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadFlexibleGpus");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_flexible_gpu_catalog_data(struct osc_read_flexible_gpu_catalog_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_flexible_gpu_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_flexible_gpu_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_flexible_gpu_catalog_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadFlexibleGpuCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_direct_links_data(struct osc_read_direct_links_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_direct_link_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_direct_links(struct osc_env *e, struct osc_str *out, struct osc_read_direct_links_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_direct_links_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadDirectLinks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_direct_link_interfaces_data(struct osc_read_direct_link_interfaces_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_direct_link_interface_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_direct_link_interfaces(struct osc_env *e, struct osc_str *out, struct osc_read_direct_link_interfaces_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_direct_link_interfaces_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadDirectLinkInterfaces");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_dhcp_options_data(struct osc_read_dhcp_options_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_dhcp_options_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_read_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_dhcp_options_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_consumption_account_data(struct osc_read_consumption_account_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->from_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FromDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->from_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_overall) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Overall\":" ))
			return -1;
                if (osc_str_append_bool(data, args->overall))
			return -1;
	   	ret += 1;
	}
	if (args->to_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ToDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->to_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_consumption_account(struct osc_env *e, struct osc_str *out, struct osc_read_consumption_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_consumption_account_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadConsumptionAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_console_output_data(struct osc_read_console_output_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_console_output(struct osc_env *e, struct osc_str *out, struct osc_read_console_output_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_console_output_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadConsoleOutput");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_client_gateways_data(struct osc_read_client_gateways_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_client_gateway_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_client_gateways(struct osc_env *e, struct osc_str *out, struct osc_read_client_gateways_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_client_gateways_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadClientGateways");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_catalog_data(struct osc_read_catalog_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_catalog_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_cas_data(struct osc_read_cas_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_ca_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_cas(struct osc_env *e, struct osc_str *out, struct osc_read_cas_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_cas_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadCas");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_api_logs_data(struct osc_read_api_logs_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_api_log_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->next_page_token) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NextPageToken\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->next_page_token))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResultsPerPage\":" ))
			return -1;
                if (osc_str_append_int(data, args->results_per_page))
			return -1;
	   	ret += 1;
	}
	if (args->with_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"With\":" ))
			return -1;
                if (osc_str_append_string(data, args->with_str))
			return -1;
		ret += 1;
	} else if (args->is_set_with) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"With\": { " ))
			return -1;
	       if (with_setter(&args->with, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_api_logs(struct osc_env *e, struct osc_str *out, struct osc_read_api_logs_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_api_logs_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadApiLogs");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_api_access_rules_data(struct osc_read_api_access_rules_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_api_access_rule_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_api_access_rules(struct osc_env *e, struct osc_str *out, struct osc_read_api_access_rules_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_api_access_rules_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadApiAccessRules");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_api_access_policy_data(struct osc_read_api_access_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_api_access_policy(struct osc_env *e, struct osc_str *out, struct osc_read_api_access_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_api_access_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadApiAccessPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_admin_password_data(struct osc_read_admin_password_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_admin_password(struct osc_env *e, struct osc_str *out, struct osc_read_admin_password_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_admin_password_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadAdminPassword");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_accounts_data(struct osc_read_accounts_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_accounts(struct osc_env *e, struct osc_str *out, struct osc_read_accounts_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_accounts_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadAccounts");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_access_keys_data(struct osc_read_access_keys_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->filters_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Filters\":" ))
			return -1;
                if (osc_str_append_string(data, args->filters_str))
			return -1;
		ret += 1;
	} else if (args->is_set_filters) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Filters\": { " ))
			return -1;
	       if (filters_access_keys_setter(&args->filters, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_access_keys(struct osc_env *e, struct osc_str *out, struct osc_read_access_keys_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_access_keys_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadAccessKeys");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_volume_data(struct osc_link_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_volume(struct osc_env *e, struct osc_str *out, struct osc_link_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_virtual_gateway_data(struct osc_link_virtual_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_link_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_virtual_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_route_table_data(struct osc_link_route_table_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_route_table(struct osc_env *e, struct osc_str *out, struct osc_link_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_route_table_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_public_ip_data(struct osc_link_public_ip_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_allow_relink) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AllowRelink\":" ))
			return -1;
                if (osc_str_append_bool(data, args->allow_relink))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_public_ip(struct osc_env *e, struct osc_str *out, struct osc_link_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_public_ip_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkPublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_private_ips_data(struct osc_link_private_ips_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_allow_relink) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AllowRelink\":" ))
			return -1;
                if (osc_str_append_bool(data, args->allow_relink))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":[" ))
			return -1;
		for (as = args->private_ips; *as > 0; ++as) {
			if (as != args->private_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_secondary_private_ip_count || args->secondary_private_ip_count) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecondaryPrivateIpCount\":" ))
			return -1;
                if (osc_str_append_int(data, args->secondary_private_ip_count))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_private_ips(struct osc_env *e, struct osc_str *out, struct osc_link_private_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_private_ips_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkPrivateIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_nic_data(struct osc_link_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_device_number || args->device_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeviceNumber\":" ))
			return -1;
                if (osc_str_append_int(data, args->device_number))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_nic(struct osc_env *e, struct osc_str *out, struct osc_link_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_load_balancer_backend_machines_data(struct osc_link_load_balancer_backend_machines_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendIps\":[" ))
			return -1;
		for (as = args->backend_ips; *as > 0; ++as) {
			if (as != args->backend_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_ips_str))
			return -1;
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":[" ))
			return -1;
		for (as = args->backend_vm_ids; *as > 0; ++as) {
			if (as != args->backend_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_load_balancer_backend_machines(struct osc_env *e, struct osc_str *out, struct osc_link_load_balancer_backend_machines_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_load_balancer_backend_machines_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkLoadBalancerBackendMachines");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_internet_service_data(struct osc_link_internet_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->internet_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InternetServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->internet_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_internet_service(struct osc_env *e, struct osc_str *out, struct osc_link_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_internet_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_flexible_gpu_data(struct osc_link_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FlexibleGpuId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->flexible_gpu_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_link_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int deregister_vms_in_load_balancer_data(struct osc_deregister_vms_in_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":[" ))
			return -1;
		for (as = args->backend_vm_ids; *as > 0; ++as) {
			if (as != args->backend_vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BackendVmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->backend_vm_ids_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_deregister_vms_in_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_deregister_vms_in_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = deregister_vms_in_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeregisterVmsInLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_vpn_connection_route_data(struct osc_delete_vpn_connection_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DestinationIpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->destination_ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnConnectionId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vpn_connection_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_vpn_connection_route(struct osc_env *e, struct osc_str *out, struct osc_delete_vpn_connection_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_vpn_connection_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVpnConnectionRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_vpn_connection_data(struct osc_delete_vpn_connection_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnConnectionId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vpn_connection_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_delete_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_vpn_connection_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_volume_data(struct osc_delete_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_volume(struct osc_env *e, struct osc_str *out, struct osc_delete_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_vms_data(struct osc_delete_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_vms(struct osc_env *e, struct osc_str *out, struct osc_delete_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_virtual_gateway_data(struct osc_delete_virtual_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_delete_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_virtual_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_tags_data(struct osc_delete_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->resource_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceIds\":[" ))
			return -1;
		for (as = args->resource_ids; *as > 0; ++as) {
			if (as != args->resource_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->resource_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->resource_ids_str))
			return -1;
		ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_tags(struct osc_env *e, struct osc_str *out, struct osc_delete_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_subnet_data(struct osc_delete_subnet_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_subnet(struct osc_env *e, struct osc_str *out, struct osc_delete_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_subnet_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_snapshot_data(struct osc_delete_snapshot_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_snapshot(struct osc_env *e, struct osc_str *out, struct osc_delete_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_snapshot_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_server_certificate_data(struct osc_delete_server_certificate_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Name\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_delete_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_server_certificate_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_security_group_rule_data(struct osc_delete_security_group_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->flow) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Flow\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->flow))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_from_port_range || args->from_port_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FromPortRange\":" ))
			return -1;
                if (osc_str_append_int(data, args->from_port_range))
			return -1;
	   	ret += 1;
	}
	if (args->ip_protocol) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpProtocol\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_protocol))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->rules) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Rules\":[" ))
			return -1;
		for (int i = 0; i < args->nb_rules; ++i) {
	       	    struct security_group_rule *p = &args->rules[i];
		    if (p != args->rules)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (security_group_rule_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->rules_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Rules\":" ))
			return -1;
                if (osc_str_append_string(data, args->rules_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_account_id_to_unlink) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupAccountIdToUnlink\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_account_id_to_unlink))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_name_to_unlink) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupNameToUnlink\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_name_to_unlink))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ToPortRange\":" ))
			return -1;
                if (osc_str_append_int(data, args->to_port_range))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_security_group_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_security_group_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_security_group_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteSecurityGroupRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_security_group_data(struct osc_delete_security_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_security_group(struct osc_env *e, struct osc_str *out, struct osc_delete_security_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_security_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteSecurityGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_route_table_data(struct osc_delete_route_table_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_route_table(struct osc_env *e, struct osc_str *out, struct osc_delete_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_route_table_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_route_data(struct osc_delete_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DestinationIpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->destination_ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_route(struct osc_env *e, struct osc_str *out, struct osc_delete_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_public_ip_data(struct osc_delete_public_ip_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_public_ip(struct osc_env *e, struct osc_str *out, struct osc_delete_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_public_ip_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeletePublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_nic_data(struct osc_delete_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_nic(struct osc_env *e, struct osc_str *out, struct osc_delete_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_peering_data(struct osc_delete_net_peering_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_peering_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_peering_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_net_peering(struct osc_env *e, struct osc_str *out, struct osc_delete_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_net_peering_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_access_point_data(struct osc_delete_net_access_point_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetAccessPointId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_access_point_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_delete_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_net_access_point_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_data(struct osc_delete_net_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_net(struct osc_env *e, struct osc_str *out, struct osc_delete_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_net_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_nat_service_data(struct osc_delete_nat_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->nat_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NatServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nat_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_nat_service(struct osc_env *e, struct osc_str *out, struct osc_delete_nat_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_nat_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNatService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_tags_data(struct osc_delete_load_balancer_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerNames\":[" ))
			return -1;
		for (as = args->load_balancer_names; *as > 0; ++as) {
			if (as != args->load_balancer_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->load_balancer_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_names_str))
			return -1;
		ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_load_balancer_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_load_balancer_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_load_balancer_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_policy_data(struct osc_delete_load_balancer_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->policy_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->policy_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_load_balancer_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_load_balancer_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_listeners_data(struct osc_delete_load_balancer_listeners_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_ports) {
		int *ip;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerPorts\":[" ))
			return -1;
		for (ip = args->load_balancer_ports; *ip > 0; ++ip) {
			if (ip != args->load_balancer_ports)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_int(data, *ip))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->load_balancer_ports_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerPorts\":" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_ports_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_load_balancer_listeners(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_listeners_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_load_balancer_listeners_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerListeners");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_data(struct osc_delete_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_listener_rule_data(struct osc_delete_listener_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerRuleName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->listener_rule_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_listener_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_keypair_data(struct osc_delete_keypair_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->keypair_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_keypair(struct osc_env *e, struct osc_str *out, struct osc_delete_keypair_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_keypair_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteKeypair");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_internet_service_data(struct osc_delete_internet_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->internet_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"InternetServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->internet_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_internet_service(struct osc_env *e, struct osc_str *out, struct osc_delete_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_internet_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_image_data(struct osc_delete_image_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->image_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_image(struct osc_env *e, struct osc_str *out, struct osc_delete_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_image_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_flexible_gpu_data(struct osc_delete_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FlexibleGpuId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->flexible_gpu_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_delete_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_export_task_data(struct osc_delete_export_task_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->export_task_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ExportTaskId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->export_task_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_export_task(struct osc_env *e, struct osc_str *out, struct osc_delete_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_export_task_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_direct_link_interface_data(struct osc_delete_direct_link_interface_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->direct_link_interface_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkInterfaceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_interface_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_delete_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_direct_link_interface_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_direct_link_data(struct osc_delete_direct_link_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->direct_link_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_direct_link(struct osc_env *e, struct osc_str *out, struct osc_delete_direct_link_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_direct_link_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteDirectLink");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_dhcp_options_data(struct osc_delete_dhcp_options_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->dhcp_options_set_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DhcpOptionsSetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->dhcp_options_set_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_delete_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_dhcp_options_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_client_gateway_data(struct osc_delete_client_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_client_gateway(struct osc_env *e, struct osc_str *out, struct osc_delete_client_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_client_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteClientGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_ca_data(struct osc_delete_ca_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->ca_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ca_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_ca(struct osc_env *e, struct osc_str *out, struct osc_delete_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_ca_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_api_access_rule_data(struct osc_delete_api_access_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->api_access_rule_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ApiAccessRuleId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->api_access_rule_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_api_access_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_access_key_data(struct osc_delete_access_key_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->access_key_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccessKeyId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->access_key_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_access_key(struct osc_env *e, struct osc_str *out, struct osc_delete_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_access_key_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_vpn_connection_route_data(struct osc_create_vpn_connection_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DestinationIpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->destination_ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VpnConnectionId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vpn_connection_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_vpn_connection_route(struct osc_env *e, struct osc_str *out, struct osc_create_vpn_connection_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_vpn_connection_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVpnConnectionRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_vpn_connection_data(struct osc_create_vpn_connection_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->connection_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->connection_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_static_routes_only) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StaticRoutesOnly\":" ))
			return -1;
                if (osc_str_append_bool(data, args->static_routes_only))
			return -1;
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VirtualGatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->virtual_gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_create_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_vpn_connection_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_volume_data(struct osc_create_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Iops\":" ))
			return -1;
                if (osc_str_append_int(data, args->iops))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_size || args->size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Size\":" ))
			return -1;
                if (osc_str_append_int(data, args->size))
			return -1;
	   	ret += 1;
	}
	if (args->snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->volume_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_volume(struct osc_env *e, struct osc_str *out, struct osc_create_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_vms_data(struct osc_create_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
        if (args->block_device_mappings) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":[" ))
			return -1;
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_vm_creation *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (block_device_mapping_vm_creation_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mappings_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_boot_on_creation) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BootOnCreation\":" ))
			return -1;
                if (osc_str_append_bool(data, args->boot_on_creation))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BsuOptimized\":" ))
			return -1;
                if (osc_str_append_bool(data, args->bsu_optimized))
			return -1;
	   	ret += 1;
	}
	if (args->client_token) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ClientToken\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->client_token))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeletionProtection\":" ))
			return -1;
                if (osc_str_append_bool(data, args->deletion_protection))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->image_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->keypair_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_max_vms_count || args->max_vms_count) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MaxVmsCount\":" ))
			return -1;
                if (osc_str_append_int(data, args->max_vms_count))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_min_vms_count || args->min_vms_count) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MinVmsCount\":" ))
			return -1;
                if (osc_str_append_int(data, args->min_vms_count))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NestedVirtualization\":" ))
			return -1;
                if (osc_str_append_bool(data, args->nested_virtualization))
			return -1;
	   	ret += 1;
	}
        if (args->nics) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Nics\":[" ))
			return -1;
		for (int i = 0; i < args->nb_nics; ++i) {
	       	    struct nic_for_vm_creation *p = &args->nics[i];
		    if (p != args->nics)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (nic_for_vm_creation_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->nics_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Nics\":" ))
			return -1;
                if (osc_str_append_string(data, args->nics_str))
			return -1;
		ret += 1;
	}
	if (args->performance) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Performance\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->performance))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->placement_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Placement\":" ))
			return -1;
                if (osc_str_append_string(data, args->placement_str))
			return -1;
		ret += 1;
	} else if (args->is_set_placement) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Placement\": { " ))
			return -1;
	       if (placement_setter(&args->placement, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->private_ips) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":[" ))
			return -1;
		for (as = args->private_ips; *as > 0; ++as) {
			if (as != args->private_ips)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":[" ))
			return -1;
		for (as = args->security_group_ids; *as > 0; ++as) {
			if (as != args->security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_ids_str))
			return -1;
		ret += 1;
	}
	if (args->security_groups) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":[" ))
			return -1;
		for (as = args->security_groups; *as > 0; ++as) {
			if (as != args->security_groups)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_groups_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_groups_str))
			return -1;
		ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->user_data) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"UserData\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->user_data))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmInitiatedShutdownBehavior\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_initiated_shutdown_behavior))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_vms(struct osc_env *e, struct osc_str *out, struct osc_create_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_virtual_gateway_data(struct osc_create_virtual_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->connection_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->connection_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_create_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_virtual_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_tags_data(struct osc_create_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->resource_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceIds\":[" ))
			return -1;
		for (as = args->resource_ids; *as > 0; ++as) {
			if (as != args->resource_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->resource_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ResourceIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->resource_ids_str))
			return -1;
		ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_tags(struct osc_env *e, struct osc_str *out, struct osc_create_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_subnet_data(struct osc_create_subnet_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_subnet(struct osc_env *e, struct osc_str *out, struct osc_create_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_subnet_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_snapshot_export_task_data(struct osc_create_snapshot_export_task_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->osu_export_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuExport\":" ))
			return -1;
                if (osc_str_append_string(data, args->osu_export_str))
			return -1;
		ret += 1;
	} else if (args->is_set_osu_export) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"OsuExport\": { " ))
			return -1;
	       if (osu_export_to_create_setter(&args->osu_export, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_snapshot_export_task(struct osc_env *e, struct osc_str *out, struct osc_create_snapshot_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_snapshot_export_task_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSnapshotExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_snapshot_data(struct osc_create_snapshot_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->file_location) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FileLocation\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->file_location))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_snapshot_size || args->snapshot_size) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SnapshotSize\":" ))
			return -1;
                if (osc_str_append_int(data, args->snapshot_size))
			return -1;
	   	ret += 1;
	}
	if (args->source_region_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceRegionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->source_region_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->source_snapshot_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceSnapshotId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->source_snapshot_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->volume_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VolumeId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->volume_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_snapshot(struct osc_env *e, struct osc_str *out, struct osc_create_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_snapshot_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_server_certificate_data(struct osc_create_server_certificate_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->body) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Body\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->body))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->chain) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Chain\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->chain))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Name\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->path) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Path\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->path))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->private_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->private_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_create_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_server_certificate_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_security_group_rule_data(struct osc_create_security_group_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->flow) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Flow\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->flow))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_from_port_range || args->from_port_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FromPortRange\":" ))
			return -1;
                if (osc_str_append_int(data, args->from_port_range))
			return -1;
	   	ret += 1;
	}
	if (args->ip_protocol) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpProtocol\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_protocol))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->rules) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Rules\":[" ))
			return -1;
		for (int i = 0; i < args->nb_rules; ++i) {
	       	    struct security_group_rule *p = &args->rules[i];
		    if (p != args->rules)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (security_group_rule_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->rules_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Rules\":" ))
			return -1;
                if (osc_str_append_string(data, args->rules_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_account_id_to_link) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupAccountIdToLink\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_account_id_to_link))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_name_to_link) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupNameToLink\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_name_to_link))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ToPortRange\":" ))
			return -1;
                if (osc_str_append_int(data, args->to_port_range))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_security_group_rule(struct osc_env *e, struct osc_str *out, struct osc_create_security_group_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_security_group_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSecurityGroupRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_security_group_data(struct osc_create_security_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_group_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_security_group(struct osc_env *e, struct osc_str *out, struct osc_create_security_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_security_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSecurityGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_route_table_data(struct osc_create_route_table_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_route_table(struct osc_env *e, struct osc_str *out, struct osc_create_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_route_table_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_route_data(struct osc_create_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DestinationIpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->destination_ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->gateway_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"GatewayId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->gateway_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nat_service_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NatServiceId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nat_service_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->net_peering_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_peering_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->nic_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NicId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->nic_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_route(struct osc_env *e, struct osc_str *out, struct osc_create_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_public_ip_data(struct osc_create_public_ip_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_public_ip(struct osc_env *e, struct osc_str *out, struct osc_create_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_public_ip_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreatePublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_nic_data(struct osc_create_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
        if (args->private_ips) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":[" ))
			return -1;
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (private_ip_light_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->private_ips_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PrivateIps\":" ))
			return -1;
                if (osc_str_append_string(data, args->private_ips_str))
			return -1;
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":[" ))
			return -1;
		for (as = args->security_group_ids; *as > 0; ++as) {
			if (as != args->security_group_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_group_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroupIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_group_ids_str))
			return -1;
		ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_nic(struct osc_env *e, struct osc_str *out, struct osc_create_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_net_peering_data(struct osc_create_net_peering_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->accepter_net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AccepterNetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->accepter_net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->source_net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceNetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->source_net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_net_peering(struct osc_env *e, struct osc_str *out, struct osc_create_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_net_peering_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_net_access_point_data(struct osc_create_net_access_point_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableIds\":[" ))
			return -1;
		for (as = args->route_table_ids; *as > 0; ++as) {
			if (as != args->route_table_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->route_table_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RouteTableIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->route_table_ids_str))
			return -1;
		ret += 1;
	}
	if (args->service_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ServiceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->service_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_create_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_net_access_point_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_net_data(struct osc_create_net_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->ip_range) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRange\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ip_range))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->tenancy) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tenancy\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->tenancy))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_net(struct osc_env *e, struct osc_str *out, struct osc_create_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_net_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_nat_service_data(struct osc_create_nat_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIpId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subnet_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubnetId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subnet_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_nat_service(struct osc_env *e, struct osc_str *out, struct osc_create_nat_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_nat_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNatService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_tags_data(struct osc_create_load_balancer_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerNames\":[" ))
			return -1;
		for (as = args->load_balancer_names; *as > 0; ++as) {
			if (as != args->load_balancer_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->load_balancer_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_names_str))
			return -1;
		ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_load_balancer_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_policy_data(struct osc_create_load_balancer_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_cookie_expiration_period || args->cookie_expiration_period) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CookieExpirationPeriod\":" ))
			return -1;
                if (osc_str_append_int(data, args->cookie_expiration_period))
			return -1;
	   	ret += 1;
	}
	if (args->cookie_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CookieName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->cookie_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->policy_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->policy_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->policy_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PolicyType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->policy_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_load_balancer_policy(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_load_balancer_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_listeners_data(struct osc_create_load_balancer_listeners_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
        if (args->listeners) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Listeners\":[" ))
			return -1;
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener_for_creation *p = &args->listeners[i];
		    if (p != args->listeners)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (listener_for_creation_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->listeners_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Listeners\":" ))
			return -1;
                if (osc_str_append_string(data, args->listeners_str))
			return -1;
		ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_load_balancer_listeners(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_listeners_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_load_balancer_listeners_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerListeners");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_data(struct osc_create_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
        if (args->listeners) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Listeners\":[" ))
			return -1;
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener_for_creation *p = &args->listeners[i];
		    if (p != args->listeners)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (listener_for_creation_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->listeners_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Listeners\":" ))
			return -1;
                if (osc_str_append_string(data, args->listeners_str))
			return -1;
		ret += 1;
	}
	if (args->load_balancer_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->load_balancer_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LoadBalancerType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->load_balancer_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":[" ))
			return -1;
		for (as = args->security_groups; *as > 0; ++as) {
			if (as != args->security_groups)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->security_groups_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SecurityGroups\":" ))
			return -1;
                if (osc_str_append_string(data, args->security_groups_str))
			return -1;
		ret += 1;
	}
	if (args->subnets) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Subnets\":[" ))
			return -1;
		for (as = args->subnets; *as > 0; ++as) {
			if (as != args->subnets)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subnets_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Subnets\":" ))
			return -1;
                if (osc_str_append_string(data, args->subnets_str))
			return -1;
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":[" ))
			return -1;
		for (as = args->subregion_names; *as > 0; ++as) {
			if (as != args->subregion_names)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->subregion_names_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionNames\":" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_names_str))
			return -1;
		ret += 1;
	}
        if (args->tags) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":[" ))
			return -1;
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (resource_tag_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->tags_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Tags\":" ))
			return -1;
                if (osc_str_append_string(data, args->tags_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_listener_rule_data(struct osc_create_listener_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->listener_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Listener\":" ))
			return -1;
                if (osc_str_append_string(data, args->listener_str))
			return -1;
		ret += 1;
	} else if (args->is_set_listener) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"Listener\": { " ))
			return -1;
	       if (load_balancer_light_setter(&args->listener, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->listener_rule_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ListenerRule\":" ))
			return -1;
                if (osc_str_append_string(data, args->listener_rule_str))
			return -1;
		ret += 1;
	} else if (args->is_set_listener_rule) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"ListenerRule\": { " ))
			return -1;
	       if (listener_rule_for_creation_setter(&args->listener_rule, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->vm_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":[" ))
			return -1;
		for (as = args->vm_ids; *as > 0; ++as) {
			if (as != args->vm_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->vm_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->vm_ids_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_create_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_listener_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_keypair_data(struct osc_create_keypair_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->keypair_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"KeypairName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->keypair_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->public_key) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicKey\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_key))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_keypair(struct osc_env *e, struct osc_str *out, struct osc_create_keypair_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_keypair_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateKeypair");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_internet_service_data(struct osc_create_internet_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_internet_service(struct osc_env *e, struct osc_str *out, struct osc_create_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_internet_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_image_export_task_data(struct osc_create_image_export_task_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->image_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->osu_export_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"OsuExport\":" ))
			return -1;
                if (osc_str_append_string(data, args->osu_export_str))
			return -1;
		ret += 1;
	} else if (args->is_set_osu_export) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"OsuExport\": { " ))
			return -1;
	       if (osu_export_to_create_setter(&args->osu_export, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_image_export_task(struct osc_env *e, struct osc_str *out, struct osc_create_image_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_image_export_task_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateImageExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_image_data(struct osc_create_image_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->architecture) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Architecture\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->architecture))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	       	if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":[" ))
			return -1;
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_image *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        if (osc_str_append_string(data, "," ))
			     return -1;
		    if (osc_str_append_string(data, "{ " ))
			return -1;
	       	    if (block_device_mapping_image_setter(p, data) < 0)
	       	  	return -1;
	       	    if (osc_str_append_string(data, "}" ))
			return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BlockDeviceMappings\":" ))
			return -1;
                if (osc_str_append_string(data, args->block_device_mappings_str))
			return -1;
		ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->file_location) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FileLocation\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->file_location))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->image_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ImageName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->image_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_no_reboot) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NoReboot\":" ))
			return -1;
                if (osc_str_append_bool(data, args->no_reboot))
			return -1;
	   	ret += 1;
	}
	if (args->root_device_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"RootDeviceName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->root_device_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->source_image_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceImageId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->source_image_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->source_region_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SourceRegionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->source_region_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vm_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VmId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vm_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_image(struct osc_env *e, struct osc_str *out, struct osc_create_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_image_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_flexible_gpu_data(struct osc_create_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_delete_on_vm_deletion) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DeleteOnVmDeletion\":" ))
			return -1;
                if (osc_str_append_bool(data, args->delete_on_vm_deletion))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->generation) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Generation\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->generation))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->model_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ModelName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->model_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->subregion_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"SubregionName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->subregion_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_create_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_direct_link_interface_data(struct osc_create_direct_link_interface_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->direct_link_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->direct_link_interface_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkInterface\":" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_interface_str))
			return -1;
		ret += 1;
	} else if (args->is_set_direct_link_interface) {
	       if (count_args++ > 0)
		       if (osc_str_append_string(data, "," ))
			       return -1;
	       if (osc_str_append_string(data, "\"DirectLinkInterface\": { " ))
			return -1;
	       if (direct_link_interface_setter(&args->direct_link_interface, data) < 0)
	       	  	return -1;
	       if (osc_str_append_string(data, "}" ))
			return -1;
	       ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_create_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_direct_link_interface_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_direct_link_data(struct osc_create_direct_link_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->bandwidth) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Bandwidth\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->bandwidth))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->direct_link_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DirectLinkName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->direct_link_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->location) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Location\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->location))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_direct_link(struct osc_env *e, struct osc_str *out, struct osc_create_direct_link_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_direct_link_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateDirectLink");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_dhcp_options_data(struct osc_create_dhcp_options_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->domain_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->domain_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainNameServers\":[" ))
			return -1;
		for (as = args->domain_name_servers; *as > 0; ++as) {
			if (as != args->domain_name_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->domain_name_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DomainNameServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->domain_name_servers_str))
			return -1;
		ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->log_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LogServers\":[" ))
			return -1;
		for (as = args->log_servers; *as > 0; ++as) {
			if (as != args->log_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->log_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LogServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->log_servers_str))
			return -1;
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NtpServers\":[" ))
			return -1;
		for (as = args->ntp_servers; *as > 0; ++as) {
			if (as != args->ntp_servers)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ntp_servers_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NtpServers\":" ))
			return -1;
                if (osc_str_append_string(data, args->ntp_servers_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_create_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_dhcp_options_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_client_gateway_data(struct osc_create_client_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_bgp_asn || args->bgp_asn) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"BgpAsn\":" ))
			return -1;
                if (osc_str_append_int(data, args->bgp_asn))
			return -1;
	   	ret += 1;
	}
	if (args->connection_type) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ConnectionType\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->connection_type))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->public_ip) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PublicIp\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->public_ip))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_client_gateway(struct osc_env *e, struct osc_str *out, struct osc_create_client_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_client_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateClientGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_ca_data(struct osc_create_ca_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->ca_pem) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaPem\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->ca_pem))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_ca(struct osc_env *e, struct osc_str *out, struct osc_create_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_ca_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_api_access_rule_data(struct osc_create_api_access_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->ca_ids) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":[" ))
			return -1;
		for (as = args->ca_ids; *as > 0; ++as) {
			if (as != args->ca_ids)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ca_ids_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CaIds\":" ))
			return -1;
                if (osc_str_append_string(data, args->ca_ids_str))
			return -1;
		ret += 1;
	}
	if (args->cns) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Cns\":[" ))
			return -1;
		for (as = args->cns; *as > 0; ++as) {
			if (as != args->cns)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->cns_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Cns\":" ))
			return -1;
                if (osc_str_append_string(data, args->cns_str))
			return -1;
		ret += 1;
	}
	if (args->description) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Description\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->description))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":[" ))
			return -1;
		for (as = args->ip_ranges; *as > 0; ++as) {
			if (as != args->ip_ranges)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->ip_ranges_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"IpRanges\":" ))
			return -1;
                if (osc_str_append_string(data, args->ip_ranges_str))
			return -1;
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_create_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_api_access_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_account_data(struct osc_create_account_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->additional_emails) {
		char **as;

		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AdditionalEmails\":[" ))
			return -1;
		for (as = args->additional_emails; *as > 0; ++as) {
			if (as != args->additional_emails)
				if (osc_str_append_string(data, "," ))
					return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
			if (osc_str_append_string(data, *as))
				return -1;
			if (osc_str_append_string(data, "\"" ))
				return -1;
		}
		if (osc_str_append_string(data, "]" ))
			return -1;
		ret += 1;
	} else if (args->additional_emails_str) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"AdditionalEmails\":" ))
			return -1;
                if (osc_str_append_string(data, args->additional_emails_str))
			return -1;
		ret += 1;
	}
	if (args->city) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"City\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->city))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->company_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CompanyName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->company_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->country) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Country\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->country))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->customer_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"CustomerId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->customer_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->email) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Email\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->email))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->first_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"FirstName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->first_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->job_title) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"JobTitle\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->job_title))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->last_name) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"LastName\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->last_name))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->mobile_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"MobileNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->mobile_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->phone_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"PhoneNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->phone_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->state_province) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"StateProvince\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->state_province))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->vat_number) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"VatNumber\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->vat_number))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->zip_code) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ZipCode\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->zip_code))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_account(struct osc_env *e, struct osc_str *out, struct osc_create_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_account_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_access_key_data(struct osc_create_access_key_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->expiration_date) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"ExpirationDate\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->expiration_date))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_access_key(struct osc_env *e, struct osc_str *out, struct osc_create_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_access_key_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int check_authentication_data(struct osc_check_authentication_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->login) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Login\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->login))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	if (args->password) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"Password\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->password))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_check_authentication(struct osc_env *e, struct osc_str *out, struct osc_check_authentication_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = check_authentication_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CheckAuthentication");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int accept_net_peering_data(struct osc_accept_net_peering_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"DryRun\":" ))
			return -1;
                if (osc_str_append_bool(data, args->dry_run))
			return -1;
	   	ret += 1;
	}
	if (args->net_peering_id) {
		if (count_args++ > 0)
			if (osc_str_append_string(data, "," ))
				return -1;
		if (osc_str_append_string(data, "\"NetPeeringId\":\"" ))
			return -1;
                if (osc_str_append_string(data, args->net_peering_id))
			return -1;
		if (osc_str_append_string(data, "\"" ))
			return -1;
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_accept_net_peering(struct osc_env *e, struct osc_str *out, struct osc_accept_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = accept_net_peering_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/AcceptNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Date send to curl>\n%s\n</Date send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}


int osc_sdk_set_useragent(struct osc_env *e, const char *str)
{
	return curl_easy_setopt(e->c, CURLOPT_USERAGENT, str);
}

int osc_init_sdk(struct osc_env *e, const char *profile, unsigned int flag)
{
	char *ca = getenv("CURL_CA_BUNDLE");
	char *endpoint;
	char user_agent[sizeof "osc-sdk-c/" + OSC_SDK_VERSON_L];
	char *cert = getenv("OSC_X509_CLIENT_CERT");
	char *sslkey = getenv("OSC_X509_CLIENT_KEY");
	char *auth = getenv("OSC_AUTH_METHOD");

	strcpy(stpcpy(user_agent, "osc-sdk-c/"), osc_sdk_version_str());
	e->region = getenv("OSC_REGION");
	e->flag = flag;
	e->auth_method = flag & OSC_ENV_PASSWORD_AUTH ? OSC_PASSWORD_METHOD :
		OSC_AKSK_METHOD;
	endpoint = getenv("OSC_ENDPOINT_API");
	osc_init_str(&e->endpoint);

	if (auth && (!strcmp(auth, "password") || !strcmp(auth, "basic")))
		e->auth_method = OSC_PASSWORD_METHOD;
	else if (auth && strcmp(auth, "accesskey")) {
		fprintf(stderr, "'%s' invalid authentication method\n", auth);
		return -1;
	}

	if (!profile) {
		profile = getenv("OSC_PROFILE");
		if (e->auth_method == OSC_PASSWORD_METHOD) {
			e->ak = getenv("OSC_LOGIN");
			e->sk = getenv("OSC_PASSWORD");
		} else {
			e->ak = getenv("OSC_ACCESS_KEY");
			e->sk = getenv("OSC_SECRET_KEY");
		}
		if (!profile && (!e->ak || !e->sk))
			profile = "default";

	}

	if (profile) {
		int f;

		if (e->auth_method == OSC_PASSWORD_METHOD) {
			if (osc_load_loging_password_from_conf(profile, &e->ak,
							       &e->sk) < 0)
				return -1;
			e->flag |= OSC_ENV_FREE_AK;
			if (!e->sk)
				e->sk = getenv("OSC_PASSWORD");
			else
				e->flag |= OSC_ENV_FREE_SK;
		} else {
			if (osc_load_ak_sk_from_conf(profile, &e->ak,
						     &e->sk) < 0)
				return -1;
			e->flag |= OSC_ENV_FREE_AK_SK;
		}
		if (!osc_load_region_from_conf(profile, &e->region))
			e->flag |= OSC_ENV_FREE_REGION;
		f = osc_load_cert_from_conf(profile, &e->cert, &e->sslkey);
		if (f < 0)
			return -1;
		e->flag |= f;
	}

	if (!e->region)
		e->region = "eu-west-2";

	if (!endpoint) {
		osc_str_append_string(&e->endpoint, "https://api.");
		osc_str_append_string(&e->endpoint, e->region);
		osc_str_append_string(&e->endpoint, ".outscale.com");
	} else {
		osc_str_append_string(&e->endpoint, endpoint);
	}

	if (e->auth_method == OSC_AKSK_METHOD) {
		if (!e->ak || !e->sk) {
			fprintf(stderr, "access key and secret key needed\n");
			return -1;
		}

		if (strlen(e->ak) != AK_SIZE || strlen(e->sk) != SK_SIZE) {
			fprintf(stderr, "Wrong access key or secret key size\n");
			return -1;
		}
	} else if (e->auth_method == OSC_PASSWORD_METHOD) {
		if (!e->ak || !e->sk) {
			fprintf(stderr, "login and password needed\n");
			return -1;
		}
	}

	e->headers = NULL;
	e->c = curl_easy_init();

	/* Setting HEADERS */
	if (flag & OSC_VERBOSE_MODE)
		curl_easy_setopt(e->c, CURLOPT_VERBOSE, 1);
	if (flag & OSC_INSECURE_MODE)
		curl_easy_setopt(e->c, CURLOPT_SSL_VERIFYPEER, 0);
	if (cert)
		curl_easy_setopt(e->c, CURLOPT_SSLCERT, cert);
	if (sslkey)
		curl_easy_setopt(e->c, CURLOPT_SSLKEY, sslkey);
	curl_easy_setopt(e->c, CURLOPT_WRITEFUNCTION, write_data);
	curl_easy_setopt(e->c, CURLOPT_USERAGENT, user_agent);

	/* setting CA is CURL_CA_BUNDLE is set */
	if (ca)
	  curl_easy_setopt(e->c, CURLOPT_CAINFO, ca);

	e->headers = curl_slist_append(e->headers, "Content-Type: application/json");

	/* For authentification we specify the method and our acces key / secret key */
	if (e->auth_method == OSC_AKSK_METHOD) {
		curl_easy_setopt(e->c, CURLOPT_AWS_SIGV4, "osc");
	} else if (e->auth_method == OSC_PASSWORD_METHOD) {
		time_t clock;
		struct tm tm;
		char time_hdr[TIME_HDR_KEY_L + TIMESTAMP_SIZE] = TIME_HDR_KEY;

		time(&clock);
		if (!gmtime_r(&clock, &tm)) {
			fprintf(stderr, "gmtime_r fail\n");
			return -1;
		}
		strftime(time_hdr + TIME_HDR_KEY_L - 1,
			 TIMESTAMP_SIZE, "%Y%m%dT%H%M%SZ", &tm);
		e->headers = curl_slist_append(e->headers, time_hdr);
	}
	curl_easy_setopt(e->c, CURLOPT_HTTPHEADER, e->headers);
	curl_easy_setopt(e->c, CURLOPT_USERNAME, e->ak);
	curl_easy_setopt(e->c, CURLOPT_PASSWORD, e->sk);

	return 0;
}

void osc_deinit_sdk(struct osc_env *e)
{
	curl_slist_free_all(e->headers);
	curl_easy_cleanup(e->c);
	osc_deinit_str(&e->endpoint);
	if (e->flag & OSC_ENV_FREE_AK) {
		free(e->ak);
		e->ak = NULL;
	}
	if (e->flag & OSC_ENV_FREE_SK) {
		free(e->sk);
		e->sk = NULL;
	}
	if (e->flag & OSC_ENV_FREE_REGION) {
		free(e->region);
		e->region = NULL;
	}

	if (e->flag & OSC_ENV_FREE_CERT) {
		free(e->cert);
	}
	if (e->flag & OSC_ENV_FREE_SSLKEY) {
		free(e->sslkey);
	}

	e->c = NULL;
	e->flag = 0;
}
