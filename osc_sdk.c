/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, Outscale SAS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

 /*
  * This code is autogenerated, don't edit it directely
  */

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "curl/curl.h"
#include <time.h>
#include <unistd.h>
#include "osc_sdk.h"
#include "json.h"
#include <math.h>

#define AK_SIZE 20
#define SK_SIZE 40
#define TIMESTAMP_SIZE 17
#define TIME_HDR_KEY "X-Osc-Date: "
#define TIME_HDR_KEY_L (sizeof TIME_HDR_KEY)

#ifdef _WIN32

#define SAFE_C 0

static inline char* stpcpy(char *dest, const char *src)
{
	for (; *src; ++src) {
		*dest++ = *src;
	}
	*dest = 0;
	return dest;
}

#define CFG_FILE "config.json"

#define LOAD_CFG_GET_HOME(buf)			\
	{					\
		strcpy(buf, CFG_FILE);		\
	}
#else

#define CFG_FILE "/.osc/config.json"

#define SAFE_C 1

#endif

#ifdef WITH_DESCRIPTION

static const char *calls_name[] = {
	"AcceptNetPeering",
	"AddUserToUserGroup",
	"CheckAuthentication",
	"CreateAccessKey",
	"CreateAccount",
	"CreateApiAccessRule",
	"CreateCa",
	"CreateClientGateway",
	"CreateDedicatedGroup",
	"CreateDhcpOptions",
	"CreateDirectLinkInterface",
	"CreateDirectLink",
	"CreateFlexibleGpu",
	"CreateImageExportTask",
	"CreateImage",
	"CreateInternetService",
	"CreateKeypair",
	"CreateListenerRule",
	"CreateLoadBalancerListeners",
	"CreateLoadBalancerPolicy",
	"CreateLoadBalancer",
	"CreateLoadBalancerTags",
	"CreateNatService",
	"CreateNetAccessPoint",
	"CreateNetPeering",
	"CreateNet",
	"CreateNic",
	"CreatePolicy",
	"CreatePolicyVersion",
	"CreateProductType",
	"CreatePublicIp",
	"CreateRoute",
	"CreateRouteTable",
	"CreateSecurityGroup",
	"CreateSecurityGroupRule",
	"CreateServerCertificate",
	"CreateSnapshotExportTask",
	"CreateSnapshot",
	"CreateSubnet",
	"CreateTags",
	"CreateUserGroup",
	"CreateUser",
	"CreateVirtualGateway",
	"CreateVmGroup",
	"CreateVmTemplate",
	"CreateVms",
	"CreateVolume",
	"CreateVpnConnection",
	"CreateVpnConnectionRoute",
	"DeleteAccessKey",
	"DeleteApiAccessRule",
	"DeleteCa",
	"DeleteClientGateway",
	"DeleteDedicatedGroup",
	"DeleteDhcpOptions",
	"DeleteDirectLinkInterface",
	"DeleteDirectLink",
	"DeleteExportTask",
	"DeleteFlexibleGpu",
	"DeleteImage",
	"DeleteInternetService",
	"DeleteKeypair",
	"DeleteListenerRule",
	"DeleteLoadBalancerListeners",
	"DeleteLoadBalancerPolicy",
	"DeleteLoadBalancer",
	"DeleteLoadBalancerTags",
	"DeleteNatService",
	"DeleteNetAccessPoint",
	"DeleteNetPeering",
	"DeleteNet",
	"DeleteNic",
	"DeletePolicy",
	"DeletePolicyVersion",
	"DeleteProductType",
	"DeletePublicIp",
	"DeleteRoute",
	"DeleteRouteTable",
	"DeleteSecurityGroup",
	"DeleteSecurityGroupRule",
	"DeleteServerCertificate",
	"DeleteSnapshot",
	"DeleteSubnet",
	"DeleteTags",
	"DeleteUserGroupPolicy",
	"DeleteUserGroup",
	"DeleteUserPolicy",
	"DeleteUser",
	"DeleteVirtualGateway",
	"DeleteVmGroup",
	"DeleteVmTemplate",
	"DeleteVms",
	"DeleteVolume",
	"DeleteVpnConnection",
	"DeleteVpnConnectionRoute",
	"DeregisterVmsInLoadBalancer",
	"DisableOutscaleLoginForUsers",
	"DisableOutscaleLoginPerUsers",
	"DisableOutscaleLogin",
	"EnableOutscaleLoginForUsers",
	"EnableOutscaleLoginPerUsers",
	"EnableOutscaleLogin",
	"LinkFlexibleGpu",
	"LinkInternetService",
	"LinkLoadBalancerBackendMachines",
	"LinkManagedPolicyToUserGroup",
	"LinkNic",
	"LinkPolicy",
	"LinkPrivateIps",
	"LinkPublicIp",
	"LinkRouteTable",
	"LinkVirtualGateway",
	"LinkVolume",
	"PutUserGroupPolicy",
	"PutUserPolicy",
	"ReadAccessKeys",
	"ReadAccounts",
	"ReadAdminPassword",
	"ReadApiAccessPolicy",
	"ReadApiAccessRules",
	"ReadApiLogs",
	"ReadCas",
	"ReadCatalog",
	"ReadCatalogs",
	"ReadClientGateways",
	"ReadConsoleOutput",
	"ReadConsumptionAccount",
	"ReadDedicatedGroups",
	"ReadDhcpOptions",
	"ReadDirectLinkInterfaces",
	"ReadDirectLinks",
	"ReadEntitiesLinkedToPolicy",
	"ReadFlexibleGpuCatalog",
	"ReadFlexibleGpus",
	"ReadImageExportTasks",
	"ReadImages",
	"ReadInternetServices",
	"ReadKeypairs",
	"ReadLinkedPolicies",
	"ReadListenerRules",
	"ReadLoadBalancerTags",
	"ReadLoadBalancers",
	"ReadLocations",
	"ReadManagedPoliciesLinkedToUserGroup",
	"ReadNatServices",
	"ReadNetAccessPointServices",
	"ReadNetAccessPoints",
	"ReadNetPeerings",
	"ReadNets",
	"ReadNics",
	"ReadPolicies",
	"ReadPolicy",
	"ReadPolicyVersion",
	"ReadPolicyVersions",
	"ReadProductTypes",
	"ReadPublicCatalog",
	"ReadPublicIpRanges",
	"ReadPublicIps",
	"ReadQuotas",
	"ReadRegions",
	"ReadRouteTables",
	"ReadSecurityGroups",
	"ReadServerCertificates",
	"ReadSnapshotExportTasks",
	"ReadSnapshots",
	"ReadSubnets",
	"ReadSubregions",
	"ReadTags",
	"ReadUnitPrice",
	"ReadUserGroupPolicies",
	"ReadUserGroupPolicy",
	"ReadUserGroup",
	"ReadUserGroupsPerUser",
	"ReadUserGroups",
	"ReadUserPolicies",
	"ReadUserPolicy",
	"ReadUsers",
	"ReadVirtualGateways",
	"ReadVmGroups",
	"ReadVmTemplates",
	"ReadVmTypes",
	"ReadVmsHealth",
	"ReadVms",
	"ReadVmsState",
	"ReadVolumes",
	"ReadVpnConnections",
	"RebootVms",
	"RegisterVmsInLoadBalancer",
	"RejectNetPeering",
	"RemoveUserFromUserGroup",
	"ScaleDownVmGroup",
	"ScaleUpVmGroup",
	"SetDefaultPolicyVersion",
	"StartVms",
	"StopVms",
	"UnlinkFlexibleGpu",
	"UnlinkInternetService",
	"UnlinkLoadBalancerBackendMachines",
	"UnlinkManagedPolicyFromUserGroup",
	"UnlinkNic",
	"UnlinkPolicy",
	"UnlinkPrivateIps",
	"UnlinkPublicIp",
	"UnlinkRouteTable",
	"UnlinkVirtualGateway",
	"UnlinkVolume",
	"UpdateAccessKey",
	"UpdateAccount",
	"UpdateApiAccessPolicy",
	"UpdateApiAccessRule",
	"UpdateCa",
	"UpdateDedicatedGroup",
	"UpdateDirectLinkInterface",
	"UpdateFlexibleGpu",
	"UpdateImage",
	"UpdateListenerRule",
	"UpdateLoadBalancer",
	"UpdateNetAccessPoint",
	"UpdateNet",
	"UpdateNic",
	"UpdateRoutePropagation",
	"UpdateRoute",
	"UpdateRouteTableLink",
	"UpdateServerCertificate",
	"UpdateSnapshot",
	"UpdateSubnet",
	"UpdateUserGroup",
	"UpdateUser",
	"UpdateVmGroup",
	"UpdateVm",
	"UpdateVmTemplate",
	"UpdateVolume",
	"UpdateVpnConnection",
	NULL
};

static const char *calls_descriptions[] = {
	"Usage: oapi-cli AcceptNetPeering --NetPeeringId=netpeeringid [OPTIONS]\n" "null\n" "\nRequired Argument: NetPeeringId \n"
,
	"Usage: oapi-cli AddUserToUserGroup --UserGroupName=usergroupname --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName UserName \n"
,
	"Usage: oapi-cli CheckAuthentication --Login=login --Password=password [OPTIONS]\n" "null\n" "\nRequired Argument: Login Password \n"
,
	"Usage: oapi-cli CreateAccessKey [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli CreateAccount --City=city --CompanyName=companyname --Country=country --CustomerId=customerid --Email=email --FirstName=firstname --LastName=lastname --ZipCode=zipcode [OPTIONS]\n" "null\n" "\nRequired Argument: City CompanyName Country CustomerId Email FirstName LastName ZipCode \n"
,
	"Usage: oapi-cli CreateApiAccessRule [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli CreateCa --CaPem=capem [OPTIONS]\n" "null\n" "\nRequired Argument: CaPem \n"
,
	"Usage: oapi-cli CreateClientGateway --BgpAsn=bgpasn --PublicIp=publicip --ConnectionType=connectiontype [OPTIONS]\n" "null\n" "\nRequired Argument: BgpAsn PublicIp ConnectionType \n"
,
	"Usage: oapi-cli CreateDedicatedGroup --CpuGeneration=cpugeneration --Name=name --SubregionName=subregionname [OPTIONS]\n" "null\n" "\nRequired Argument: CpuGeneration Name SubregionName \n"
,
	"Usage: oapi-cli CreateDhcpOptions [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli CreateDirectLinkInterface --DirectLinkId=directlinkid --DirectLinkInterface=directlinkinterface [OPTIONS]\n" "null\n" "\nRequired Argument: DirectLinkId DirectLinkInterface \n"
,
	"Usage: oapi-cli CreateDirectLink --Bandwidth=bandwidth --DirectLinkName=directlinkname --Location=location [OPTIONS]\n" "null\n" "\nRequired Argument: Bandwidth DirectLinkName Location \n"
,
	"Usage: oapi-cli CreateFlexibleGpu --ModelName=modelname --SubregionName=subregionname [OPTIONS]\n" "null\n" "\nRequired Argument: ModelName SubregionName \n"
,
	"Usage: oapi-cli CreateImageExportTask --OsuExport=osuexport --ImageId=imageid [OPTIONS]\n" "null\n" "\nRequired Argument: OsuExport ImageId \n"
,
	"Usage: oapi-cli CreateImage [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli CreateInternetService [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli CreateKeypair --KeypairName=keypairname [OPTIONS]\n" "null\n" "\nRequired Argument: KeypairName \n"
,
	"Usage: oapi-cli CreateListenerRule --VmIds=vmids --Listener=listener --ListenerRule=listenerrule [OPTIONS]\n" "null\n" "\nRequired Argument: VmIds Listener ListenerRule \n"
,
	"Usage: oapi-cli CreateLoadBalancerListeners --Listeners=listeners --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: Listeners LoadBalancerName \n"
,
	"Usage: oapi-cli CreateLoadBalancerPolicy --PolicyType=policytype --LoadBalancerName=loadbalancername --PolicyName=policyname [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyType LoadBalancerName PolicyName \n"
,
	"Usage: oapi-cli CreateLoadBalancer --Listeners=listeners --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: Listeners LoadBalancerName \n"
,
	"Usage: oapi-cli CreateLoadBalancerTags --LoadBalancerNames=loadbalancernames --Tags=tags [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerNames Tags \n"
,
	"Usage: oapi-cli CreateNatService --PublicIpId=publicipid --SubnetId=subnetid [OPTIONS]\n" "null\n" "\nRequired Argument: PublicIpId SubnetId \n"
,
	"Usage: oapi-cli CreateNetAccessPoint --ServiceName=servicename --NetId=netid [OPTIONS]\n" "null\n" "\nRequired Argument: ServiceName NetId \n"
,
	"Usage: oapi-cli CreateNetPeering --AccepterNetId=accepternetid --SourceNetId=sourcenetid [OPTIONS]\n" "null\n" "\nRequired Argument: AccepterNetId SourceNetId \n"
,
	"Usage: oapi-cli CreateNet --IpRange=iprange [OPTIONS]\n" "null\n" "\nRequired Argument: IpRange \n"
,
	"Usage: oapi-cli CreateNic --SubnetId=subnetid [OPTIONS]\n" "null\n" "\nRequired Argument: SubnetId \n"
,
	"Usage: oapi-cli CreatePolicy --Document=document --PolicyName=policyname [OPTIONS]\n" "null\n" "\nRequired Argument: Document PolicyName \n"
,
	"Usage: oapi-cli CreatePolicyVersion --Document=document --PolicyOrn=policyorn [OPTIONS]\n" "null\n" "\nRequired Argument: Document PolicyOrn \n"
,
	"Usage: oapi-cli CreateProductType --Description=description [OPTIONS]\n" "null\n" "\nRequired Argument: Description \n"
,
	"Usage: oapi-cli CreatePublicIp [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli CreateRoute --DestinationIpRange=destinationiprange --RouteTableId=routetableid [OPTIONS]\n" "null\n" "\nRequired Argument: DestinationIpRange RouteTableId \n"
,
	"Usage: oapi-cli CreateRouteTable --NetId=netid [OPTIONS]\n" "null\n" "\nRequired Argument: NetId \n"
,
	"Usage: oapi-cli CreateSecurityGroup --Description=description --SecurityGroupName=securitygroupname [OPTIONS]\n" "null\n" "\nRequired Argument: Description SecurityGroupName \n"
,
	"Usage: oapi-cli CreateSecurityGroupRule --SecurityGroupId=securitygroupid --Flow=flow [OPTIONS]\n" "null\n" "\nRequired Argument: SecurityGroupId Flow \n"
,
	"Usage: oapi-cli CreateServerCertificate --Body=body --PrivateKey=privatekey --Name=name [OPTIONS]\n" "null\n" "\nRequired Argument: Body PrivateKey Name \n"
,
	"Usage: oapi-cli CreateSnapshotExportTask --OsuExport=osuexport --SnapshotId=snapshotid [OPTIONS]\n" "null\n" "\nRequired Argument: OsuExport SnapshotId \n"
,
	"Usage: oapi-cli CreateSnapshot [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli CreateSubnet --IpRange=iprange --NetId=netid [OPTIONS]\n" "null\n" "\nRequired Argument: IpRange NetId \n"
,
	"Usage: oapi-cli CreateTags --ResourceIds=resourceids --Tags=tags [OPTIONS]\n" "null\n" "\nRequired Argument: ResourceIds Tags \n"
,
	"Usage: oapi-cli CreateUserGroup --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName \n"
,
	"Usage: oapi-cli CreateUser --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli CreateVirtualGateway --ConnectionType=connectiontype [OPTIONS]\n" "null\n" "\nRequired Argument: ConnectionType \n"
,
	"Usage: oapi-cli CreateVmGroup --SecurityGroupIds=securitygroupids --SubnetId=subnetid --VmGroupName=vmgroupname --VmTemplateId=vmtemplateid --VmCount=vmcount [OPTIONS]\n" "null\n" "\nRequired Argument: SecurityGroupIds SubnetId VmGroupName VmTemplateId VmCount \n"
,
	"Usage: oapi-cli CreateVmTemplate --CpuCores=cpucores --CpuGeneration=cpugeneration --ImageId=imageid --Ram=ram --VmTemplateName=vmtemplatename [OPTIONS]\n" "null\n" "\nRequired Argument: CpuCores CpuGeneration ImageId Ram VmTemplateName \n"
,
	"Usage: oapi-cli CreateVms --ImageId=imageid [OPTIONS]\n" "null\n" "\nRequired Argument: ImageId \n"
,
	"Usage: oapi-cli CreateVolume --SubregionName=subregionname [OPTIONS]\n" "null\n" "\nRequired Argument: SubregionName \n"
,
	"Usage: oapi-cli CreateVpnConnection --ClientGatewayId=clientgatewayid --ConnectionType=connectiontype --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "null\n" "\nRequired Argument: ClientGatewayId ConnectionType VirtualGatewayId \n"
,
	"Usage: oapi-cli CreateVpnConnectionRoute --DestinationIpRange=destinationiprange --VpnConnectionId=vpnconnectionid [OPTIONS]\n" "null\n" "\nRequired Argument: DestinationIpRange VpnConnectionId \n"
,
	"Usage: oapi-cli DeleteAccessKey --AccessKeyId=accesskeyid [OPTIONS]\n" "null\n" "\nRequired Argument: AccessKeyId \n"
,
	"Usage: oapi-cli DeleteApiAccessRule --ApiAccessRuleId=apiaccessruleid [OPTIONS]\n" "null\n" "\nRequired Argument: ApiAccessRuleId \n"
,
	"Usage: oapi-cli DeleteCa --CaId=caid [OPTIONS]\n" "null\n" "\nRequired Argument: CaId \n"
,
	"Usage: oapi-cli DeleteClientGateway --ClientGatewayId=clientgatewayid [OPTIONS]\n" "null\n" "\nRequired Argument: ClientGatewayId \n"
,
	"Usage: oapi-cli DeleteDedicatedGroup --DedicatedGroupId=dedicatedgroupid [OPTIONS]\n" "null\n" "\nRequired Argument: DedicatedGroupId \n"
,
	"Usage: oapi-cli DeleteDhcpOptions --DhcpOptionsSetId=dhcpoptionssetid [OPTIONS]\n" "null\n" "\nRequired Argument: DhcpOptionsSetId \n"
,
	"Usage: oapi-cli DeleteDirectLinkInterface --DirectLinkInterfaceId=directlinkinterfaceid [OPTIONS]\n" "null\n" "\nRequired Argument: DirectLinkInterfaceId \n"
,
	"Usage: oapi-cli DeleteDirectLink --DirectLinkId=directlinkid [OPTIONS]\n" "null\n" "\nRequired Argument: DirectLinkId \n"
,
	"Usage: oapi-cli DeleteExportTask --ExportTaskId=exporttaskid [OPTIONS]\n" "null\n" "\nRequired Argument: ExportTaskId \n"
,
	"Usage: oapi-cli DeleteFlexibleGpu --FlexibleGpuId=flexiblegpuid [OPTIONS]\n" "null\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli DeleteImage --ImageId=imageid [OPTIONS]\n" "null\n" "\nRequired Argument: ImageId \n"
,
	"Usage: oapi-cli DeleteInternetService --InternetServiceId=internetserviceid [OPTIONS]\n" "null\n" "\nRequired Argument: InternetServiceId \n"
,
	"Usage: oapi-cli DeleteKeypair [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli DeleteListenerRule --ListenerRuleName=listenerrulename [OPTIONS]\n" "null\n" "\nRequired Argument: ListenerRuleName \n"
,
	"Usage: oapi-cli DeleteLoadBalancerListeners --LoadBalancerName=loadbalancername --LoadBalancerPorts=loadbalancerports [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerName LoadBalancerPorts \n"
,
	"Usage: oapi-cli DeleteLoadBalancerPolicy --LoadBalancerName=loadbalancername --PolicyName=policyname [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerName PolicyName \n"
,
	"Usage: oapi-cli DeleteLoadBalancer --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli DeleteLoadBalancerTags --LoadBalancerNames=loadbalancernames --Tags=tags [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerNames Tags \n"
,
	"Usage: oapi-cli DeleteNatService --NatServiceId=natserviceid [OPTIONS]\n" "null\n" "\nRequired Argument: NatServiceId \n"
,
	"Usage: oapi-cli DeleteNetAccessPoint --NetAccessPointId=netaccesspointid [OPTIONS]\n" "null\n" "\nRequired Argument: NetAccessPointId \n"
,
	"Usage: oapi-cli DeleteNetPeering --NetPeeringId=netpeeringid [OPTIONS]\n" "null\n" "\nRequired Argument: NetPeeringId \n"
,
	"Usage: oapi-cli DeleteNet --NetId=netid [OPTIONS]\n" "null\n" "\nRequired Argument: NetId \n"
,
	"Usage: oapi-cli DeleteNic --NicId=nicid [OPTIONS]\n" "null\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli DeletePolicy --PolicyOrn=policyorn [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn \n"
,
	"Usage: oapi-cli DeletePolicyVersion --PolicyOrn=policyorn --VersionId=versionid [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn VersionId \n"
,
	"Usage: oapi-cli DeleteProductType --ProductTypeId=producttypeid [OPTIONS]\n" "null\n" "\nRequired Argument: ProductTypeId \n"
,
	"Usage: oapi-cli DeletePublicIp [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli DeleteRoute --RouteTableId=routetableid --DestinationIpRange=destinationiprange [OPTIONS]\n" "null\n" "\nRequired Argument: RouteTableId DestinationIpRange \n"
,
	"Usage: oapi-cli DeleteRouteTable --RouteTableId=routetableid [OPTIONS]\n" "null\n" "\nRequired Argument: RouteTableId \n"
,
	"Usage: oapi-cli DeleteSecurityGroup [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli DeleteSecurityGroupRule --SecurityGroupId=securitygroupid --Flow=flow [OPTIONS]\n" "null\n" "\nRequired Argument: SecurityGroupId Flow \n"
,
	"Usage: oapi-cli DeleteServerCertificate --Name=name [OPTIONS]\n" "null\n" "\nRequired Argument: Name \n"
,
	"Usage: oapi-cli DeleteSnapshot --SnapshotId=snapshotid [OPTIONS]\n" "null\n" "\nRequired Argument: SnapshotId \n"
,
	"Usage: oapi-cli DeleteSubnet --SubnetId=subnetid [OPTIONS]\n" "null\n" "\nRequired Argument: SubnetId \n"
,
	"Usage: oapi-cli DeleteTags --ResourceIds=resourceids --Tags=tags [OPTIONS]\n" "null\n" "\nRequired Argument: ResourceIds Tags \n"
,
	"Usage: oapi-cli DeleteUserGroupPolicy --UserGroupName=usergroupname --PolicyName=policyname [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName PolicyName \n"
,
	"Usage: oapi-cli DeleteUserGroup --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName \n"
,
	"Usage: oapi-cli DeleteUserPolicy --UserName=username --PolicyName=policyname [OPTIONS]\n" "null\n" "\nRequired Argument: UserName PolicyName \n"
,
	"Usage: oapi-cli DeleteUser --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli DeleteVirtualGateway --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "null\n" "\nRequired Argument: VirtualGatewayId \n"
,
	"Usage: oapi-cli DeleteVmGroup --VmGroupId=vmgroupid [OPTIONS]\n" "null\n" "\nRequired Argument: VmGroupId \n"
,
	"Usage: oapi-cli DeleteVmTemplate --VmTemplateId=vmtemplateid [OPTIONS]\n" "null\n" "\nRequired Argument: VmTemplateId \n"
,
	"Usage: oapi-cli DeleteVms --VmIds=vmids [OPTIONS]\n" "null\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli DeleteVolume --VolumeId=volumeid [OPTIONS]\n" "null\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli DeleteVpnConnection --VpnConnectionId=vpnconnectionid [OPTIONS]\n" "null\n" "\nRequired Argument: VpnConnectionId \n"
,
	"Usage: oapi-cli DeleteVpnConnectionRoute --DestinationIpRange=destinationiprange --VpnConnectionId=vpnconnectionid [OPTIONS]\n" "null\n" "\nRequired Argument: DestinationIpRange VpnConnectionId \n"
,
	"Usage: oapi-cli DeregisterVmsInLoadBalancer --BackendVmIds=backendvmids --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: BackendVmIds LoadBalancerName \n"
,
	"Usage: oapi-cli DisableOutscaleLoginForUsers [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli DisableOutscaleLoginPerUsers [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli DisableOutscaleLogin [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli EnableOutscaleLoginForUsers [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli EnableOutscaleLoginPerUsers [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli EnableOutscaleLogin [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli LinkFlexibleGpu --FlexibleGpuId=flexiblegpuid --VmId=vmid [OPTIONS]\n" "null\n" "\nRequired Argument: FlexibleGpuId VmId \n"
,
	"Usage: oapi-cli LinkInternetService --InternetServiceId=internetserviceid --NetId=netid [OPTIONS]\n" "null\n" "\nRequired Argument: InternetServiceId NetId \n"
,
	"Usage: oapi-cli LinkLoadBalancerBackendMachines --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli LinkManagedPolicyToUserGroup --PolicyOrn=policyorn --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn UserGroupName \n"
,
	"Usage: oapi-cli LinkNic --DeviceNumber=devicenumber --VmId=vmid --NicId=nicid [OPTIONS]\n" "null\n" "\nRequired Argument: DeviceNumber VmId NicId \n"
,
	"Usage: oapi-cli LinkPolicy --PolicyOrn=policyorn --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn UserName \n"
,
	"Usage: oapi-cli LinkPrivateIps --NicId=nicid [OPTIONS]\n" "null\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli LinkPublicIp [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli LinkRouteTable --RouteTableId=routetableid --SubnetId=subnetid [OPTIONS]\n" "null\n" "\nRequired Argument: RouteTableId SubnetId \n"
,
	"Usage: oapi-cli LinkVirtualGateway --NetId=netid --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "null\n" "\nRequired Argument: NetId VirtualGatewayId \n"
,
	"Usage: oapi-cli LinkVolume --DeviceName=devicename --VmId=vmid --VolumeId=volumeid [OPTIONS]\n" "null\n" "\nRequired Argument: DeviceName VmId VolumeId \n"
,
	"Usage: oapi-cli PutUserGroupPolicy --PolicyName=policyname --PolicyDocument=policydocument --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyName PolicyDocument UserGroupName \n"
,
	"Usage: oapi-cli PutUserPolicy --PolicyName=policyname --PolicyDocument=policydocument --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyName PolicyDocument UserName \n"
,
	"Usage: oapi-cli ReadAccessKeys [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadAccounts [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadAdminPassword --VmId=vmid [OPTIONS]\n" "null\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli ReadApiAccessPolicy [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadApiAccessRules [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadApiLogs [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadCas [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadCatalog [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadCatalogs [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadClientGateways [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadConsoleOutput --VmId=vmid [OPTIONS]\n" "null\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli ReadConsumptionAccount --FromDate=fromdate --ToDate=todate [OPTIONS]\n" "null\n" "\nRequired Argument: FromDate ToDate \n"
,
	"Usage: oapi-cli ReadDedicatedGroups [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadDhcpOptions [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadDirectLinkInterfaces [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadDirectLinks [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadEntitiesLinkedToPolicy [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadFlexibleGpuCatalog [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadFlexibleGpus [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadImageExportTasks [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadImages [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadInternetServices [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadKeypairs [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadLinkedPolicies --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli ReadListenerRules [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadLoadBalancerTags --LoadBalancerNames=loadbalancernames [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerNames \n"
,
	"Usage: oapi-cli ReadLoadBalancers [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadLocations [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadManagedPoliciesLinkedToUserGroup --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName \n"
,
	"Usage: oapi-cli ReadNatServices [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadNetAccessPointServices [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadNetAccessPoints [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadNetPeerings [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadNets [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadNics [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadPolicies [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadPolicy --PolicyOrn=policyorn [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn \n"
,
	"Usage: oapi-cli ReadPolicyVersion --PolicyOrn=policyorn --VersionId=versionid [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn VersionId \n"
,
	"Usage: oapi-cli ReadPolicyVersions --PolicyOrn=policyorn [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn \n"
,
	"Usage: oapi-cli ReadProductTypes [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadPublicCatalog [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadPublicIpRanges [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadPublicIps [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadQuotas [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadRegions [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadRouteTables [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadSecurityGroups [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadServerCertificates [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadSnapshotExportTasks [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadSnapshots [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadSubnets [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadSubregions [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadTags [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadUnitPrice --Operation=operation --Service=service --Type=type [OPTIONS]\n" "null\n" "\nRequired Argument: Operation Service Type \n"
,
	"Usage: oapi-cli ReadUserGroupPolicies --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName \n"
,
	"Usage: oapi-cli ReadUserGroupPolicy --PolicyName=policyname --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyName UserGroupName \n"
,
	"Usage: oapi-cli ReadUserGroup --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName \n"
,
	"Usage: oapi-cli ReadUserGroupsPerUser --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli ReadUserGroups [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadUserPolicies --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli ReadUserPolicy --UserName=username --PolicyName=policyname [OPTIONS]\n" "null\n" "\nRequired Argument: UserName PolicyName \n"
,
	"Usage: oapi-cli ReadUsers [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadVirtualGateways [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadVmGroups [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadVmTemplates [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadVmTypes [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadVmsHealth --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli ReadVms [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadVmsState [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadVolumes [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli ReadVpnConnections [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli RebootVms --VmIds=vmids [OPTIONS]\n" "null\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli RegisterVmsInLoadBalancer --BackendVmIds=backendvmids --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: BackendVmIds LoadBalancerName \n"
,
	"Usage: oapi-cli RejectNetPeering --NetPeeringId=netpeeringid [OPTIONS]\n" "null\n" "\nRequired Argument: NetPeeringId \n"
,
	"Usage: oapi-cli RemoveUserFromUserGroup --UserGroupName=usergroupname --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName UserName \n"
,
	"Usage: oapi-cli ScaleDownVmGroup --VmGroupId=vmgroupid --VmSubtraction=vmsubtraction [OPTIONS]\n" "null\n" "\nRequired Argument: VmGroupId VmSubtraction \n"
,
	"Usage: oapi-cli ScaleUpVmGroup --VmGroupId=vmgroupid --VmAddition=vmaddition [OPTIONS]\n" "null\n" "\nRequired Argument: VmGroupId VmAddition \n"
,
	"Usage: oapi-cli SetDefaultPolicyVersion --PolicyOrn=policyorn --VersionId=versionid [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn VersionId \n"
,
	"Usage: oapi-cli StartVms --VmIds=vmids [OPTIONS]\n" "null\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli StopVms --VmIds=vmids [OPTIONS]\n" "null\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli UnlinkFlexibleGpu --FlexibleGpuId=flexiblegpuid [OPTIONS]\n" "null\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli UnlinkInternetService --InternetServiceId=internetserviceid --NetId=netid [OPTIONS]\n" "null\n" "\nRequired Argument: InternetServiceId NetId \n"
,
	"Usage: oapi-cli UnlinkLoadBalancerBackendMachines --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli UnlinkManagedPolicyFromUserGroup --PolicyOrn=policyorn --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn UserGroupName \n"
,
	"Usage: oapi-cli UnlinkNic --LinkNicId=linknicid [OPTIONS]\n" "null\n" "\nRequired Argument: LinkNicId \n"
,
	"Usage: oapi-cli UnlinkPolicy --PolicyOrn=policyorn --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: PolicyOrn UserName \n"
,
	"Usage: oapi-cli UnlinkPrivateIps --NicId=nicid --PrivateIps=privateips [OPTIONS]\n" "null\n" "\nRequired Argument: NicId PrivateIps \n"
,
	"Usage: oapi-cli UnlinkPublicIp [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli UnlinkRouteTable --LinkRouteTableId=linkroutetableid [OPTIONS]\n" "null\n" "\nRequired Argument: LinkRouteTableId \n"
,
	"Usage: oapi-cli UnlinkVirtualGateway --NetId=netid --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "null\n" "\nRequired Argument: NetId VirtualGatewayId \n"
,
	"Usage: oapi-cli UnlinkVolume --VolumeId=volumeid [OPTIONS]\n" "null\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli UpdateAccessKey --AccessKeyId=accesskeyid --State=state [OPTIONS]\n" "null\n" "\nRequired Argument: AccessKeyId State \n"
,
	"Usage: oapi-cli UpdateAccount [OPTIONS]\n" "null\n" "\nRequired Argument: null \n"
,
	"Usage: oapi-cli UpdateApiAccessPolicy --MaxAccessKeyExpirationSeconds=maxaccesskeyexpirationseconds --RequireTrustedEnv=requiretrustedenv [OPTIONS]\n" "null\n" "\nRequired Argument: MaxAccessKeyExpirationSeconds RequireTrustedEnv \n"
,
	"Usage: oapi-cli UpdateApiAccessRule --ApiAccessRuleId=apiaccessruleid [OPTIONS]\n" "null\n" "\nRequired Argument: ApiAccessRuleId \n"
,
	"Usage: oapi-cli UpdateCa --CaId=caid [OPTIONS]\n" "null\n" "\nRequired Argument: CaId \n"
,
	"Usage: oapi-cli UpdateDedicatedGroup --DedicatedGroupId=dedicatedgroupid --Name=name [OPTIONS]\n" "null\n" "\nRequired Argument: DedicatedGroupId Name \n"
,
	"Usage: oapi-cli UpdateDirectLinkInterface --DirectLinkInterfaceId=directlinkinterfaceid --Mtu=mtu [OPTIONS]\n" "null\n" "\nRequired Argument: DirectLinkInterfaceId Mtu \n"
,
	"Usage: oapi-cli UpdateFlexibleGpu --FlexibleGpuId=flexiblegpuid [OPTIONS]\n" "null\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli UpdateImage --ImageId=imageid [OPTIONS]\n" "null\n" "\nRequired Argument: ImageId \n"
,
	"Usage: oapi-cli UpdateListenerRule --ListenerRuleName=listenerrulename [OPTIONS]\n" "null\n" "\nRequired Argument: ListenerRuleName \n"
,
	"Usage: oapi-cli UpdateLoadBalancer --LoadBalancerName=loadbalancername [OPTIONS]\n" "null\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli UpdateNetAccessPoint --NetAccessPointId=netaccesspointid [OPTIONS]\n" "null\n" "\nRequired Argument: NetAccessPointId \n"
,
	"Usage: oapi-cli UpdateNet --DhcpOptionsSetId=dhcpoptionssetid --NetId=netid [OPTIONS]\n" "null\n" "\nRequired Argument: DhcpOptionsSetId NetId \n"
,
	"Usage: oapi-cli UpdateNic --NicId=nicid [OPTIONS]\n" "null\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli UpdateRoutePropagation --Enable=enable --RouteTableId=routetableid --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "null\n" "\nRequired Argument: Enable RouteTableId VirtualGatewayId \n"
,
	"Usage: oapi-cli UpdateRoute --RouteTableId=routetableid --DestinationIpRange=destinationiprange [OPTIONS]\n" "null\n" "\nRequired Argument: RouteTableId DestinationIpRange \n"
,
	"Usage: oapi-cli UpdateRouteTableLink --RouteTableId=routetableid --LinkRouteTableId=linkroutetableid [OPTIONS]\n" "null\n" "\nRequired Argument: RouteTableId LinkRouteTableId \n"
,
	"Usage: oapi-cli UpdateServerCertificate --Name=name [OPTIONS]\n" "null\n" "\nRequired Argument: Name \n"
,
	"Usage: oapi-cli UpdateSnapshot --SnapshotId=snapshotid --PermissionsToCreateVolume=permissionstocreatevolume [OPTIONS]\n" "null\n" "\nRequired Argument: SnapshotId PermissionsToCreateVolume \n"
,
	"Usage: oapi-cli UpdateSubnet --SubnetId=subnetid --MapPublicIpOnLaunch=mappubliciponlaunch [OPTIONS]\n" "null\n" "\nRequired Argument: SubnetId MapPublicIpOnLaunch \n"
,
	"Usage: oapi-cli UpdateUserGroup --UserGroupName=usergroupname [OPTIONS]\n" "null\n" "\nRequired Argument: UserGroupName \n"
,
	"Usage: oapi-cli UpdateUser --UserName=username [OPTIONS]\n" "null\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli UpdateVmGroup --VmGroupId=vmgroupid [OPTIONS]\n" "null\n" "\nRequired Argument: VmGroupId \n"
,
	"Usage: oapi-cli UpdateVm --VmId=vmid [OPTIONS]\n" "null\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli UpdateVmTemplate --VmTemplateId=vmtemplateid [OPTIONS]\n" "null\n" "\nRequired Argument: VmTemplateId \n"
,
	"Usage: oapi-cli UpdateVolume --VolumeId=volumeid [OPTIONS]\n" "null\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli UpdateVpnConnection --VpnConnectionId=vpnconnectionid [OPTIONS]\n" "null\n" "\nRequired Argument: VpnConnectionId \n"
,
	NULL
};

static const char *calls_args_descriptions[] = {
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetPeeringId: string\n"
	"  The ID of the Net peering you want to accept.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--UserGroupName: string\n"
	"  The name of the group you want to add a user to.\n"
"--UserGroupPath: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
"--UserName: string\n"
	"  The name of the user you want to add to the group.\n"
"--UserPath: string\n"
	"  The path to the user. If not specified, it is set to a slash (`/`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Login: string\n"
	"  The email address of the account.\n"
"--Password: string\n"
	"  The password of the account.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ExpirationDate: string\n"
	"  The date and time, or the date, at which you want the access key to expire, in ISO 8601 \n"
	"  format (for example, `2020-06-14T00:00:00.000Z`, or `2020-06-14`). To remove an existing \n"
	"  expiration date, use the method without specifying this parameter.\n"
"--Tag: string\n"
	"  A tag to add to the access key.\n"
"--UserName: string\n"
	"  The name of the EIM user that owns the key to be created. If you do not specify a user \n"
	"  name, this action creates an access key for the user who sends the request (which can be \n"
	"  the root account).\n"
,
	"--AdditionalEmails: array string\n"
	"  One or more additional email addresses for the account. These addresses are used for \n"
	"  notifications only. If you already have a list of additional emails registered, you cannot \n"
	"  add to it, only replace it. To remove all registered additional emails, specify an empty \n"
	"  list.\n"
"--City: string\n"
	"  The city of the account owner.\n"
"--CompanyName: string\n"
	"  The name of the company for the account.\n"
"--Country: string\n"
	"  The country of the account owner.\n"
"--CustomerId: string\n"
	"  The ID of the customer. It must be 8 digits.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Email: string\n"
	"  The main email address for the account. This address is used for your credentials and \n"
	"  notifications.\n"
"--FirstName: string\n"
	"  The first name of the account owner.\n"
"--JobTitle: string\n"
	"  The job title of the account owner.\n"
"--LastName: string\n"
	"  The last name of the account owner.\n"
"--MobileNumber: string\n"
	"  The mobile phone number of the account owner.\n"
"--PhoneNumber: string\n"
	"  The landline phone number of the account owner.\n"
"--StateProvince: string\n"
	"  The state/province of the account.\n"
"--VatNumber: string\n"
	"  The value added tax (VAT) number for the account.\n"
"--ZipCode: string\n"
	"  The ZIP code of the city.\n"
,
	"--CaIds: array string\n"
	"  One or more IDs of Client Certificate Authorities (CAs).\n"
"--Cns: array string\n"
	"  One or more Client Certificate Common Names (CNs). If this parameter is specified, you must \n"
	"  also specify the `CaIds` parameter.\n"
"--Description: string\n"
	"  A description for the API access rule.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--IpRanges: array string\n"
	"  One or more IPs or CIDR blocks (for example, `192.0.2.0/16`).\n"
,
	"--CaPem: string\n"
	"  The CA in PEM format.With OSC CLI, use the following syntax to make sure your CA file is \n"
	"  correctly parsed: `--CaPem=\"$(cat FILENAME)\"`.\n"
"--Description: string\n"
	"  The description of the CA.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--BgpAsn: long long int\n"
	"  The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the \n"
	"  path to your client gateway through the Internet. <br/>\nThis number must be between `1` \n"
	"  and `4294967295`, except `50624`, `53306`, and `132418`. <br/>\nIf you do not have an ASN, \n"
	"  you can choose one between `64512` and `65534` (both included), or between `4200000000` and \n"
	"  `4294967295` (both included).\n"
"--ConnectionType: string\n"
	"  The communication protocol used to establish tunnel with your client gateway (always \n"
	"  `ipsec.1`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PublicIp: string\n"
	"  The public fixed IPv4 address of your client gateway.\n"
,
	"--CpuGeneration: long long int\n"
	"  The processor generation for the VMs in the dedicated group (for example, `4`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Name: string\n"
	"  A name for the dedicated group.\n"
"--SubregionName: string\n"
	"  The Subregion in which you want to create the dedicated group.\n"
,
	"--DomainName: string\n"
	"  Specify a domain name (for example, `MyCompany.com`). You can specify only one domain name. \n"
	"  You must specify at least one of the following parameters: `DomainName`, \n"
	"  `DomainNameServers`, `LogServers`, or `NtpServers`.\n"
"--DomainNameServers: array string\n"
	"  The IPs of domain name servers. If no IPs are specified, the `OutscaleProvidedDNS` value is \n"
	"  set by default. You must specify at least one of the following parameters: `DomainName`, \n"
	"  `DomainNameServers`, `LogServers`, or `NtpServers`.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LogServers: array string\n"
	"  The IPs of the log servers. You must specify at least one of the following parameters: \n"
	"  `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.\n"
"--NtpServers: array string\n"
	"  The IPs of the Network Time Protocol (NTP) servers. You must specify at least one of the \n"
	"  following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.\n"
,
	"--DirectLinkId: string\n"
	"  The ID of the existing DirectLink for which you want to create the DirectLink interface.\n"
"--DirectLinkInterface: ref DirectLinkInterface\n"
	"    Information about the DirectLink interface.\n"
	"    --DirectLinkInterface.BgpAsn: long long int\n"
	"      The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on the \n"
	"      customer's side of the DirectLink interface. <br/>\nThis number must be \n"
	"      between `1` and `4294967295`, except `50624`, `53306`, and `132418`. \n"
	"      <br/>\nIf you do not have an ASN, you can choose one between `64512` and \n"
	"      `65534` (both included), or between `4200000000` and `4294967295` (both \n"
	"      included).\n"
	"    --DirectLinkInterface.BgpKey: string\n"
	"      The BGP authentication key.\n"
	"    --DirectLinkInterface.ClientPrivateIp: string\n"
	"      The IP on the customer's side of the DirectLink interface.\n"
	"    --DirectLinkInterface.DirectLinkInterfaceName: string\n"
	"      The name of the DirectLink interface.\n"
	"    --DirectLinkInterface.OutscalePrivateIp: string\n"
	"      The IP on the OUTSCALE side of the DirectLink interface.\n"
	"    --DirectLinkInterface.VirtualGatewayId: string\n"
	"      The ID of the target virtual gateway.\n"
	"    --DirectLinkInterface.Vlan: long long int\n"
	"      The VLAN number associated with the DirectLink interface. This number \n"
	"      must be unique and be between `2` and `4094`.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--Bandwidth: string\n"
	"  The bandwidth of the DirectLink (`1Gbps` \\| `10Gbps`).\n"
"--DirectLinkName: string\n"
	"  The name of the DirectLink.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Location: string\n"
	"  The code of the requested location for the DirectLink, returned by the \n"
	"  [ReadLocations](#readlocations) method.\n"
,
	"--DeleteOnVmDeletion: bool\n"
	"  If true, the fGPU is deleted when the VM is terminated.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Generation: string\n"
	"  The processor generation that the fGPU must be compatible with. If not specified, the \n"
	"  oldest possible processor generation is selected (as provided by \n"
	"  [ReadFlexibleGpuCatalog](#readflexiblegpucatalog) for the specified model of fGPU).\n"
"--ModelName: string\n"
	"  The model of fGPU you want to allocate. For more information, see [About Flexible \n"
	"  GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).\n"
"--SubregionName: string\n"
	"  The Subregion in which you want to create the fGPU.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ImageId: string\n"
	"  The ID of the OMI to export.\n"
"--OsuExport: ref OsuExportToCreate\n"
	"    Information about the OOS export task to create.\n"
	"    --OsuExport.DiskImageFormat: string\n"
	"      The format of the export disk (`qcow2` \\| `raw`).\n"
	"    --OsuExport.OsuApiKey: ref OsuApiKey\n"
	"        Information about the OOS API key.\n"
	"        --OsuExport.OsuApiKey.ApiKeyId: string\n"
	"          The API key of the OOS account that enables you to access the bucket.\n"
	"        --OsuExport.OsuApiKey.SecretKey: string\n"
	"          The secret key of the OOS account that enables you to access the bucket.\n"
	"    --OsuExport.OsuBucket: string\n"
	"      The name of the OOS bucket where you want to export the object.\n"
	"    --OsuExport.OsuManifestUrl: string\n"
	"      The URL of the manifest file.\n"
	"    --OsuExport.OsuPrefix: string\n"
	"      The prefix for the key of the OOS object.\n"
,
	"--Architecture: string\n"
	"  **When registering from a snapshot:** The architecture of the OMI (`i386` or `x86_64`).\n"
"--BlockDeviceMappings: array ref BlockDeviceMappingImage\n"
	"  **(required) When registering from a snapshot:** One or more block device mappings.\n"
	"    One or more parameters used to automatically set up volumes when the VM \n"
	"    is created.\n"
	"    --BlockDeviceMappings.INDEX.Bsu: ref BsuToCreate\n"
	"        Information about the BSU volume to create.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.DeleteOnVmDeletion: bool\n"
	"          If set to true, the volume is deleted when terminating the VM. If false, \n"
	"          the volume is not deleted when terminating the VM.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.Iops: long long int\n"
	"          The number of I/O operations per second (IOPS). This parameter must be \n"
	"          specified only if you create an `io1` volume. The maximum number of IOPS \n"
	"          allowed for `io1` volumes is `13000` with a maximum performance ratio of \n"
	"          300 IOPS per gibibyte.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.SnapshotId: string\n"
	"          The ID of the snapshot used to create the volume.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.VolumeSize: long long int\n"
	"          The size of the volume, in gibibytes (GiB).\nIf you specify a \n"
	"          snapshot ID, the volume size must be at least equal to the snapshot \n"
	"          size.\nIf you specify a snapshot ID but no volume size, the volume \n"
	"          is created with a size similar to the snapshot one.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.VolumeType: string\n"
	"          The type of the volume (`standard` \\| `io1` \\| `gp2`). If not \n"
	"          specified in the request, a `standard` volume is created.\nFor more \n"
	"          information about volume types, see [About Volumes > Volume Types and \n"
	"          IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_ty\n"
	"          pes_and_iops).\n"
	"    --BlockDeviceMappings.INDEX.DeviceName: string\n"
	"      The device name for the volume. For a root device, you must use \n"
	"      `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, \n"
	"      `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` \n"
	"      and `z`, and the second `X` is a letter between `a` and `z`).\n"
	"    --BlockDeviceMappings.INDEX.VirtualDeviceName: string\n"
	"      The name of the virtual device (`ephemeralN`).\n"
"--BootModes: array string\n"
	"  The boot modes compatible with the OMI.\n"
"--Description: string\n"
	"  A description for the new OMI.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--FileLocation: string\n"
	"  **(required) When registering from a bucket by using a manifest file:** The pre-signed URL \n"
	"  of the manifest file for the OMI you want to register. For more information, see [Creating \n"
	"  a Pre-signed URL](https://docs.outscale.com/en/userguide/Creating-a-Pre-Signed-URL.html).\n"
"--ImageName: string\n"
	"  A unique name for the new OMI.\nConstraints: 3-128 alphanumeric characters, underscores \n"
	"  (`_`), spaces (` `), parentheses (`()`), slashes (`/`), periods (`.`), or dashes (`-`).\n"
"--NoReboot: bool\n"
	"  **When creating from a VM:** If false, the VM shuts down before creating the OMI and then \n"
	"  reboots. If true, the VM does not.\n"
"--ProductCodes: array string\n"
	"  The product codes associated with the OMI.\n"
"--RootDeviceName: string\n"
	"  **(required) When registering from a snapshot:** The name of the root device for the new \n"
	"  OMI.\n"
"--SourceImageId: string\n"
	"  **(required) When copying an OMI:** The ID of the OMI you want to copy.\n"
"--SourceRegionName: string\n"
	"  **(required) When copying an OMI:** The name of the source Region (always the same as the \n"
	"  Region of your account).\n"
"--VmId: string\n"
	"  **(required) When creating from a VM:** The ID of the VM from which you want to create the \n"
	"  OMI.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--KeypairName: string\n"
	"  A unique name for the keypair, with a maximum length of 255 [ASCII printable \n"
	"  characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\n"
"--PublicKey: string\n"
	"  The public key to import in your account, if you are importing an existing keypair. This \n"
	"  value must be Base64-encoded.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Listener: ref LoadBalancerLight\n"
	"    Information about the load balancer.\n"
	"    --Listener.LoadBalancerName: string\n"
	"      The name of the load balancer to which the listener is attached.\n"
	"    --Listener.LoadBalancerPort: long long int\n"
	"      The port of load balancer on which the load balancer is listening \n"
	"      (between `1` and `65535` both included).\n"
"--ListenerRule: ref ListenerRuleForCreation\n"
	"    Information about the listener rule.\n"
	"    --ListenerRule.Action: string\n"
	"      The type of action for the rule (always `forward`).\n"
	"    --ListenerRule.HostNamePattern: string\n"
	"      A host-name pattern for the rule, with a maximum length of 128 \n"
	"      characters. This host-name pattern supports maximum three wildcards, and \n"
	"      must not contain any special characters except `-.?`.\n"
	"    --ListenerRule.ListenerRuleName: string\n"
	"      A human-readable name for the listener rule.\n"
	"    --ListenerRule.PathPattern: string\n"
	"      A path pattern for the rule, with a maximum length of 128 characters. \n"
	"      This path pattern supports maximum three wildcards, and must not contain \n"
	"      any special characters except `_-.$/~\"'@:+?`.\n"
	"    --ListenerRule.Priority: long long int\n"
	"      The priority level of the listener rule, between `1` and `19999` both \n"
	"      included. Each rule must have a unique priority level. Otherwise, an \n"
	"      error is returned.\n"
"--VmIds: array string\n"
	"  The IDs of the backend VMs.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Listeners: array ref ListenerForCreation\n"
	"  One or more listeners for the load balancer.\n"
	"    Information about the listener to create.\n"
	"    --Listeners.INDEX.BackendPort: long long int\n"
	"      The port on which the backend VM is listening (between `1` and `65535`, \n"
	"      both included).\n"
	"    --Listeners.INDEX.BackendProtocol: string\n"
	"      The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| \n"
	"      `TCP` \\| `SSL`).\n"
	"    --Listeners.INDEX.LoadBalancerPort: long long int\n"
	"      The port on which the load balancer is listening (between `1` and \n"
	"      `65535`, both included).\n"
	"    --Listeners.INDEX.LoadBalancerProtocol: string\n"
	"      The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).\n"
	"    --Listeners.INDEX.ServerCertificateId: string\n"
	"      The OUTSCALE Resource Name (ORN) of the server certificate. For more \n"
	"      information, see [Resource Identifiers > OUTSCALE Resource Names \n"
	"      (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_\n"
	"      outscale_resource_names_orns).<br/>\nThis parameter is required for \n"
	"      `HTTPS` and `SSL` protocols.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer for which you want to create listeners.\n"
,
	"--CookieExpirationPeriod: long long int\n"
	"  The lifetime of the cookie, in seconds. If not specified, the default value of this \n"
	"  parameter is `1`, which means that the sticky session lasts for the duration of the browser \n"
	"  session.\n"
"--CookieName: string\n"
	"  The name of the application cookie used for stickiness. This parameter is required if you \n"
	"  create a stickiness policy based on an application-generated cookie.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer for which you want to create a policy.\n"
"--PolicyName: string\n"
	"  The unique name of the policy, with a maximum length of 32 alphanumeric characters and \n"
	"  dashes (`-`).\n"
"--PolicyType: string\n"
	"  The type of stickiness policy you want to create: `app` or `load_balancer`.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Listeners: array ref ListenerForCreation\n"
	"  One or more listeners to create.\n"
	"    Information about the listener to create.\n"
	"    --Listeners.INDEX.BackendPort: long long int\n"
	"      The port on which the backend VM is listening (between `1` and `65535`, \n"
	"      both included).\n"
	"    --Listeners.INDEX.BackendProtocol: string\n"
	"      The protocol for routing traffic to backend VMs (`HTTP` \\| `HTTPS` \\| \n"
	"      `TCP` \\| `SSL`).\n"
	"    --Listeners.INDEX.LoadBalancerPort: long long int\n"
	"      The port on which the load balancer is listening (between `1` and \n"
	"      `65535`, both included).\n"
	"    --Listeners.INDEX.LoadBalancerProtocol: string\n"
	"      The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).\n"
	"    --Listeners.INDEX.ServerCertificateId: string\n"
	"      The OUTSCALE Resource Name (ORN) of the server certificate. For more \n"
	"      information, see [Resource Identifiers > OUTSCALE Resource Names \n"
	"      (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_\n"
	"      outscale_resource_names_orns).<br/>\nThis parameter is required for \n"
	"      `HTTPS` and `SSL` protocols.\n"
"--LoadBalancerName: string\n"
	"  The unique name of the load balancer, with a maximum length of 32 alphanumeric characters \n"
	"  and dashes (`-`). This name must not start or end with a dash.\n"
"--LoadBalancerType: string\n"
	"  The type of load balancer: `internet-facing` or `internal`. Use this parameter only for \n"
	"  load balancers in a Net.\n"
"--PublicIp: string\n"
	"  (internet-facing only) The public IP you want to associate with the load balancer. If not \n"
	"  specified, a public IP owned by 3DS OUTSCALE is associated.\n"
"--SecurityGroups: array string\n"
	"  (Net only) One or more IDs of security groups you want to assign to the load balancer. If \n"
	"  not specified, the default security group of the Net is assigned to the load balancer.\n"
"--Subnets: array string\n"
	"  (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless \n"
	"  of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is \n"
	"  required in a Net.\n"
"--SubregionNames: array string\n"
	"  (public Cloud only) The Subregion in which you want to create the load balancer. Regardless \n"
	"  of this Subregion, the load balancer can distribute traffic to all Subregions. This \n"
	"  parameter is required in the public Cloud.\n"
"--Tags: array ref ResourceTag\n"
	"  One or more tags assigned to the load balancer.\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    --Tags.INDEX.Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerNames: array string\n"
	"  One or more load balancer names.\n"
"--Tags: array ref ResourceTag\n"
	"  One or more tags to add to the specified load balancers.\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    --Tags.INDEX.Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
,
	"--ClientToken: string\n"
	"  A unique identifier which enables you to manage the idempotency.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PublicIpId: string\n"
	"  The allocation ID of the public IP to associate with the NAT service.\nIf the public IP is \n"
	"  already associated with another resource, you must first disassociate it.\n"
"--SubnetId: string\n"
	"  The ID of the Subnet in which you want to create the NAT service.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetId: string\n"
	"  The ID of the Net.\n"
"--RouteTableIds: array string\n"
	"  One or more IDs of route tables to use for the connection.\n"
"--ServiceName: string\n"
	"  The name of the service (in the format `com.outscale.region.service`).\n"
,
	"--AccepterNetId: string\n"
	"  The ID of the Net you want to connect with. <br/ > <br/ >\nIf the Net does not belong to \n"
	"  you, you must also specify the `AccepterOwnerId` parameter with the account ID owning the \n"
	"  Net you want to connect with.\n"
"--AccepterOwnerId: string\n"
	"  The account ID of the owner of the Net you want to connect with. By default, the account ID \n"
	"  of the owner of the Net from which the peering request is sent. <br/ >\nThis parameter is \n"
	"  required if the Net you want to connect with does not belong to you.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--SourceNetId: string\n"
	"  The ID of the Net you send the peering request from.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--IpRange: string\n"
	"  The IP range for the Net, in CIDR notation (for example, `10.0.0.0/16`).\n"
"--Tenancy: string\n"
	"  The tenancy options for the VMs:\n- `default` if a VM created in a Net can be launched with \n"
	"  any tenancy.\n- `dedicated` if it can be launched with dedicated tenancy VMs running on \n"
	"  single-tenant hardware.\n- `dedicated group ID`: if it can be launched in a dedicated group \n"
	"  on single-tenant hardware.\n"
,
	"--Description: string\n"
	"  A description for the NIC.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PrivateIps: array ref PrivateIpLight\n"
	"  The primary private IP for the NIC.\nThis IP must be within the IP range of the Subnet that \n"
	"  you specify with the `SubnetId` attribute.\nIf you do not specify this attribute, a random \n"
	"  private IP is selected within the IP range of the Subnet.\n"
	"    Information about the private IP.\n"
	"    --PrivateIps.INDEX.IsPrimary: bool\n"
	"      If true, the IP is the primary private IP of the NIC.\n"
	"    --PrivateIps.INDEX.PrivateIp: string\n"
	"      The private IP of the NIC.\n"
"--SecurityGroupIds: array string\n"
	"  One or more IDs of security groups for the NIC.\n"
"--SubnetId: string\n"
	"  The ID of the Subnet in which you want to create the NIC.\n"
,
	"--Description: string\n"
	"  A description for the policy.\n"
"--Document: string\n"
	"  The policy document, corresponding to a JSON string that contains the policy. This policy \n"
	"  document can contain a maximum of 5120 non-whitespace characters. For more information, see \n"
	"  [EIM Reference \n"
	"  Information](https://docs.outscale.com/en/userguide/EIM-Reference-Information.html) and \n"
	"  [EIM Policy Generator](https://docs.outscale.com/en/userguide/EIM-Policy-Generator.html).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Path: string\n"
	"  The path of the policy.\n"
"--PolicyName: string\n"
	"  The name of the policy.\n"
,
	"--Document: string\n"
	"  The policy document, corresponding to a JSON string that contains the policy. This policy \n"
	"  document can contain a maximum of 5120 non-whitespace characters. For more information, see \n"
	"  [EIM Reference \n"
	"  Information](https://docs.outscale.com/en/userguide/EIM-Reference-Information.html) and \n"
	"  [EIM Policy Generator](https://docs.outscale.com/en/userguide/EIM-Policy-Generator.html).\n"
"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--SetAsDefault: bool\n"
	"  If set to true, the new policy version is set as the default version and becomes the \n"
	"  operative one.\n"
,
	"--Description: string\n"
	"  The description of the product type.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Vendor: string\n"
	"  The vendor of the product type.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DestinationIpRange: string\n"
	"  The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--GatewayId: string\n"
	"  The ID of an internet service or virtual gateway attached to your Net.\n"
"--NatServiceId: string\n"
	"  The ID of a NAT service.\n"
"--NetPeeringId: string\n"
	"  The ID of a Net peering.\n"
"--NicId: string\n"
	"  The ID of a NIC.\n"
"--RouteTableId: string\n"
	"  The ID of the route table for which you want to create a route.\n"
"--VmId: string\n"
	"  The ID of a NAT VM in your Net (attached to exactly one NIC).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetId: string\n"
	"  The ID of the Net for which you want to create a route table.\n"
,
	"--Description: string\n"
	"  A description for the security group.\nThis description can contain between 1 and 255 \n"
	"  characters. Allowed characters are `a-z`, `A-Z`, `0-9`, accented letters, spaces, and \n"
	"  `_.-:/()#,@[]+=&;{}!$*`.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetId: string\n"
	"  The ID of the Net for the security group.\n"
"--SecurityGroupName: string\n"
	"  The name of the security group.\nThis name must not start with `sg-`.\nThis name must be \n"
	"  unique and contain between 1 and 255 characters. Allowed characters are `a-z`, `A-Z`, \n"
	"  `0-9`, spaces, and `_.-:/()#,@[]+=&;{}!$*`.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Flow: string\n"
	"  The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Nets \n"
	"  only.\n"
"--FromPortRange: long long int\n"
	"  The beginning of the port range for the TCP and UDP protocols, or an ICMP type number. If \n"
	"  you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.\n"
"--IpProtocol: string\n"
	"  The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. \n"
	"  In a Net, this can also be an IP protocol number. For more information, see the [IANA.org \n"
	"  website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). If you \n"
	"  specify this parameter, you cannot specify the `Rules` parameter and its subparameters.\n"
"--IpRange: string\n"
	"  The IP range for the security group rule, in CIDR notation (for example, 10.0.0.0/16). If \n"
	"  you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.\n"
"--Rules: array ref SecurityGroupRule\n"
	"  Information about the security group rule to create. If you specify this parent parameter \n"
	"  and its subparameters, you cannot specify the following parent parameters: `FromPortRange`, \n"
	"  `IpProtocol`, `IpRange`, and `ToPortRange`.\n"
	"    Information about the security group rule.\n"
	"    --Rules.INDEX.FromPortRange: long long int\n"
	"      The beginning of the port range for the TCP and UDP protocols, or an \n"
	"      ICMP type number.\n"
	"    --Rules.INDEX.IpProtocol: string\n"
	"      The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). \n"
	"      By default, `-1`. In a Net, this can also be an IP protocol number. For \n"
	"      more information, see the [IANA.org \n"
	"      website](https://www.iana.org/assignments/protocol-numbers/protocol-number\n"
	"      s.xhtml).\n"
	"    --Rules.INDEX.IpRanges: array string\n"
	"      One or more IP ranges for the security group rules, in CIDR notation \n"
	"      (for example, `10.0.0.0/16`).\n"
	"    --Rules.INDEX.SecurityGroupsMembers: array ref SecurityGroupsMember\n"
	"      Information about one or more source or destination security groups.\n"
	"        Information about a source or destination security group.\n"
	"        --Rules.INDEX.SecurityGroupsMembers.INDEX.AccountId: string\n"
	"          The account ID that owns the source or destination security group.\n"
	"        --Rules.INDEX.SecurityGroupsMembers.INDEX.SecurityGroupId: string\n"
	"          The ID of a source or destination security group that you want to link \n"
	"          to the security group of the rule.\n"
	"        --Rules.INDEX.SecurityGroupsMembers.INDEX.SecurityGroupName: string\n"
	"          (Public Cloud only) The name of a source or destination security group \n"
	"          that you want to link to the security group of the rule.\n"
	"    --Rules.INDEX.ServiceIds: array string\n"
	"      One or more service IDs to allow traffic from a Net to access the \n"
	"      corresponding OUTSCALE services. For more information, see \n"
	"      [ReadNetAccessPointServices](#readnetaccesspointservices).\n"
	"    --Rules.INDEX.ToPortRange: long long int\n"
	"      The end of the port range for the TCP and UDP protocols, or an ICMP code \n"
	"      number.\n"
"--SecurityGroupAccountIdToLink: string\n"
	"  The account ID that owns the source or destination security group specified in the \n"
	"  `SecurityGroupNameToLink` parameter.\n"
"--SecurityGroupId: string\n"
	"  The ID of the security group for which you want to create a rule.\n"
"--SecurityGroupNameToLink: string\n"
	"  The ID of a source or destination security group that you want to link to the security \n"
	"  group of the rule.\n"
"--ToPortRange: long long int\n"
	"  The end of the port range for the TCP and UDP protocols, or an ICMP code number. If you \n"
	"  specify this parameter, you cannot specify the `Rules` parameter and its subparameters.\n"
,
	"--Body: string\n"
	"  The PEM-encoded X509 certificate.With OSC CLI, use the following syntax to make sure your \n"
	"  certificate file is correctly parsed: `--Body=\"$(cat FILENAME)\"`.\n"
"--Chain: string\n"
	"  The PEM-encoded intermediate certification authorities.With OSC CLI, use the following \n"
	"  syntax to make sure your certificate chain file is correctly parsed: `--Chain=\"$(cat \n"
	"  FILENAME)\"`.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Name: string\n"
	"  A unique name for the certificate. Constraints: 1-128 alphanumeric characters, pluses \n"
	"  (`+`), equals (`=`), commas (`,`), periods (`.`), at signs (`@`), minuses (`-`), or \n"
	"  underscores (`_`).\n"
"--Path: string\n"
	"  The path to the server certificate, set to a slash (`/`) if not specified.\n"
"--PrivateKey: string\n"
	"  The PEM-encoded private key matching the certificate.With OSC CLI, use the following syntax \n"
	"  to make sure your key file is correctly parsed: `--PrivateKey=\"$(cat FILENAME)\"`.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--OsuExport: ref OsuExportToCreate\n"
	"    Information about the OOS export task to create.\n"
	"    --OsuExport.DiskImageFormat: string\n"
	"      The format of the export disk (`qcow2` \\| `raw`).\n"
	"    --OsuExport.OsuApiKey: ref OsuApiKey\n"
	"        Information about the OOS API key.\n"
	"        --OsuExport.OsuApiKey.ApiKeyId: string\n"
	"          The API key of the OOS account that enables you to access the bucket.\n"
	"        --OsuExport.OsuApiKey.SecretKey: string\n"
	"          The secret key of the OOS account that enables you to access the bucket.\n"
	"    --OsuExport.OsuBucket: string\n"
	"      The name of the OOS bucket where you want to export the object.\n"
	"    --OsuExport.OsuManifestUrl: string\n"
	"      The URL of the manifest file.\n"
	"    --OsuExport.OsuPrefix: string\n"
	"      The prefix for the key of the OOS object.\n"
"--SnapshotId: string\n"
	"  The ID of the snapshot to export.\n"
,
	"--ClientToken: string\n"
	"  A unique identifier which enables you to manage the idempotency.\n"
"--Description: string\n"
	"  A description for the snapshot.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--FileLocation: string\n"
	"  **(when importing from a bucket)** The pre-signed URL of the snapshot you want to import. \n"
	"  For more information, see [Creating a Pre-signed \n"
	"  URL](https://docs.outscale.com/en/userguide/Creating-a-Pre-Signed-URL.html).\n"
"--SnapshotSize: long long int\n"
	"  **(when importing from a bucket)** The size of the snapshot you want to create in your \n"
	"  account, in bytes. This size must be greater than or equal to the size of the original, \n"
	"  uncompressed snapshot.\n"
"--SourceRegionName: string\n"
	"  **(when copying a snapshot)** The name of the source Region, which must be the same as the \n"
	"  Region of your account.\n"
"--SourceSnapshotId: string\n"
	"  **(when copying a snapshot)** The ID of the snapshot you want to copy.\n"
"--VolumeId: string\n"
	"  **(when creating from a volume)** The ID of the volume you want to create a snapshot of.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--IpRange: string\n"
	"  The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).\nThe IP range of \n"
	"  the Subnet can be either the same as the Net one if you create only a single Subnet in this \n"
	"  Net, or a subset of the Net one. In case of several Subnets in a Net, their IP ranges must \n"
	"  not overlap. The smallest Subnet you can create uses a /29 netmask (eight IPs). For more \n"
	"  information, see [About Nets](https://docs.outscale.com/en/userguide/About-Nets.html).\n"
"--NetId: string\n"
	"  The ID of the Net for which you want to create a Subnet.\n"
"--SubregionName: string\n"
	"  The name of the Subregion in which you want to create the Subnet.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ResourceIds: array string\n"
	"  One or more resource IDs.\n"
"--Tags: array ref ResourceTag\n"
	"  One or more tags to add to the specified resources.\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    --Tags.INDEX.Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Path: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
"--UserGroupName: string\n"
	"  The name of the group.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Path: string\n"
	"  The path to the EIM user you want to create (by default, `/`). This path name must begin \n"
	"  and end with a slash (`/`), and contain between 1 and 512 alphanumeric characters and/or \n"
	"  slashes (`/`), or underscores (`_`).\n"
"--UserEmail: string\n"
	"  The email address of the EIM user.\n"
"--UserName: string\n"
	"  The name of the EIM user. This user name must contain between 1 and 64 alphanumeric \n"
	"  characters and/or pluses (`+`), equals (`=`), commas (`,`), periods (`.`), at signs (`@`), \n"
	"  dashes (`-`), or underscores (`_`).\n"
,
	"--ConnectionType: string\n"
	"  The type of VPN connection supported by the virtual gateway (always `ipsec.1`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--Description: string\n"
	"  A description for the VM group.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PositioningStrategy: string\n"
	"  The positioning strategy of VMs on hypervisors. If set to `no-strategy`, our orchestrator \n"
	"  determines the most adequate position for your VMs. If set to `attract`, your VMs are \n"
	"  deployed on the same hypervisor, which improves network performance. If set to `repulse`, \n"
	"  your VMs are deployed on a different hypervisor, which improves fault tolerance.\n"
"--SecurityGroupIds: array string\n"
	"  One or more IDs of security groups for the VM group.\n"
"--SubnetId: string\n"
	"  The ID of the Subnet in which you want to create the VM group.\n"
"--Tags: array ref ResourceTag\n"
	"  One or more tags to add to the VM group.\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    --Tags.INDEX.Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
"--VmCount: long long int\n"
	"  The number of VMs deployed in the VM group.\n"
"--VmGroupName: string\n"
	"  The name of the VM group.\n"
"--VmTemplateId: string\n"
	"  The ID of the VM template used to launch VMs in the VM group.\n"
,
	"--CpuCores: long long int\n"
	"  The number of vCores to use for each VM.\n"
"--CpuGeneration: string\n"
	"  The processor generation to use for each VM (for example, `v4`).\n"
"--CpuPerformance: string\n"
	"  The performance of the VMs.\n"
"--Description: string\n"
	"  A description for the VM template.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ImageId: string\n"
	"  The ID of the OMI to use for each VM. You can find a list of OMIs by calling the \n"
	"  [ReadImages](#readimages) method.\n"
"--KeypairName: string\n"
	"  The name of the keypair to use for each VM.\n"
"--Ram: long long int\n"
	"  The amount of RAM to use for each VM.\n"
"--Tags: array ref ResourceTag\n"
	"  One or more tags to add to the VM template.\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    --Tags.INDEX.Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
"--VmTemplateName: string\n"
	"  The name of the VM template.\n"
,
	"--ActionsOnNextBoot: ref ActionsOnNextBoot\n"
	"    The action to perform on the next boot of the VM.\n"
	"    --ActionsOnNextBoot.SecureBoot: string\n"
	"        One action to perform on the next boot of the VM. For more information, \n"
	"        see [About Secure \n"
	"        Boot](https://docs.outscale.com/en/userguide/About-Secure-Boot.html#_secur\n"
	"        e_boot_actions).\n"
"--BlockDeviceMappings: array ref BlockDeviceMappingVmCreation\n"
	"  One or more block device mappings.\n"
	"    Information about the block device mapping.\n"
	"    --BlockDeviceMappings.INDEX.Bsu: ref BsuToCreate\n"
	"        Information about the BSU volume to create.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.DeleteOnVmDeletion: bool\n"
	"          If set to true, the volume is deleted when terminating the VM. If false, \n"
	"          the volume is not deleted when terminating the VM.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.Iops: long long int\n"
	"          The number of I/O operations per second (IOPS). This parameter must be \n"
	"          specified only if you create an `io1` volume. The maximum number of IOPS \n"
	"          allowed for `io1` volumes is `13000` with a maximum performance ratio of \n"
	"          300 IOPS per gibibyte.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.SnapshotId: string\n"
	"          The ID of the snapshot used to create the volume.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.VolumeSize: long long int\n"
	"          The size of the volume, in gibibytes (GiB).\nIf you specify a \n"
	"          snapshot ID, the volume size must be at least equal to the snapshot \n"
	"          size.\nIf you specify a snapshot ID but no volume size, the volume \n"
	"          is created with a size similar to the snapshot one.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.VolumeType: string\n"
	"          The type of the volume (`standard` \\| `io1` \\| `gp2`). If not \n"
	"          specified in the request, a `standard` volume is created.\nFor more \n"
	"          information about volume types, see [About Volumes > Volume Types and \n"
	"          IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_ty\n"
	"          pes_and_iops).\n"
	"    --BlockDeviceMappings.INDEX.DeviceName: string\n"
	"      The device name for the volume. For a root device, you must use \n"
	"      `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, \n"
	"      `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` \n"
	"      and `z`, and the second `X` is a letter between `a` and `z`).\n"
	"    --BlockDeviceMappings.INDEX.NoDevice: string\n"
	"      Removes the device which is included in the block device mapping of the \n"
	"      OMI.\n"
	"    --BlockDeviceMappings.INDEX.VirtualDeviceName: string\n"
	"      The name of the virtual device (`ephemeralN`).\n"
"--BootMode: string\n"
	"    Information about the boot mode of the VM.\n"
"--BootOnCreation: bool\n"
	"  If true, the VM is started on creation. If false, the VM is stopped on creation.\n"
"--BsuOptimized: bool\n"
	"  This parameter is not available. It is present in our API for the sake of historical \n"
	"  compatibility with AWS.\n"
"--ClientToken: string\n"
	"  A unique identifier which enables you to manage the idempotency.\n"
"--DeletionProtection: bool\n"
	"  If true, you cannot delete the VM unless you change this parameter back to false.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ImageId: string\n"
	"  The ID of the OMI used to create the VM. You can find the list of OMIs by calling the \n"
	"  [ReadImages](#readimages) method.\n"
"--KeypairName: string\n"
	"  The name of the keypair.\n"
"--MaxVmsCount: long long int\n"
	"  The maximum number of VMs you want to create. If all the VMs cannot be created, the largest \n"
	"  possible number of VMs above MinVmsCount is created.\n"
"--MinVmsCount: long long int\n"
	"  The minimum number of VMs you want to create. If this number of VMs cannot be created, no \n"
	"  VMs are created.\n"
"--NestedVirtualization: bool\n"
	"  (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is \n"
	"  disabled.\n"
"--Nics: array ref NicForVmCreation\n"
	"  One or more NICs. If you specify this parameter, you must not specify the `SubnetId` and \n"
	"  `SubregionName` parameters. You also must define one NIC as the primary network interface \n"
	"  of the VM with `0` as its device number.\n"
	"    Information about the network interface card (NIC) when creating a \n"
	"    virtual machine (VM).\n"
	"    --Nics.INDEX.DeleteOnVmDeletion: bool\n"
	"      If true, the NIC is deleted when the VM is terminated. You can specify \n"
	"      this parameter only for a new NIC. To modify this value for an existing \n"
	"      NIC, see [UpdateNic](#updatenic).\n"
	"    --Nics.INDEX.Description: string\n"
	"      The description of the NIC, if you are creating a NIC when creating the \n"
	"      VM.\n"
	"    --Nics.INDEX.DeviceNumber: long long int\n"
	"      The index of the VM device for the NIC attachment (between `0` and `7`, \n"
	"      both included). This parameter is required if you create a NIC when \n"
	"      creating the VM.\n"
	"    --Nics.INDEX.NicId: string\n"
	"      The ID of the NIC, if you are attaching an existing NIC when creating a \n"
	"      VM.\n"
	"    --Nics.INDEX.PrivateIps: array ref PrivateIpLight\n"
	"      One or more private IPs to assign to the NIC, if you create a NIC when \n"
	"      creating a VM. Only one private IP can be the primary private IP.\n"
	"        Information about the private IP.\n"
	"        --Nics.INDEX.PrivateIps.INDEX.IsPrimary: bool\n"
	"          If true, the IP is the primary private IP of the NIC.\n"
	"        --Nics.INDEX.PrivateIps.INDEX.PrivateIp: string\n"
	"          The private IP of the NIC.\n"
	"    --Nics.INDEX.SecondaryPrivateIpCount: long long int\n"
	"      The number of secondary private IPs, if you create a NIC when creating a \n"
	"      VM. This parameter cannot be specified if you specified more than one \n"
	"      private IP in the `PrivateIps` parameter.\n"
	"    --Nics.INDEX.SecurityGroupIds: array string\n"
	"      One or more IDs of security groups for the NIC, if you create a NIC when \n"
	"      creating a VM.\n"
	"    --Nics.INDEX.SubnetId: string\n"
	"      The ID of the Subnet for the NIC, if you create a NIC when creating a \n"
	"      VM. This parameter is required if you create a NIC when creating the VM.\n"
"--Performance: string\n"
	"  The performance of the VM. This parameter is ignored if you specify a performance flag \n"
	"  directly in the `VmType` parameter.\n"
"--Placement: ref Placement\n"
	"    Information about the placement of the VM.\n"
	"    --Placement.SubregionName: string\n"
	"      The name of the Subregion. If you specify this parameter, you must not \n"
	"      specify the `Nics` parameter.\n"
	"    --Placement.Tenancy: string\n"
	"      The tenancy of the VM (`default`, `dedicated`, or a dedicated group ID).\n"
"--PrivateIps: array string\n"
	"  One or more private IPs of the VM.\n"
"--SecurityGroupIds: array string\n"
	"  One or more IDs of security group for the VMs.\n"
"--SecurityGroups: array string\n"
	"  One or more names of security groups for the VMs.\n"
"--SubnetId: string\n"
	"  The ID of the Subnet in which you want to create the VM. If you specify this parameter, you \n"
	"  must not specify the `Nics` parameter.\n"
"--UserData: string\n"
	"  Data or script used to add a specific configuration to the VM. It must be Base64-encoded \n"
	"  and is limited to 500 kibibytes (KiB). For more information about user data, see \n"
	"  [Configuring a VM with User Data and OUTSCALE \n"
	"  Tags](https://docs.outscale.com/en/userguide/Configuring-a-VM-with-User-Data-and-OUTSCALE-Ta\n"
	"  gs.html).\n"
"--VmInitiatedShutdownBehavior: string\n"
	"  The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the \n"
	"  VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.\n"
"--VmType: string\n"
	"  The type of VM. You can specify a TINA type (in the `tinavW.cXrYpZ` or `tinavW.cXrY` \n"
	"  format), or an AWS type (for example, `t2.small`, which is the default value).\nIf you \n"
	"  specify an AWS type, it is converted in the background to its corresponding TINA type, but \n"
	"  the AWS type is still returned. If the specified or converted TINA type includes a \n"
	"  performance flag, this performance flag is applied regardless of the value you may have \n"
	"  provided in the `Performance` parameter. For more information, see [VM \n"
	"  Types](https://docs.outscale.com/en/userguide/VM-Types.html).\n"
,
	"--ClientToken: string\n"
	"  A unique identifier which enables you to manage the idempotency.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Iops: long long int\n"
	"  The number of I/O operations per second (IOPS). This parameter must be specified only if \n"
	"  you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` \n"
	"  with a maximum performance ratio of 300 IOPS per gibibyte.\n"
"--Size: long long int\n"
	"  The size of the volume, in gibibytes (GiB). The maximum allowed size for a volume is 14901 \n"
	"  GiB. This parameter is required if the volume is not created from a snapshot (`SnapshotId` \n"
	"  unspecified).\n"
"--SnapshotId: string\n"
	"  The ID of the snapshot from which you want to create the volume.\n"
"--SubregionName: string\n"
	"  The Subregion in which you want to create the volume.\n"
"--VolumeType: string\n"
	"  The type of volume you want to create (`io1` \\| `gp2` \\| `standard`). If not specified, a \n"
	"  `standard` volume is created.\nFor more information about volume types, see [About Volumes \n"
	"  > Volume Types and \n"
	"  IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).\n"
,
	"--ClientGatewayId: string\n"
	"  The ID of the client gateway.\n"
"--ConnectionType: string\n"
	"  The type of VPN connection (always `ipsec.1`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--StaticRoutesOnly: bool\n"
	"  By default or if false, the VPN connection uses dynamic routing with Border Gateway \n"
	"  Protocol (BGP). If true, routing is controlled using static routes. For more information \n"
	"  about how to create and delete static routes, see \n"
	"  [CreateVpnConnectionRoute](#createvpnconnectionroute) and \n"
	"  [DeleteVpnConnectionRoute](#deletevpnconnectionroute).\n"
"--VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
,
	"--DestinationIpRange: string\n"
	"  The network prefix of the route, in CIDR notation (for example, `10.12.0.0/16`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VpnConnectionId: string\n"
	"  The ID of the target VPN connection of the static route.\n"
,
	"--AccessKeyId: string\n"
	"  The ID of the access key you want to delete.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--UserName: string\n"
	"  The name of the EIM user the access key you want to delete is associated with. By default, \n"
	"  the user who sends the request (which can be the root account).\n"
,
	"--ApiAccessRuleId: string\n"
	"  The ID of the API access rule you want to delete.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--CaId: string\n"
	"  The ID of the CA you want to delete.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--ClientGatewayId: string\n"
	"  The ID of the client gateway you want to delete.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DedicatedGroupId: string\n"
	"  The ID of the dedicated group you want to delete.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Force: bool\n"
	"  If true, forces the deletion of the dedicated group and all its dependencies.\n"
,
	"--DhcpOptionsSetId: string\n"
	"  The ID of the DHCP options set you want to delete.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DirectLinkInterfaceId: string\n"
	"  The ID of the DirectLink interface you want to delete.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DirectLinkId: string\n"
	"  The ID of the DirectLink you want to delete.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ExportTaskId: string\n"
	"  The ID of the export task to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--FlexibleGpuId: string\n"
	"  The ID of the fGPU you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ImageId: string\n"
	"  The ID of the OMI you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--InternetServiceId: string\n"
	"  The ID of the internet service you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--KeypairId: string\n"
	"  The ID of the keypair you want to delete.\n"
"--KeypairName: string\n"
	"  The name of the keypair you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ListenerRuleName: string\n"
	"  The name of the rule you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer for which you want to delete listeners.\n"
"--LoadBalancerPorts: array integer\n"
	"  One or more port numbers of the listeners you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer for which you want to delete a policy.\n"
"--PolicyName: string\n"
	"  The name of the policy you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerNames: array string\n"
	"  One or more load balancer names.\n"
"--Tags: array ref ResourceLoadBalancerTag\n"
	"  One or more tags to delete from the load balancers.\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, between 1 and 128 characters.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NatServiceId: string\n"
	"  The ID of the NAT service you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetAccessPointId: string\n"
	"  The ID of the Net access point.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetPeeringId: string\n"
	"  The ID of the Net peering you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetId: string\n"
	"  The ID of the Net you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NicId: string\n"
	"  The ID of the NIC you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy you want to delete. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
,
	"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--VersionId: string\n"
	"  The ID of the version of the policy you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Force: bool\n"
	"  If true, forces the deletion of the product type associated with one or more OMIs.\n"
"--ProductTypeId: string\n"
	"  The ID of the product type you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PublicIp: string\n"
	"  The public IP. In the public Cloud, this parameter is required.\n"
"--PublicIpId: string\n"
	"  The ID representing the association of the public IP with the VM or the NIC. In a Net, this \n"
	"  parameter is required.\n"
,
	"--DestinationIpRange: string\n"
	"  The exact IP range for the route.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--RouteTableId: string\n"
	"  The ID of the route table from which you want to delete a route.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--RouteTableId: string\n"
	"  The ID of the route table you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--SecurityGroupId: string\n"
	"  The ID of the security group you want to delete.\n"
"--SecurityGroupName: string\n"
	"  The name of the security group.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Flow: string\n"
	"  The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Nets \n"
	"  only.\n"
"--FromPortRange: long long int\n"
	"  The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.\n"
"--IpProtocol: string\n"
	"  The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. \n"
	"  In a Net, this can also be an IP protocol number. For more information, see the [IANA.org \n"
	"  website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).\n"
"--IpRange: string\n"
	"  The IP range for the security group rule, in CIDR notation (for example, `10.0.0.0/16`).\n"
"--Rules: array ref SecurityGroupRule\n"
	"  One or more rules you want to delete from the security group.\n"
	"    Information about the security group rule.\n"
	"    --Rules.INDEX.FromPortRange: long long int\n"
	"      The beginning of the port range for the TCP and UDP protocols, or an \n"
	"      ICMP type number.\n"
	"    --Rules.INDEX.IpProtocol: string\n"
	"      The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). \n"
	"      By default, `-1`. In a Net, this can also be an IP protocol number. For \n"
	"      more information, see the [IANA.org \n"
	"      website](https://www.iana.org/assignments/protocol-numbers/protocol-number\n"
	"      s.xhtml).\n"
	"    --Rules.INDEX.IpRanges: array string\n"
	"      One or more IP ranges for the security group rules, in CIDR notation \n"
	"      (for example, `10.0.0.0/16`).\n"
	"    --Rules.INDEX.SecurityGroupsMembers: array ref SecurityGroupsMember\n"
	"      Information about one or more source or destination security groups.\n"
	"        Information about a source or destination security group.\n"
	"        --Rules.INDEX.SecurityGroupsMembers.INDEX.AccountId: string\n"
	"          The account ID that owns the source or destination security group.\n"
	"        --Rules.INDEX.SecurityGroupsMembers.INDEX.SecurityGroupId: string\n"
	"          The ID of a source or destination security group that you want to link \n"
	"          to the security group of the rule.\n"
	"        --Rules.INDEX.SecurityGroupsMembers.INDEX.SecurityGroupName: string\n"
	"          (Public Cloud only) The name of a source or destination security group \n"
	"          that you want to link to the security group of the rule.\n"
	"    --Rules.INDEX.ServiceIds: array string\n"
	"      One or more service IDs to allow traffic from a Net to access the \n"
	"      corresponding OUTSCALE services. For more information, see \n"
	"      [ReadNetAccessPointServices](#readnetaccesspointservices).\n"
	"    --Rules.INDEX.ToPortRange: long long int\n"
	"      The end of the port range for the TCP and UDP protocols, or an ICMP code \n"
	"      number.\n"
"--SecurityGroupAccountIdToUnlink: string\n"
	"  The account ID of the owner of the security group you want to delete a rule from.\n"
"--SecurityGroupId: string\n"
	"  The ID of the security group you want to delete a rule from.\n"
"--SecurityGroupNameToUnlink: string\n"
	"  The ID of the source security group. If you are in the Public Cloud, you can also specify \n"
	"  the name of the source security group.\n"
"--ToPortRange: long long int\n"
	"  The end of the port range for the TCP and UDP protocols, or an ICMP code number.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Name: string\n"
	"  The name of the server certificate you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--SnapshotId: string\n"
	"  The ID of the snapshot you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--SubnetId: string\n"
	"  The ID of the Subnet you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ResourceIds: array string\n"
	"  One or more resource IDs.\n"
"--Tags: array ref ResourceTag\n"
	"  One or more tags to delete (if you set a tag value, only the tags matching exactly this \n"
	"  value are deleted).\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    --Tags.INDEX.Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyName: string\n"
	"  The name of the policy document you want to delete.\n"
"--UserGroupName: string\n"
	"  The name of the group.\n"
"--UserGroupPath: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Force: bool\n"
	"  If true, forces the deletion of the user group even if it is not empty.\n"
"--Path: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
"--UserGroupName: string\n"
	"  The name of the group you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyName: string\n"
	"  The name of the policy document you want to delete (between 1 and 128 characters).\n"
"--UserName: string\n"
	"  The name of the user you want to delete the policy from.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--UserName: string\n"
	"  The name of the EIM user you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VirtualGatewayId: string\n"
	"  The ID of the virtual gateway you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmGroupId: string\n"
	"  The ID of the VM group you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmTemplateId: string\n"
	"  The ID of the VM template you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmIds: array string\n"
	"  One or more IDs of VMs.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VolumeId: string\n"
	"  The ID of the volume you want to delete.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VpnConnectionId: string\n"
	"  The ID of the VPN connection you want to delete.\n"
,
	"--DestinationIpRange: string\n"
	"  The network prefix of the route to delete, in CIDR notation (for example, `10.12.0.0/16`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VpnConnectionId: string\n"
	"  The ID of the target VPN connection of the static route to delete.\n"
,
	"--BackendVmIds: array string\n"
	"  One or more IDs of backend VMs.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--UserNames: array string\n"
	"  The usernames of the EIM users you want to disable the Outscale login for.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--UserNames: array string\n"
	"  The usernames of the EIM users you want to enable the Outscale login for.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--FlexibleGpuId: string\n"
	"  The ID of the fGPU you want to attach.\n"
"--VmId: string\n"
	"  The ID of the VM you want to attach the fGPU to.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--InternetServiceId: string\n"
	"  The ID of the internet service you want to attach.\n"
"--NetId: string\n"
	"  The ID of the Net to which you want to attach the internet service.\n"
,
	"--BackendIps: array string\n"
	"  One or more public IPs of backend VMs.\n"
"--BackendVmIds: array string\n"
	"  One or more IDs of backend VMs.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--UserGroupName: string\n"
	"  The name of the group you want to link the policy to.\n"
,
	"--DeviceNumber: long long int\n"
	"  The index of the VM device for the NIC attachment (between `1` and `7`, both included).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NicId: string\n"
	"  The ID of the NIC you want to attach.\n"
"--VmId: string\n"
	"  The ID of the VM to which you want to attach the NIC.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--UserName: string\n"
	"  The name of the user you want to link the policy to (between 1 and 64 characters).\n"
,
	"--AllowRelink: bool\n"
	"  If true, allows an IP that is already assigned to another NIC in the same Subnet to be \n"
	"  assigned to the NIC you specified.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NicId: string\n"
	"  The ID of the NIC.\n"
"--PrivateIps: array string\n"
	"  The secondary private IP or IPs you want to assign to the NIC within the IP range of the \n"
	"  Subnet.\n"
"--SecondaryPrivateIpCount: long long int\n"
	"  The number of secondary private IPs to assign to the NIC.\n"
,
	"--AllowRelink: bool\n"
	"  If true, allows the public IP to be associated with the VM or NIC that you specify even if \n"
	"  it is already associated with another VM or NIC. If false, prevents the public IP from \n"
	"  being associated with the VM or NIC that you specify if it is already associated with \n"
	"  another VM or NIC. (By default, true in the public Cloud, false in a Net.)\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NicId: string\n"
	"  (Net only) The ID of the NIC. This parameter is required if the VM has more than one NIC \n"
	"  attached. Otherwise, you need to specify the `VmId` parameter instead. You cannot specify \n"
	"  both parameters at the same time.\n"
"--PrivateIp: string\n"
	"  (Net only) The primary or secondary private IP of the specified NIC. By default, the \n"
	"  primary private IP.\n"
"--PublicIp: string\n"
	"  The public IP. This parameter is required unless you use the `PublicIpId` parameter.\n"
"--PublicIpId: string\n"
	"  The allocation ID of the public IP. This parameter is required unless you use the \n"
	"  `PublicIp` parameter.\n"
"--VmId: string\n"
	"  The ID of the VM.\n- In the public Cloud, this parameter is required.\n- In a Net, this \n"
	"  parameter is required if the VM has only one NIC. Otherwise, you need to specify the \n"
	"  `NicId` parameter instead. You cannot specify both parameters at the same time.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--RouteTableId: string\n"
	"  The ID of the route table.\n"
"--SubnetId: string\n"
	"  The ID of the Subnet.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetId: string\n"
	"  The ID of the Net to which you want to attach the virtual gateway.\n"
"--VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
,
	"--DeviceName: string\n"
	"  The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you \n"
	"  must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a \n"
	"  letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmId: string\n"
	"  The ID of the VM you want to attach the volume to.\n"
"--VolumeId: string\n"
	"  The ID of the volume you want to attach.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyDocument: string\n"
	"  The policy document, corresponding to a JSON string that contains the policy. For more \n"
	"  information, see [EIM Reference \n"
	"  Information](https://docs.outscale.com/en/userguide/EIM-Reference-Information.html) and \n"
	"  [EIM Policy Generator](https://docs.outscale.com/en/userguide/EIM-Policy-Generator.html).\n"
"--PolicyName: string\n"
	"  The name of the policy.\n"
"--UserGroupName: string\n"
	"  The name of the group.\n"
"--UserGroupPath: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyDocument: string\n"
	"  The policy document, corresponding to a JSON string that contains the policy. For more \n"
	"  information, see [EIM Reference \n"
	"  Information](https://docs.outscale.com/en/userguide/EIM-Reference-Information.html) and \n"
	"  [EIM Policy Generator](https://docs.outscale.com/en/userguide/EIM-Policy-Generator.html).\n"
"--PolicyName: string\n"
	"  The name of the policy (between 1 and 128 characters).\n"
"--UserName: string\n"
	"  The name of the user.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersAccessKeys\n"
	"    One or more filters.\n"
	"    --Filters.AccessKeyIds: array string\n"
	"      The IDs of the access keys.\n"
	"    --Filters.States: array string\n"
	"      The states of the access keys (`ACTIVE` \\| `INACTIVE`).\n"
"--Tag: string\n"
	"  The tag added to the access key.\n"
"--UserName: string\n"
	"  The name of the EIM user. By default, the user who sends the request (which can be the root \n"
	"  account).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmId: string\n"
	"  The ID of the VM.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersApiAccessRule\n"
	"    One or more filters.\n"
	"    --Filters.ApiAccessRuleIds: array string\n"
	"      One or more IDs of API access rules.\n"
	"    --Filters.CaIds: array string\n"
	"      One or more IDs of Client Certificate Authorities (CAs).\n"
	"    --Filters.Cns: array string\n"
	"      One or more Client Certificate Common Names (CNs).\n"
	"    --Filters.Descriptions: array string\n"
	"      One or more descriptions of API access rules.\n"
	"    --Filters.IpRanges: array string\n"
	"      One or more IPs or CIDR blocks (for example, `192.0.2.0/16`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersApiLog\n"
	"    One or more filters.\n"
	"    --Filters.QueryAccessKeys: array string\n"
	"      The access keys used for the logged calls.\n"
	"    --Filters.QueryApiNames: array string\n"
	"      The names of the APIs of the logged calls (always `oapi` for the \n"
	"      OUTSCALE API).\n"
	"    --Filters.QueryCallNames: array string\n"
	"      The names of the logged calls.\n"
	"    --Filters.QueryDateAfter: string\n"
	"      The date and time, or the date, after which you want to retrieve logged \n"
	"      calls, in ISO 8601 format (for example, `2020-06-14T00:00:00.000Z` or \n"
	"      `2020-06-14`). By default, this date is set to 48 hours before the \n"
	"      `QueryDateBefore` parameter value.\n"
	"    --Filters.QueryDateBefore: string\n"
	"      The date and time, or the date, before which you want to retrieve logged \n"
	"      calls, in ISO 8601 format (for example, `2020-06-30T00:00:00.000Z` or \n"
	"      `2020-06-14`). By default, this date is set to now, or 48 hours after the \n"
	"      `QueryDateAfter` parameter value.\n"
	"    --Filters.QueryIpAddresses: array string\n"
	"      The IPs used for the logged calls.\n"
	"    --Filters.QueryUserAgents: array string\n"
	"      The user agents of the HTTP requests of the logged calls.\n"
	"    --Filters.RequestIds: array string\n"
	"      The request IDs provided in the responses of the logged calls.\n"
	"    --Filters.ResponseStatusCodes: array integer\n"
	"      The HTTP status codes of the logged calls.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
"--With: ref With\n"
	"    The information to display in each returned log.\n"
	"    --With.AccountId: bool\n"
	"      If true, the account ID is displayed.\n"
	"    --With.CallDuration: bool\n"
	"      If true, the duration of the call is displayed.\n"
	"    --With.QueryAccessKey: bool\n"
	"      If true, the access key is displayed.\n"
	"    --With.QueryApiName: bool\n"
	"      If true, the name of the API is displayed.\n"
	"    --With.QueryApiVersion: bool\n"
	"      If true, the version of the API is displayed.\n"
	"    --With.QueryCallName: bool\n"
	"      If true, the name of the call is displayed.\n"
	"    --With.QueryDate: bool\n"
	"      If true, the date of the call is displayed.\n"
	"    --With.QueryHeaderRaw: bool\n"
	"      If true, the raw header of the HTTP request is displayed.\n"
	"    --With.QueryHeaderSize: bool\n"
	"      If true, the size of the raw header of the HTTP request is displayed.\n"
	"    --With.QueryIpAddress: bool\n"
	"      If true, the IP is displayed.\n"
	"    --With.QueryPayloadRaw: bool\n"
	"      If true, the raw payload of the HTTP request is displayed.\n"
	"    --With.QueryPayloadSize: bool\n"
	"      If true, the size of the raw payload of the HTTP request is displayed.\n"
	"    --With.QueryUserAgent: bool\n"
	"      If true, the user agent of the HTTP request is displayed.\n"
	"    --With.RequestId: bool\n"
	"      If true, the request ID is displayed.\n"
	"    --With.ResponseSize: bool\n"
	"      If true, the size of the response is displayed.\n"
	"    --With.ResponseStatusCode: bool\n"
	"      If true, the HTTP status code of the response is displayed.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersCa\n"
	"    One or more filters.\n"
	"    --Filters.CaFingerprints: array string\n"
	"      The fingerprints of the CAs.\n"
	"    --Filters.CaIds: array string\n"
	"      The IDs of the CAs.\n"
	"    --Filters.Descriptions: array string\n"
	"      The descriptions of the CAs.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersCatalogs\n"
	"    One or more filters.\n"
	"    --Filters.CurrentCatalogOnly: bool\n"
	"      By default or if set to true, only returns the current catalog. If \n"
	"      false, returns the current catalog and past catalogs.\n"
	"    --Filters.FromDate: string\n"
	"      The beginning of the time period, in ISO 8601 date format (for example, \n"
	"      `2020-06-14`). This date cannot be older than 3 years. You must specify \n"
	"      the parameters `FromDate` and `ToDate` together.\n"
	"    --Filters.ToDate: string\n"
	"      The end of the time period, in ISO 8601 date format (for example, \n"
	"      `2020-06-30`). You must specify the parameters `FromDate` and `ToDate` \n"
	"      together.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersClientGateway\n"
	"    One or more filters.\n"
	"    --Filters.BgpAsns: array integer\n"
	"      The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of \n"
	"      the connections.\n"
	"    --Filters.ClientGatewayIds: array string\n"
	"      The IDs of the client gateways.\n"
	"    --Filters.ConnectionTypes: array string\n"
	"      The types of communication tunnels used by the client gateways (always \n"
	"      `ipsec.1`).\n"
	"    --Filters.PublicIps: array string\n"
	"      The public IPv4 addresses of the client gateways.\n"
	"    --Filters.States: array string\n"
	"      The states of the client gateways (`pending` \\| `available` \\| \n"
	"      `deleting` \\| `deleted`).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the client gateways.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the client gateways.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the client \n"
	"      gateways, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmId: string\n"
	"  The ID of the VM.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--FromDate: string\n"
	"  The beginning of the time period, in ISO 8601 date format (for example, `2020-06-14`). The \n"
	"  date-time format is also accepted, but only with a time set to midnight (for example, \n"
	"  `2020-06-14T00:00:00.000Z`). This value is included in the time period.\n"
"--Overall: bool\n"
	"  If false, returns only the consumption of the specific account that sends this request. If \n"
	"  true, returns either the overall consumption of your paying account and all linked accounts \n"
	"  (if the account that sends this request is a paying account) or returns nothing (if the \n"
	"  account that sends this request is a linked account).\n"
"--ShowPrice: bool\n"
	"  If true, the response also includes the unit price of the consumed resource (`UnitPrice`) \n"
	"  and the total price of the consumed resource during the specified time period (`Price`), in \n"
	"  the currency of your account.\n"
"--ToDate: string\n"
	"  The end of the time period, in ISO 8601 date format (for example, `2020-06-30`). The \n"
	"  date-time format is also accepted, but only with a time set to midnight (for example, \n"
	"  `2020-06-30T00:00:00.000Z`). This value is excluded from the time period, and must be set \n"
	"  to a later date than `FromDate`.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersDedicatedGroup\n"
	"    One or more filters.\n"
	"    --Filters.CpuGenerations: array integer\n"
	"      The processor generation for the VMs in the dedicated group (for \n"
	"      example, `4`).\n"
	"    --Filters.DedicatedGroupIds: array string\n"
	"      The IDs of the dedicated groups.\n"
	"    --Filters.Names: array string\n"
	"      The names of the dedicated groups.\n"
	"    --Filters.SubregionNames: array string\n"
	"      The names of the Subregions in which the dedicated groups are located.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersDhcpOptions\n"
	"    One or more filters.\n"
	"    --Filters.Default: bool\n"
	"      If true, lists all default DHCP options set. If false, lists all \n"
	"      non-default DHCP options set.\n"
	"    --Filters.DhcpOptionsSetIds: array string\n"
	"      The IDs of the DHCP options sets.\n"
	"    --Filters.DomainNameServers: array string\n"
	"      The IPs of the domain name servers used for the DHCP options sets.\n"
	"    --Filters.DomainNames: array string\n"
	"      The domain names used for the DHCP options sets.\n"
	"    --Filters.LogServers: array string\n"
	"      The IPs of the log servers used for the DHCP options sets.\n"
	"    --Filters.NtpServers: array string\n"
	"      The IPs of the Network Time Protocol (NTP) servers used for the DHCP \n"
	"      options sets.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the DHCP options sets.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the DHCP options sets.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the DHCP options \n"
	"      sets, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersDirectLinkInterface\n"
	"    One or more filters.\n"
	"    --Filters.DirectLinkIds: array string\n"
	"      The IDs of the DirectLinks.\n"
	"    --Filters.DirectLinkInterfaceIds: array string\n"
	"      The IDs of the DirectLink interfaces.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersDirectLink\n"
	"    One or more filters.\n"
	"    --Filters.DirectLinkIds: array string\n"
	"      The IDs of the DirectLinks.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--EntitiesType: array string\n"
	"  The type of entity linked to the policy you want to get information about.\n"
"--FirstItem: long long int\n"
	"  The item starting the list of entities requested.\n"
"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of items that can be returned in a single response (by default, 100).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersFlexibleGpu\n"
	"    One or more filters.\n"
	"    --Filters.DeleteOnVmDeletion: bool\n"
	"      Indicates whether the fGPU is deleted when terminating the VM.\n"
	"    --Filters.FlexibleGpuIds: array string\n"
	"      One or more IDs of fGPUs.\n"
	"    --Filters.Generations: array string\n"
	"      The processor generations that the fGPUs are compatible with.\n"
	"    --Filters.ModelNames: array string\n"
	"      One or more models of fGPUs. For more information, see [About Flexible \n"
	"      GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).\n"
	"    --Filters.States: array string\n"
	"      The states of the fGPUs (`allocated` \\| `attaching` \\| `attached` \\| \n"
	"      `detaching`).\n"
	"    --Filters.SubregionNames: array string\n"
	"      The Subregions where the fGPUs are located.\n"
	"    --Filters.VmIds: array string\n"
	"      One or more IDs of VMs.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersExportTask\n"
	"    One or more filters.\n"
	"    --Filters.TaskIds: array string\n"
	"      The IDs of the export tasks.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersImage\n"
	"    One or more filters.\n"
	"    --Filters.AccountAliases: array string\n"
	"      The account aliases of the owners of the OMIs.\n"
	"    --Filters.AccountIds: array string\n"
	"      The account IDs of the owners of the OMIs. By default, all the OMIs for \n"
	"      which you have launch permissions are described.\n"
	"    --Filters.Architectures: array string\n"
	"      The architectures of the OMIs (`i386` \\| `x86_64`).\n"
	"    --Filters.BlockDeviceMappingDeleteOnVmDeletion: bool\n"
	"      Whether the volumes are deleted or not when terminating the VM.\n"
	"    --Filters.BlockDeviceMappingDeviceNames: array string\n"
	"      The device names for the volumes.\n"
	"    --Filters.BlockDeviceMappingSnapshotIds: array string\n"
	"      The IDs of the snapshots used to create the volumes.\n"
	"    --Filters.BlockDeviceMappingVolumeSizes: array integer\n"
	"      The sizes of the volumes, in gibibytes (GiB).\n"
	"    --Filters.BlockDeviceMappingVolumeTypes: array string\n"
	"      The types of volumes (`standard` \\| `gp2` \\| `io1`).\n"
	"    --Filters.BootModes: array string\n"
	"      The boot modes compatible with the OMIs.\n"
	"    --Filters.Descriptions: array string\n"
	"      The descriptions of the OMIs, provided when they were created.\n"
	"    --Filters.FileLocations: array string\n"
	"      The locations of the buckets where the OMI files are stored.\n"
	"    --Filters.Hypervisors: array string\n"
	"      The hypervisor type of the OMI (always `xen`).\n"
	"    --Filters.ImageIds: array string\n"
	"      The IDs of the OMIs.\n"
	"    --Filters.ImageNames: array string\n"
	"      The names of the OMIs, provided when they were created.\n"
	"    --Filters.PermissionsToLaunchAccountIds: array string\n"
	"      The account IDs which have launch permissions for the OMIs.\n"
	"    --Filters.PermissionsToLaunchGlobalPermission: bool\n"
	"      If true, lists all public OMIs. If false, lists all private OMIs.\n"
	"    --Filters.ProductCodeNames: array string\n"
	"      The names of the product codes associated with the OMI.\n"
	"    --Filters.ProductCodes: array string\n"
	"      The product codes associated with the OMI.\n"
	"    --Filters.RootDeviceNames: array string\n"
	"      The name of the root device. This value must be /dev/sda1.\n"
	"    --Filters.RootDeviceTypes: array string\n"
	"      The types of root device used by the OMIs (`bsu` or `ebs`).\n"
	"    --Filters.SecureBoot: bool\n"
	"      Whether secure boot is activated or not.\n"
	"    --Filters.States: array string\n"
	"      The states of the OMIs (`pending` \\| `available` \\| `failed`).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the OMIs.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the OMIs.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the OMIs, in the \n"
	"      following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.VirtualizationTypes: array string\n"
	"      The virtualization types (always `hvm`).\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersInternetService\n"
	"    One or more filters.\n"
	"    --Filters.InternetServiceIds: array string\n"
	"      The IDs of the internet services.\n"
	"    --Filters.LinkNetIds: array string\n"
	"      The IDs of the Nets the internet services are attached to.\n"
	"    --Filters.LinkStates: array string\n"
	"      The current states of the attachments between the internet services and \n"
	"      the Nets (only `available`, if the internet gateway is attached to a \n"
	"      Net).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the internet services.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the internet services.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the internet \n"
	"      services, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersKeypair\n"
	"    One or more filters.\n"
	"    --Filters.KeypairFingerprints: array string\n"
	"      The fingerprints of the keypairs.\n"
	"    --Filters.KeypairIds: array string\n"
	"      The IDs of the keypairs.\n"
	"    --Filters.KeypairNames: array string\n"
	"      The names of the keypairs.\n"
	"    --Filters.KeypairTypes: array string\n"
	"      The types of the keypairs (`ssh-rsa`, `ssh-ed25519`, \n"
	"      `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the keypairs.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the keypairs.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the keypairs, in \n"
	"      the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included). By default, `100`.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref ReadLinkedPoliciesFilters\n"
	"    One or more filters.\n"
	"    --Filters.PathPrefix: string\n"
	"      The path prefix of the policies. If not specified, it is set to a slash \n"
	"      (`/`).\n"
"--FirstItem: long long int\n"
	"  The item starting the list of policies requested.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of items that can be returned in a single response (by default, `100`).\n"
"--UserName: string\n"
	"  The name of the user the policies are linked to.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersListenerRule\n"
	"    One or more filters.\n"
	"    --Filters.ListenerRuleNames: array string\n"
	"      The names of the listener rules.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerNames: array string\n"
	"  One or more load balancer names.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersLoadBalancer\n"
	"    One or more filters.\n"
	"    --Filters.LoadBalancerNames: array string\n"
	"      The names of the load balancers.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersUserGroup\n"
	"    One or more filters.\n"
	"    --Filters.PathPrefix: string\n"
	"      The path prefix of the groups. If not specified, it is set to a slash \n"
	"      (`/`).\n"
	"    --Filters.UserGroupIds: array string\n"
	"      The IDs of the user groups.\n"
"--FirstItem: long long int\n"
	"  The item starting the list of policies requested.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of items that can be returned in a single response (by default, `100`).\n"
"--UserGroupName: string\n"
	"  The name of the group.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersNatService\n"
	"    One or more filters.\n"
	"    --Filters.ClientTokens: array string\n"
	"      The idempotency tokens provided when creating the NAT services.\n"
	"    --Filters.NatServiceIds: array string\n"
	"      The IDs of the NAT services.\n"
	"    --Filters.NetIds: array string\n"
	"      The IDs of the Nets in which the NAT services are.\n"
	"    --Filters.States: array string\n"
	"      The states of the NAT services (`pending` \\| `available` \\| `deleting` \n"
	"      \\| `deleted`).\n"
	"    --Filters.SubnetIds: array string\n"
	"      The IDs of the Subnets in which the NAT services are.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the NAT services.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the NAT services.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the NAT services, \n"
	"      in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersService\n"
	"    One or more filters.\n"
	"    --Filters.ServiceIds: array string\n"
	"      The IDs of the services.\n"
	"    --Filters.ServiceNames: array string\n"
	"      The names of the services.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersNetAccessPoint\n"
	"    One or more filters.\n"
	"    --Filters.NetAccessPointIds: array string\n"
	"      The IDs of the Net access points.\n"
	"    --Filters.NetIds: array string\n"
	"      The IDs of the Nets.\n"
	"    --Filters.ServiceNames: array string\n"
	"      The names of the services. For more information, see \n"
	"      [ReadNetAccessPointServices](#readnetaccesspointservices).\n"
	"    --Filters.States: array string\n"
	"      The states of the Net access points (`pending` \\| `available` \\| \n"
	"      `deleting` \\| `deleted`).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the Net access points.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the Net access points.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the Net access \n"
	"      points, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersNetPeering\n"
	"    One or more filters.\n"
	"    --Filters.AccepterNetAccountIds: array string\n"
	"      The account IDs of the owners of the peer Nets.\n"
	"    --Filters.AccepterNetIpRanges: array string\n"
	"      The IP ranges of the peer Nets, in CIDR notation (for example, \n"
	"      `10.0.0.0/24`).\n"
	"    --Filters.AccepterNetNetIds: array string\n"
	"      The IDs of the peer Nets.\n"
	"    --Filters.ExpirationDates: array string\n"
	"      The dates and times at which the Net peerings expire, in ISO 8601 \n"
	"      date-time format (for example, `2020-06-14T00:00:00.000Z`).\n"
	"    --Filters.NetPeeringIds: array string\n"
	"      The IDs of the Net peerings.\n"
	"    --Filters.SourceNetAccountIds: array string\n"
	"      The account IDs of the owners of the peer Nets.\n"
	"    --Filters.SourceNetIpRanges: array string\n"
	"      The IP ranges of the peer Nets.\n"
	"    --Filters.SourceNetNetIds: array string\n"
	"      The IDs of the peer Nets.\n"
	"    --Filters.StateMessages: array string\n"
	"      Additional information about the states of the Net peerings.\n"
	"    --Filters.StateNames: array string\n"
	"      The states of the Net peerings (`pending-acceptance` \\| `active` \\| \n"
	"      `rejected` \\| `failed` \\| `expired` \\| `deleted`).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the Net peerings.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the Net peerings.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the Net peerings, \n"
	"      in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersNet\n"
	"    One or more filters.\n"
	"    --Filters.DhcpOptionsSetIds: array string\n"
	"      The IDs of the DHCP options sets.\n"
	"    --Filters.IpRanges: array string\n"
	"      The IP ranges for the Nets, in CIDR notation (for example, \n"
	"      `10.0.0.0/16`).\n"
	"    --Filters.IsDefault: bool\n"
	"      If true, the Net used is the default one.\n"
	"    --Filters.NetIds: array string\n"
	"      The IDs of the Nets.\n"
	"    --Filters.States: array string\n"
	"      The states of the Nets (`pending` \\| `available` \\| `deleting`).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the Nets.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the Nets.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the Nets, in the \n"
	"      following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersNic\n"
	"    One or more filters.\n"
	"    --Filters.Descriptions: array string\n"
	"      The descriptions of the NICs.\n"
	"    --Filters.IsSourceDestCheck: bool\n"
	"      Whether the source/destination checking is enabled (true) or disabled \n"
	"      (false).\n"
	"    --Filters.LinkNicDeleteOnVmDeletion: bool\n"
	"      Whether the NICs are deleted when the VMs they are attached to are \n"
	"      terminated.\n"
	"    --Filters.LinkNicDeviceNumbers: array integer\n"
	"      The device numbers the NICs are attached to.\n"
	"    --Filters.LinkNicLinkNicIds: array string\n"
	"      The attachment IDs of the NICs.\n"
	"    --Filters.LinkNicStates: array string\n"
	"      The states of the attachments.\n"
	"    --Filters.LinkNicVmAccountIds: array string\n"
	"      The account IDs of the owners of the VMs the NICs are attached to.\n"
	"    --Filters.LinkNicVmIds: array string\n"
	"      The IDs of the VMs the NICs are attached to.\n"
	"    --Filters.LinkPublicIpAccountIds: array string\n"
	"      The account IDs of the owners of the public IPs associated with the \n"
	"      NICs.\n"
	"    --Filters.LinkPublicIpLinkPublicIpIds: array string\n"
	"      The association IDs returned when the public IPs were associated with \n"
	"      the NICs.\n"
	"    --Filters.LinkPublicIpPublicDnsNames: array string\n"
	"      The public DNS names associated with the public IPs.\n"
	"    --Filters.LinkPublicIpPublicIpIds: array string\n"
	"      The allocation IDs returned when the public IPs were allocated to their \n"
	"      accounts.\n"
	"    --Filters.LinkPublicIpPublicIps: array string\n"
	"      The public IPs associated with the NICs.\n"
	"    --Filters.MacAddresses: array string\n"
	"      The Media Access Control (MAC) addresses of the NICs.\n"
	"    --Filters.NetIds: array string\n"
	"      The IDs of the Nets where the NICs are located.\n"
	"    --Filters.NicIds: array string\n"
	"      The IDs of the NICs.\n"
	"    --Filters.PrivateDnsNames: array string\n"
	"      The private DNS names associated with the primary private IPs.\n"
	"    --Filters.PrivateIpsLinkPublicIpAccountIds: array string\n"
	"      The account IDs of the owner of the public IPs associated with the \n"
	"      private IPs.\n"
	"    --Filters.PrivateIpsLinkPublicIpPublicIps: array string\n"
	"      The public IPs associated with the private IPs.\n"
	"    --Filters.PrivateIpsPrimaryIp: bool\n"
	"      Whether the private IP is the primary IP associated with the NIC.\n"
	"    --Filters.PrivateIpsPrivateIps: array string\n"
	"      The private IPs of the NICs.\n"
	"    --Filters.SecurityGroupIds: array string\n"
	"      The IDs of the security groups associated with the NICs.\n"
	"    --Filters.SecurityGroupNames: array string\n"
	"      The names of the security groups associated with the NICs.\n"
	"    --Filters.States: array string\n"
	"      The states of the NICs.\n"
	"    --Filters.SubnetIds: array string\n"
	"      The IDs of the Subnets for the NICs.\n"
	"    --Filters.SubregionNames: array string\n"
	"      The Subregions where the NICs are located.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the NICs.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the NICs.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the NICs, in the \n"
	"      following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref ReadPoliciesFilters\n"
	"    One or more filters.\n"
	"    --Filters.OnlyLinked: bool\n"
	"      If set to true, lists only the policies attached to a user.\n"
	"    --Filters.PathPrefix: string\n"
	"      The path prefix you can use to filter the results. If not specified, it \n"
	"      is set to a slash (`/`).\n"
	"    --Filters.Scope: string\n"
	"      The scope of the policies. A policy can either be created by Outscale \n"
	"      (`OWS`), and therefore applies to all accounts, or be created by its \n"
	"      users (`LOCAL`).\n"
"--FirstItem: long long int\n"
	"  The item starting the list of policies requested.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of items that can be returned in a single response (by default, `100`).\n"
,
	"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
,
	"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--VersionId: string\n"
	"  The ID of the policy version.\n"
,
	"--FirstItem: long long int\n"
	"  The item starting the list of policies requested.\n"
"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of items that can be returned in a single response (by default, `100`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersProductType\n"
	"    One or more filters.\n"
	"    --Filters.ProductTypeIds: array string\n"
	"      The IDs of the product types.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersPublicIp\n"
	"    One or more filters.\n"
	"    --Filters.LinkPublicIpIds: array string\n"
	"      The IDs representing the associations of public IPs with VMs or NICs.\n"
	"    --Filters.NicAccountIds: array string\n"
	"      The account IDs of the owners of the NICs.\n"
	"    --Filters.NicIds: array string\n"
	"      The IDs of the NICs.\n"
	"    --Filters.Placements: array string\n"
	"      Whether the public IPs are for use in the public Cloud or in a Net.\n"
	"    --Filters.PrivateIps: array string\n"
	"      The private IPs associated with the public IPs.\n"
	"    --Filters.PublicIpIds: array string\n"
	"      The IDs of the public IPs.\n"
	"    --Filters.PublicIps: array string\n"
	"      The public IPs.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the public IPs.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the public IPs.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the public IPs, in \n"
	"      the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.VmIds: array string\n"
	"      The IDs of the VMs.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersQuota\n"
	"    One or more filters.\n"
	"    --Filters.Collections: array string\n"
	"      The group names of the quotas.\n"
	"    --Filters.QuotaNames: array string\n"
	"      The names of the quotas.\n"
	"    --Filters.QuotaTypes: array string\n"
	"      The resource IDs if these are resource-specific quotas, `global` if they \n"
	"      are not.\n"
	"    --Filters.ShortDescriptions: array string\n"
	"      The description of the quotas.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersRouteTable\n"
	"    One or more filters.\n"
	"    --Filters.LinkRouteTableIds: array string\n"
	"      The IDs of the route tables involved in the associations.\n"
	"    --Filters.LinkRouteTableLinkRouteTableIds: array string\n"
	"      The IDs of the associations between the route tables and the Subnets.\n"
	"    --Filters.LinkRouteTableMain: bool\n"
	"      If true, the route tables are the main ones for their Nets.\n"
	"    --Filters.LinkSubnetIds: array string\n"
	"      The IDs of the Subnets involved in the associations.\n"
	"    --Filters.NetIds: array string\n"
	"      The IDs of the Nets for the route tables.\n"
	"    --Filters.RouteCreationMethods: array string\n"
	"      The methods used to create a route.\n"
	"    --Filters.RouteDestinationIpRanges: array string\n"
	"      The IP ranges specified in routes in the tables.\n"
	"    --Filters.RouteDestinationServiceIds: array string\n"
	"      The service IDs specified in routes in the tables.\n"
	"    --Filters.RouteGatewayIds: array string\n"
	"      The IDs of the gateways specified in routes in the tables.\n"
	"    --Filters.RouteNatServiceIds: array string\n"
	"      The IDs of the NAT services specified in routes in the tables.\n"
	"    --Filters.RouteNetPeeringIds: array string\n"
	"      The IDs of the Net peerings specified in routes in the tables.\n"
	"    --Filters.RouteStates: array string\n"
	"      The states of routes in the route tables (always `active`).\n"
	"    --Filters.RouteTableIds: array string\n"
	"      The IDs of the route tables.\n"
	"    --Filters.RouteVmIds: array string\n"
	"      The IDs of the VMs specified in routes in the tables.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the route tables.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the route tables.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the route tables, \n"
	"      in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersSecurityGroup\n"
	"    One or more filters.\n"
	"    --Filters.Descriptions: array string\n"
	"      The descriptions of the security groups.\n"
	"    --Filters.InboundRuleAccountIds: array string\n"
	"      The account IDs that have been granted permissions.\n"
	"    --Filters.InboundRuleFromPortRanges: array integer\n"
	"      The beginnings of the port ranges for the TCP and UDP protocols, or the \n"
	"      ICMP type numbers.\n"
	"    --Filters.InboundRuleIpRanges: array string\n"
	"      The IP ranges that have been granted permissions, in CIDR notation (for \n"
	"      example, `10.0.0.0/24`).\n"
	"    --Filters.InboundRuleProtocols: array string\n"
	"      The IP protocols for the permissions (`tcp` \\| `udp` \\| `icmp`, or a \n"
	"      protocol number, or `-1` for all protocols).\n"
	"    --Filters.InboundRuleSecurityGroupIds: array string\n"
	"      The IDs of the security groups that have been granted permissions.\n"
	"    --Filters.InboundRuleSecurityGroupNames: array string\n"
	"      The names of the security groups that have been granted permissions.\n"
	"    --Filters.InboundRuleToPortRanges: array integer\n"
	"      The ends of the port ranges for the TCP and UDP protocols, or the ICMP \n"
	"      code numbers.\n"
	"    --Filters.NetIds: array string\n"
	"      The IDs of the Nets specified when the security groups were created.\n"
	"    --Filters.OutboundRuleAccountIds: array string\n"
	"      The account IDs that have been granted permissions.\n"
	"    --Filters.OutboundRuleFromPortRanges: array integer\n"
	"      The beginnings of the port ranges for the TCP and UDP protocols, or the \n"
	"      ICMP type numbers.\n"
	"    --Filters.OutboundRuleIpRanges: array string\n"
	"      The IP ranges that have been granted permissions, in CIDR notation (for \n"
	"      example, `10.0.0.0/24`).\n"
	"    --Filters.OutboundRuleProtocols: array string\n"
	"      The IP protocols for the permissions (`tcp` \\| `udp` \\| `icmp`, or a \n"
	"      protocol number, or `-1` for all protocols).\n"
	"    --Filters.OutboundRuleSecurityGroupIds: array string\n"
	"      The IDs of the security groups that have been granted permissions.\n"
	"    --Filters.OutboundRuleSecurityGroupNames: array string\n"
	"      The names of the security groups that have been granted permissions.\n"
	"    --Filters.OutboundRuleToPortRanges: array integer\n"
	"      The ends of the port ranges for the TCP and UDP protocols, or the ICMP \n"
	"      code numbers.\n"
	"    --Filters.SecurityGroupIds: array string\n"
	"      The IDs of the security groups.\n"
	"    --Filters.SecurityGroupNames: array string\n"
	"      The names of the security groups.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the security groups.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the security groups.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the security \n"
	"      groups, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersServerCertificate\n"
	"    One or more filters.\n"
	"    --Filters.Paths: array string\n"
	"      The paths to the server certificates.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersExportTask\n"
	"    One or more filters.\n"
	"    --Filters.TaskIds: array string\n"
	"      The IDs of the export tasks.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersSnapshot\n"
	"    One or more filters.\n"
	"    --Filters.AccountAliases: array string\n"
	"      The account aliases of the owners of the snapshots.\n"
	"    --Filters.AccountIds: array string\n"
	"      The account IDs of the owners of the snapshots.\n"
	"    --Filters.ClientTokens: array string\n"
	"      The idempotency tokens provided when creating the snapshots.\n"
	"    --Filters.Descriptions: array string\n"
	"      The descriptions of the snapshots.\n"
	"    --Filters.FromCreationDate: string\n"
	"      The beginning of the time period, in ISO 8601 date-time format (for \n"
	"      example, `2020-06-14T00:00:00.000Z`).\n"
	"    --Filters.PermissionsToCreateVolumeAccountIds: array string\n"
	"      The account IDs which have permissions to create volumes.\n"
	"    --Filters.PermissionsToCreateVolumeGlobalPermission: bool\n"
	"      If true, lists all public volumes. If false, lists all private volumes.\n"
	"    --Filters.Progresses: array integer\n"
	"      The progresses of the snapshots, as a percentage.\n"
	"    --Filters.SnapshotIds: array string\n"
	"      The IDs of the snapshots.\n"
	"    --Filters.States: array string\n"
	"      The states of the snapshots (`in-queue` \\| `pending` \\| `completed` \n"
	"      \\| `error` \\| `deleting`).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the snapshots.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the snapshots.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the snapshots, in \n"
	"      the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.ToCreationDate: string\n"
	"      The end of the time period, in ISO 8601 date-time format (for example, \n"
	"      `2020-06-30T00:00:00.000Z`).\n"
	"    --Filters.VolumeIds: array string\n"
	"      The IDs of the volumes used to create the snapshots.\n"
	"    --Filters.VolumeSizes: array integer\n"
	"      The sizes of the volumes used to create the snapshots, in gibibytes \n"
	"      (GiB).\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersSubnet\n"
	"    One or more filters.\n"
	"    --Filters.AvailableIpsCounts: array integer\n"
	"      The number of available IPs.\n"
	"    --Filters.IpRanges: array string\n"
	"      The IP ranges in the Subnets, in CIDR notation (for example, \n"
	"      `10.0.0.0/16`).\n"
	"    --Filters.NetIds: array string\n"
	"      The IDs of the Nets in which the Subnets are.\n"
	"    --Filters.States: array string\n"
	"      The states of the Subnets (`pending` \\| `available` \\| `deleted`).\n"
	"    --Filters.SubnetIds: array string\n"
	"      The IDs of the Subnets.\n"
	"    --Filters.SubregionNames: array string\n"
	"      The names of the Subregions in which the Subnets are located.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the Subnets.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the Subnets.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the Subnets, in \n"
	"      the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersSubregion\n"
	"    One or more filters.\n"
	"    --Filters.RegionNames: array string\n"
	"      The names of the Regions containing the Subregions.\n"
	"    --Filters.States: array string\n"
	"      The states of the Subregions.\n"
	"    --Filters.SubregionNames: array string\n"
	"      The names of the Subregions.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersTag\n"
	"    One or more filters.\n"
	"    --Filters.Keys: array string\n"
	"      The keys of the tags that are assigned to the resources. You can use \n"
	"      this filter alongside the `Values` filter. In that case, you filter the \n"
	"      resources corresponding to each tag, regardless of the other filter.\n"
	"    --Filters.ResourceIds: array string\n"
	"      The IDs of the resources with which the tags are associated.\n"
	"    --Filters.ResourceTypes: array string\n"
	"      The resource type (`customer-gateway` \\| `dhcpoptions` \\| `image` \\| \n"
	"      `instance` \\| `keypair` \\| `natgateway` \\| `network-interface` \\| \n"
	"      `public-ip` \\| `route-table` \\| `security-group` \\| `snapshot` \\| \n"
	"      `subnet` \\| `task` \\| `virtual-private-gateway` \\| `volume` \\| `vpc` \n"
	"      \\| `vpc-endpoint` \\| `vpc-peering-connection`\\| `vpn-connection`).\n"
	"    --Filters.Values: array string\n"
	"      The values of the tags that are assigned to the resources. You can use \n"
	"      this filter alongside the `TagKeys` filter. In that case, you filter the \n"
	"      resources corresponding to each tag, regardless of the other filter.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--Operation: string\n"
	"  The operation associated with the catalog entry (for example, `RunInstances-OD` or \n"
	"  `CreateVolume`).\n"
"--Service: string\n"
	"  The service associated with the catalog entry (for example, `TinaOS-FCU` or `TinaOS-OOS`).\n"
"--Type: string\n"
	"  The type associated with the catalog entry (for example, `BSU:VolumeIOPS:io1` or \n"
	"  `BoxUsage:tinav6.c6r16p3`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--FirstItem: long long int\n"
	"  The item starting the list of policies requested.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of items that can be returned in a single response (by default, `100`).\n"
"--UserGroupName: string\n"
	"  The name of the group.\n"
"--UserGroupPath: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyName: string\n"
	"  The name of the policy.\n"
"--UserGroupName: string\n"
	"  The name of the group.\n"
"--UserGroupPath: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Path: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
"--UserGroupName: string\n"
	"  The name of the group.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--UserName: string\n"
	"  The name of the user.\n"
"--UserPath: string\n"
	"  The path to the user (by default, `/`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersUserGroup\n"
	"    One or more filters.\n"
	"    --Filters.PathPrefix: string\n"
	"      The path prefix of the groups. If not specified, it is set to a slash \n"
	"      (`/`).\n"
	"    --Filters.UserGroupIds: array string\n"
	"      The IDs of the user groups.\n"
"--FirstItem: long long int\n"
	"  The item starting the list of groups requested.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of items that can be returned in a single response (by default, `100`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--UserName: string\n"
	"  The name of the user.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyName: string\n"
	"  The name of the policy.\n"
"--UserName: string\n"
	"  The name of the user.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersUsers\n"
	"    One or more filters.\n"
	"    --Filters.UserIds: array string\n"
	"      The IDs of the users.\n"
"--FirstItem: long long int\n"
	"  The item starting the list of users requested.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of items that can be returned in a single response (by default, `100`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersVirtualGateway\n"
	"    One or more filters.\n"
	"    --Filters.ConnectionTypes: array string\n"
	"      The types of the virtual gateways (always `ipsec.1`).\n"
	"    --Filters.LinkNetIds: array string\n"
	"      The IDs of the Nets the virtual gateways are attached to.\n"
	"    --Filters.LinkStates: array string\n"
	"      The current states of the attachments between the virtual gateways and \n"
	"      the Nets (`attaching` \\| `attached` \\| `detaching` \\| `detached`).\n"
	"    --Filters.States: array string\n"
	"      The states of the virtual gateways (`pending` \\| `available` \\| \n"
	"      `deleting` \\| `deleted`).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the virtual gateways.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the virtual gateways.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the virtual \n"
	"      gateways, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.VirtualGatewayIds: array string\n"
	"      The IDs of the virtual gateways.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersVmGroup\n"
	"    One or more filters.\n"
	"    --Filters.Descriptions: array string\n"
	"      The descriptions of the VM groups.\n"
	"    --Filters.SecurityGroupIds: array string\n"
	"      The IDs of the security groups.\n"
	"    --Filters.SubnetIds: array string\n"
	"      The IDs of the Subnets.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the VM groups.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the VM groups.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the VMs, in the \n"
	"      following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.VmCounts: array integer\n"
	"      The number of VMs in the VM group.\n"
	"    --Filters.VmGroupIds: array string\n"
	"      The IDs of the VM groups.\n"
	"    --Filters.VmGroupNames: array string\n"
	"      The names of the VM groups.\n"
	"    --Filters.VmTemplateIds: array string\n"
	"      The IDs of the VM templates.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersVmTemplate\n"
	"    One or more filters.\n"
	"    --Filters.CpuCores: array integer\n"
	"      The number of vCores.\n"
	"    --Filters.CpuGenerations: array string\n"
	"      The processor generations (for example, `v4`).\n"
	"    --Filters.CpuPerformances: array string\n"
	"      The performances of the VMs.\n"
	"    --Filters.Descriptions: array string\n"
	"      The descriptions of the VM templates.\n"
	"    --Filters.ImageIds: array string\n"
	"      The IDs of the OMIs.\n"
	"    --Filters.KeypairNames: array string\n"
	"      The names of the keypairs.\n"
	"    --Filters.Rams: array integer\n"
	"      The amount of RAM.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the VM templates.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the VM templates.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the VM templates, \n"
	"      in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.VmTemplateIds: array string\n"
	"      The IDs of the VM templates.\n"
	"    --Filters.VmTemplateNames: array string\n"
	"      The names of the VM templates.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersVmType\n"
	"    One or more filters.\n"
	"    --Filters.BsuOptimized: bool\n"
	"      This parameter is not available. It is present in our API for the sake \n"
	"      of historical compatibility with AWS.\n"
	"    --Filters.EphemeralsTypes: array string\n"
	"      The types of ephemeral storage disk.\n"
	"    --Filters.Eths: array integer\n"
	"      The number of Ethernet interfaces available.\n"
	"    --Filters.Gpus: array integer\n"
	"      The number of GPUs available.\n"
	"    --Filters.MemorySizes: array double\n"
	"      The amounts of memory, in gibibytes (GiB).\n"
	"    --Filters.VcoreCounts: array integer\n"
	"      The numbers of vCores.\n"
	"    --Filters.VmTypeNames: array string\n"
	"      The names of the VM types. For more information, see [VM \n"
	"      Types](https://docs.outscale.com/en/userguide/VM-Types.html).\n"
	"    --Filters.VolumeCounts: array integer\n"
	"      The maximum number of ephemeral storage disks.\n"
	"    --Filters.VolumeSizes: array integer\n"
	"      The size of one ephemeral storage disk, in gibibytes (GiB).\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--BackendVmIds: array string\n"
	"  One or more IDs of backend VMs.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersVm\n"
	"    One or more filters.\n"
	"    --Filters.Architectures: array string\n"
	"      The architectures of the VMs (`i386` \\| `x86_64`).\n"
	"    --Filters.BlockDeviceMappingDeleteOnVmDeletion: bool\n"
	"      Whether the BSU volumes are deleted when terminating the VMs.\n"
	"    --Filters.BlockDeviceMappingDeviceNames: array string\n"
	"      The device names for the BSU volumes (in the format `/dev/sdX`, \n"
	"      `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX`).\n"
	"    --Filters.BlockDeviceMappingLinkDates: array string\n"
	"      The link dates for the BSU volumes mapped to the VMs (for example, \n"
	"      `2016-01-23T18:45:30.000Z`).\n"
	"    --Filters.BlockDeviceMappingStates: array string\n"
	"      The states for the BSU volumes (`attaching` \\| `attached` \\| \n"
	"      `detaching` \\| `detached`).\n"
	"    --Filters.BlockDeviceMappingVolumeIds: array string\n"
	"      The volume IDs of the BSU volumes.\n"
	"    --Filters.BootModes: array string\n"
	"      The boot modes of the VMs.\n"
	"    --Filters.ClientTokens: array string\n"
	"      The idempotency tokens provided when launching the VMs.\n"
	"    --Filters.CreationDates: array string\n"
	"      The dates when the VMs were launched.\n"
	"    --Filters.ImageIds: array string\n"
	"      The IDs of the OMIs used to launch the VMs.\n"
	"    --Filters.IsSourceDestChecked: bool\n"
	"      Whether the source/destination checking is enabled (true) or disabled \n"
	"      (false).\n"
	"    --Filters.KeypairNames: array string\n"
	"      The names of the keypairs used when launching the VMs.\n"
	"    --Filters.LaunchNumbers: array integer\n"
	"      The numbers for the VMs when launching a group of several VMs (for \n"
	"      example, `0`, `1`, `2`, and so on).\n"
	"    --Filters.Lifecycles: array string\n"
	"      Whether the VMs are Spot Instances (spot).\n"
	"    --Filters.NetIds: array string\n"
	"      The IDs of the Nets in which the VMs are running.\n"
	"    --Filters.NicAccountIds: array string\n"
	"      The IDs of the NICs.\n"
	"    --Filters.NicDescriptions: array string\n"
	"      The descriptions of the NICs.\n"
	"    --Filters.NicIsSourceDestChecked: bool\n"
	"      Whether the source/destination checking is enabled (true) or disabled \n"
	"      (false).\n"
	"    --Filters.NicLinkNicDeleteOnVmDeletion: bool\n"
	"      Whether the NICs are deleted when the VMs they are attached to are \n"
	"      deleted.\n"
	"    --Filters.NicLinkNicDeviceNumbers: array integer\n"
	"      The device numbers the NICs are attached to.\n"
	"    --Filters.NicLinkNicLinkNicDates: array string\n"
	"      The dates and times (UTC) when the NICs were attached to the VMs.\n"
	"    --Filters.NicLinkNicLinkNicIds: array string\n"
	"      The IDs of the NIC attachments.\n"
	"    --Filters.NicLinkNicStates: array string\n"
	"      The states of the attachments.\n"
	"    --Filters.NicLinkNicVmAccountIds: array string\n"
	"      The account IDs of the owners of the VMs the NICs are attached to.\n"
	"    --Filters.NicLinkNicVmIds: array string\n"
	"      The IDs of the VMs the NICs are attached to.\n"
	"    --Filters.NicLinkPublicIpAccountIds: array string\n"
	"      The account IDs of the owners of the public IPs associated with the \n"
	"      NICs.\n"
	"    --Filters.NicLinkPublicIpLinkPublicIpIds: array string\n"
	"      The association IDs returned when the public IPs were associated with \n"
	"      the NICs.\n"
	"    --Filters.NicLinkPublicIpPublicIpIds: array string\n"
	"      The allocation IDs returned when the public IPs were allocated to their \n"
	"      accounts.\n"
	"    --Filters.NicLinkPublicIpPublicIps: array string\n"
	"      The public IPs associated with the NICs.\n"
	"    --Filters.NicMacAddresses: array string\n"
	"      The Media Access Control (MAC) addresses of the NICs.\n"
	"    --Filters.NicNetIds: array string\n"
	"      The IDs of the Nets where the NICs are located.\n"
	"    --Filters.NicNicIds: array string\n"
	"      The IDs of the NICs.\n"
	"    --Filters.NicPrivateIpsLinkPublicIpAccountIds: array string\n"
	"      The account IDs of the owner of the public IPs associated with the \n"
	"      private IPs.\n"
	"    --Filters.NicPrivateIpsLinkPublicIpIds: array string\n"
	"      The public IPs associated with the private IPs.\n"
	"    --Filters.NicPrivateIpsPrimaryIp: bool\n"
	"      Whether the private IPs are the primary IPs associated with the NICs.\n"
	"    --Filters.NicPrivateIpsPrivateIps: array string\n"
	"      The private IPs of the NICs.\n"
	"    --Filters.NicSecurityGroupIds: array string\n"
	"      The IDs of the security groups associated with the NICs.\n"
	"    --Filters.NicSecurityGroupNames: array string\n"
	"      The names of the security groups associated with the NICs.\n"
	"    --Filters.NicStates: array string\n"
	"      The states of the NICs (`available` \\| `in-use`).\n"
	"    --Filters.NicSubnetIds: array string\n"
	"      The IDs of the Subnets for the NICs.\n"
	"    --Filters.NicSubregionNames: array string\n"
	"      The Subregions where the NICs are located.\n"
	"    --Filters.Platforms: array string\n"
	"      The platforms. Use windows if you have Windows VMs. Otherwise, leave \n"
	"      this filter blank.\n"
	"    --Filters.PrivateIps: array string\n"
	"      The private IPs of the VMs.\n"
	"    --Filters.ProductCodes: array string\n"
	"      The product codes associated with the OMI used to create the VMs.\n"
	"    --Filters.PublicIps: array string\n"
	"      The public IPs of the VMs.\n"
	"    --Filters.ReservationIds: array string\n"
	"      The IDs of the reservation of the VMs, created every time you launch \n"
	"      VMs. These reservation IDs can be associated with several VMs when you \n"
	"      launch a group of VMs using the same launch request.\n"
	"    --Filters.RootDeviceNames: array string\n"
	"      The names of the root devices for the VMs (for example, `/dev/sda1`)\n"
	"    --Filters.RootDeviceTypes: array string\n"
	"      The root devices types used by the VMs (always `ebs`)\n"
	"    --Filters.SecurityGroupIds: array string\n"
	"      The IDs of the security groups for the VMs (only in the public Cloud).\n"
	"    --Filters.SecurityGroupNames: array string\n"
	"      The names of the security groups for the VMs (only in the public Cloud).\n"
	"    --Filters.StateReasonCodes: array integer\n"
	"      The reason codes for the state changes.\n"
	"    --Filters.StateReasonMessages: array string\n"
	"      The messages describing the state changes.\n"
	"    --Filters.StateReasons: array string\n"
	"      The reasons explaining the current states of the VMs. This filter is \n"
	"      like the `StateReasonCodes` one.\n"
	"    --Filters.SubnetIds: array string\n"
	"      The IDs of the Subnets for the VMs.\n"
	"    --Filters.SubregionNames: array string\n"
	"      The names of the Subregions of the VMs.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the VMs.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the VMs.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the VMs, in the \n"
	"      following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.Tenancies: array string\n"
	"      The tenancies of the VMs (`dedicated` \\| `default` \\| `host`).\n"
	"    --Filters.VmIds: array string\n"
	"      One or more IDs of VMs.\n"
	"    --Filters.VmSecurityGroupIds: array string\n"
	"      The IDs of the security groups for the VMs.\n"
	"    --Filters.VmSecurityGroupNames: array string\n"
	"      The names of the security group for the VMs.\n"
	"    --Filters.VmStateCodes: array integer\n"
	"      The state codes of the VMs: `-1` (quarantine), `0` (pending), `16` \n"
	"      (running), `32` (shutting-down), `48` (terminated), `64` (stopping), and \n"
	"      `80` (stopped).\n"
	"    --Filters.VmStateNames: array string\n"
	"      The state names of the VMs (`pending` \\| `running` \\| `stopping` \\| \n"
	"      `stopped` \\| `shutting-down` \\| `terminated` \\| `quarantine`).\n"
	"    --Filters.VmTypes: array string\n"
	"      The VM types (for example, t2.micro). For more information, see [VM \n"
	"      Types](https://docs.outscale.com/en/userguide/VM-Types.html).\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--AllVms: bool\n"
	"  If true, includes the status of all VMs. If false, only includes the status of running VMs.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersVmsState\n"
	"    One or more filters.\n"
	"    --Filters.MaintenanceEventCodes: array string\n"
	"      The code for the scheduled event (`system-reboot` \\| \n"
	"      `system-maintenance`).\n"
	"    --Filters.MaintenanceEventDescriptions: array string\n"
	"      The description of the scheduled event.\n"
	"    --Filters.MaintenanceEventsNotAfter: array string\n"
	"      The latest date and time (UTC) the event can end.\n"
	"    --Filters.MaintenanceEventsNotBefore: array string\n"
	"      The earliest date and time (UTC) the event can start.\n"
	"    --Filters.SubregionNames: array string\n"
	"      The names of the Subregions of the VMs.\n"
	"    --Filters.VmIds: array string\n"
	"      One or more IDs of VMs.\n"
	"    --Filters.VmStates: array string\n"
	"      The states of the VMs (`pending` \\| `running` \\| `stopping` \\| \n"
	"      `stopped` \\| `shutting-down` \\| `terminated` \\| `quarantine`).\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersVolume\n"
	"    One or more filters.\n"
	"    --Filters.ClientTokens: array string\n"
	"      The idempotency tokens provided when creating the volumes.\n"
	"    --Filters.CreationDates: array string\n"
	"      The dates and times at which the volumes were created, in ISO 8601 \n"
	"      date-time format (for example, `2020-06-30T00:00:00.000Z`).\n"
	"    --Filters.LinkVolumeDeleteOnVmDeletion: bool\n"
	"      Whether the volumes are deleted or not when terminating the VMs.\n"
	"    --Filters.LinkVolumeDeviceNames: array string\n"
	"      The VM device names.\n"
	"    --Filters.LinkVolumeLinkDates: array string\n"
	"      The dates and times at which the volumes were attached, in ISO 8601 \n"
	"      date-time format (for example, `2020-06-30T00:00:00.000Z`).\n"
	"    --Filters.LinkVolumeLinkStates: array string\n"
	"      The attachment states of the volumes (`attaching` \\| `detaching` \\| \n"
	"      `attached` \\| `detached`).\n"
	"    --Filters.LinkVolumeVmIds: array string\n"
	"      One or more IDs of VMs.\n"
	"    --Filters.SnapshotIds: array string\n"
	"      The snapshots from which the volumes were created.\n"
	"    --Filters.SubregionNames: array string\n"
	"      The names of the Subregions in which the volumes were created.\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the volumes.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the volumes.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the volumes, in \n"
	"      the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.VolumeIds: array string\n"
	"      The IDs of the volumes.\n"
	"    --Filters.VolumeSizes: array integer\n"
	"      The sizes of the volumes, in gibibytes (GiB).\n"
	"    --Filters.VolumeStates: array string\n"
	"      The states of the volumes (`creating` \\| `available` \\| `in-use` \\| \n"
	"      `deleting` \\| `error`).\n"
	"    --Filters.VolumeTypes: array string\n"
	"      The types of the volumes (`standard` \\| `gp2` \\| `io1`).\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Filters: ref FiltersVpnConnection\n"
	"    One or more filters.\n"
	"    --Filters.BgpAsns: array integer\n"
	"      The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of \n"
	"      the connections.\n"
	"    --Filters.ClientGatewayIds: array string\n"
	"      The IDs of the client gateways.\n"
	"    --Filters.ConnectionTypes: array string\n"
	"      The types of the VPN connections (always `ipsec.1`).\n"
	"    --Filters.RouteDestinationIpRanges: array string\n"
	"      The destination IP ranges.\n"
	"    --Filters.States: array string\n"
	"      The states of the VPN connections (`pending` \\| `available` \\| \n"
	"      `deleting` \\| `deleted`).\n"
	"    --Filters.StaticRoutesOnly: bool\n"
	"      If false, the VPN connection uses dynamic routing with Border Gateway \n"
	"      Protocol (BGP). If true, routing is controlled using static routes. For \n"
	"      more information about how to create and delete static routes, see \n"
	"      [CreateVpnConnectionRoute](#createvpnconnectionroute) and \n"
	"      [DeleteVpnConnectionRoute](#deletevpnconnectionroute).\n"
	"    --Filters.TagKeys: array string\n"
	"      The keys of the tags associated with the VPN connections.\n"
	"    --Filters.TagValues: array string\n"
	"      The values of the tags associated with the VPN connections.\n"
	"    --Filters.Tags: array string\n"
	"      The key/value combination of the tags associated with the VPN \n"
	"      connections, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE\"]}.\n"
	"    --Filters.VirtualGatewayIds: array string\n"
	"      The IDs of the virtual gateways.\n"
	"    --Filters.VpnConnectionIds: array string\n"
	"      The IDs of the VPN connections.\n"
"--NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a specific page.\n"
"--ResultsPerPage: long long int\n"
	"  The maximum number of logs returned in a single response (between `1` and `1000`, both \n"
	"  included).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmIds: array string\n"
	"  One or more IDs of the VMs you want to reboot.\n"
,
	"--BackendVmIds: array string\n"
	"  One or more IDs of backend VMs.\nSpecifying the same ID several times has no effect as each \n"
	"  backend VM has equal weight.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetPeeringId: string\n"
	"  The ID of the Net peering you want to reject.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--UserGroupName: string\n"
	"  The name of the group you want to remove the user from.\n"
"--UserGroupPath: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
"--UserName: string\n"
	"  The name of the user you want to remove from the group.\n"
"--UserPath: string\n"
	"  The path to the user (by default, `/`).\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmGroupId: string\n"
	"  The ID of the VM group you want to scale down.\n"
"--VmSubtraction: long long int\n"
	"  The number of VMs you want to delete from the VM group.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmAddition: long long int\n"
	"  The number of VMs you want to add to the VM group.\n"
"--VmGroupId: string\n"
	"  The ID of the VM group you want to scale up.\n"
,
	"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--VersionId: string\n"
	"  The ID of the version.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VmIds: array string\n"
	"  One or more IDs of VMs.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ForceStop: bool\n"
	"  Forces the VM to stop.\n"
"--VmIds: array string\n"
	"  One or more IDs of VMs.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--FlexibleGpuId: string\n"
	"  The ID of the fGPU you want to detach from your VM.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--InternetServiceId: string\n"
	"  The ID of the internet service you want to detach.\n"
"--NetId: string\n"
	"  The ID of the Net from which you want to detach the internet service.\n"
,
	"--BackendIps: array string\n"
	"  One or more public IPs of backend VMs.\n"
"--BackendVmIds: array string\n"
	"  One or more IDs of backend VMs.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--UserGroupName: string\n"
	"  The name of the group you want to unlink the policy from.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LinkNicId: string\n"
	"  The ID of the attachment operation.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers.html).\n"
"--UserName: string\n"
	"  The name of the user you want to detach the policy from.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NicId: string\n"
	"  The ID of the NIC.\n"
"--PrivateIps: array string\n"
	"  One or more secondary private IPs you want to unassign from the NIC.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LinkPublicIpId: string\n"
	"  The ID representing the association of the public IP with the VM or the NIC. This parameter \n"
	"  is required unless you use the `PublicIp` parameter.\n"
"--PublicIp: string\n"
	"  The public IP. This parameter is required unless you use the `LinkPublicIpId` parameter.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LinkRouteTableId: string\n"
	"  The ID of the association between the route table and the Subnet.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetId: string\n"
	"  The ID of the Net from which you want to detach the virtual gateway.\n"
"--VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ForceUnlink: bool\n"
	"  Forces the detachment of the volume in case of previous failure. Important: This action may \n"
	"  damage your data or file systems.\n"
"--VolumeId: string\n"
	"  The ID of the volume you want to detach.\n"
,
	"--AccessKeyId: string\n"
	"  The ID of the access key.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ExpirationDate: string\n"
	"  The date and time, or the date, at which you want the access key to expire, in ISO 8601 \n"
	"  format (for example, `2020-06-14T00:00:00.000Z` or `2020-06-14`). If not specified, the \n"
	"  access key is set to not expire.\n"
"--State: string\n"
	"  The new state for the access key (`ACTIVE` \\| `INACTIVE`). When set to `ACTIVE`, the \n"
	"  access key is enabled and can be used to send requests. When set to `INACTIVE`, the access \n"
	"  key is disabled.\n"
"--UserName: string\n"
	"  The name of the EIM user that the access key you want to modify is associated with. If you \n"
	"  do not specify a user name, this action modifies the access key of the user who sends the \n"
	"  request (which can be the root account).\n"
,
	"--AdditionalEmails: array string\n"
	"  One or more additional email addresses for the account. These addresses are used for \n"
	"  notifications only. If you already have a list of additional emails registered, you cannot \n"
	"  add to it, only replace it. To remove all registered additional emails, specify an empty \n"
	"  list.\n"
"--City: string\n"
	"  The new city of the account owner.\n"
"--CompanyName: string\n"
	"  The new name of the company for the account.\n"
"--Country: string\n"
	"  The new country of the account owner.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Email: string\n"
	"  The main email address for the account. This address is used for your credentials and \n"
	"  notifications.\n"
"--FirstName: string\n"
	"  The new first name of the account owner.\n"
"--JobTitle: string\n"
	"  The new job title of the account owner.\n"
"--LastName: string\n"
	"  The new last name of the account owner.\n"
"--MobileNumber: string\n"
	"  The new mobile phone number of the account owner.\n"
"--PhoneNumber: string\n"
	"  The new landline phone number of the account owner.\n"
"--StateProvince: string\n"
	"  The new state/province of the account owner.\n"
"--VatNumber: string\n"
	"  The new value added tax (VAT) number for the account.\n"
"--ZipCode: string\n"
	"  The new ZIP code of the city.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--MaxAccessKeyExpirationSeconds: long long int\n"
	"  The maximum possible lifetime for your access keys, in seconds (between `0` and \n"
	"  `3153600000`, both included). If set to `O`, your access keys can have unlimited lifetimes, \n"
	"  but a trusted session cannot be activated. Otherwise, all your access keys must have an \n"
	"  expiration date. This value must be greater than the remaining lifetime of each access key \n"
	"  of your account.\n"
"--RequireTrustedEnv: bool\n"
	"  If true, a trusted session is activated, provided that you specify the \n"
	"  `MaxAccessKeyExpirationSeconds` parameter with a value greater than `0`.\nEnabling this \n"
	"  will require you and all your users to log in to Cockpit v2 using the WebAuthn method for \n"
	"  multi-factor authentication. For more information, see [About Authentication > Multi-Factor \n"
	"  Authentication](https://docs.outscale.com/en/userguide/About-Authentication.html#_multi_fact\n"
	"  or_authentication).\n"
,
	"--ApiAccessRuleId: string\n"
	"  The ID of the API access rule you want to update.\n"
"--CaIds: array string\n"
	"  One or more IDs of Client Certificate Authorities (CAs).\n"
"--Cns: array string\n"
	"  One or more Client Certificate Common Names (CNs).\n"
"--Description: string\n"
	"  A new description for the API access rule.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--IpRanges: array string\n"
	"  One or more IPs or CIDR blocks (for example, `192.0.2.0/16`).\n"
,
	"--CaId: string\n"
	"  The ID of the CA.\n"
"--Description: string\n"
	"  The description of the CA.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
,
	"--DedicatedGroupId: string\n"
	"  The ID of the dedicated group you want to update.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Name: string\n"
	"  The new name of the dedicated group.\n"
,
	"--DirectLinkInterfaceId: string\n"
	"  The ID of the DirectLink interface you want to update.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Mtu: long long int\n"
	"  The maximum transmission unit (MTU) of the DirectLink interface, in bytes.\n"
,
	"--DeleteOnVmDeletion: bool\n"
	"  If true, the fGPU is deleted when the VM is terminated.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--FlexibleGpuId: string\n"
	"  The ID of the fGPU you want to modify.\n"
,
	"--Description: string\n"
	"  A new description for the image.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--ImageId: string\n"
	"  The ID of the OMI you want to modify.\n"
"--PermissionsToLaunch: ref PermissionsOnResourceCreation\n"
	"    Information about the permissions for the resource.\nSpecify \n"
	"    either the `Additions` or the `Removals` parameter.\n"
	"    --PermissionsToLaunch.Additions: ref PermissionsOnResource\n"
	"        Permissions for the resource.\n"
	"        --PermissionsToLaunch.Additions.AccountIds: array string\n"
	"          One or more account IDs that the permission is associated with.\n"
	"        --PermissionsToLaunch.Additions.GlobalPermission: bool\n"
	"          A global permission for all accounts.\n(Request) Set this \n"
	"          parameter to true to make the resource public (if the parent parameter is \n"
	"          `Additions`) or to make the resource private (if the parent parameter is \n"
	"          `Removals`).\n(Response) If true, the resource is public. If false, \n"
	"          the resource is private.\n"
	"    --PermissionsToLaunch.Removals: ref PermissionsOnResource\n"
	"        Permissions for the resource.\n"
	"        --PermissionsToLaunch.Removals.AccountIds: array string\n"
	"          One or more account IDs that the permission is associated with.\n"
	"        --PermissionsToLaunch.Removals.GlobalPermission: bool\n"
	"          A global permission for all accounts.\n(Request) Set this \n"
	"          parameter to true to make the resource public (if the parent parameter is \n"
	"          `Additions`) or to make the resource private (if the parent parameter is \n"
	"          `Removals`).\n(Response) If true, the resource is public. If false, \n"
	"          the resource is private.\n"
"--ProductCodes: array string\n"
	"  The product codes associated with the OMI. Any previously set value is deleted. Make sure \n"
	"  to specify all product codes you want to associate with the OMI.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--HostPattern: string\n"
	"  A host-name pattern for the rule, with a maximum length of 128 characters. This host-name \n"
	"  pattern supports maximum three wildcards, and must not contain any special characters \n"
	"  except `-.?`.\n"
"--ListenerRuleName: string\n"
	"  The name of the listener rule.\n"
"--PathPattern: string\n"
	"  A path pattern for the rule, with a maximum length of 128 characters. This path pattern \n"
	"  supports maximum three wildcards, and must not contain any special characters except \n"
	"  `_-.$/~\"'@:+?`.\n"
,
	"--AccessLog: ref AccessLog\n"
	"    Information about access logs.\n"
	"    --AccessLog.IsEnabled: bool\n"
	"      If true, access logs are enabled for your load balancer. If false, they \n"
	"      are not. If you set this to true in your request, the `OsuBucketName` \n"
	"      parameter is required.\n"
	"    --AccessLog.OsuBucketName: string\n"
	"      The name of the OOS bucket for the access logs.\n"
	"    --AccessLog.OsuBucketPrefix: string\n"
	"      The path to the folder of the access logs in your OOS bucket (by \n"
	"      default, the `root` level of your bucket).\n"
	"    --AccessLog.PublicationInterval: long long int\n"
	"      The time interval for the publication of access logs in the OOS bucket, \n"
	"      in minutes. This value can be either `5` or `60` (by default, `60`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--HealthCheck: ref HealthCheck\n"
	"    Information about the health check configuration.\n"
	"    --HealthCheck.CheckInterval: long long int\n"
	"      The number of seconds between two requests (between `5` and `600` both \n"
	"      included).\n"
	"    --HealthCheck.HealthyThreshold: long long int\n"
	"      The number of consecutive successful requests before considering the VM \n"
	"      as healthy (between `2` and `10` both included).\n"
	"    --HealthCheck.Path: string\n"
	"      If you use the HTTP or HTTPS protocols, the request URL path. Always \n"
	"      starts with a slash (`/`).\n"
	"    --HealthCheck.Port: long long int\n"
	"      The port number (between `1` and `65535`, both included).\n"
	"    --HealthCheck.Protocol: string\n"
	"      The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| \n"
	"      `SSL`).\n"
	"    --HealthCheck.Timeout: long long int\n"
	"      The maximum waiting time for a response before considering the VM as \n"
	"      unhealthy, in seconds (between `2` and `60` both included).\n"
	"    --HealthCheck.UnhealthyThreshold: long long int\n"
	"      The number of consecutive failed requests before considering the VM as \n"
	"      unhealthy (between `2` and `10` both included).\n"
"--LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
"--LoadBalancerPort: long long int\n"
	"  The port on which the load balancer is listening (between `1` and `65535`, both included). \n"
	"  This parameter is required if you want to update the server certificate.\n"
"--PolicyNames: array string\n"
	"  The name of the policy you want to enable for the listener.\n"
"--PublicIp: string\n"
	"  (internet-facing only) The public IP you want to associate with the load balancer. The \n"
	"  former public IP of the load balancer is then disassociated. If you specify an empty string \n"
	"  and the former public IP belonged to you, it is disassociated and replaced by a public IP \n"
	"  owned by 3DS OUTSCALE.\n"
"--SecuredCookies: bool\n"
	"  If true, secure cookies are enabled for the load balancer.\n"
"--SecurityGroups: array string\n"
	"  (Net only) One or more IDs of security groups you want to assign to the load balancer. You \n"
	"  need to specify the already assigned security groups that you want to keep along with the \n"
	"  new ones you are assigning. If the list is empty, the default security group of the Net is \n"
	"  assigned to the load balancer.\n"
"--ServerCertificateId: string\n"
	"  The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see \n"
	"  [Resource Identifiers > OUTSCALE Resource Names \n"
	"  (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_\n"
	"  names_orns). If this parameter is specified, you must also specify the `LoadBalancerPort` \n"
	"  parameter.\n"
,
	"--AddRouteTableIds: array string\n"
	"  One or more IDs of route tables to associate with the specified Net access point.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetAccessPointId: string\n"
	"  The ID of the Net access point.\n"
"--RemoveRouteTableIds: array string\n"
	"  One or more IDs of route tables to disassociate from the specified Net access point.\n"
,
	"--DhcpOptionsSetId: string\n"
	"  The ID of the DHCP options set (or `default` if you want to associate the default one).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NetId: string\n"
	"  The ID of the Net.\n"
,
	"--Description: string\n"
	"  A new description for the NIC.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LinkNic: ref LinkNicToUpdate\n"
	"    Information about the NIC attachment. If you are modifying the \n"
	"    `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC \n"
	"    attachment.\n"
	"    --LinkNic.DeleteOnVmDeletion: bool\n"
	"      If true, the NIC is deleted when the VM is terminated. If false, the NIC \n"
	"      is detached from the VM.\n"
	"    --LinkNic.LinkNicId: string\n"
	"      The ID of the NIC attachment.\n"
"--NicId: string\n"
	"  The ID of the NIC you want to modify.\n"
"--SecurityGroupIds: array string\n"
	"  One or more IDs of security groups for the NIC.\nYou must specify at least one group, even \n"
	"  if you use the default security group in the Net.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Enable: bool\n"
	"  If true, a virtual gateway can propagate routes to a specified route table of a Net. If \n"
	"  false, the propagation is disabled.\n"
"--RouteTableId: string\n"
	"  The ID of the route table.\n"
"--VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
,
	"--DestinationIpRange: string\n"
	"  The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--GatewayId: string\n"
	"  The ID of an internet service or virtual gateway attached to your Net.\n"
"--NatServiceId: string\n"
	"  The ID of a NAT service.\n"
"--NetPeeringId: string\n"
	"  The ID of a Net peering.\n"
"--NicId: string\n"
	"  The ID of a network interface card (NIC).\n"
"--RouteTableId: string\n"
	"  The ID of the route table.\n"
"--VmId: string\n"
	"  The ID of a NAT VM in your Net.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--LinkRouteTableId: string\n"
	"  The ID of the current route table link.\n"
"--RouteTableId: string\n"
	"  The ID of the new route table to associate with the Subnet.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Name: string\n"
	"  The name of the server certificate you want to modify.\n"
"--NewName: string\n"
	"  A new name for the server certificate.\n"
"--NewPath: string\n"
	"  A new path for the server certificate.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--PermissionsToCreateVolume: ref PermissionsOnResourceCreation\n"
	"    Information about the permissions for the resource.\nSpecify \n"
	"    either the `Additions` or the `Removals` parameter.\n"
	"    --PermissionsToCreateVolume.Additions: ref PermissionsOnResource\n"
	"        Permissions for the resource.\n"
	"        --PermissionsToCreateVolume.Additions.AccountIds: array string\n"
	"          One or more account IDs that the permission is associated with.\n"
	"        --PermissionsToCreateVolume.Additions.GlobalPermission: bool\n"
	"          A global permission for all accounts.\n(Request) Set this \n"
	"          parameter to true to make the resource public (if the parent parameter is \n"
	"          `Additions`) or to make the resource private (if the parent parameter is \n"
	"          `Removals`).\n(Response) If true, the resource is public. If false, \n"
	"          the resource is private.\n"
	"    --PermissionsToCreateVolume.Removals: ref PermissionsOnResource\n"
	"        Permissions for the resource.\n"
	"        --PermissionsToCreateVolume.Removals.AccountIds: array string\n"
	"          One or more account IDs that the permission is associated with.\n"
	"        --PermissionsToCreateVolume.Removals.GlobalPermission: bool\n"
	"          A global permission for all accounts.\n(Request) Set this \n"
	"          parameter to true to make the resource public (if the parent parameter is \n"
	"          `Additions`) or to make the resource private (if the parent parameter is \n"
	"          `Removals`).\n(Response) If true, the resource is public. If false, \n"
	"          the resource is private.\n"
"--SnapshotId: string\n"
	"  The ID of the snapshot.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--MapPublicIpOnLaunch: bool\n"
	"  If true, a public IP is assigned to the network interface cards (NICs) created in the \n"
	"  specified Subnet.\n"
"--SubnetId: string\n"
	"  The ID of the Subnet.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NewPath: string\n"
	"  A new path for the group. If not specified, it is set to a slash (`/`).\n"
"--NewUserGroupName: string\n"
	"  A new name for the user group.\n"
"--Path: string\n"
	"  The path to the group. If not specified, it is set to a slash (`/`).\n"
"--UserGroupName: string\n"
	"  The name of the group you want to update.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--NewPath: string\n"
	"  A new path for the EIM user.\n"
"--NewUserEmail: string\n"
	"  A new email address for the EIM user.\n"
"--NewUserName: string\n"
	"  A new name for the EIM user.\n"
"--UserName: string\n"
	"  The name of the EIM user you want to modify.\n"
,
	"--Description: string\n"
	"  A new description for the VM group.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Tags: array ref ResourceTag\n"
	"  New tags for your VM group.\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    --Tags.INDEX.Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
"--VmGroupId: string\n"
	"  The ID of the VM group you want to update.\n"
"--VmGroupName: string\n"
	"  A new name for your VM group.\n"
"--VmTemplateId: string\n"
	"  A new VM template ID for your VM group.\n"
,
	"--ActionsOnNextBoot: ref ActionsOnNextBoot\n"
	"    The action to perform on the next boot of the VM.\n"
	"    --ActionsOnNextBoot.SecureBoot: string\n"
	"        One action to perform on the next boot of the VM. For more information, \n"
	"        see [About Secure \n"
	"        Boot](https://docs.outscale.com/en/userguide/About-Secure-Boot.html#_secur\n"
	"        e_boot_actions).\n"
"--BlockDeviceMappings: array ref BlockDeviceMappingVmUpdate\n"
	"  One or more block device mappings of the VM.\n"
	"    Information about the block device mapping.\n"
	"    --BlockDeviceMappings.INDEX.Bsu: ref BsuToUpdateVm\n"
	"        Information about the BSU volume.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.DeleteOnVmDeletion: bool\n"
	"          If set to true, the volume is deleted when terminating the VM. If set to \n"
	"          false, the volume is not deleted when terminating the VM.\n"
	"        --BlockDeviceMappings.INDEX.Bsu.VolumeId: string\n"
	"          The ID of the volume.\n"
	"    --BlockDeviceMappings.INDEX.DeviceName: string\n"
	"      The device name for the volume. For a root device, you must use \n"
	"      `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, \n"
	"      `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` \n"
	"      and `z`, and the second `X` is a letter between `a` and `z`).\n"
	"    --BlockDeviceMappings.INDEX.NoDevice: string\n"
	"      Removes the device which is included in the block device mapping of the \n"
	"      OMI.\n"
	"    --BlockDeviceMappings.INDEX.VirtualDeviceName: string\n"
	"      The name of the virtual device (`ephemeralN`).\n"
"--BsuOptimized: bool\n"
	"  This parameter is not available. It is present in our API for the sake of historical \n"
	"  compatibility with AWS.\n"
"--DeletionProtection: bool\n"
	"  If true, you cannot delete the VM unless you change this parameter back to false.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--IsSourceDestChecked: bool\n"
	"  (Net only) If true, the source/destination check is enabled. If false, it is disabled.\n"
"--KeypairName: string\n"
	"  The name of a keypair you want to associate with the VM.\nWhen you replace the keypair of a \n"
	"  VM with another one, the metadata of the VM is modified to reflect the new public key, but \n"
	"  the replacement is still not effective in the operating system of the VM. To complete the \n"
	"  replacement and effectively apply the new keypair, you need to perform other actions inside \n"
	"  the VM. For more information, see [Modifying the Keypair of a \n"
	"  VM](https://docs.outscale.com/en/userguide/Modifying-the-Keypair-of-a-VM.html).\n"
"--NestedVirtualization: bool\n"
	"  (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is \n"
	"  disabled.\n"
"--Performance: string\n"
	"  The performance of the VM.\n"
"--SecurityGroupIds: array string\n"
	"  One or more IDs of security groups for the VM.\n"
"--UserData: string\n"
	"  The Base64-encoded MIME user data, limited to 500 kibibytes (KiB).\n"
"--VmId: string\n"
	"  The ID of the VM.\n"
"--VmInitiatedShutdownBehavior: string\n"
	"  The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the \n"
	"  VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.\n"
"--VmType: string\n"
	"  The type of VM. For more information, see [VM \n"
	"  Types](https://docs.outscale.com/en/userguide/VM-Types.html).\n"
,
	"--Description: string\n"
	"  A new description for the VM template.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Tags: array ref ResourceTag\n"
	"  New tags for your VM template.\n"
	"    Information about the tag.\n"
	"    --Tags.INDEX.Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    --Tags.INDEX.Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
"--VmTemplateId: string\n"
	"  The ID of the VM template you want to update.\n"
"--VmTemplateName: string\n"
	"  A new name for your VM template.\n"
,
	"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--Iops: long long int\n"
	"  **Cold volume**: the new number of I/O operations per second (IOPS). This parameter can be \n"
	"  specified only if you update an `io1` volume or if you change the type of the volume for an \n"
	"  `io1`. This modification is instantaneous. \n**Hot volume**: the new number of I/O \n"
	"  operations per second (IOPS). This parameter can be specified only if you update an `io1` \n"
	"  volume. This modification is not instantaneous. \nThe maximum number of IOPS allowed for \n"
	"  `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.\n"
"--Size: long long int\n"
	"  **Cold volume**: the new size of the volume, in gibibytes (GiB). This value must be equal \n"
	"  to or greater than the current size of the volume. This modification is not instantaneous. \n"
	"  \n**Hot volume**: you cannot change the size of a hot volume.\n"
"--VolumeId: string\n"
	"  The ID of the volume you want to update.\n"
"--VolumeType: string\n"
	"  **Cold volume**: the new type of the volume (`standard` \\| `io1` \\| `gp2`). This \n"
	"  modification is instantaneous. If you update to an `io1` volume, you must also specify the \n"
	"  `Iops` parameter.\n**Hot volume**: you cannot change the type of a hot volume.\n"
,
	"--ClientGatewayId: string\n"
	"  The ID of the client gateway.\n"
"--DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform the action.\n"
"--VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
"--VpnConnectionId: string\n"
	"  The ID of the VPN connection you want to modify.\n"
"--VpnOptions: ref VpnOptions\n"
	"    Information about the VPN options.\n"
	"    --VpnOptions.Phase1Options: ref Phase1Options\n"
	"        Information about Phase 1 of the Internet Key Exchange (IKE) \n"
	"        negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 \n"
	"        negotiations.\n"
	"        --VpnOptions.Phase1Options.DpdTimeoutAction: string\n"
	"          The action to carry out after a Dead Peer Detection (DPD) timeout \n"
	"          occurs.\n"
	"        --VpnOptions.Phase1Options.DpdTimeoutSeconds: long long int\n"
	"          The maximum waiting time for a Dead Peer Detection (DPD) response before \n"
	"          considering the peer as dead, in seconds.\n"
	"        --VpnOptions.Phase1Options.IkeVersions: array string\n"
	"          The Internet Key Exchange (IKE) versions allowed for the VPN tunnel.\n"
	"        --VpnOptions.Phase1Options.Phase1DhGroupNumbers: array integer\n"
	"          The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for \n"
	"          phase 1.\n"
	"        --VpnOptions.Phase1Options.Phase1EncryptionAlgorithms: array string\n"
	"          The encryption algorithms allowed for the VPN tunnel for phase 1.\n"
	"        --VpnOptions.Phase1Options.Phase1IntegrityAlgorithms: array string\n"
	"          The integrity algorithms allowed for the VPN tunnel for phase 1.\n"
	"        --VpnOptions.Phase1Options.Phase1LifetimeSeconds: long long int\n"
	"          The lifetime for phase 1 of the IKE negotiation process, in seconds.\n"
	"        --VpnOptions.Phase1Options.ReplayWindowSize: long long int\n"
	"          The number of packets in an IKE replay window.\n"
	"        --VpnOptions.Phase1Options.StartupAction: string\n"
	"          The action to carry out when establishing tunnels for a VPN connection.\n"
	"    --VpnOptions.Phase2Options: ref Phase2Options\n"
	"        Information about Phase 2 of the Internet Key Exchange (IKE) \n"
	"        negotiation.\n"
	"        --VpnOptions.Phase2Options.Phase2DhGroupNumbers: array integer\n"
	"          The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for \n"
	"          phase 2.\n"
	"        --VpnOptions.Phase2Options.Phase2EncryptionAlgorithms: array string\n"
	"          The encryption algorithms allowed for the VPN tunnel for phase 2.\n"
	"        --VpnOptions.Phase2Options.Phase2IntegrityAlgorithms: array string\n"
	"          The integrity algorithms allowed for the VPN tunnel for phase 2.\n"
	"        --VpnOptions.Phase2Options.Phase2LifetimeSeconds: long long int\n"
	"          The lifetime for phase 2 of the Internet Key Exchange (IKE) negotiation \n"
	"          process, in seconds.\n"
	"        --VpnOptions.Phase2Options.PreSharedKey: string\n"
	"          The pre-shared key to establish the initial authentication between the \n"
	"          client gateway and the virtual gateway. This key can contain any \n"
	"          character except line breaks and double quotes (\").\n"
	"    --VpnOptions.TunnelInsideIpRange: string\n"
	"      The range of inside IPs for the tunnel. This must be a /30 CIDR block \n"
	"      from the 169.254.254.0/24 range.\n"
,
	NULL
};

const char *osc_find_description(const char *call_name)
{
	const char **c;
	int i = 0;

	for (c = calls_name; *c; ++c) {
		if (!strcmp(*c, call_name))
			return calls_descriptions[i];
		++i;
	}
	return NULL;
}

const char *osc_find_args_description(const char *call_name)
{
	const char **c;
	int i = 0;

	for (c = calls_name; *c; ++c) {
		if (!strcmp(*c, call_name))
			return calls_args_descriptions[i];
		++i;
	}
	return NULL;
}

const char **osc_calls_name(void)
{
	return calls_name;
}

#endif  /* WITH_DESCRIPTION */

#ifdef WITH_C11_THREAD_LOCAL
#define THREAD_LOCAL _Thread_local
#else
#define THREAD_LOCAL
#endif

static THREAD_LOCAL const char *cfg_path;

void osc_set_cfg_path(const char *cfg)
{
	cfg_path = cfg;
}

const char *osc_set_get_path(void)
{
	return cfg_path;
}

void *osc_realloc(void *buf, size_t l)
{
	void *ret = realloc(buf, l);

	if (!ret)
		free(buf);
	return ret;
}

/* We don't use _Bool as we try to be C89 compatible */
int osc_str_append_bool(struct osc_str *osc_str, int bool)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->len = len + (bool ? 4 : 5);
	osc_str->buf = osc_realloc(osc_str->buf, osc_str->len + 1);
	if (!osc_str->buf)
		return -1;
	strcpy(osc_str->buf + len, (bool ? "true" : "false"));
	return 0;
}

int osc_str_append_int(struct osc_str *osc_str, long long int i)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->buf = osc_realloc(osc_str->buf, len + 64);
	if (!osc_str->buf)
		return -1;
	osc_str->len = len + snprintf(osc_str->buf + len, 64, "%lld", i);
	osc_str->buf[osc_str->len] = 0;
	return 0;
}

int osc_str_append_double(struct osc_str *osc_str, double i)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->buf = osc_realloc(osc_str->buf, len + 64);
	if (!osc_str->buf)
		return -1;
	osc_str->len = len + snprintf(osc_str->buf + len, 64, "%f", i);
	osc_str->buf[osc_str->len] = 0;
	return 0;
}

int osc_str_append_string(struct osc_str *osc_str, const char *str)
{
	if (!str)
		return 0;
	assert(osc_str);

	int len = osc_str->len;
	int dlen = strlen(str);

	osc_str->len = osc_str->len + dlen;
	osc_str->buf = osc_realloc(osc_str->buf, osc_str->len + 1);
	if (!osc_str->buf)
		return -1;
	memcpy(osc_str->buf + len, str, dlen + 1);
	return 0;
}

int osc_str_append_n_string(struct osc_str *osc_str, const char *str, int l)
{
	if (!str)
		return 0;
	assert(osc_str);

	int len = osc_str->len;

	osc_str->len = osc_str->len + l;
	osc_str->buf = osc_realloc(osc_str->buf, osc_str->len + 1);
	if (!osc_str->buf)
		return -1;
	memcpy(osc_str->buf + len, str, l);
	osc_str->buf[len + l] = 0;
	return 0;
}

static char *osc_strdup(const char *str) {
	if (!str)
		return NULL;
	return strdup(str);
}

#define TRY(test,  ...)						\
	if (test) { fprintf(stderr, __VA_ARGS__); return -1; }

#define STRY(test,  ...)					\
	if (test) return -1

#define TRY_APPEND_COL(count_args, data)			\
	if (count_args++ > 0)					\
		STRY(osc_str_append_string(data, "," ));

#ifndef LOAD_CFG_GET_HOME
#define LOAD_CFG_GET_HOME(buf)						\
	{								\
		const char *dest = CFG_FILE;				\
		char *home = getenv("HOME");				\
									\
		TRY(strlen(home) + sizeof CFG_FILE > sizeof buf,	\
		    "path of home directory is too long");				\
		strcpy(stpcpy(buf, home), dest);			\
	}
#endif

#define ARG_TO_JSON_STR(separator, what) do {				\
		auto_osc_str struct osc_str s;				\
		char *tmp = what;					\
		char *endl;						\
									\
		osc_init_str(&s);					\
		while((endl = strchr(tmp, '\n')) != NULL) {		\
			int l = endl - tmp;				\
									\
			osc_str_append_n_string(&s, tmp, l);		\
			osc_str_append_string(&s, "\\n");		\
			tmp = endl + 1;					\
		}							\
		osc_str_append_string(&s, tmp);				\
		STRY(osc_str_append_string(data, separator));		\
		STRY(osc_str_append_string(data, "\"" ));		\
		STRY(osc_str_append_string(data, s.buf));		\
		STRY(osc_str_append_string(data, "\"" ));		\
	} while (0)

#define ARG_TO_JSON(name, type, what) do {				\
		TRY_APPEND_COL(count_args, data);			\
		STRY(osc_str_append_string(data, "\""#name"\":" ));	\
		STRY(osc_str_append_##type(data, what));		\
	} while (0)


int osc_set_extra_flag_from_conf(const char *profile, unsigned int *flag)
{
	char buf[1024];
	const char *cfg = cfg_path;
	auto_osc_json_c struct json_object *to_free = NULL;
	struct json_object *json_tmp, *js = NULL;

	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	TRY(access(cfg, R_OK), "can't open/read %s\n", cfg);
	js = json_object_from_file(cfg);
	TRY(!js, "can't load json-file %s (json might have incorect syntaxe)\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	TRY(!js, "can't find profile %s\n", profile);

	json_tmp = json_object_object_get(js, "ssl_verify");
	if (json_tmp) {
		if (!json_object_get_boolean(json_tmp) ||
		    !json_object_get_int(json_tmp)) {
			*flag = *flag | OSC_INSECURE_MODE;
		} else {
			*flag = *flag & (~OSC_INSECURE_MODE);
		}
	}
	json_tmp = json_object_object_get(js, "verbose");
	if (json_tmp) {
		if (json_object_get_boolean(json_tmp) ||
		    json_object_get_int(json_tmp)) {
			*flag = *flag | OSC_VERBOSE_MODE;
		} else {
			*flag = *flag & (~OSC_VERBOSE_MODE);
		}
	}
	return 0;
}

int osc_load_ak_sk_from_conf(const char *profile, char **ak, char **sk)
{
	char buf[1024];
	const char *cfg = cfg_path;
	struct json_object *js, *ak_js, *sk_js;
	auto_osc_json_c struct json_object *to_free = NULL;

	if (!ak && !sk)
		return 0;
	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	if (sk)
		*sk = NULL;
	if (ak)
		*ak = NULL;
	TRY(access(cfg, R_OK), "can't open/read %s\n", cfg);
	js = json_object_from_file(cfg);
	TRY(!js, "can't load json-file %s (json might have incorect syntaxe)\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	TRY(!js, "can't find profile %s\n", profile);
	if (ak) {
		ak_js = json_object_object_get(js, "access_key");
		TRY(!ak_js, "can't find 'access_key' in profile '%s'\n", profile);
		*ak = strdup(json_object_get_string(json_object_object_get(js, "access_key")));
	}
	if (sk) {
		sk_js = json_object_object_get(js, "secret_key");
		TRY(!sk_js, "can't find 'secret_key' in profile '%s'\n", profile);
		*sk = strdup(json_object_get_string(json_object_object_get(js, "secret_key")));
	}
	return 0;
}

int osc_load_loging_password_from_conf(const char *profile,
				       char **email, char **password)
{
	char buf[1024];
	const char *cfg = cfg_path;
	auto_osc_json_c struct json_object *to_free = NULL;
	struct json_object *js, *login_js, *pass_js;

	if (!email && !password)
		return 0;
	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	if (password)
		*password = NULL;
	if (email)
		*email = NULL;
	js = json_object_from_file(cfg);
	TRY(!js, "can't open %s\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	TRY(!js, "can't find profile '%s'\n", profile);
	if (email) {
		login_js = json_object_object_get(js, "login");
		TRY(!login_js, "can't find 'login' in profile '%s'\n", profile);
		*email = osc_strdup(json_object_get_string(login_js));
	}

	if (password) {
		pass_js = json_object_object_get(js, "password");
		if (!pass_js) {
			return 0; /* is optional */
		}
		*password = osc_strdup(json_object_get_string(pass_js));
	}
	return 0;
}

int osc_load_region_from_conf(const char *profile, char **region)
{
	struct json_object *region_obj;
	const char *cfg = cfg_path;
	char buf[1024];
	struct json_object *js;
	auto_osc_json_c struct json_object *to_free = NULL;

	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	js = json_object_from_file(cfg);
	TRY(!js, "can't open %s\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	if (!js)
		return -1;

	region_obj = json_object_object_get(js, "region");
	if (!region_obj) {
		return -1;
	}
	*region = osc_strdup(json_object_get_string(region_obj));
	return 0;
}

static int osc_load_cert_from_conf_(const char *profile, char **cert, char **key,
				    char **proxy, char **endpoint)
{
	struct json_object *cert_obj, *key_obj, *js;
	const char *cfg = cfg_path;
	auto_osc_json_c struct json_object *to_free = NULL;
	char buf[1024];
	int ret = 0;

	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	js = json_object_from_file(cfg);
	TRY(!js, "can't open %s\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	if (!js)
		return 0;

	cert_obj = json_object_object_get(js, "x509_client_cert");
	if (!cert_obj)
		cert_obj = json_object_object_get(js, "client_certificate");
	if (cert_obj) {
		*cert = osc_strdup(json_object_get_string(cert_obj));
		ret |= OSC_ENV_FREE_CERT;
	}

	key_obj = json_object_object_get(js, "x509_client_sslkey");
	if (key_obj) {
		*key = osc_strdup(json_object_get_string(key_obj));
		ret |= OSC_ENV_FREE_SSLKEY;
	}

	if (proxy) {
		key_obj = json_object_object_get(js, "proxy");
		if (key_obj) {
			*proxy = osc_strdup(json_object_get_string(key_obj));
			ret |= OSC_ENV_FREE_PROXY;
		}
	}

	if (endpoint) {
		struct json_object *e = json_object_object_get(js, "endpoints");

		if (e)
			e = json_object_object_get(e, "api");
		else
			e = json_object_object_get(js, "endpoint");
		if (e) {
			*endpoint = osc_strdup(json_object_get_string(e));
			ret |= OSC_ENV_FREE_ENDPOINT;
		}
	}

	return 0;
}

int osc_load_cert_from_conf(const char *profile, char **cert, char **key)
{
	return osc_load_cert_from_conf_(profile, cert, key, NULL, NULL);
}

/* Function that will write the data inside a variable */
static size_t write_data(void *data, size_t size, size_t nmemb, void *userp)
{
	size_t bufsize = size * nmemb;
	struct osc_str *response = userp;
	int olen = response->len;

	response->len = response->len + bufsize;
	response->buf = osc_realloc(response->buf, response->len + 1);
	memcpy(response->buf + olen, data, bufsize);
	response->buf[response->len] = 0;
	return bufsize;
}

void osc_init_str(struct osc_str *r)
{
	r->len = 0;
	r->buf = NULL;
}

void osc_deinit_json_c(json_object **j)
{
	if (j && *j)
		json_object_put(*j);
}

void osc_deinit_str(struct osc_str *r)
{
	free(r->buf);
	osc_init_str(r);
}

static int accepter_net_setter(struct accepter_net *args, struct osc_str *data);
static int access_key_setter(struct access_key *args, struct osc_str *data);
static int access_key_secret_key_setter(struct access_key_secret_key *args, struct osc_str *data);
static int access_log_setter(struct access_log *args, struct osc_str *data);
static int account_setter(struct account *args, struct osc_str *data);
static int actions_on_next_boot_setter(struct actions_on_next_boot *args, struct osc_str *data);
static int api_access_policy_setter(struct api_access_policy *args, struct osc_str *data);
static int api_access_rule_setter(struct api_access_rule *args, struct osc_str *data);
static int application_sticky_cookie_policy_setter(struct application_sticky_cookie_policy *args, struct osc_str *data);
static int backend_vm_health_setter(struct backend_vm_health *args, struct osc_str *data);
static int block_device_mapping_created_setter(struct block_device_mapping_created *args, struct osc_str *data);
static int block_device_mapping_image_setter(struct block_device_mapping_image *args, struct osc_str *data);
static int block_device_mapping_vm_creation_setter(struct block_device_mapping_vm_creation *args, struct osc_str *data);
static int block_device_mapping_vm_update_setter(struct block_device_mapping_vm_update *args, struct osc_str *data);
static int bsu_created_setter(struct bsu_created *args, struct osc_str *data);
static int bsu_to_create_setter(struct bsu_to_create *args, struct osc_str *data);
static int bsu_to_update_vm_setter(struct bsu_to_update_vm *args, struct osc_str *data);
static int ca_setter(struct ca *args, struct osc_str *data);
static int catalog_setter(struct catalog *args, struct osc_str *data);
static int catalog_entry_setter(struct catalog_entry *args, struct osc_str *data);
static int catalogs_setter(struct catalogs *args, struct osc_str *data);
static int client_gateway_setter(struct client_gateway *args, struct osc_str *data);
static int consumption_entry_setter(struct consumption_entry *args, struct osc_str *data);
static int dedicated_group_setter(struct dedicated_group *args, struct osc_str *data);
static int dhcp_options_set_setter(struct dhcp_options_set *args, struct osc_str *data);
static int direct_link_setter(struct direct_link *args, struct osc_str *data);
static int direct_link_interface_setter(struct direct_link_interface *args, struct osc_str *data);
static int direct_link_interfaces_setter(struct direct_link_interfaces *args, struct osc_str *data);
static int errors_setter(struct errors *args, struct osc_str *data);
static int filters_access_keys_setter(struct filters_access_keys *args, struct osc_str *data);
static int filters_api_access_rule_setter(struct filters_api_access_rule *args, struct osc_str *data);
static int filters_api_log_setter(struct filters_api_log *args, struct osc_str *data);
static int filters_ca_setter(struct filters_ca *args, struct osc_str *data);
static int filters_catalogs_setter(struct filters_catalogs *args, struct osc_str *data);
static int filters_client_gateway_setter(struct filters_client_gateway *args, struct osc_str *data);
static int filters_dedicated_group_setter(struct filters_dedicated_group *args, struct osc_str *data);
static int filters_dhcp_options_setter(struct filters_dhcp_options *args, struct osc_str *data);
static int filters_direct_link_setter(struct filters_direct_link *args, struct osc_str *data);
static int filters_direct_link_interface_setter(struct filters_direct_link_interface *args, struct osc_str *data);
static int filters_export_task_setter(struct filters_export_task *args, struct osc_str *data);
static int filters_flexible_gpu_setter(struct filters_flexible_gpu *args, struct osc_str *data);
static int filters_image_setter(struct filters_image *args, struct osc_str *data);
static int filters_internet_service_setter(struct filters_internet_service *args, struct osc_str *data);
static int filters_keypair_setter(struct filters_keypair *args, struct osc_str *data);
static int filters_listener_rule_setter(struct filters_listener_rule *args, struct osc_str *data);
static int filters_load_balancer_setter(struct filters_load_balancer *args, struct osc_str *data);
static int filters_nat_service_setter(struct filters_nat_service *args, struct osc_str *data);
static int filters_net_setter(struct filters_net *args, struct osc_str *data);
static int filters_net_access_point_setter(struct filters_net_access_point *args, struct osc_str *data);
static int filters_net_peering_setter(struct filters_net_peering *args, struct osc_str *data);
static int filters_nic_setter(struct filters_nic *args, struct osc_str *data);
static int filters_product_type_setter(struct filters_product_type *args, struct osc_str *data);
static int filters_public_ip_setter(struct filters_public_ip *args, struct osc_str *data);
static int filters_quota_setter(struct filters_quota *args, struct osc_str *data);
static int filters_route_table_setter(struct filters_route_table *args, struct osc_str *data);
static int filters_security_group_setter(struct filters_security_group *args, struct osc_str *data);
static int filters_server_certificate_setter(struct filters_server_certificate *args, struct osc_str *data);
static int filters_service_setter(struct filters_service *args, struct osc_str *data);
static int filters_snapshot_setter(struct filters_snapshot *args, struct osc_str *data);
static int filters_subnet_setter(struct filters_subnet *args, struct osc_str *data);
static int filters_subregion_setter(struct filters_subregion *args, struct osc_str *data);
static int filters_tag_setter(struct filters_tag *args, struct osc_str *data);
static int filters_user_group_setter(struct filters_user_group *args, struct osc_str *data);
static int filters_users_setter(struct filters_users *args, struct osc_str *data);
static int filters_virtual_gateway_setter(struct filters_virtual_gateway *args, struct osc_str *data);
static int filters_vm_setter(struct filters_vm *args, struct osc_str *data);
static int filters_vm_group_setter(struct filters_vm_group *args, struct osc_str *data);
static int filters_vm_template_setter(struct filters_vm_template *args, struct osc_str *data);
static int filters_vm_type_setter(struct filters_vm_type *args, struct osc_str *data);
static int filters_vms_state_setter(struct filters_vms_state *args, struct osc_str *data);
static int filters_volume_setter(struct filters_volume *args, struct osc_str *data);
static int filters_vpn_connection_setter(struct filters_vpn_connection *args, struct osc_str *data);
static int flexible_gpu_setter(struct flexible_gpu *args, struct osc_str *data);
static int flexible_gpu_catalog_setter(struct flexible_gpu_catalog *args, struct osc_str *data);
static int health_check_setter(struct health_check *args, struct osc_str *data);
static int image_setter(struct image *args, struct osc_str *data);
static int image_export_task_setter(struct image_export_task *args, struct osc_str *data);
static int inline_policy_setter(struct inline_policy *args, struct osc_str *data);
static int internet_service_setter(struct internet_service *args, struct osc_str *data);
static int keypair_setter(struct keypair *args, struct osc_str *data);
static int keypair_created_setter(struct keypair_created *args, struct osc_str *data);
static int link_nic_setter(struct link_nic *args, struct osc_str *data);
static int link_nic_light_setter(struct link_nic_light *args, struct osc_str *data);
static int link_nic_to_update_setter(struct link_nic_to_update *args, struct osc_str *data);
static int link_public_ip_setter(struct link_public_ip *args, struct osc_str *data);
static int link_public_ip_light_for_vm_setter(struct link_public_ip_light_for_vm *args, struct osc_str *data);
static int link_route_table_setter(struct link_route_table *args, struct osc_str *data);
static int linked_policy_setter(struct linked_policy *args, struct osc_str *data);
static int linked_volume_setter(struct linked_volume *args, struct osc_str *data);
static int listener_setter(struct listener *args, struct osc_str *data);
static int listener_for_creation_setter(struct listener_for_creation *args, struct osc_str *data);
static int listener_rule_setter(struct listener_rule *args, struct osc_str *data);
static int listener_rule_for_creation_setter(struct listener_rule_for_creation *args, struct osc_str *data);
static int load_balancer_setter(struct load_balancer *args, struct osc_str *data);
static int load_balancer_light_setter(struct load_balancer_light *args, struct osc_str *data);
static int load_balancer_sticky_cookie_policy_setter(struct load_balancer_sticky_cookie_policy *args, struct osc_str *data);
static int load_balancer_tag_setter(struct load_balancer_tag *args, struct osc_str *data);
static int location_setter(struct location *args, struct osc_str *data);
static int log_setter(struct log *args, struct osc_str *data);
static int maintenance_event_setter(struct maintenance_event *args, struct osc_str *data);
static int minimal_policy_setter(struct minimal_policy *args, struct osc_str *data);
static int nat_service_setter(struct nat_service *args, struct osc_str *data);
static int net_setter(struct net *args, struct osc_str *data);
static int net_access_point_setter(struct net_access_point *args, struct osc_str *data);
static int net_peering_setter(struct net_peering *args, struct osc_str *data);
static int net_peering_state_setter(struct net_peering_state *args, struct osc_str *data);
static int net_to_virtual_gateway_link_setter(struct net_to_virtual_gateway_link *args, struct osc_str *data);
static int nic_setter(struct nic *args, struct osc_str *data);
static int nic_for_vm_creation_setter(struct nic_for_vm_creation *args, struct osc_str *data);
static int nic_light_setter(struct nic_light *args, struct osc_str *data);
static int osu_api_key_setter(struct osu_api_key *args, struct osc_str *data);
static int osu_export_image_export_task_setter(struct osu_export_image_export_task *args, struct osc_str *data);
static int osu_export_snapshot_export_task_setter(struct osu_export_snapshot_export_task *args, struct osc_str *data);
static int osu_export_to_create_setter(struct osu_export_to_create *args, struct osc_str *data);
static int permissions_on_resource_setter(struct permissions_on_resource *args, struct osc_str *data);
static int permissions_on_resource_creation_setter(struct permissions_on_resource_creation *args, struct osc_str *data);
static int phase1_options_setter(struct phase1_options *args, struct osc_str *data);
static int phase2_options_setter(struct phase2_options *args, struct osc_str *data);
static int placement_setter(struct placement *args, struct osc_str *data);
static int policy_setter(struct policy *args, struct osc_str *data);
static int policy_entities_setter(struct policy_entities *args, struct osc_str *data);
static int policy_version_setter(struct policy_version *args, struct osc_str *data);
static int private_ip_setter(struct private_ip *args, struct osc_str *data);
static int private_ip_light_setter(struct private_ip_light *args, struct osc_str *data);
static int private_ip_light_for_vm_setter(struct private_ip_light_for_vm *args, struct osc_str *data);
static int product_type_setter(struct product_type *args, struct osc_str *data);
static int public_ip_setter(struct public_ip *args, struct osc_str *data);
static int public_ip_light_setter(struct public_ip_light *args, struct osc_str *data);
static int quota_setter(struct quota *args, struct osc_str *data);
static int quota_types_setter(struct quota_types *args, struct osc_str *data);
static int read_linked_policies_filters_setter(struct read_linked_policies_filters *args, struct osc_str *data);
static int read_policies_filters_setter(struct read_policies_filters *args, struct osc_str *data);
static int region_setter(struct region *args, struct osc_str *data);
static int resource_load_balancer_tag_setter(struct resource_load_balancer_tag *args, struct osc_str *data);
static int resource_tag_setter(struct resource_tag *args, struct osc_str *data);
static int route_setter(struct route *args, struct osc_str *data);
static int route_light_setter(struct route_light *args, struct osc_str *data);
static int route_propagating_virtual_gateway_setter(struct route_propagating_virtual_gateway *args, struct osc_str *data);
static int route_table_setter(struct route_table *args, struct osc_str *data);
static int security_group_setter(struct security_group *args, struct osc_str *data);
static int security_group_light_setter(struct security_group_light *args, struct osc_str *data);
static int security_group_rule_setter(struct security_group_rule *args, struct osc_str *data);
static int security_groups_member_setter(struct security_groups_member *args, struct osc_str *data);
static int server_certificate_setter(struct server_certificate *args, struct osc_str *data);
static int service_setter(struct service *args, struct osc_str *data);
static int snapshot_setter(struct snapshot *args, struct osc_str *data);
static int snapshot_export_task_setter(struct snapshot_export_task *args, struct osc_str *data);
static int source_net_setter(struct source_net *args, struct osc_str *data);
static int source_security_group_setter(struct source_security_group *args, struct osc_str *data);
static int state_comment_setter(struct state_comment *args, struct osc_str *data);
static int subnet_setter(struct subnet *args, struct osc_str *data);
static int subregion_setter(struct subregion *args, struct osc_str *data);
static int tag_setter(struct tag *args, struct osc_str *data);
static int unit_price_entry_setter(struct unit_price_entry *args, struct osc_str *data);
static int user_setter(struct user *args, struct osc_str *data);
static int user_group_setter(struct user_group *args, struct osc_str *data);
static int vgw_telemetry_setter(struct vgw_telemetry *args, struct osc_str *data);
static int virtual_gateway_setter(struct virtual_gateway *args, struct osc_str *data);
static int vm_setter(struct vm *args, struct osc_str *data);
static int vm_group_setter(struct vm_group *args, struct osc_str *data);
static int vm_state_setter(struct vm_state *args, struct osc_str *data);
static int vm_states_setter(struct vm_states *args, struct osc_str *data);
static int vm_template_setter(struct vm_template *args, struct osc_str *data);
static int vm_type_setter(struct vm_type *args, struct osc_str *data);
static int volume_setter(struct volume *args, struct osc_str *data);
static int vpn_connection_setter(struct vpn_connection *args, struct osc_str *data);
static int vpn_options_setter(struct vpn_options *args, struct osc_str *data);
static int with_setter(struct with *args, struct osc_str *data);
static int accepter_net_setter(struct accepter_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}

	return !!ret;
}
static int access_key_setter(struct access_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->tag) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tag\":", args->tag);
	   	ret += 1;
	}

	return !!ret;
}
static int access_key_secret_key_setter(struct access_key_secret_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->secret_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecretKey\":", args->secret_key);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->tag) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tag\":", args->tag);
	   	ret += 1;
	}

	return !!ret;
}
static int access_log_setter(struct access_log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_enabled) {
		ARG_TO_JSON(IsEnabled, bool, args->is_enabled);
	   	ret += 1;
	}
	if (args->osu_bucket_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucketName\":", args->osu_bucket_name);
	   	ret += 1;
	}
	if (args->osu_bucket_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucketPrefix\":", args->osu_bucket_prefix);
	   	ret += 1;
	}
	if (args->is_set_publication_interval || args->publication_interval) {
		ARG_TO_JSON(PublicationInterval, int, args->publication_interval);
	   	ret += 1;
	}

	return !!ret;
}
static int account_setter(struct account *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->additional_emails) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AdditionalEmails\":[" ));
		for (as = args->additional_emails; *as; ++as) {
			if (as != args->additional_emails)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->additional_emails_str) {
		ARG_TO_JSON(AdditionalEmails, string, args->additional_emails_str);
		ret += 1;
	}
	if (args->city) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"City\":", args->city);
	   	ret += 1;
	}
	if (args->company_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CompanyName\":", args->company_name);
	   	ret += 1;
	}
	if (args->country) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Country\":", args->country);
	   	ret += 1;
	}
	if (args->customer_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CustomerId\":", args->customer_id);
	   	ret += 1;
	}
	if (args->email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Email\":", args->email);
	   	ret += 1;
	}
	if (args->first_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FirstName\":", args->first_name);
	   	ret += 1;
	}
	if (args->job_title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"JobTitle\":", args->job_title);
	   	ret += 1;
	}
	if (args->last_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastName\":", args->last_name);
	   	ret += 1;
	}
	if (args->mobile_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MobileNumber\":", args->mobile_number);
	   	ret += 1;
	}
	if (args->is_set_outscale_login_allowed) {
		ARG_TO_JSON(OutscaleLoginAllowed, bool, args->outscale_login_allowed);
	   	ret += 1;
	}
	if (args->phone_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PhoneNumber\":", args->phone_number);
	   	ret += 1;
	}
	if (args->state_province) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateProvince\":", args->state_province);
	   	ret += 1;
	}
	if (args->vat_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VatNumber\":", args->vat_number);
	   	ret += 1;
	}
	if (args->zip_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ZipCode\":", args->zip_code);
	   	ret += 1;
	}

	return !!ret;
}
static int actions_on_next_boot_setter(struct actions_on_next_boot *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->secure_boot) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecureBoot\":", args->secure_boot);
	   	ret += 1;
	}

	return !!ret;
}
static int api_access_policy_setter(struct api_access_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_max_access_key_expiration_seconds || args->max_access_key_expiration_seconds) {
		ARG_TO_JSON(MaxAccessKeyExpirationSeconds, int, args->max_access_key_expiration_seconds);
	   	ret += 1;
	}
	if (args->is_set_require_trusted_env) {
		ARG_TO_JSON(RequireTrustedEnv, bool, args->require_trusted_env);
	   	ret += 1;
	}

	return !!ret;
}
static int api_access_rule_setter(struct api_access_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_access_rule_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ApiAccessRuleId\":", args->api_access_rule_id);
	   	ret += 1;
	}
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->cns) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Cns\":[" ));
		for (as = args->cns; *as; ++as) {
			if (as != args->cns)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cns_str) {
		ARG_TO_JSON(Cns, string, args->cns_str);
		ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}

	return !!ret;
}
static int application_sticky_cookie_policy_setter(struct application_sticky_cookie_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->cookie_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CookieName\":", args->cookie_name);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}

	return !!ret;
}
static int backend_vm_health_setter(struct backend_vm_health *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->state_reason) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateReason\":", args->state_reason);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}

	return !!ret;
}
static int block_device_mapping_created_setter(struct block_device_mapping_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		ARG_TO_JSON(Bsu, string, args->bsu_str);
		ret += 1;
	} else if (args->is_set_bsu) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Bsu\": { " ));
	       STRY(bsu_created_setter(&args->bsu, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}

	return !!ret;
}
static int block_device_mapping_image_setter(struct block_device_mapping_image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		ARG_TO_JSON(Bsu, string, args->bsu_str);
		ret += 1;
	} else if (args->is_set_bsu) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Bsu\": { " ));
	       STRY(bsu_to_create_setter(&args->bsu, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualDeviceName\":", args->virtual_device_name);
	   	ret += 1;
	}

	return !!ret;
}
static int block_device_mapping_vm_creation_setter(struct block_device_mapping_vm_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		ARG_TO_JSON(Bsu, string, args->bsu_str);
		ret += 1;
	} else if (args->is_set_bsu) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Bsu\": { " ));
	       STRY(bsu_to_create_setter(&args->bsu, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->no_device) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NoDevice\":", args->no_device);
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualDeviceName\":", args->virtual_device_name);
	   	ret += 1;
	}

	return !!ret;
}
static int block_device_mapping_vm_update_setter(struct block_device_mapping_vm_update *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		ARG_TO_JSON(Bsu, string, args->bsu_str);
		ret += 1;
	} else if (args->is_set_bsu) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Bsu\": { " ));
	       STRY(bsu_to_update_vm_setter(&args->bsu, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->no_device) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NoDevice\":", args->no_device);
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualDeviceName\":", args->virtual_device_name);
	   	ret += 1;
	}

	return !!ret;
}
static int bsu_created_setter(struct bsu_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->link_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkDate\":", args->link_date);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}

	return !!ret;
}
static int bsu_to_create_setter(struct bsu_to_create *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		ARG_TO_JSON(Iops, int, args->iops);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		ARG_TO_JSON(VolumeSize, int, args->volume_size);
	   	ret += 1;
	}
	if (args->volume_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeType\":", args->volume_type);
	   	ret += 1;
	}

	return !!ret;
}
static int bsu_to_update_vm_setter(struct bsu_to_update_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}

	return !!ret;
}
static int ca_setter(struct ca *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ca_fingerprint) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaFingerprint\":", args->ca_fingerprint);
	   	ret += 1;
	}
	if (args->ca_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaId\":", args->ca_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}

	return !!ret;
}
static int catalog_setter(struct catalog *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->entries) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Entries\":[" ));
		for (int i = 0; i < args->nb_entries; ++i) {
	       	    struct catalog_entry *p = &args->entries[i];
		    if (p != args->entries)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(catalog_entry_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->entries_str) {
		ARG_TO_JSON(Entries, string, args->entries_str);
		ret += 1;
	}

	return !!ret;
}
static int catalog_entry_setter(struct catalog_entry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->category) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Category\":", args->category);
	   	ret += 1;
	}
	if (args->flags) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Flags\":", args->flags);
	   	ret += 1;
	}
	if (args->operation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Operation\":", args->operation);
	   	ret += 1;
	}
	if (args->service) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Service\":", args->service);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Title\":", args->title);
	   	ret += 1;
	}
	if (args->type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Type\":", args->type);
	   	ret += 1;
	}
	if (args->is_set_unit_price || args->unit_price) {
		ARG_TO_JSON(UnitPrice, double, args->unit_price);
	   	ret += 1;
	}

	return !!ret;
}
static int catalogs_setter(struct catalogs *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->entries) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Entries\":[" ));
		for (int i = 0; i < args->nb_entries; ++i) {
	       	    struct catalog_entry *p = &args->entries[i];
		    if (p != args->entries)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(catalog_entry_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->entries_str) {
		ARG_TO_JSON(Entries, string, args->entries_str);
		ret += 1;
	}
	if (args->from_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromDate\":", args->from_date);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->to_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToDate\":", args->to_date);
	   	ret += 1;
	}

	return !!ret;
}
static int client_gateway_setter(struct client_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bgp_asn || args->bgp_asn) {
		ARG_TO_JSON(BgpAsn, int, args->bgp_asn);
	   	ret += 1;
	}
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int consumption_entry_setter(struct consumption_entry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->category) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Category\":", args->category);
	   	ret += 1;
	}
	if (args->from_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromDate\":", args->from_date);
	   	ret += 1;
	}
	if (args->operation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Operation\":", args->operation);
	   	ret += 1;
	}
	if (args->paying_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PayingAccountId\":", args->paying_account_id);
	   	ret += 1;
	}
	if (args->is_set_price || args->price) {
		ARG_TO_JSON(Price, double, args->price);
	   	ret += 1;
	}
	if (args->service) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Service\":", args->service);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Title\":", args->title);
	   	ret += 1;
	}
	if (args->to_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToDate\":", args->to_date);
	   	ret += 1;
	}
	if (args->type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Type\":", args->type);
	   	ret += 1;
	}
	if (args->is_set_unit_price || args->unit_price) {
		ARG_TO_JSON(UnitPrice, double, args->unit_price);
	   	ret += 1;
	}
	if (args->is_set_value || args->value) {
		ARG_TO_JSON(Value, double, args->value);
	   	ret += 1;
	}

	return !!ret;
}
static int dedicated_group_setter(struct dedicated_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->is_set_cpu_generation || args->cpu_generation) {
		ARG_TO_JSON(CpuGeneration, int, args->cpu_generation);
	   	ret += 1;
	}
	if (args->dedicated_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DedicatedGroupId\":", args->dedicated_group_id);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int dhcp_options_set_setter(struct dhcp_options_set *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_default_arg) {
		ARG_TO_JSON(Default, bool, args->default_arg);
	   	ret += 1;
	}
	if (args->dhcp_options_set_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DhcpOptionsSetId\":", args->dhcp_options_set_id);
	   	ret += 1;
	}
	if (args->domain_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DomainName\":", args->domain_name);
	   	ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DomainNameServers\":[" ));
		for (as = args->domain_name_servers; *as; ++as) {
			if (as != args->domain_name_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->domain_name_servers_str) {
		ARG_TO_JSON(DomainNameServers, string, args->domain_name_servers_str);
		ret += 1;
	}
	if (args->log_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LogServers\":[" ));
		for (as = args->log_servers; *as; ++as) {
			if (as != args->log_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->log_servers_str) {
		ARG_TO_JSON(LogServers, string, args->log_servers_str);
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NtpServers\":[" ));
		for (as = args->ntp_servers; *as; ++as) {
			if (as != args->ntp_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ntp_servers_str) {
		ARG_TO_JSON(NtpServers, string, args->ntp_servers_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int direct_link_setter(struct direct_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->bandwidth) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Bandwidth\":", args->bandwidth);
	   	ret += 1;
	}
	if (args->direct_link_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkId\":", args->direct_link_id);
	   	ret += 1;
	}
	if (args->direct_link_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkName\":", args->direct_link_name);
	   	ret += 1;
	}
	if (args->location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Location\":", args->location);
	   	ret += 1;
	}
	if (args->region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RegionName\":", args->region_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}

	return !!ret;
}
static int direct_link_interface_setter(struct direct_link_interface *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bgp_asn || args->bgp_asn) {
		ARG_TO_JSON(BgpAsn, int, args->bgp_asn);
	   	ret += 1;
	}
	if (args->bgp_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BgpKey\":", args->bgp_key);
	   	ret += 1;
	}
	if (args->client_private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientPrivateIp\":", args->client_private_ip);
	   	ret += 1;
	}
	if (args->direct_link_interface_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceName\":", args->direct_link_interface_name);
	   	ret += 1;
	}
	if (args->outscale_private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OutscalePrivateIp\":", args->outscale_private_ip);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	if (args->is_set_vlan || args->vlan) {
		ARG_TO_JSON(Vlan, int, args->vlan);
	   	ret += 1;
	}

	return !!ret;
}
static int direct_link_interfaces_setter(struct direct_link_interfaces *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->is_set_bgp_asn || args->bgp_asn) {
		ARG_TO_JSON(BgpAsn, int, args->bgp_asn);
	   	ret += 1;
	}
	if (args->bgp_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BgpKey\":", args->bgp_key);
	   	ret += 1;
	}
	if (args->client_private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientPrivateIp\":", args->client_private_ip);
	   	ret += 1;
	}
	if (args->direct_link_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkId\":", args->direct_link_id);
	   	ret += 1;
	}
	if (args->direct_link_interface_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceId\":", args->direct_link_interface_id);
	   	ret += 1;
	}
	if (args->direct_link_interface_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceName\":", args->direct_link_interface_name);
	   	ret += 1;
	}
	if (args->interface_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InterfaceType\":", args->interface_type);
	   	ret += 1;
	}
	if (args->location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Location\":", args->location);
	   	ret += 1;
	}
	if (args->is_set_mtu || args->mtu) {
		ARG_TO_JSON(Mtu, int, args->mtu);
	   	ret += 1;
	}
	if (args->outscale_private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OutscalePrivateIp\":", args->outscale_private_ip);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	if (args->is_set_vlan || args->vlan) {
		ARG_TO_JSON(Vlan, int, args->vlan);
	   	ret += 1;
	}

	return !!ret;
}
static int errors_setter(struct errors *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Code\":", args->code);
	   	ret += 1;
	}
	if (args->details) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Details\":", args->details);
	   	ret += 1;
	}
	if (args->type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Type\":", args->type);
	   	ret += 1;
	}

	return !!ret;
}
static int filters_access_keys_setter(struct filters_access_keys *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccessKeyIds\":[" ));
		for (as = args->access_key_ids; *as; ++as) {
			if (as != args->access_key_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->access_key_ids_str) {
		ARG_TO_JSON(AccessKeyIds, string, args->access_key_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_api_access_rule_setter(struct filters_api_access_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_access_rule_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ApiAccessRuleIds\":[" ));
		for (as = args->api_access_rule_ids; *as; ++as) {
			if (as != args->api_access_rule_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->api_access_rule_ids_str) {
		ARG_TO_JSON(ApiAccessRuleIds, string, args->api_access_rule_ids_str);
		ret += 1;
	}
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->cns) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Cns\":[" ));
		for (as = args->cns; *as; ++as) {
			if (as != args->cns)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cns_str) {
		ARG_TO_JSON(Cns, string, args->cns_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_api_log_setter(struct filters_api_log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->query_access_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryAccessKeys\":[" ));
		for (as = args->query_access_keys; *as; ++as) {
			if (as != args->query_access_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_access_keys_str) {
		ARG_TO_JSON(QueryAccessKeys, string, args->query_access_keys_str);
		ret += 1;
	}
	if (args->query_api_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryApiNames\":[" ));
		for (as = args->query_api_names; *as; ++as) {
			if (as != args->query_api_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_api_names_str) {
		ARG_TO_JSON(QueryApiNames, string, args->query_api_names_str);
		ret += 1;
	}
	if (args->query_call_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryCallNames\":[" ));
		for (as = args->query_call_names; *as; ++as) {
			if (as != args->query_call_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_call_names_str) {
		ARG_TO_JSON(QueryCallNames, string, args->query_call_names_str);
		ret += 1;
	}
	if (args->query_date_after) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryDateAfter\":", args->query_date_after);
	   	ret += 1;
	}
	if (args->query_date_before) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryDateBefore\":", args->query_date_before);
	   	ret += 1;
	}
	if (args->query_ip_addresses) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryIpAddresses\":[" ));
		for (as = args->query_ip_addresses; *as; ++as) {
			if (as != args->query_ip_addresses)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_ip_addresses_str) {
		ARG_TO_JSON(QueryIpAddresses, string, args->query_ip_addresses_str);
		ret += 1;
	}
	if (args->query_user_agents) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryUserAgents\":[" ));
		for (as = args->query_user_agents; *as; ++as) {
			if (as != args->query_user_agents)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_user_agents_str) {
		ARG_TO_JSON(QueryUserAgents, string, args->query_user_agents_str);
		ret += 1;
	}
	if (args->request_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RequestIds\":[" ));
		for (as = args->request_ids; *as; ++as) {
			if (as != args->request_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->request_ids_str) {
		ARG_TO_JSON(RequestIds, string, args->request_ids_str);
		ret += 1;
	}
	if (args->response_status_codes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResponseStatusCodes\":[" ));
		for (ip = args->response_status_codes; *ip > 0; ++ip) {
			if (ip != args->response_status_codes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->response_status_codes_str) {
		ARG_TO_JSON(ResponseStatusCodes, string, args->response_status_codes_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_ca_setter(struct filters_ca *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ca_fingerprints) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaFingerprints\":[" ));
		for (as = args->ca_fingerprints; *as; ++as) {
			if (as != args->ca_fingerprints)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_fingerprints_str) {
		ARG_TO_JSON(CaFingerprints, string, args->ca_fingerprints_str);
		ret += 1;
	}
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_catalogs_setter(struct filters_catalogs *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_current_catalog_only) {
		ARG_TO_JSON(CurrentCatalogOnly, bool, args->current_catalog_only);
	   	ret += 1;
	}
	if (args->from_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromDate\":", args->from_date);
	   	ret += 1;
	}
	if (args->to_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToDate\":", args->to_date);
	   	ret += 1;
	}

	return !!ret;
}
static int filters_client_gateway_setter(struct filters_client_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bgp_asns) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BgpAsns\":[" ));
		for (ip = args->bgp_asns; *ip > 0; ++ip) {
			if (ip != args->bgp_asns)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->bgp_asns_str) {
		ARG_TO_JSON(BgpAsns, string, args->bgp_asns_str);
		ret += 1;
	}
	if (args->client_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientGatewayIds\":[" ));
		for (as = args->client_gateway_ids; *as; ++as) {
			if (as != args->client_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_gateway_ids_str) {
		ARG_TO_JSON(ClientGatewayIds, string, args->client_gateway_ids_str);
		ret += 1;
	}
	if (args->connection_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ConnectionTypes\":[" ));
		for (as = args->connection_types; *as; ++as) {
			if (as != args->connection_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->connection_types_str) {
		ARG_TO_JSON(ConnectionTypes, string, args->connection_types_str);
		ret += 1;
	}
	if (args->public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIps\":[" ));
		for (as = args->public_ips; *as; ++as) {
			if (as != args->public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->public_ips_str) {
		ARG_TO_JSON(PublicIps, string, args->public_ips_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_dedicated_group_setter(struct filters_dedicated_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->cpu_generations) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CpuGenerations\":[" ));
		for (ip = args->cpu_generations; *ip > 0; ++ip) {
			if (ip != args->cpu_generations)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cpu_generations_str) {
		ARG_TO_JSON(CpuGenerations, string, args->cpu_generations_str);
		ret += 1;
	}
	if (args->dedicated_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DedicatedGroupIds\":[" ));
		for (as = args->dedicated_group_ids; *as; ++as) {
			if (as != args->dedicated_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->dedicated_group_ids_str) {
		ARG_TO_JSON(DedicatedGroupIds, string, args->dedicated_group_ids_str);
		ret += 1;
	}
	if (args->names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Names\":[" ));
		for (as = args->names; *as; ++as) {
			if (as != args->names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->names_str) {
		ARG_TO_JSON(Names, string, args->names_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_dhcp_options_setter(struct filters_dhcp_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_default_arg) {
		ARG_TO_JSON(Default, bool, args->default_arg);
	   	ret += 1;
	}
	if (args->dhcp_options_set_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DhcpOptionsSetIds\":[" ));
		for (as = args->dhcp_options_set_ids; *as; ++as) {
			if (as != args->dhcp_options_set_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->dhcp_options_set_ids_str) {
		ARG_TO_JSON(DhcpOptionsSetIds, string, args->dhcp_options_set_ids_str);
		ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DomainNameServers\":[" ));
		for (as = args->domain_name_servers; *as; ++as) {
			if (as != args->domain_name_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->domain_name_servers_str) {
		ARG_TO_JSON(DomainNameServers, string, args->domain_name_servers_str);
		ret += 1;
	}
	if (args->domain_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DomainNames\":[" ));
		for (as = args->domain_names; *as; ++as) {
			if (as != args->domain_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->domain_names_str) {
		ARG_TO_JSON(DomainNames, string, args->domain_names_str);
		ret += 1;
	}
	if (args->log_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LogServers\":[" ));
		for (as = args->log_servers; *as; ++as) {
			if (as != args->log_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->log_servers_str) {
		ARG_TO_JSON(LogServers, string, args->log_servers_str);
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NtpServers\":[" ));
		for (as = args->ntp_servers; *as; ++as) {
			if (as != args->ntp_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ntp_servers_str) {
		ARG_TO_JSON(NtpServers, string, args->ntp_servers_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_direct_link_setter(struct filters_direct_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->direct_link_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DirectLinkIds\":[" ));
		for (as = args->direct_link_ids; *as; ++as) {
			if (as != args->direct_link_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->direct_link_ids_str) {
		ARG_TO_JSON(DirectLinkIds, string, args->direct_link_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_direct_link_interface_setter(struct filters_direct_link_interface *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->direct_link_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DirectLinkIds\":[" ));
		for (as = args->direct_link_ids; *as; ++as) {
			if (as != args->direct_link_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->direct_link_ids_str) {
		ARG_TO_JSON(DirectLinkIds, string, args->direct_link_ids_str);
		ret += 1;
	}
	if (args->direct_link_interface_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DirectLinkInterfaceIds\":[" ));
		for (as = args->direct_link_interface_ids; *as; ++as) {
			if (as != args->direct_link_interface_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->direct_link_interface_ids_str) {
		ARG_TO_JSON(DirectLinkInterfaceIds, string, args->direct_link_interface_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_export_task_setter(struct filters_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->task_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TaskIds\":[" ));
		for (as = args->task_ids; *as; ++as) {
			if (as != args->task_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->task_ids_str) {
		ARG_TO_JSON(TaskIds, string, args->task_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_flexible_gpu_setter(struct filters_flexible_gpu *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->flexible_gpu_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"FlexibleGpuIds\":[" ));
		for (as = args->flexible_gpu_ids; *as; ++as) {
			if (as != args->flexible_gpu_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->flexible_gpu_ids_str) {
		ARG_TO_JSON(FlexibleGpuIds, string, args->flexible_gpu_ids_str);
		ret += 1;
	}
	if (args->generations) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Generations\":[" ));
		for (as = args->generations; *as; ++as) {
			if (as != args->generations)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->generations_str) {
		ARG_TO_JSON(Generations, string, args->generations_str);
		ret += 1;
	}
	if (args->model_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ModelNames\":[" ));
		for (as = args->model_names; *as; ++as) {
			if (as != args->model_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->model_names_str) {
		ARG_TO_JSON(ModelNames, string, args->model_names_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_image_setter(struct filters_image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_aliases) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountAliases\":[" ));
		for (as = args->account_aliases; *as; ++as) {
			if (as != args->account_aliases)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_aliases_str) {
		ARG_TO_JSON(AccountAliases, string, args->account_aliases_str);
		ret += 1;
	}
	if (args->account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountIds\":[" ));
		for (as = args->account_ids; *as; ++as) {
			if (as != args->account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_ids_str) {
		ARG_TO_JSON(AccountIds, string, args->account_ids_str);
		ret += 1;
	}
	if (args->architectures) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Architectures\":[" ));
		for (as = args->architectures; *as; ++as) {
			if (as != args->architectures)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->architectures_str) {
		ARG_TO_JSON(Architectures, string, args->architectures_str);
		ret += 1;
	}
	if (args->is_set_block_device_mapping_delete_on_vm_deletion) {
		ARG_TO_JSON(BlockDeviceMappingDeleteOnVmDeletion, bool, args->block_device_mapping_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->block_device_mapping_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingDeviceNames\":[" ));
		for (as = args->block_device_mapping_device_names; *as; ++as) {
			if (as != args->block_device_mapping_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_device_names_str) {
		ARG_TO_JSON(BlockDeviceMappingDeviceNames, string, args->block_device_mapping_device_names_str);
		ret += 1;
	}
	if (args->block_device_mapping_snapshot_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingSnapshotIds\":[" ));
		for (as = args->block_device_mapping_snapshot_ids; *as; ++as) {
			if (as != args->block_device_mapping_snapshot_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_snapshot_ids_str) {
		ARG_TO_JSON(BlockDeviceMappingSnapshotIds, string, args->block_device_mapping_snapshot_ids_str);
		ret += 1;
	}
	if (args->block_device_mapping_volume_sizes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingVolumeSizes\":[" ));
		for (ip = args->block_device_mapping_volume_sizes; *ip > 0; ++ip) {
			if (ip != args->block_device_mapping_volume_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_volume_sizes_str) {
		ARG_TO_JSON(BlockDeviceMappingVolumeSizes, string, args->block_device_mapping_volume_sizes_str);
		ret += 1;
	}
	if (args->block_device_mapping_volume_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingVolumeTypes\":[" ));
		for (as = args->block_device_mapping_volume_types; *as; ++as) {
			if (as != args->block_device_mapping_volume_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_volume_types_str) {
		ARG_TO_JSON(BlockDeviceMappingVolumeTypes, string, args->block_device_mapping_volume_types_str);
		ret += 1;
	}
	if (args->boot_modes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BootModes\":[" ));
		for (as = args->boot_modes; *as; ++as) {
			if (as != args->boot_modes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->boot_modes_str) {
		ARG_TO_JSON(BootModes, string, args->boot_modes_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->file_locations) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"FileLocations\":[" ));
		for (as = args->file_locations; *as; ++as) {
			if (as != args->file_locations)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->file_locations_str) {
		ARG_TO_JSON(FileLocations, string, args->file_locations_str);
		ret += 1;
	}
	if (args->hypervisors) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Hypervisors\":[" ));
		for (as = args->hypervisors; *as; ++as) {
			if (as != args->hypervisors)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->hypervisors_str) {
		ARG_TO_JSON(Hypervisors, string, args->hypervisors_str);
		ret += 1;
	}
	if (args->image_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ImageIds\":[" ));
		for (as = args->image_ids; *as; ++as) {
			if (as != args->image_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->image_ids_str) {
		ARG_TO_JSON(ImageIds, string, args->image_ids_str);
		ret += 1;
	}
	if (args->image_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ImageNames\":[" ));
		for (as = args->image_names; *as; ++as) {
			if (as != args->image_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->image_names_str) {
		ARG_TO_JSON(ImageNames, string, args->image_names_str);
		ret += 1;
	}
	if (args->permissions_to_launch_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PermissionsToLaunchAccountIds\":[" ));
		for (as = args->permissions_to_launch_account_ids; *as; ++as) {
			if (as != args->permissions_to_launch_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->permissions_to_launch_account_ids_str) {
		ARG_TO_JSON(PermissionsToLaunchAccountIds, string, args->permissions_to_launch_account_ids_str);
		ret += 1;
	}
	if (args->is_set_permissions_to_launch_global_permission) {
		ARG_TO_JSON(PermissionsToLaunchGlobalPermission, bool, args->permissions_to_launch_global_permission);
	   	ret += 1;
	}
	if (args->product_code_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodeNames\":[" ));
		for (as = args->product_code_names; *as; ++as) {
			if (as != args->product_code_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_code_names_str) {
		ARG_TO_JSON(ProductCodeNames, string, args->product_code_names_str);
		ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->root_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RootDeviceNames\":[" ));
		for (as = args->root_device_names; *as; ++as) {
			if (as != args->root_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->root_device_names_str) {
		ARG_TO_JSON(RootDeviceNames, string, args->root_device_names_str);
		ret += 1;
	}
	if (args->root_device_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RootDeviceTypes\":[" ));
		for (as = args->root_device_types; *as; ++as) {
			if (as != args->root_device_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->root_device_types_str) {
		ARG_TO_JSON(RootDeviceTypes, string, args->root_device_types_str);
		ret += 1;
	}
	if (args->is_set_secure_boot) {
		ARG_TO_JSON(SecureBoot, bool, args->secure_boot);
	   	ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->virtualization_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VirtualizationTypes\":[" ));
		for (as = args->virtualization_types; *as; ++as) {
			if (as != args->virtualization_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->virtualization_types_str) {
		ARG_TO_JSON(VirtualizationTypes, string, args->virtualization_types_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_internet_service_setter(struct filters_internet_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->internet_service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InternetServiceIds\":[" ));
		for (as = args->internet_service_ids; *as; ++as) {
			if (as != args->internet_service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->internet_service_ids_str) {
		ARG_TO_JSON(InternetServiceIds, string, args->internet_service_ids_str);
		ret += 1;
	}
	if (args->link_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNetIds\":[" ));
		for (as = args->link_net_ids; *as; ++as) {
			if (as != args->link_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_net_ids_str) {
		ARG_TO_JSON(LinkNetIds, string, args->link_net_ids_str);
		ret += 1;
	}
	if (args->link_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkStates\":[" ));
		for (as = args->link_states; *as; ++as) {
			if (as != args->link_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_states_str) {
		ARG_TO_JSON(LinkStates, string, args->link_states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_keypair_setter(struct filters_keypair *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprints) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairFingerprints\":[" ));
		for (as = args->keypair_fingerprints; *as; ++as) {
			if (as != args->keypair_fingerprints)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_fingerprints_str) {
		ARG_TO_JSON(KeypairFingerprints, string, args->keypair_fingerprints_str);
		ret += 1;
	}
	if (args->keypair_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairIds\":[" ));
		for (as = args->keypair_ids; *as; ++as) {
			if (as != args->keypair_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_ids_str) {
		ARG_TO_JSON(KeypairIds, string, args->keypair_ids_str);
		ret += 1;
	}
	if (args->keypair_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairNames\":[" ));
		for (as = args->keypair_names; *as; ++as) {
			if (as != args->keypair_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_names_str) {
		ARG_TO_JSON(KeypairNames, string, args->keypair_names_str);
		ret += 1;
	}
	if (args->keypair_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairTypes\":[" ));
		for (as = args->keypair_types; *as; ++as) {
			if (as != args->keypair_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_types_str) {
		ARG_TO_JSON(KeypairTypes, string, args->keypair_types_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_listener_rule_setter(struct filters_listener_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->listener_rule_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ListenerRuleNames\":[" ));
		for (as = args->listener_rule_names; *as; ++as) {
			if (as != args->listener_rule_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->listener_rule_names_str) {
		ARG_TO_JSON(ListenerRuleNames, string, args->listener_rule_names_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_load_balancer_setter(struct filters_load_balancer *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->load_balancer_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerNames\":[" ));
		for (as = args->load_balancer_names; *as; ++as) {
			if (as != args->load_balancer_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_names_str) {
		ARG_TO_JSON(LoadBalancerNames, string, args->load_balancer_names_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_nat_service_setter(struct filters_nat_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->client_tokens) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientTokens\":[" ));
		for (as = args->client_tokens; *as; ++as) {
			if (as != args->client_tokens)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_tokens_str) {
		ARG_TO_JSON(ClientTokens, string, args->client_tokens_str);
		ret += 1;
	}
	if (args->nat_service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NatServiceIds\":[" ));
		for (as = args->nat_service_ids; *as; ++as) {
			if (as != args->nat_service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nat_service_ids_str) {
		ARG_TO_JSON(NatServiceIds, string, args->nat_service_ids_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_net_setter(struct filters_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dhcp_options_set_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DhcpOptionsSetIds\":[" ));
		for (as = args->dhcp_options_set_ids; *as; ++as) {
			if (as != args->dhcp_options_set_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->dhcp_options_set_ids_str) {
		ARG_TO_JSON(DhcpOptionsSetIds, string, args->dhcp_options_set_ids_str);
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	if (args->is_set_is_default) {
		ARG_TO_JSON(IsDefault, bool, args->is_default);
	   	ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_net_access_point_setter(struct filters_net_access_point *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_access_point_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetAccessPointIds\":[" ));
		for (as = args->net_access_point_ids; *as; ++as) {
			if (as != args->net_access_point_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_access_point_ids_str) {
		ARG_TO_JSON(NetAccessPointIds, string, args->net_access_point_ids_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->service_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ServiceNames\":[" ));
		for (as = args->service_names; *as; ++as) {
			if (as != args->service_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->service_names_str) {
		ARG_TO_JSON(ServiceNames, string, args->service_names_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_net_peering_setter(struct filters_net_peering *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->accepter_net_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccepterNetAccountIds\":[" ));
		for (as = args->accepter_net_account_ids; *as; ++as) {
			if (as != args->accepter_net_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->accepter_net_account_ids_str) {
		ARG_TO_JSON(AccepterNetAccountIds, string, args->accepter_net_account_ids_str);
		ret += 1;
	}
	if (args->accepter_net_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccepterNetIpRanges\":[" ));
		for (as = args->accepter_net_ip_ranges; *as; ++as) {
			if (as != args->accepter_net_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->accepter_net_ip_ranges_str) {
		ARG_TO_JSON(AccepterNetIpRanges, string, args->accepter_net_ip_ranges_str);
		ret += 1;
	}
	if (args->accepter_net_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccepterNetNetIds\":[" ));
		for (as = args->accepter_net_net_ids; *as; ++as) {
			if (as != args->accepter_net_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->accepter_net_net_ids_str) {
		ARG_TO_JSON(AccepterNetNetIds, string, args->accepter_net_net_ids_str);
		ret += 1;
	}
	if (args->expiration_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ExpirationDates\":[" ));
		for (as = args->expiration_dates; *as; ++as) {
			if (as != args->expiration_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->expiration_dates_str) {
		ARG_TO_JSON(ExpirationDates, string, args->expiration_dates_str);
		ret += 1;
	}
	if (args->net_peering_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetPeeringIds\":[" ));
		for (as = args->net_peering_ids; *as; ++as) {
			if (as != args->net_peering_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_peering_ids_str) {
		ARG_TO_JSON(NetPeeringIds, string, args->net_peering_ids_str);
		ret += 1;
	}
	if (args->source_net_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SourceNetAccountIds\":[" ));
		for (as = args->source_net_account_ids; *as; ++as) {
			if (as != args->source_net_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->source_net_account_ids_str) {
		ARG_TO_JSON(SourceNetAccountIds, string, args->source_net_account_ids_str);
		ret += 1;
	}
	if (args->source_net_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SourceNetIpRanges\":[" ));
		for (as = args->source_net_ip_ranges; *as; ++as) {
			if (as != args->source_net_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->source_net_ip_ranges_str) {
		ARG_TO_JSON(SourceNetIpRanges, string, args->source_net_ip_ranges_str);
		ret += 1;
	}
	if (args->source_net_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SourceNetNetIds\":[" ));
		for (as = args->source_net_net_ids; *as; ++as) {
			if (as != args->source_net_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->source_net_net_ids_str) {
		ARG_TO_JSON(SourceNetNetIds, string, args->source_net_net_ids_str);
		ret += 1;
	}
	if (args->state_messages) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateMessages\":[" ));
		for (as = args->state_messages; *as; ++as) {
			if (as != args->state_messages)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_messages_str) {
		ARG_TO_JSON(StateMessages, string, args->state_messages_str);
		ret += 1;
	}
	if (args->state_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateNames\":[" ));
		for (as = args->state_names; *as; ++as) {
			if (as != args->state_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_names_str) {
		ARG_TO_JSON(StateNames, string, args->state_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_nic_setter(struct filters_nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->is_set_is_source_dest_check) {
		ARG_TO_JSON(IsSourceDestCheck, bool, args->is_source_dest_check);
	   	ret += 1;
	}
	if (args->is_set_link_nic_delete_on_vm_deletion) {
		ARG_TO_JSON(LinkNicDeleteOnVmDeletion, bool, args->link_nic_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->link_nic_device_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicDeviceNumbers\":[" ));
		for (ip = args->link_nic_device_numbers; *ip > 0; ++ip) {
			if (ip != args->link_nic_device_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_device_numbers_str) {
		ARG_TO_JSON(LinkNicDeviceNumbers, string, args->link_nic_device_numbers_str);
		ret += 1;
	}
	if (args->link_nic_link_nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicLinkNicIds\":[" ));
		for (as = args->link_nic_link_nic_ids; *as; ++as) {
			if (as != args->link_nic_link_nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_link_nic_ids_str) {
		ARG_TO_JSON(LinkNicLinkNicIds, string, args->link_nic_link_nic_ids_str);
		ret += 1;
	}
	if (args->link_nic_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicStates\":[" ));
		for (as = args->link_nic_states; *as; ++as) {
			if (as != args->link_nic_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_states_str) {
		ARG_TO_JSON(LinkNicStates, string, args->link_nic_states_str);
		ret += 1;
	}
	if (args->link_nic_vm_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicVmAccountIds\":[" ));
		for (as = args->link_nic_vm_account_ids; *as; ++as) {
			if (as != args->link_nic_vm_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_vm_account_ids_str) {
		ARG_TO_JSON(LinkNicVmAccountIds, string, args->link_nic_vm_account_ids_str);
		ret += 1;
	}
	if (args->link_nic_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicVmIds\":[" ));
		for (as = args->link_nic_vm_ids; *as; ++as) {
			if (as != args->link_nic_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_vm_ids_str) {
		ARG_TO_JSON(LinkNicVmIds, string, args->link_nic_vm_ids_str);
		ret += 1;
	}
	if (args->link_public_ip_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpAccountIds\":[" ));
		for (as = args->link_public_ip_account_ids; *as; ++as) {
			if (as != args->link_public_ip_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_account_ids_str) {
		ARG_TO_JSON(LinkPublicIpAccountIds, string, args->link_public_ip_account_ids_str);
		ret += 1;
	}
	if (args->link_public_ip_link_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpLinkPublicIpIds\":[" ));
		for (as = args->link_public_ip_link_public_ip_ids; *as; ++as) {
			if (as != args->link_public_ip_link_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_link_public_ip_ids_str) {
		ARG_TO_JSON(LinkPublicIpLinkPublicIpIds, string, args->link_public_ip_link_public_ip_ids_str);
		ret += 1;
	}
	if (args->link_public_ip_public_dns_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpPublicDnsNames\":[" ));
		for (as = args->link_public_ip_public_dns_names; *as; ++as) {
			if (as != args->link_public_ip_public_dns_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_public_dns_names_str) {
		ARG_TO_JSON(LinkPublicIpPublicDnsNames, string, args->link_public_ip_public_dns_names_str);
		ret += 1;
	}
	if (args->link_public_ip_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpPublicIpIds\":[" ));
		for (as = args->link_public_ip_public_ip_ids; *as; ++as) {
			if (as != args->link_public_ip_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_public_ip_ids_str) {
		ARG_TO_JSON(LinkPublicIpPublicIpIds, string, args->link_public_ip_public_ip_ids_str);
		ret += 1;
	}
	if (args->link_public_ip_public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpPublicIps\":[" ));
		for (as = args->link_public_ip_public_ips; *as; ++as) {
			if (as != args->link_public_ip_public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_public_ips_str) {
		ARG_TO_JSON(LinkPublicIpPublicIps, string, args->link_public_ip_public_ips_str);
		ret += 1;
	}
	if (args->mac_addresses) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MacAddresses\":[" ));
		for (as = args->mac_addresses; *as; ++as) {
			if (as != args->mac_addresses)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->mac_addresses_str) {
		ARG_TO_JSON(MacAddresses, string, args->mac_addresses_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicIds\":[" ));
		for (as = args->nic_ids; *as; ++as) {
			if (as != args->nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_ids_str) {
		ARG_TO_JSON(NicIds, string, args->nic_ids_str);
		ret += 1;
	}
	if (args->private_dns_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateDnsNames\":[" ));
		for (as = args->private_dns_names; *as; ++as) {
			if (as != args->private_dns_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_dns_names_str) {
		ARG_TO_JSON(PrivateDnsNames, string, args->private_dns_names_str);
		ret += 1;
	}
	if (args->private_ips_link_public_ip_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIpsLinkPublicIpAccountIds\":[" ));
		for (as = args->private_ips_link_public_ip_account_ids; *as; ++as) {
			if (as != args->private_ips_link_public_ip_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_link_public_ip_account_ids_str) {
		ARG_TO_JSON(PrivateIpsLinkPublicIpAccountIds, string, args->private_ips_link_public_ip_account_ids_str);
		ret += 1;
	}
	if (args->private_ips_link_public_ip_public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIpsLinkPublicIpPublicIps\":[" ));
		for (as = args->private_ips_link_public_ip_public_ips; *as; ++as) {
			if (as != args->private_ips_link_public_ip_public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_link_public_ip_public_ips_str) {
		ARG_TO_JSON(PrivateIpsLinkPublicIpPublicIps, string, args->private_ips_link_public_ip_public_ips_str);
		ret += 1;
	}
	if (args->is_set_private_ips_primary_ip) {
		ARG_TO_JSON(PrivateIpsPrimaryIp, bool, args->private_ips_primary_ip);
	   	ret += 1;
	}
	if (args->private_ips_private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIpsPrivateIps\":[" ));
		for (as = args->private_ips_private_ips; *as; ++as) {
			if (as != args->private_ips_private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_private_ips_str) {
		ARG_TO_JSON(PrivateIpsPrivateIps, string, args->private_ips_private_ips_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupNames\":[" ));
		for (as = args->security_group_names; *as; ++as) {
			if (as != args->security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_names_str) {
		ARG_TO_JSON(SecurityGroupNames, string, args->security_group_names_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_product_type_setter(struct filters_product_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->product_type_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductTypeIds\":[" ));
		for (as = args->product_type_ids; *as; ++as) {
			if (as != args->product_type_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_type_ids_str) {
		ARG_TO_JSON(ProductTypeIds, string, args->product_type_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_public_ip_setter(struct filters_public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpIds\":[" ));
		for (as = args->link_public_ip_ids; *as; ++as) {
			if (as != args->link_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_ids_str) {
		ARG_TO_JSON(LinkPublicIpIds, string, args->link_public_ip_ids_str);
		ret += 1;
	}
	if (args->nic_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicAccountIds\":[" ));
		for (as = args->nic_account_ids; *as; ++as) {
			if (as != args->nic_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_account_ids_str) {
		ARG_TO_JSON(NicAccountIds, string, args->nic_account_ids_str);
		ret += 1;
	}
	if (args->nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicIds\":[" ));
		for (as = args->nic_ids; *as; ++as) {
			if (as != args->nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_ids_str) {
		ARG_TO_JSON(NicIds, string, args->nic_ids_str);
		ret += 1;
	}
	if (args->placements) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Placements\":[" ));
		for (as = args->placements; *as; ++as) {
			if (as != args->placements)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->placements_str) {
		ARG_TO_JSON(Placements, string, args->placements_str);
		ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIpIds\":[" ));
		for (as = args->public_ip_ids; *as; ++as) {
			if (as != args->public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->public_ip_ids_str) {
		ARG_TO_JSON(PublicIpIds, string, args->public_ip_ids_str);
		ret += 1;
	}
	if (args->public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIps\":[" ));
		for (as = args->public_ips; *as; ++as) {
			if (as != args->public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->public_ips_str) {
		ARG_TO_JSON(PublicIps, string, args->public_ips_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_quota_setter(struct filters_quota *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->collections) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Collections\":[" ));
		for (as = args->collections; *as; ++as) {
			if (as != args->collections)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->collections_str) {
		ARG_TO_JSON(Collections, string, args->collections_str);
		ret += 1;
	}
	if (args->quota_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QuotaNames\":[" ));
		for (as = args->quota_names; *as; ++as) {
			if (as != args->quota_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->quota_names_str) {
		ARG_TO_JSON(QuotaNames, string, args->quota_names_str);
		ret += 1;
	}
	if (args->quota_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QuotaTypes\":[" ));
		for (as = args->quota_types; *as; ++as) {
			if (as != args->quota_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->quota_types_str) {
		ARG_TO_JSON(QuotaTypes, string, args->quota_types_str);
		ret += 1;
	}
	if (args->short_descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ShortDescriptions\":[" ));
		for (as = args->short_descriptions; *as; ++as) {
			if (as != args->short_descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->short_descriptions_str) {
		ARG_TO_JSON(ShortDescriptions, string, args->short_descriptions_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_route_table_setter(struct filters_route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkRouteTableIds\":[" ));
		for (as = args->link_route_table_ids; *as; ++as) {
			if (as != args->link_route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_route_table_ids_str) {
		ARG_TO_JSON(LinkRouteTableIds, string, args->link_route_table_ids_str);
		ret += 1;
	}
	if (args->link_route_table_link_route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkRouteTableLinkRouteTableIds\":[" ));
		for (as = args->link_route_table_link_route_table_ids; *as; ++as) {
			if (as != args->link_route_table_link_route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_route_table_link_route_table_ids_str) {
		ARG_TO_JSON(LinkRouteTableLinkRouteTableIds, string, args->link_route_table_link_route_table_ids_str);
		ret += 1;
	}
	if (args->is_set_link_route_table_main) {
		ARG_TO_JSON(LinkRouteTableMain, bool, args->link_route_table_main);
	   	ret += 1;
	}
	if (args->link_subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkSubnetIds\":[" ));
		for (as = args->link_subnet_ids; *as; ++as) {
			if (as != args->link_subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_subnet_ids_str) {
		ARG_TO_JSON(LinkSubnetIds, string, args->link_subnet_ids_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->route_creation_methods) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteCreationMethods\":[" ));
		for (as = args->route_creation_methods; *as; ++as) {
			if (as != args->route_creation_methods)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_creation_methods_str) {
		ARG_TO_JSON(RouteCreationMethods, string, args->route_creation_methods_str);
		ret += 1;
	}
	if (args->route_destination_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteDestinationIpRanges\":[" ));
		for (as = args->route_destination_ip_ranges; *as; ++as) {
			if (as != args->route_destination_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_destination_ip_ranges_str) {
		ARG_TO_JSON(RouteDestinationIpRanges, string, args->route_destination_ip_ranges_str);
		ret += 1;
	}
	if (args->route_destination_service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteDestinationServiceIds\":[" ));
		for (as = args->route_destination_service_ids; *as; ++as) {
			if (as != args->route_destination_service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_destination_service_ids_str) {
		ARG_TO_JSON(RouteDestinationServiceIds, string, args->route_destination_service_ids_str);
		ret += 1;
	}
	if (args->route_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteGatewayIds\":[" ));
		for (as = args->route_gateway_ids; *as; ++as) {
			if (as != args->route_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_gateway_ids_str) {
		ARG_TO_JSON(RouteGatewayIds, string, args->route_gateway_ids_str);
		ret += 1;
	}
	if (args->route_nat_service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteNatServiceIds\":[" ));
		for (as = args->route_nat_service_ids; *as; ++as) {
			if (as != args->route_nat_service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_nat_service_ids_str) {
		ARG_TO_JSON(RouteNatServiceIds, string, args->route_nat_service_ids_str);
		ret += 1;
	}
	if (args->route_net_peering_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteNetPeeringIds\":[" ));
		for (as = args->route_net_peering_ids; *as; ++as) {
			if (as != args->route_net_peering_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_net_peering_ids_str) {
		ARG_TO_JSON(RouteNetPeeringIds, string, args->route_net_peering_ids_str);
		ret += 1;
	}
	if (args->route_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteStates\":[" ));
		for (as = args->route_states; *as; ++as) {
			if (as != args->route_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_states_str) {
		ARG_TO_JSON(RouteStates, string, args->route_states_str);
		ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteTableIds\":[" ));
		for (as = args->route_table_ids; *as; ++as) {
			if (as != args->route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_table_ids_str) {
		ARG_TO_JSON(RouteTableIds, string, args->route_table_ids_str);
		ret += 1;
	}
	if (args->route_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteVmIds\":[" ));
		for (as = args->route_vm_ids; *as; ++as) {
			if (as != args->route_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_vm_ids_str) {
		ARG_TO_JSON(RouteVmIds, string, args->route_vm_ids_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_security_group_setter(struct filters_security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->inbound_rule_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleAccountIds\":[" ));
		for (as = args->inbound_rule_account_ids; *as; ++as) {
			if (as != args->inbound_rule_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_account_ids_str) {
		ARG_TO_JSON(InboundRuleAccountIds, string, args->inbound_rule_account_ids_str);
		ret += 1;
	}
	if (args->inbound_rule_from_port_ranges) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleFromPortRanges\":[" ));
		for (ip = args->inbound_rule_from_port_ranges; *ip > 0; ++ip) {
			if (ip != args->inbound_rule_from_port_ranges)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_from_port_ranges_str) {
		ARG_TO_JSON(InboundRuleFromPortRanges, string, args->inbound_rule_from_port_ranges_str);
		ret += 1;
	}
	if (args->inbound_rule_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleIpRanges\":[" ));
		for (as = args->inbound_rule_ip_ranges; *as; ++as) {
			if (as != args->inbound_rule_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_ip_ranges_str) {
		ARG_TO_JSON(InboundRuleIpRanges, string, args->inbound_rule_ip_ranges_str);
		ret += 1;
	}
	if (args->inbound_rule_protocols) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleProtocols\":[" ));
		for (as = args->inbound_rule_protocols; *as; ++as) {
			if (as != args->inbound_rule_protocols)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_protocols_str) {
		ARG_TO_JSON(InboundRuleProtocols, string, args->inbound_rule_protocols_str);
		ret += 1;
	}
	if (args->inbound_rule_security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleSecurityGroupIds\":[" ));
		for (as = args->inbound_rule_security_group_ids; *as; ++as) {
			if (as != args->inbound_rule_security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_security_group_ids_str) {
		ARG_TO_JSON(InboundRuleSecurityGroupIds, string, args->inbound_rule_security_group_ids_str);
		ret += 1;
	}
	if (args->inbound_rule_security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleSecurityGroupNames\":[" ));
		for (as = args->inbound_rule_security_group_names; *as; ++as) {
			if (as != args->inbound_rule_security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_security_group_names_str) {
		ARG_TO_JSON(InboundRuleSecurityGroupNames, string, args->inbound_rule_security_group_names_str);
		ret += 1;
	}
	if (args->inbound_rule_to_port_ranges) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleToPortRanges\":[" ));
		for (ip = args->inbound_rule_to_port_ranges; *ip > 0; ++ip) {
			if (ip != args->inbound_rule_to_port_ranges)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_to_port_ranges_str) {
		ARG_TO_JSON(InboundRuleToPortRanges, string, args->inbound_rule_to_port_ranges_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->outbound_rule_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleAccountIds\":[" ));
		for (as = args->outbound_rule_account_ids; *as; ++as) {
			if (as != args->outbound_rule_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_account_ids_str) {
		ARG_TO_JSON(OutboundRuleAccountIds, string, args->outbound_rule_account_ids_str);
		ret += 1;
	}
	if (args->outbound_rule_from_port_ranges) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleFromPortRanges\":[" ));
		for (ip = args->outbound_rule_from_port_ranges; *ip > 0; ++ip) {
			if (ip != args->outbound_rule_from_port_ranges)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_from_port_ranges_str) {
		ARG_TO_JSON(OutboundRuleFromPortRanges, string, args->outbound_rule_from_port_ranges_str);
		ret += 1;
	}
	if (args->outbound_rule_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleIpRanges\":[" ));
		for (as = args->outbound_rule_ip_ranges; *as; ++as) {
			if (as != args->outbound_rule_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_ip_ranges_str) {
		ARG_TO_JSON(OutboundRuleIpRanges, string, args->outbound_rule_ip_ranges_str);
		ret += 1;
	}
	if (args->outbound_rule_protocols) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleProtocols\":[" ));
		for (as = args->outbound_rule_protocols; *as; ++as) {
			if (as != args->outbound_rule_protocols)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_protocols_str) {
		ARG_TO_JSON(OutboundRuleProtocols, string, args->outbound_rule_protocols_str);
		ret += 1;
	}
	if (args->outbound_rule_security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleSecurityGroupIds\":[" ));
		for (as = args->outbound_rule_security_group_ids; *as; ++as) {
			if (as != args->outbound_rule_security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_security_group_ids_str) {
		ARG_TO_JSON(OutboundRuleSecurityGroupIds, string, args->outbound_rule_security_group_ids_str);
		ret += 1;
	}
	if (args->outbound_rule_security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleSecurityGroupNames\":[" ));
		for (as = args->outbound_rule_security_group_names; *as; ++as) {
			if (as != args->outbound_rule_security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_security_group_names_str) {
		ARG_TO_JSON(OutboundRuleSecurityGroupNames, string, args->outbound_rule_security_group_names_str);
		ret += 1;
	}
	if (args->outbound_rule_to_port_ranges) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleToPortRanges\":[" ));
		for (ip = args->outbound_rule_to_port_ranges; *ip > 0; ++ip) {
			if (ip != args->outbound_rule_to_port_ranges)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_to_port_ranges_str) {
		ARG_TO_JSON(OutboundRuleToPortRanges, string, args->outbound_rule_to_port_ranges_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupNames\":[" ));
		for (as = args->security_group_names; *as; ++as) {
			if (as != args->security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_names_str) {
		ARG_TO_JSON(SecurityGroupNames, string, args->security_group_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_server_certificate_setter(struct filters_server_certificate *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->paths) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Paths\":[" ));
		for (as = args->paths; *as; ++as) {
			if (as != args->paths)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->paths_str) {
		ARG_TO_JSON(Paths, string, args->paths_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_service_setter(struct filters_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ServiceIds\":[" ));
		for (as = args->service_ids; *as; ++as) {
			if (as != args->service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->service_ids_str) {
		ARG_TO_JSON(ServiceIds, string, args->service_ids_str);
		ret += 1;
	}
	if (args->service_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ServiceNames\":[" ));
		for (as = args->service_names; *as; ++as) {
			if (as != args->service_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->service_names_str) {
		ARG_TO_JSON(ServiceNames, string, args->service_names_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_snapshot_setter(struct filters_snapshot *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_aliases) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountAliases\":[" ));
		for (as = args->account_aliases; *as; ++as) {
			if (as != args->account_aliases)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_aliases_str) {
		ARG_TO_JSON(AccountAliases, string, args->account_aliases_str);
		ret += 1;
	}
	if (args->account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountIds\":[" ));
		for (as = args->account_ids; *as; ++as) {
			if (as != args->account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_ids_str) {
		ARG_TO_JSON(AccountIds, string, args->account_ids_str);
		ret += 1;
	}
	if (args->client_tokens) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientTokens\":[" ));
		for (as = args->client_tokens; *as; ++as) {
			if (as != args->client_tokens)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_tokens_str) {
		ARG_TO_JSON(ClientTokens, string, args->client_tokens_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->from_creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromCreationDate\":", args->from_creation_date);
	   	ret += 1;
	}
	if (args->permissions_to_create_volume_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PermissionsToCreateVolumeAccountIds\":[" ));
		for (as = args->permissions_to_create_volume_account_ids; *as; ++as) {
			if (as != args->permissions_to_create_volume_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->permissions_to_create_volume_account_ids_str) {
		ARG_TO_JSON(PermissionsToCreateVolumeAccountIds, string, args->permissions_to_create_volume_account_ids_str);
		ret += 1;
	}
	if (args->is_set_permissions_to_create_volume_global_permission) {
		ARG_TO_JSON(PermissionsToCreateVolumeGlobalPermission, bool, args->permissions_to_create_volume_global_permission);
	   	ret += 1;
	}
	if (args->progresses) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Progresses\":[" ));
		for (ip = args->progresses; *ip > 0; ++ip) {
			if (ip != args->progresses)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->progresses_str) {
		ARG_TO_JSON(Progresses, string, args->progresses_str);
		ret += 1;
	}
	if (args->snapshot_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SnapshotIds\":[" ));
		for (as = args->snapshot_ids; *as; ++as) {
			if (as != args->snapshot_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->snapshot_ids_str) {
		ARG_TO_JSON(SnapshotIds, string, args->snapshot_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->to_creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToCreationDate\":", args->to_creation_date);
	   	ret += 1;
	}
	if (args->volume_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeIds\":[" ));
		for (as = args->volume_ids; *as; ++as) {
			if (as != args->volume_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_ids_str) {
		ARG_TO_JSON(VolumeIds, string, args->volume_ids_str);
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeSizes\":[" ));
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_sizes_str) {
		ARG_TO_JSON(VolumeSizes, string, args->volume_sizes_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_subnet_setter(struct filters_subnet *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->available_ips_counts) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AvailableIpsCounts\":[" ));
		for (ip = args->available_ips_counts; *ip > 0; ++ip) {
			if (ip != args->available_ips_counts)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->available_ips_counts_str) {
		ARG_TO_JSON(AvailableIpsCounts, string, args->available_ips_counts_str);
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_subregion_setter(struct filters_subregion *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->region_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RegionNames\":[" ));
		for (as = args->region_names; *as; ++as) {
			if (as != args->region_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->region_names_str) {
		ARG_TO_JSON(RegionNames, string, args->region_names_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_tag_setter(struct filters_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Keys\":[" ));
		for (as = args->keys; *as; ++as) {
			if (as != args->keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keys_str) {
		ARG_TO_JSON(Keys, string, args->keys_str);
		ret += 1;
	}
	if (args->resource_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResourceIds\":[" ));
		for (as = args->resource_ids; *as; ++as) {
			if (as != args->resource_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->resource_ids_str) {
		ARG_TO_JSON(ResourceIds, string, args->resource_ids_str);
		ret += 1;
	}
	if (args->resource_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResourceTypes\":[" ));
		for (as = args->resource_types; *as; ++as) {
			if (as != args->resource_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->resource_types_str) {
		ARG_TO_JSON(ResourceTypes, string, args->resource_types_str);
		ret += 1;
	}
	if (args->values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Values\":[" ));
		for (as = args->values; *as; ++as) {
			if (as != args->values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->values_str) {
		ARG_TO_JSON(Values, string, args->values_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_user_group_setter(struct filters_user_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->path_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPrefix\":", args->path_prefix);
	   	ret += 1;
	}
	if (args->user_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"UserGroupIds\":[" ));
		for (as = args->user_group_ids; *as; ++as) {
			if (as != args->user_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->user_group_ids_str) {
		ARG_TO_JSON(UserGroupIds, string, args->user_group_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_users_setter(struct filters_users *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->user_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"UserIds\":[" ));
		for (as = args->user_ids; *as; ++as) {
			if (as != args->user_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->user_ids_str) {
		ARG_TO_JSON(UserIds, string, args->user_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_virtual_gateway_setter(struct filters_virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->connection_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ConnectionTypes\":[" ));
		for (as = args->connection_types; *as; ++as) {
			if (as != args->connection_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->connection_types_str) {
		ARG_TO_JSON(ConnectionTypes, string, args->connection_types_str);
		ret += 1;
	}
	if (args->link_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNetIds\":[" ));
		for (as = args->link_net_ids; *as; ++as) {
			if (as != args->link_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_net_ids_str) {
		ARG_TO_JSON(LinkNetIds, string, args->link_net_ids_str);
		ret += 1;
	}
	if (args->link_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkStates\":[" ));
		for (as = args->link_states; *as; ++as) {
			if (as != args->link_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_states_str) {
		ARG_TO_JSON(LinkStates, string, args->link_states_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->virtual_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VirtualGatewayIds\":[" ));
		for (as = args->virtual_gateway_ids; *as; ++as) {
			if (as != args->virtual_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->virtual_gateway_ids_str) {
		ARG_TO_JSON(VirtualGatewayIds, string, args->virtual_gateway_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_vm_setter(struct filters_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->architectures) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Architectures\":[" ));
		for (as = args->architectures; *as; ++as) {
			if (as != args->architectures)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->architectures_str) {
		ARG_TO_JSON(Architectures, string, args->architectures_str);
		ret += 1;
	}
	if (args->is_set_block_device_mapping_delete_on_vm_deletion) {
		ARG_TO_JSON(BlockDeviceMappingDeleteOnVmDeletion, bool, args->block_device_mapping_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->block_device_mapping_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingDeviceNames\":[" ));
		for (as = args->block_device_mapping_device_names; *as; ++as) {
			if (as != args->block_device_mapping_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_device_names_str) {
		ARG_TO_JSON(BlockDeviceMappingDeviceNames, string, args->block_device_mapping_device_names_str);
		ret += 1;
	}
	if (args->block_device_mapping_link_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingLinkDates\":[" ));
		for (as = args->block_device_mapping_link_dates; *as; ++as) {
			if (as != args->block_device_mapping_link_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_link_dates_str) {
		ARG_TO_JSON(BlockDeviceMappingLinkDates, string, args->block_device_mapping_link_dates_str);
		ret += 1;
	}
	if (args->block_device_mapping_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingStates\":[" ));
		for (as = args->block_device_mapping_states; *as; ++as) {
			if (as != args->block_device_mapping_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_states_str) {
		ARG_TO_JSON(BlockDeviceMappingStates, string, args->block_device_mapping_states_str);
		ret += 1;
	}
	if (args->block_device_mapping_volume_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingVolumeIds\":[" ));
		for (as = args->block_device_mapping_volume_ids; *as; ++as) {
			if (as != args->block_device_mapping_volume_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_volume_ids_str) {
		ARG_TO_JSON(BlockDeviceMappingVolumeIds, string, args->block_device_mapping_volume_ids_str);
		ret += 1;
	}
	if (args->boot_modes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BootModes\":[" ));
		for (as = args->boot_modes; *as; ++as) {
			if (as != args->boot_modes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->boot_modes_str) {
		ARG_TO_JSON(BootModes, string, args->boot_modes_str);
		ret += 1;
	}
	if (args->client_tokens) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientTokens\":[" ));
		for (as = args->client_tokens; *as; ++as) {
			if (as != args->client_tokens)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_tokens_str) {
		ARG_TO_JSON(ClientTokens, string, args->client_tokens_str);
		ret += 1;
	}
	if (args->creation_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CreationDates\":[" ));
		for (as = args->creation_dates; *as; ++as) {
			if (as != args->creation_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->creation_dates_str) {
		ARG_TO_JSON(CreationDates, string, args->creation_dates_str);
		ret += 1;
	}
	if (args->image_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ImageIds\":[" ));
		for (as = args->image_ids; *as; ++as) {
			if (as != args->image_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->image_ids_str) {
		ARG_TO_JSON(ImageIds, string, args->image_ids_str);
		ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->keypair_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairNames\":[" ));
		for (as = args->keypair_names; *as; ++as) {
			if (as != args->keypair_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_names_str) {
		ARG_TO_JSON(KeypairNames, string, args->keypair_names_str);
		ret += 1;
	}
	if (args->launch_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LaunchNumbers\":[" ));
		for (ip = args->launch_numbers; *ip > 0; ++ip) {
			if (ip != args->launch_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->launch_numbers_str) {
		ARG_TO_JSON(LaunchNumbers, string, args->launch_numbers_str);
		ret += 1;
	}
	if (args->lifecycles) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Lifecycles\":[" ));
		for (as = args->lifecycles; *as; ++as) {
			if (as != args->lifecycles)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->lifecycles_str) {
		ARG_TO_JSON(Lifecycles, string, args->lifecycles_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->nic_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicAccountIds\":[" ));
		for (as = args->nic_account_ids; *as; ++as) {
			if (as != args->nic_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_account_ids_str) {
		ARG_TO_JSON(NicAccountIds, string, args->nic_account_ids_str);
		ret += 1;
	}
	if (args->nic_descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicDescriptions\":[" ));
		for (as = args->nic_descriptions; *as; ++as) {
			if (as != args->nic_descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_descriptions_str) {
		ARG_TO_JSON(NicDescriptions, string, args->nic_descriptions_str);
		ret += 1;
	}
	if (args->is_set_nic_is_source_dest_checked) {
		ARG_TO_JSON(NicIsSourceDestChecked, bool, args->nic_is_source_dest_checked);
	   	ret += 1;
	}
	if (args->is_set_nic_link_nic_delete_on_vm_deletion) {
		ARG_TO_JSON(NicLinkNicDeleteOnVmDeletion, bool, args->nic_link_nic_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->nic_link_nic_device_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicDeviceNumbers\":[" ));
		for (ip = args->nic_link_nic_device_numbers; *ip > 0; ++ip) {
			if (ip != args->nic_link_nic_device_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_device_numbers_str) {
		ARG_TO_JSON(NicLinkNicDeviceNumbers, string, args->nic_link_nic_device_numbers_str);
		ret += 1;
	}
	if (args->nic_link_nic_link_nic_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicLinkNicDates\":[" ));
		for (as = args->nic_link_nic_link_nic_dates; *as; ++as) {
			if (as != args->nic_link_nic_link_nic_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_link_nic_dates_str) {
		ARG_TO_JSON(NicLinkNicLinkNicDates, string, args->nic_link_nic_link_nic_dates_str);
		ret += 1;
	}
	if (args->nic_link_nic_link_nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicLinkNicIds\":[" ));
		for (as = args->nic_link_nic_link_nic_ids; *as; ++as) {
			if (as != args->nic_link_nic_link_nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_link_nic_ids_str) {
		ARG_TO_JSON(NicLinkNicLinkNicIds, string, args->nic_link_nic_link_nic_ids_str);
		ret += 1;
	}
	if (args->nic_link_nic_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicStates\":[" ));
		for (as = args->nic_link_nic_states; *as; ++as) {
			if (as != args->nic_link_nic_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_states_str) {
		ARG_TO_JSON(NicLinkNicStates, string, args->nic_link_nic_states_str);
		ret += 1;
	}
	if (args->nic_link_nic_vm_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicVmAccountIds\":[" ));
		for (as = args->nic_link_nic_vm_account_ids; *as; ++as) {
			if (as != args->nic_link_nic_vm_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_vm_account_ids_str) {
		ARG_TO_JSON(NicLinkNicVmAccountIds, string, args->nic_link_nic_vm_account_ids_str);
		ret += 1;
	}
	if (args->nic_link_nic_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicVmIds\":[" ));
		for (as = args->nic_link_nic_vm_ids; *as; ++as) {
			if (as != args->nic_link_nic_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_vm_ids_str) {
		ARG_TO_JSON(NicLinkNicVmIds, string, args->nic_link_nic_vm_ids_str);
		ret += 1;
	}
	if (args->nic_link_public_ip_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkPublicIpAccountIds\":[" ));
		for (as = args->nic_link_public_ip_account_ids; *as; ++as) {
			if (as != args->nic_link_public_ip_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_public_ip_account_ids_str) {
		ARG_TO_JSON(NicLinkPublicIpAccountIds, string, args->nic_link_public_ip_account_ids_str);
		ret += 1;
	}
	if (args->nic_link_public_ip_link_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkPublicIpLinkPublicIpIds\":[" ));
		for (as = args->nic_link_public_ip_link_public_ip_ids; *as; ++as) {
			if (as != args->nic_link_public_ip_link_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_public_ip_link_public_ip_ids_str) {
		ARG_TO_JSON(NicLinkPublicIpLinkPublicIpIds, string, args->nic_link_public_ip_link_public_ip_ids_str);
		ret += 1;
	}
	if (args->nic_link_public_ip_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkPublicIpPublicIpIds\":[" ));
		for (as = args->nic_link_public_ip_public_ip_ids; *as; ++as) {
			if (as != args->nic_link_public_ip_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_public_ip_public_ip_ids_str) {
		ARG_TO_JSON(NicLinkPublicIpPublicIpIds, string, args->nic_link_public_ip_public_ip_ids_str);
		ret += 1;
	}
	if (args->nic_link_public_ip_public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkPublicIpPublicIps\":[" ));
		for (as = args->nic_link_public_ip_public_ips; *as; ++as) {
			if (as != args->nic_link_public_ip_public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_public_ip_public_ips_str) {
		ARG_TO_JSON(NicLinkPublicIpPublicIps, string, args->nic_link_public_ip_public_ips_str);
		ret += 1;
	}
	if (args->nic_mac_addresses) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicMacAddresses\":[" ));
		for (as = args->nic_mac_addresses; *as; ++as) {
			if (as != args->nic_mac_addresses)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_mac_addresses_str) {
		ARG_TO_JSON(NicMacAddresses, string, args->nic_mac_addresses_str);
		ret += 1;
	}
	if (args->nic_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicNetIds\":[" ));
		for (as = args->nic_net_ids; *as; ++as) {
			if (as != args->nic_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_net_ids_str) {
		ARG_TO_JSON(NicNetIds, string, args->nic_net_ids_str);
		ret += 1;
	}
	if (args->nic_nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicNicIds\":[" ));
		for (as = args->nic_nic_ids; *as; ++as) {
			if (as != args->nic_nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_nic_ids_str) {
		ARG_TO_JSON(NicNicIds, string, args->nic_nic_ids_str);
		ret += 1;
	}
	if (args->nic_private_ips_link_public_ip_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicPrivateIpsLinkPublicIpAccountIds\":[" ));
		for (as = args->nic_private_ips_link_public_ip_account_ids; *as; ++as) {
			if (as != args->nic_private_ips_link_public_ip_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_private_ips_link_public_ip_account_ids_str) {
		ARG_TO_JSON(NicPrivateIpsLinkPublicIpAccountIds, string, args->nic_private_ips_link_public_ip_account_ids_str);
		ret += 1;
	}
	if (args->nic_private_ips_link_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicPrivateIpsLinkPublicIpIds\":[" ));
		for (as = args->nic_private_ips_link_public_ip_ids; *as; ++as) {
			if (as != args->nic_private_ips_link_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_private_ips_link_public_ip_ids_str) {
		ARG_TO_JSON(NicPrivateIpsLinkPublicIpIds, string, args->nic_private_ips_link_public_ip_ids_str);
		ret += 1;
	}
	if (args->is_set_nic_private_ips_primary_ip) {
		ARG_TO_JSON(NicPrivateIpsPrimaryIp, bool, args->nic_private_ips_primary_ip);
	   	ret += 1;
	}
	if (args->nic_private_ips_private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicPrivateIpsPrivateIps\":[" ));
		for (as = args->nic_private_ips_private_ips; *as; ++as) {
			if (as != args->nic_private_ips_private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_private_ips_private_ips_str) {
		ARG_TO_JSON(NicPrivateIpsPrivateIps, string, args->nic_private_ips_private_ips_str);
		ret += 1;
	}
	if (args->nic_security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicSecurityGroupIds\":[" ));
		for (as = args->nic_security_group_ids; *as; ++as) {
			if (as != args->nic_security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_security_group_ids_str) {
		ARG_TO_JSON(NicSecurityGroupIds, string, args->nic_security_group_ids_str);
		ret += 1;
	}
	if (args->nic_security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicSecurityGroupNames\":[" ));
		for (as = args->nic_security_group_names; *as; ++as) {
			if (as != args->nic_security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_security_group_names_str) {
		ARG_TO_JSON(NicSecurityGroupNames, string, args->nic_security_group_names_str);
		ret += 1;
	}
	if (args->nic_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicStates\":[" ));
		for (as = args->nic_states; *as; ++as) {
			if (as != args->nic_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_states_str) {
		ARG_TO_JSON(NicStates, string, args->nic_states_str);
		ret += 1;
	}
	if (args->nic_subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicSubnetIds\":[" ));
		for (as = args->nic_subnet_ids; *as; ++as) {
			if (as != args->nic_subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_subnet_ids_str) {
		ARG_TO_JSON(NicSubnetIds, string, args->nic_subnet_ids_str);
		ret += 1;
	}
	if (args->nic_subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicSubregionNames\":[" ));
		for (as = args->nic_subregion_names; *as; ++as) {
			if (as != args->nic_subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_subregion_names_str) {
		ARG_TO_JSON(NicSubregionNames, string, args->nic_subregion_names_str);
		ret += 1;
	}
	if (args->platforms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Platforms\":[" ));
		for (as = args->platforms; *as; ++as) {
			if (as != args->platforms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->platforms_str) {
		ARG_TO_JSON(Platforms, string, args->platforms_str);
		ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIps\":[" ));
		for (as = args->public_ips; *as; ++as) {
			if (as != args->public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->public_ips_str) {
		ARG_TO_JSON(PublicIps, string, args->public_ips_str);
		ret += 1;
	}
	if (args->reservation_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ReservationIds\":[" ));
		for (as = args->reservation_ids; *as; ++as) {
			if (as != args->reservation_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->reservation_ids_str) {
		ARG_TO_JSON(ReservationIds, string, args->reservation_ids_str);
		ret += 1;
	}
	if (args->root_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RootDeviceNames\":[" ));
		for (as = args->root_device_names; *as; ++as) {
			if (as != args->root_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->root_device_names_str) {
		ARG_TO_JSON(RootDeviceNames, string, args->root_device_names_str);
		ret += 1;
	}
	if (args->root_device_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RootDeviceTypes\":[" ));
		for (as = args->root_device_types; *as; ++as) {
			if (as != args->root_device_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->root_device_types_str) {
		ARG_TO_JSON(RootDeviceTypes, string, args->root_device_types_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupNames\":[" ));
		for (as = args->security_group_names; *as; ++as) {
			if (as != args->security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_names_str) {
		ARG_TO_JSON(SecurityGroupNames, string, args->security_group_names_str);
		ret += 1;
	}
	if (args->state_reason_codes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateReasonCodes\":[" ));
		for (ip = args->state_reason_codes; *ip > 0; ++ip) {
			if (ip != args->state_reason_codes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_reason_codes_str) {
		ARG_TO_JSON(StateReasonCodes, string, args->state_reason_codes_str);
		ret += 1;
	}
	if (args->state_reason_messages) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateReasonMessages\":[" ));
		for (as = args->state_reason_messages; *as; ++as) {
			if (as != args->state_reason_messages)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_reason_messages_str) {
		ARG_TO_JSON(StateReasonMessages, string, args->state_reason_messages_str);
		ret += 1;
	}
	if (args->state_reasons) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateReasons\":[" ));
		for (as = args->state_reasons; *as; ++as) {
			if (as != args->state_reasons)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_reasons_str) {
		ARG_TO_JSON(StateReasons, string, args->state_reasons_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->tenancies) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tenancies\":[" ));
		for (as = args->tenancies; *as; ++as) {
			if (as != args->tenancies)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tenancies_str) {
		ARG_TO_JSON(Tenancies, string, args->tenancies_str);
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	if (args->vm_security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmSecurityGroupIds\":[" ));
		for (as = args->vm_security_group_ids; *as; ++as) {
			if (as != args->vm_security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_security_group_ids_str) {
		ARG_TO_JSON(VmSecurityGroupIds, string, args->vm_security_group_ids_str);
		ret += 1;
	}
	if (args->vm_security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmSecurityGroupNames\":[" ));
		for (as = args->vm_security_group_names; *as; ++as) {
			if (as != args->vm_security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_security_group_names_str) {
		ARG_TO_JSON(VmSecurityGroupNames, string, args->vm_security_group_names_str);
		ret += 1;
	}
	if (args->vm_state_codes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmStateCodes\":[" ));
		for (ip = args->vm_state_codes; *ip > 0; ++ip) {
			if (ip != args->vm_state_codes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_state_codes_str) {
		ARG_TO_JSON(VmStateCodes, string, args->vm_state_codes_str);
		ret += 1;
	}
	if (args->vm_state_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmStateNames\":[" ));
		for (as = args->vm_state_names; *as; ++as) {
			if (as != args->vm_state_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_state_names_str) {
		ARG_TO_JSON(VmStateNames, string, args->vm_state_names_str);
		ret += 1;
	}
	if (args->vm_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTypes\":[" ));
		for (as = args->vm_types; *as; ++as) {
			if (as != args->vm_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_types_str) {
		ARG_TO_JSON(VmTypes, string, args->vm_types_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_vm_group_setter(struct filters_vm_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_counts) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmCounts\":[" ));
		for (ip = args->vm_counts; *ip > 0; ++ip) {
			if (ip != args->vm_counts)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_counts_str) {
		ARG_TO_JSON(VmCounts, string, args->vm_counts_str);
		ret += 1;
	}
	if (args->vm_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmGroupIds\":[" ));
		for (as = args->vm_group_ids; *as; ++as) {
			if (as != args->vm_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_group_ids_str) {
		ARG_TO_JSON(VmGroupIds, string, args->vm_group_ids_str);
		ret += 1;
	}
	if (args->vm_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmGroupNames\":[" ));
		for (as = args->vm_group_names; *as; ++as) {
			if (as != args->vm_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_group_names_str) {
		ARG_TO_JSON(VmGroupNames, string, args->vm_group_names_str);
		ret += 1;
	}
	if (args->vm_template_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTemplateIds\":[" ));
		for (as = args->vm_template_ids; *as; ++as) {
			if (as != args->vm_template_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_template_ids_str) {
		ARG_TO_JSON(VmTemplateIds, string, args->vm_template_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_vm_template_setter(struct filters_vm_template *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->cpu_cores) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CpuCores\":[" ));
		for (ip = args->cpu_cores; *ip > 0; ++ip) {
			if (ip != args->cpu_cores)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cpu_cores_str) {
		ARG_TO_JSON(CpuCores, string, args->cpu_cores_str);
		ret += 1;
	}
	if (args->cpu_generations) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CpuGenerations\":[" ));
		for (as = args->cpu_generations; *as; ++as) {
			if (as != args->cpu_generations)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cpu_generations_str) {
		ARG_TO_JSON(CpuGenerations, string, args->cpu_generations_str);
		ret += 1;
	}
	if (args->cpu_performances) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CpuPerformances\":[" ));
		for (as = args->cpu_performances; *as; ++as) {
			if (as != args->cpu_performances)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cpu_performances_str) {
		ARG_TO_JSON(CpuPerformances, string, args->cpu_performances_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->image_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ImageIds\":[" ));
		for (as = args->image_ids; *as; ++as) {
			if (as != args->image_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->image_ids_str) {
		ARG_TO_JSON(ImageIds, string, args->image_ids_str);
		ret += 1;
	}
	if (args->keypair_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairNames\":[" ));
		for (as = args->keypair_names; *as; ++as) {
			if (as != args->keypair_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_names_str) {
		ARG_TO_JSON(KeypairNames, string, args->keypair_names_str);
		ret += 1;
	}
	if (args->rams) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Rams\":[" ));
		for (ip = args->rams; *ip > 0; ++ip) {
			if (ip != args->rams)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->rams_str) {
		ARG_TO_JSON(Rams, string, args->rams_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_template_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTemplateIds\":[" ));
		for (as = args->vm_template_ids; *as; ++as) {
			if (as != args->vm_template_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_template_ids_str) {
		ARG_TO_JSON(VmTemplateIds, string, args->vm_template_ids_str);
		ret += 1;
	}
	if (args->vm_template_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTemplateNames\":[" ));
		for (as = args->vm_template_names; *as; ++as) {
			if (as != args->vm_template_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_template_names_str) {
		ARG_TO_JSON(VmTemplateNames, string, args->vm_template_names_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_vm_type_setter(struct filters_vm_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->ephemerals_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"EphemeralsTypes\":[" ));
		for (as = args->ephemerals_types; *as; ++as) {
			if (as != args->ephemerals_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ephemerals_types_str) {
		ARG_TO_JSON(EphemeralsTypes, string, args->ephemerals_types_str);
		ret += 1;
	}
	if (args->eths) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Eths\":[" ));
		for (ip = args->eths; *ip > 0; ++ip) {
			if (ip != args->eths)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->eths_str) {
		ARG_TO_JSON(Eths, string, args->eths_str);
		ret += 1;
	}
	if (args->gpus) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Gpus\":[" ));
		for (ip = args->gpus; *ip > 0; ++ip) {
			if (ip != args->gpus)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->gpus_str) {
		ARG_TO_JSON(Gpus, string, args->gpus_str);
		ret += 1;
	}
	if (args->memory_sizes) {
		double *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MemorySizes\":[" ));
		for (ip = args->memory_sizes; *ip > 0; ++ip) {
			if (ip != args->memory_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_double(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->memory_sizes_str) {
		ARG_TO_JSON(MemorySizes, string, args->memory_sizes_str);
		ret += 1;
	}
	if (args->vcore_counts) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VcoreCounts\":[" ));
		for (ip = args->vcore_counts; *ip > 0; ++ip) {
			if (ip != args->vcore_counts)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vcore_counts_str) {
		ARG_TO_JSON(VcoreCounts, string, args->vcore_counts_str);
		ret += 1;
	}
	if (args->vm_type_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTypeNames\":[" ));
		for (as = args->vm_type_names; *as; ++as) {
			if (as != args->vm_type_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_type_names_str) {
		ARG_TO_JSON(VmTypeNames, string, args->vm_type_names_str);
		ret += 1;
	}
	if (args->volume_counts) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeCounts\":[" ));
		for (ip = args->volume_counts; *ip > 0; ++ip) {
			if (ip != args->volume_counts)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_counts_str) {
		ARG_TO_JSON(VolumeCounts, string, args->volume_counts_str);
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeSizes\":[" ));
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_sizes_str) {
		ARG_TO_JSON(VolumeSizes, string, args->volume_sizes_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_vms_state_setter(struct filters_vms_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->maintenance_event_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEventCodes\":[" ));
		for (as = args->maintenance_event_codes; *as; ++as) {
			if (as != args->maintenance_event_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->maintenance_event_codes_str) {
		ARG_TO_JSON(MaintenanceEventCodes, string, args->maintenance_event_codes_str);
		ret += 1;
	}
	if (args->maintenance_event_descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEventDescriptions\":[" ));
		for (as = args->maintenance_event_descriptions; *as; ++as) {
			if (as != args->maintenance_event_descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->maintenance_event_descriptions_str) {
		ARG_TO_JSON(MaintenanceEventDescriptions, string, args->maintenance_event_descriptions_str);
		ret += 1;
	}
	if (args->maintenance_events_not_after) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEventsNotAfter\":[" ));
		for (as = args->maintenance_events_not_after; *as; ++as) {
			if (as != args->maintenance_events_not_after)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->maintenance_events_not_after_str) {
		ARG_TO_JSON(MaintenanceEventsNotAfter, string, args->maintenance_events_not_after_str);
		ret += 1;
	}
	if (args->maintenance_events_not_before) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEventsNotBefore\":[" ));
		for (as = args->maintenance_events_not_before; *as; ++as) {
			if (as != args->maintenance_events_not_before)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->maintenance_events_not_before_str) {
		ARG_TO_JSON(MaintenanceEventsNotBefore, string, args->maintenance_events_not_before_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	if (args->vm_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmStates\":[" ));
		for (as = args->vm_states; *as; ++as) {
			if (as != args->vm_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_states_str) {
		ARG_TO_JSON(VmStates, string, args->vm_states_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_volume_setter(struct filters_volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->client_tokens) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientTokens\":[" ));
		for (as = args->client_tokens; *as; ++as) {
			if (as != args->client_tokens)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_tokens_str) {
		ARG_TO_JSON(ClientTokens, string, args->client_tokens_str);
		ret += 1;
	}
	if (args->creation_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CreationDates\":[" ));
		for (as = args->creation_dates; *as; ++as) {
			if (as != args->creation_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->creation_dates_str) {
		ARG_TO_JSON(CreationDates, string, args->creation_dates_str);
		ret += 1;
	}
	if (args->is_set_link_volume_delete_on_vm_deletion) {
		ARG_TO_JSON(LinkVolumeDeleteOnVmDeletion, bool, args->link_volume_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->link_volume_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkVolumeDeviceNames\":[" ));
		for (as = args->link_volume_device_names; *as; ++as) {
			if (as != args->link_volume_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_volume_device_names_str) {
		ARG_TO_JSON(LinkVolumeDeviceNames, string, args->link_volume_device_names_str);
		ret += 1;
	}
	if (args->link_volume_link_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkVolumeLinkDates\":[" ));
		for (as = args->link_volume_link_dates; *as; ++as) {
			if (as != args->link_volume_link_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_volume_link_dates_str) {
		ARG_TO_JSON(LinkVolumeLinkDates, string, args->link_volume_link_dates_str);
		ret += 1;
	}
	if (args->link_volume_link_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkVolumeLinkStates\":[" ));
		for (as = args->link_volume_link_states; *as; ++as) {
			if (as != args->link_volume_link_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_volume_link_states_str) {
		ARG_TO_JSON(LinkVolumeLinkStates, string, args->link_volume_link_states_str);
		ret += 1;
	}
	if (args->link_volume_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkVolumeVmIds\":[" ));
		for (as = args->link_volume_vm_ids; *as; ++as) {
			if (as != args->link_volume_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_volume_vm_ids_str) {
		ARG_TO_JSON(LinkVolumeVmIds, string, args->link_volume_vm_ids_str);
		ret += 1;
	}
	if (args->snapshot_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SnapshotIds\":[" ));
		for (as = args->snapshot_ids; *as; ++as) {
			if (as != args->snapshot_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->snapshot_ids_str) {
		ARG_TO_JSON(SnapshotIds, string, args->snapshot_ids_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->volume_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeIds\":[" ));
		for (as = args->volume_ids; *as; ++as) {
			if (as != args->volume_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_ids_str) {
		ARG_TO_JSON(VolumeIds, string, args->volume_ids_str);
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeSizes\":[" ));
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_sizes_str) {
		ARG_TO_JSON(VolumeSizes, string, args->volume_sizes_str);
		ret += 1;
	}
	if (args->volume_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeStates\":[" ));
		for (as = args->volume_states; *as; ++as) {
			if (as != args->volume_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_states_str) {
		ARG_TO_JSON(VolumeStates, string, args->volume_states_str);
		ret += 1;
	}
	if (args->volume_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeTypes\":[" ));
		for (as = args->volume_types; *as; ++as) {
			if (as != args->volume_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_types_str) {
		ARG_TO_JSON(VolumeTypes, string, args->volume_types_str);
		ret += 1;
	}

	return !!ret;
}
static int filters_vpn_connection_setter(struct filters_vpn_connection *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bgp_asns) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BgpAsns\":[" ));
		for (ip = args->bgp_asns; *ip > 0; ++ip) {
			if (ip != args->bgp_asns)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->bgp_asns_str) {
		ARG_TO_JSON(BgpAsns, string, args->bgp_asns_str);
		ret += 1;
	}
	if (args->client_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientGatewayIds\":[" ));
		for (as = args->client_gateway_ids; *as; ++as) {
			if (as != args->client_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_gateway_ids_str) {
		ARG_TO_JSON(ClientGatewayIds, string, args->client_gateway_ids_str);
		ret += 1;
	}
	if (args->connection_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ConnectionTypes\":[" ));
		for (as = args->connection_types; *as; ++as) {
			if (as != args->connection_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->connection_types_str) {
		ARG_TO_JSON(ConnectionTypes, string, args->connection_types_str);
		ret += 1;
	}
	if (args->route_destination_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteDestinationIpRanges\":[" ));
		for (as = args->route_destination_ip_ranges; *as; ++as) {
			if (as != args->route_destination_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_destination_ip_ranges_str) {
		ARG_TO_JSON(RouteDestinationIpRanges, string, args->route_destination_ip_ranges_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->is_set_static_routes_only) {
		ARG_TO_JSON(StaticRoutesOnly, bool, args->static_routes_only);
	   	ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->virtual_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VirtualGatewayIds\":[" ));
		for (as = args->virtual_gateway_ids; *as; ++as) {
			if (as != args->virtual_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->virtual_gateway_ids_str) {
		ARG_TO_JSON(VirtualGatewayIds, string, args->virtual_gateway_ids_str);
		ret += 1;
	}
	if (args->vpn_connection_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VpnConnectionIds\":[" ));
		for (as = args->vpn_connection_ids; *as; ++as) {
			if (as != args->vpn_connection_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vpn_connection_ids_str) {
		ARG_TO_JSON(VpnConnectionIds, string, args->vpn_connection_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int flexible_gpu_setter(struct flexible_gpu *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	if (args->generation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Generation\":", args->generation);
	   	ret += 1;
	}
	if (args->model_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ModelName\":", args->model_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}

	return !!ret;
}
static int flexible_gpu_catalog_setter(struct flexible_gpu_catalog *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->generations) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Generations\":[" ));
		for (as = args->generations; *as; ++as) {
			if (as != args->generations)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->generations_str) {
		ARG_TO_JSON(Generations, string, args->generations_str);
		ret += 1;
	}
	if (args->is_set_max_cpu || args->max_cpu) {
		ARG_TO_JSON(MaxCpu, int, args->max_cpu);
	   	ret += 1;
	}
	if (args->is_set_max_ram || args->max_ram) {
		ARG_TO_JSON(MaxRam, int, args->max_ram);
	   	ret += 1;
	}
	if (args->model_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ModelName\":", args->model_name);
	   	ret += 1;
	}
	if (args->is_set_vram || args->vram) {
		ARG_TO_JSON(VRam, int, args->vram);
	   	ret += 1;
	}

	return !!ret;
}
static int health_check_setter(struct health_check *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_check_interval || args->check_interval) {
		ARG_TO_JSON(CheckInterval, int, args->check_interval);
	   	ret += 1;
	}
	if (args->is_set_healthy_threshold || args->healthy_threshold) {
		ARG_TO_JSON(HealthyThreshold, int, args->healthy_threshold);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->is_set_port || args->port) {
		ARG_TO_JSON(Port, int, args->port);
	   	ret += 1;
	}
	if (args->protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Protocol\":", args->protocol);
	   	ret += 1;
	}
	if (args->is_set_timeout || args->timeout) {
		ARG_TO_JSON(Timeout, int, args->timeout);
	   	ret += 1;
	}
	if (args->is_set_unhealthy_threshold || args->unhealthy_threshold) {
		ARG_TO_JSON(UnhealthyThreshold, int, args->unhealthy_threshold);
	   	ret += 1;
	}

	return !!ret;
}
static int image_setter(struct image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_alias) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountAlias\":", args->account_alias);
	   	ret += 1;
	}
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->architecture) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Architecture\":", args->architecture);
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_image *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_image_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->boot_modes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BootModes\":[" ));
		for (as = args->boot_modes; *as; ++as) {
			if (as != args->boot_modes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->boot_modes_str) {
		ARG_TO_JSON(BootModes, string, args->boot_modes_str);
		ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->file_location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FileLocation\":", args->file_location);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->image_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageName\":", args->image_name);
	   	ret += 1;
	}
	if (args->image_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageType\":", args->image_type);
	   	ret += 1;
	}
	if (args->permissions_to_launch_str) {
		ARG_TO_JSON(PermissionsToLaunch, string, args->permissions_to_launch_str);
		ret += 1;
	} else if (args->is_set_permissions_to_launch) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"PermissionsToLaunch\": { " ));
	       STRY(permissions_on_resource_setter(&args->permissions_to_launch, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->root_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceName\":", args->root_device_name);
	   	ret += 1;
	}
	if (args->root_device_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceType\":", args->root_device_type);
	   	ret += 1;
	}
	if (args->is_set_secure_boot) {
		ARG_TO_JSON(SecureBoot, bool, args->secure_boot);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->state_comment_str) {
		ARG_TO_JSON(StateComment, string, args->state_comment_str);
		ret += 1;
	} else if (args->is_set_state_comment) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"StateComment\": { " ));
	       STRY(state_comment_setter(&args->state_comment, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int image_export_task_setter(struct image_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->comment) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Comment\":", args->comment);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->osu_export_str) {
		ARG_TO_JSON(OsuExport, string, args->osu_export_str);
		ret += 1;
	} else if (args->is_set_osu_export) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuExport\": { " ));
	       STRY(osu_export_image_export_task_setter(&args->osu_export, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		ARG_TO_JSON(Progress, int, args->progress);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->task_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"TaskId\":", args->task_id);
	   	ret += 1;
	}

	return !!ret;
}
static int inline_policy_setter(struct inline_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->body) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Body\":", args->body);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}

	return !!ret;
}
static int internet_service_setter(struct internet_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->internet_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InternetServiceId\":", args->internet_service_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int keypair_setter(struct keypair *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprint) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairFingerprint\":", args->keypair_fingerprint);
	   	ret += 1;
	}
	if (args->keypair_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairId\":", args->keypair_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->keypair_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairType\":", args->keypair_type);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int keypair_created_setter(struct keypair_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprint) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairFingerprint\":", args->keypair_fingerprint);
	   	ret += 1;
	}
	if (args->keypair_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairId\":", args->keypair_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->keypair_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairType\":", args->keypair_type);
	   	ret += 1;
	}
	if (args->private_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateKey\":", args->private_key);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int link_nic_setter(struct link_nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		ARG_TO_JSON(DeviceNumber, int, args->device_number);
	   	ret += 1;
	}
	if (args->link_nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkNicId\":", args->link_nic_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->vm_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmAccountId\":", args->vm_account_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}

	return !!ret;
}
static int link_nic_light_setter(struct link_nic_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		ARG_TO_JSON(DeviceNumber, int, args->device_number);
	   	ret += 1;
	}
	if (args->link_nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkNicId\":", args->link_nic_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}

	return !!ret;
}
static int link_nic_to_update_setter(struct link_nic_to_update *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->link_nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkNicId\":", args->link_nic_id);
	   	ret += 1;
	}

	return !!ret;
}
static int link_public_ip_setter(struct link_public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkPublicIpId\":", args->link_public_ip_id);
	   	ret += 1;
	}
	if (args->public_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicDnsName\":", args->public_dns_name);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpAccountId\":", args->public_ip_account_id);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}

	return !!ret;
}
static int link_public_ip_light_for_vm_setter(struct link_public_ip_light_for_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->public_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicDnsName\":", args->public_dns_name);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpAccountId\":", args->public_ip_account_id);
	   	ret += 1;
	}

	return !!ret;
}
static int link_route_table_setter(struct link_route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkRouteTableId\":", args->link_route_table_id);
	   	ret += 1;
	}
	if (args->is_set_main) {
		ARG_TO_JSON(Main, bool, args->main);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}

	return !!ret;
}
static int linked_policy_setter(struct linked_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Orn\":", args->orn);
	   	ret += 1;
	}
	if (args->policy_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyId\":", args->policy_id);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}

	return !!ret;
}
static int linked_volume_setter(struct linked_volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}

	return !!ret;
}
static int listener_setter(struct listener *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_backend_port || args->backend_port) {
		ARG_TO_JSON(BackendPort, int, args->backend_port);
	   	ret += 1;
	}
	if (args->backend_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BackendProtocol\":", args->backend_protocol);
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		ARG_TO_JSON(LoadBalancerPort, int, args->load_balancer_port);
	   	ret += 1;
	}
	if (args->load_balancer_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerProtocol\":", args->load_balancer_protocol);
	   	ret += 1;
	}
	if (args->policy_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PolicyNames\":[" ));
		for (as = args->policy_names; *as; ++as) {
			if (as != args->policy_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->policy_names_str) {
		ARG_TO_JSON(PolicyNames, string, args->policy_names_str);
		ret += 1;
	}
	if (args->server_certificate_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServerCertificateId\":", args->server_certificate_id);
	   	ret += 1;
	}

	return !!ret;
}
static int listener_for_creation_setter(struct listener_for_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_backend_port || args->backend_port) {
		ARG_TO_JSON(BackendPort, int, args->backend_port);
	   	ret += 1;
	}
	if (args->backend_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BackendProtocol\":", args->backend_protocol);
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		ARG_TO_JSON(LoadBalancerPort, int, args->load_balancer_port);
	   	ret += 1;
	}
	if (args->load_balancer_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerProtocol\":", args->load_balancer_protocol);
	   	ret += 1;
	}
	if (args->server_certificate_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServerCertificateId\":", args->server_certificate_id);
	   	ret += 1;
	}

	return !!ret;
}
static int listener_rule_setter(struct listener_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->action) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Action\":", args->action);
	   	ret += 1;
	}
	if (args->host_name_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"HostNamePattern\":", args->host_name_pattern);
	   	ret += 1;
	}
	if (args->is_set_listener_id || args->listener_id) {
		ARG_TO_JSON(ListenerId, int, args->listener_id);
	   	ret += 1;
	}
	if (args->is_set_listener_rule_id || args->listener_rule_id) {
		ARG_TO_JSON(ListenerRuleId, int, args->listener_rule_id);
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ListenerRuleName\":", args->listener_rule_name);
	   	ret += 1;
	}
	if (args->path_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPattern\":", args->path_pattern);
	   	ret += 1;
	}
	if (args->is_set_priority || args->priority) {
		ARG_TO_JSON(Priority, int, args->priority);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}

	return !!ret;
}
static int listener_rule_for_creation_setter(struct listener_rule_for_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->action) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Action\":", args->action);
	   	ret += 1;
	}
	if (args->host_name_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"HostNamePattern\":", args->host_name_pattern);
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ListenerRuleName\":", args->listener_rule_name);
	   	ret += 1;
	}
	if (args->path_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPattern\":", args->path_pattern);
	   	ret += 1;
	}
	if (args->is_set_priority || args->priority) {
		ARG_TO_JSON(Priority, int, args->priority);
	   	ret += 1;
	}

	return !!ret;
}
static int load_balancer_setter(struct load_balancer *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_log_str) {
		ARG_TO_JSON(AccessLog, string, args->access_log_str);
		ret += 1;
	} else if (args->is_set_access_log) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"AccessLog\": { " ));
	       STRY(access_log_setter(&args->access_log, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->application_sticky_cookie_policies) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ApplicationStickyCookiePolicies\":[" ));
		for (int i = 0; i < args->nb_application_sticky_cookie_policies; ++i) {
	       	    struct application_sticky_cookie_policy *p = &args->application_sticky_cookie_policies[i];
		    if (p != args->application_sticky_cookie_policies)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(application_sticky_cookie_policy_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->application_sticky_cookie_policies_str) {
		ARG_TO_JSON(ApplicationStickyCookiePolicies, string, args->application_sticky_cookie_policies_str);
		ret += 1;
	}
	if (args->backend_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendIps\":[" ));
		for (as = args->backend_ips; *as; ++as) {
			if (as != args->backend_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_ips_str) {
		ARG_TO_JSON(BackendIps, string, args->backend_ips_str);
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DnsName\":", args->dns_name);
	   	ret += 1;
	}
	if (args->health_check_str) {
		ARG_TO_JSON(HealthCheck, string, args->health_check_str);
		ret += 1;
	} else if (args->is_set_health_check) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"HealthCheck\": { " ));
	       STRY(health_check_setter(&args->health_check, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->listeners) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Listeners\":[" ));
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener *p = &args->listeners[i];
		    if (p != args->listeners)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(listener_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->listeners_str) {
		ARG_TO_JSON(Listeners, string, args->listeners_str);
		ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
        if (args->load_balancer_sticky_cookie_policies) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerStickyCookiePolicies\":[" ));
		for (int i = 0; i < args->nb_load_balancer_sticky_cookie_policies; ++i) {
	       	    struct load_balancer_sticky_cookie_policy *p = &args->load_balancer_sticky_cookie_policies[i];
		    if (p != args->load_balancer_sticky_cookie_policies)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(load_balancer_sticky_cookie_policy_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->load_balancer_sticky_cookie_policies_str) {
		ARG_TO_JSON(LoadBalancerStickyCookiePolicies, string, args->load_balancer_sticky_cookie_policies_str);
		ret += 1;
	}
	if (args->load_balancer_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerType\":", args->load_balancer_type);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->is_set_secured_cookies) {
		ARG_TO_JSON(SecuredCookies, bool, args->secured_cookies);
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (as = args->security_groups; *as; ++as) {
			if (as != args->security_groups)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->source_security_group_str) {
		ARG_TO_JSON(SourceSecurityGroup, string, args->source_security_group_str);
		ret += 1;
	} else if (args->is_set_source_security_group) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"SourceSecurityGroup\": { " ));
	       STRY(source_security_group_setter(&args->source_security_group, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->subnets) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Subnets\":[" ));
		for (as = args->subnets; *as; ++as) {
			if (as != args->subnets)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnets_str) {
		ARG_TO_JSON(Subnets, string, args->subnets_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int load_balancer_light_setter(struct load_balancer_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		ARG_TO_JSON(LoadBalancerPort, int, args->load_balancer_port);
	   	ret += 1;
	}

	return !!ret;
}
static int load_balancer_sticky_cookie_policy_setter(struct load_balancer_sticky_cookie_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_cookie_expiration_period || args->cookie_expiration_period) {
		ARG_TO_JSON(CookieExpirationPeriod, int, args->cookie_expiration_period);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}

	return !!ret;
}
static int load_balancer_tag_setter(struct load_balancer_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Key\":", args->key);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->value) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Value\":", args->value);
	   	ret += 1;
	}

	return !!ret;
}
static int location_setter(struct location *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Code\":", args->code);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}

	return !!ret;
}
static int log_setter(struct log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->is_set_call_duration || args->call_duration) {
		ARG_TO_JSON(CallDuration, int, args->call_duration);
	   	ret += 1;
	}
	if (args->query_access_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryAccessKey\":", args->query_access_key);
	   	ret += 1;
	}
	if (args->query_api_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryApiName\":", args->query_api_name);
	   	ret += 1;
	}
	if (args->query_api_version) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryApiVersion\":", args->query_api_version);
	   	ret += 1;
	}
	if (args->query_call_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryCallName\":", args->query_call_name);
	   	ret += 1;
	}
	if (args->query_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryDate\":", args->query_date);
	   	ret += 1;
	}
	if (args->query_header_raw) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryHeaderRaw\":", args->query_header_raw);
	   	ret += 1;
	}
	if (args->is_set_query_header_size || args->query_header_size) {
		ARG_TO_JSON(QueryHeaderSize, int, args->query_header_size);
	   	ret += 1;
	}
	if (args->query_ip_address) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryIpAddress\":", args->query_ip_address);
	   	ret += 1;
	}
	if (args->query_payload_raw) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryPayloadRaw\":", args->query_payload_raw);
	   	ret += 1;
	}
	if (args->is_set_query_payload_size || args->query_payload_size) {
		ARG_TO_JSON(QueryPayloadSize, int, args->query_payload_size);
	   	ret += 1;
	}
	if (args->query_user_agent) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryUserAgent\":", args->query_user_agent);
	   	ret += 1;
	}
	if (args->request_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RequestId\":", args->request_id);
	   	ret += 1;
	}
	if (args->is_set_response_size || args->response_size) {
		ARG_TO_JSON(ResponseSize, int, args->response_size);
	   	ret += 1;
	}
	if (args->is_set_response_status_code || args->response_status_code) {
		ARG_TO_JSON(ResponseStatusCode, int, args->response_status_code);
	   	ret += 1;
	}

	return !!ret;
}
static int maintenance_event_setter(struct maintenance_event *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Code\":", args->code);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->not_after) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NotAfter\":", args->not_after);
	   	ret += 1;
	}
	if (args->not_before) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NotBefore\":", args->not_before);
	   	ret += 1;
	}

	return !!ret;
}
static int minimal_policy_setter(struct minimal_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Id\":", args->id);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Orn\":", args->orn);
	   	ret += 1;
	}

	return !!ret;
}
static int nat_service_setter(struct nat_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
        if (args->public_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIps\":[" ));
		for (int i = 0; i < args->nb_public_ips; ++i) {
	       	    struct public_ip_light *p = &args->public_ips[i];
		    if (p != args->public_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(public_ip_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->public_ips_str) {
		ARG_TO_JSON(PublicIps, string, args->public_ips_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int net_setter(struct net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dhcp_options_set_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DhcpOptionsSetId\":", args->dhcp_options_set_id);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->tenancy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tenancy\":", args->tenancy);
	   	ret += 1;
	}

	return !!ret;
}
static int net_access_point_setter(struct net_access_point *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_access_point_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetAccessPointId\":", args->net_access_point_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteTableIds\":[" ));
		for (as = args->route_table_ids; *as; ++as) {
			if (as != args->route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_table_ids_str) {
		ARG_TO_JSON(RouteTableIds, string, args->route_table_ids_str);
		ret += 1;
	}
	if (args->service_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServiceName\":", args->service_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int net_peering_setter(struct net_peering *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->accepter_net_str) {
		ARG_TO_JSON(AccepterNet, string, args->accepter_net_str);
		ret += 1;
	} else if (args->is_set_accepter_net) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"AccepterNet\": { " ));
	       STRY(accepter_net_setter(&args->accepter_net, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	if (args->source_net_str) {
		ARG_TO_JSON(SourceNet, string, args->source_net_str);
		ret += 1;
	} else if (args->is_set_source_net) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"SourceNet\": { " ));
	       STRY(source_net_setter(&args->source_net, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->state_str) {
		ARG_TO_JSON(State, string, args->state_str);
		ret += 1;
	} else if (args->is_set_state) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"State\": { " ));
	       STRY(net_peering_state_setter(&args->state, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int net_peering_state_setter(struct net_peering_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->message) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Message\":", args->message);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}

	return !!ret;
}
static int net_to_virtual_gateway_link_setter(struct net_to_virtual_gateway_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}

	return !!ret;
}
static int nic_setter(struct nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->link_nic_str) {
		ARG_TO_JSON(LinkNic, string, args->link_nic_str);
		ret += 1;
	} else if (args->is_set_link_nic) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkNic\": { " ));
	       STRY(link_nic_setter(&args->link_nic, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->link_public_ip_str) {
		ARG_TO_JSON(LinkPublicIp, string, args->link_public_ip_str);
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkPublicIp\": { " ));
	       STRY(link_public_ip_setter(&args->link_public_ip, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->mac_address) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MacAddress\":", args->mac_address);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
        if (args->private_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(private_ip_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
        if (args->security_groups) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int nic_for_vm_creation_setter(struct nic_for_vm_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		ARG_TO_JSON(DeviceNumber, int, args->device_number);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
        if (args->private_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(private_ip_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->is_set_secondary_private_ip_count || args->secondary_private_ip_count) {
		ARG_TO_JSON(SecondaryPrivateIpCount, int, args->secondary_private_ip_count);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}

	return !!ret;
}
static int nic_light_setter(struct nic_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->link_nic_str) {
		ARG_TO_JSON(LinkNic, string, args->link_nic_str);
		ret += 1;
	} else if (args->is_set_link_nic) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkNic\": { " ));
	       STRY(link_nic_light_setter(&args->link_nic, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->link_public_ip_str) {
		ARG_TO_JSON(LinkPublicIp, string, args->link_public_ip_str);
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkPublicIp\": { " ));
	       STRY(link_public_ip_light_for_vm_setter(&args->link_public_ip, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->mac_address) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MacAddress\":", args->mac_address);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
        if (args->private_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light_for_vm *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(private_ip_light_for_vm_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
        if (args->security_groups) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}

	return !!ret;
}
static int osu_api_key_setter(struct osu_api_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ApiKeyId\":", args->api_key_id);
	   	ret += 1;
	}
	if (args->secret_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecretKey\":", args->secret_key);
	   	ret += 1;
	}

	return !!ret;
}
static int osu_export_image_export_task_setter(struct osu_export_image_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DiskImageFormat\":", args->disk_image_format);
	   	ret += 1;
	}
	if (args->osu_bucket) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucket\":", args->osu_bucket);
	   	ret += 1;
	}
	if (args->osu_manifest_url) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuManifestUrl\":", args->osu_manifest_url);
	   	ret += 1;
	}
	if (args->osu_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuPrefix\":", args->osu_prefix);
	   	ret += 1;
	}

	return !!ret;
}
static int osu_export_snapshot_export_task_setter(struct osu_export_snapshot_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DiskImageFormat\":", args->disk_image_format);
	   	ret += 1;
	}
	if (args->osu_bucket) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucket\":", args->osu_bucket);
	   	ret += 1;
	}
	if (args->osu_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuPrefix\":", args->osu_prefix);
	   	ret += 1;
	}

	return !!ret;
}
static int osu_export_to_create_setter(struct osu_export_to_create *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DiskImageFormat\":", args->disk_image_format);
	   	ret += 1;
	}
	if (args->osu_api_key_str) {
		ARG_TO_JSON(OsuApiKey, string, args->osu_api_key_str);
		ret += 1;
	} else if (args->is_set_osu_api_key) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuApiKey\": { " ));
	       STRY(osu_api_key_setter(&args->osu_api_key, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->osu_bucket) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucket\":", args->osu_bucket);
	   	ret += 1;
	}
	if (args->osu_manifest_url) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuManifestUrl\":", args->osu_manifest_url);
	   	ret += 1;
	}
	if (args->osu_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuPrefix\":", args->osu_prefix);
	   	ret += 1;
	}

	return !!ret;
}
static int permissions_on_resource_setter(struct permissions_on_resource *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountIds\":[" ));
		for (as = args->account_ids; *as; ++as) {
			if (as != args->account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_ids_str) {
		ARG_TO_JSON(AccountIds, string, args->account_ids_str);
		ret += 1;
	}
	if (args->is_set_global_permission) {
		ARG_TO_JSON(GlobalPermission, bool, args->global_permission);
	   	ret += 1;
	}

	return !!ret;
}
static int permissions_on_resource_creation_setter(struct permissions_on_resource_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->additions_str) {
		ARG_TO_JSON(Additions, string, args->additions_str);
		ret += 1;
	} else if (args->is_set_additions) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Additions\": { " ));
	       STRY(permissions_on_resource_setter(&args->additions, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->removals_str) {
		ARG_TO_JSON(Removals, string, args->removals_str);
		ret += 1;
	} else if (args->is_set_removals) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Removals\": { " ));
	       STRY(permissions_on_resource_setter(&args->removals, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}

	return !!ret;
}
static int phase1_options_setter(struct phase1_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dpd_timeout_action) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DpdTimeoutAction\":", args->dpd_timeout_action);
	   	ret += 1;
	}
	if (args->is_set_dpd_timeout_seconds || args->dpd_timeout_seconds) {
		ARG_TO_JSON(DpdTimeoutSeconds, int, args->dpd_timeout_seconds);
	   	ret += 1;
	}
	if (args->ike_versions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IkeVersions\":[" ));
		for (as = args->ike_versions; *as; ++as) {
			if (as != args->ike_versions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ike_versions_str) {
		ARG_TO_JSON(IkeVersions, string, args->ike_versions_str);
		ret += 1;
	}
	if (args->phase1_dh_group_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase1DhGroupNumbers\":[" ));
		for (ip = args->phase1_dh_group_numbers; *ip > 0; ++ip) {
			if (ip != args->phase1_dh_group_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase1_dh_group_numbers_str) {
		ARG_TO_JSON(Phase1DhGroupNumbers, string, args->phase1_dh_group_numbers_str);
		ret += 1;
	}
	if (args->phase1_encryption_algorithms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase1EncryptionAlgorithms\":[" ));
		for (as = args->phase1_encryption_algorithms; *as; ++as) {
			if (as != args->phase1_encryption_algorithms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase1_encryption_algorithms_str) {
		ARG_TO_JSON(Phase1EncryptionAlgorithms, string, args->phase1_encryption_algorithms_str);
		ret += 1;
	}
	if (args->phase1_integrity_algorithms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase1IntegrityAlgorithms\":[" ));
		for (as = args->phase1_integrity_algorithms; *as; ++as) {
			if (as != args->phase1_integrity_algorithms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase1_integrity_algorithms_str) {
		ARG_TO_JSON(Phase1IntegrityAlgorithms, string, args->phase1_integrity_algorithms_str);
		ret += 1;
	}
	if (args->is_set_phase1_lifetime_seconds || args->phase1_lifetime_seconds) {
		ARG_TO_JSON(Phase1LifetimeSeconds, int, args->phase1_lifetime_seconds);
	   	ret += 1;
	}
	if (args->is_set_replay_window_size || args->replay_window_size) {
		ARG_TO_JSON(ReplayWindowSize, int, args->replay_window_size);
	   	ret += 1;
	}
	if (args->startup_action) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StartupAction\":", args->startup_action);
	   	ret += 1;
	}

	return !!ret;
}
static int phase2_options_setter(struct phase2_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->phase2_dh_group_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase2DhGroupNumbers\":[" ));
		for (ip = args->phase2_dh_group_numbers; *ip > 0; ++ip) {
			if (ip != args->phase2_dh_group_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase2_dh_group_numbers_str) {
		ARG_TO_JSON(Phase2DhGroupNumbers, string, args->phase2_dh_group_numbers_str);
		ret += 1;
	}
	if (args->phase2_encryption_algorithms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase2EncryptionAlgorithms\":[" ));
		for (as = args->phase2_encryption_algorithms; *as; ++as) {
			if (as != args->phase2_encryption_algorithms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase2_encryption_algorithms_str) {
		ARG_TO_JSON(Phase2EncryptionAlgorithms, string, args->phase2_encryption_algorithms_str);
		ret += 1;
	}
	if (args->phase2_integrity_algorithms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase2IntegrityAlgorithms\":[" ));
		for (as = args->phase2_integrity_algorithms; *as; ++as) {
			if (as != args->phase2_integrity_algorithms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase2_integrity_algorithms_str) {
		ARG_TO_JSON(Phase2IntegrityAlgorithms, string, args->phase2_integrity_algorithms_str);
		ret += 1;
	}
	if (args->is_set_phase2_lifetime_seconds || args->phase2_lifetime_seconds) {
		ARG_TO_JSON(Phase2LifetimeSeconds, int, args->phase2_lifetime_seconds);
	   	ret += 1;
	}
	if (args->pre_shared_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PreSharedKey\":", args->pre_shared_key);
	   	ret += 1;
	}

	return !!ret;
}
static int placement_setter(struct placement *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->tenancy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tenancy\":", args->tenancy);
	   	ret += 1;
	}

	return !!ret;
}
static int policy_setter(struct policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_is_linkable) {
		ARG_TO_JSON(IsLinkable, bool, args->is_linkable);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Orn\":", args->orn);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->policy_default_version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyDefaultVersionId\":", args->policy_default_version_id);
	   	ret += 1;
	}
	if (args->policy_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyId\":", args->policy_id);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->is_set_resources_count || args->resources_count) {
		ARG_TO_JSON(ResourcesCount, int, args->resources_count);
	   	ret += 1;
	}

	return !!ret;
}
static int policy_entities_setter(struct policy_entities *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->accounts) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Accounts\":[" ));
		for (int i = 0; i < args->nb_accounts; ++i) {
	       	    struct minimal_policy *p = &args->accounts[i];
		    if (p != args->accounts)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(minimal_policy_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->accounts_str) {
		ARG_TO_JSON(Accounts, string, args->accounts_str);
		ret += 1;
	}
        if (args->groups) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Groups\":[" ));
		for (int i = 0; i < args->nb_groups; ++i) {
	       	    struct minimal_policy *p = &args->groups[i];
		    if (p != args->groups)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(minimal_policy_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->groups_str) {
		ARG_TO_JSON(Groups, string, args->groups_str);
		ret += 1;
	}
	if (args->is_set_has_more_items) {
		ARG_TO_JSON(HasMoreItems, bool, args->has_more_items);
	   	ret += 1;
	}
	if (args->is_set_items_count || args->items_count) {
		ARG_TO_JSON(ItemsCount, int, args->items_count);
	   	ret += 1;
	}
	if (args->is_set_max_results_limit || args->max_results_limit) {
		ARG_TO_JSON(MaxResultsLimit, int, args->max_results_limit);
	   	ret += 1;
	}
	if (args->is_set_max_results_truncated) {
		ARG_TO_JSON(MaxResultsTruncated, bool, args->max_results_truncated);
	   	ret += 1;
	}
        if (args->users) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Users\":[" ));
		for (int i = 0; i < args->nb_users; ++i) {
	       	    struct minimal_policy *p = &args->users[i];
		    if (p != args->users)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(minimal_policy_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->users_str) {
		ARG_TO_JSON(Users, string, args->users_str);
		ret += 1;
	}

	return !!ret;
}
static int policy_version_setter(struct policy_version *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->body) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Body\":", args->body);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->is_set_default_version) {
		ARG_TO_JSON(DefaultVersion, bool, args->default_version);
	   	ret += 1;
	}
	if (args->version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VersionId\":", args->version_id);
	   	ret += 1;
	}

	return !!ret;
}
static int private_ip_setter(struct private_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		ARG_TO_JSON(IsPrimary, bool, args->is_primary);
	   	ret += 1;
	}
	if (args->link_public_ip_str) {
		ARG_TO_JSON(LinkPublicIp, string, args->link_public_ip_str);
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkPublicIp\": { " ));
	       STRY(link_public_ip_setter(&args->link_public_ip, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}

	return !!ret;
}
static int private_ip_light_setter(struct private_ip_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		ARG_TO_JSON(IsPrimary, bool, args->is_primary);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}

	return !!ret;
}
static int private_ip_light_for_vm_setter(struct private_ip_light_for_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		ARG_TO_JSON(IsPrimary, bool, args->is_primary);
	   	ret += 1;
	}
	if (args->link_public_ip_str) {
		ARG_TO_JSON(LinkPublicIp, string, args->link_public_ip_str);
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkPublicIp\": { " ));
	       STRY(link_public_ip_light_for_vm_setter(&args->link_public_ip, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}

	return !!ret;
}
static int product_type_setter(struct product_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->product_type_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ProductTypeId\":", args->product_type_id);
	   	ret += 1;
	}
	if (args->vendor) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Vendor\":", args->vendor);
	   	ret += 1;
	}

	return !!ret;
}
static int public_ip_setter(struct public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkPublicIpId\":", args->link_public_ip_id);
	   	ret += 1;
	}
	if (args->nic_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicAccountId\":", args->nic_account_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}

	return !!ret;
}
static int public_ip_light_setter(struct public_ip_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}

	return !!ret;
}
static int quota_setter(struct quota *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_max_value || args->max_value) {
		ARG_TO_JSON(MaxValue, int, args->max_value);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->quota_collection) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QuotaCollection\":", args->quota_collection);
	   	ret += 1;
	}
	if (args->short_description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ShortDescription\":", args->short_description);
	   	ret += 1;
	}
	if (args->is_set_used_value || args->used_value) {
		ARG_TO_JSON(UsedValue, int, args->used_value);
	   	ret += 1;
	}

	return !!ret;
}
static int quota_types_setter(struct quota_types *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->quota_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QuotaType\":", args->quota_type);
	   	ret += 1;
	}
        if (args->quotas) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Quotas\":[" ));
		for (int i = 0; i < args->nb_quotas; ++i) {
	       	    struct quota *p = &args->quotas[i];
		    if (p != args->quotas)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(quota_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->quotas_str) {
		ARG_TO_JSON(Quotas, string, args->quotas_str);
		ret += 1;
	}

	return !!ret;
}
static int read_linked_policies_filters_setter(struct read_linked_policies_filters *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->path_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPrefix\":", args->path_prefix);
	   	ret += 1;
	}

	return !!ret;
}
static int read_policies_filters_setter(struct read_policies_filters *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_only_linked) {
		ARG_TO_JSON(OnlyLinked, bool, args->only_linked);
	   	ret += 1;
	}
	if (args->path_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPrefix\":", args->path_prefix);
	   	ret += 1;
	}
	if (args->scope) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Scope\":", args->scope);
	   	ret += 1;
	}

	return !!ret;
}
static int region_setter(struct region *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->endpoint) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Endpoint\":", args->endpoint);
	   	ret += 1;
	}
	if (args->region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RegionName\":", args->region_name);
	   	ret += 1;
	}

	return !!ret;
}
static int resource_load_balancer_tag_setter(struct resource_load_balancer_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Key\":", args->key);
	   	ret += 1;
	}

	return !!ret;
}
static int resource_tag_setter(struct resource_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Key\":", args->key);
	   	ret += 1;
	}
	if (args->value) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Value\":", args->value);
	   	ret += 1;
	}

	return !!ret;
}
static int route_setter(struct route *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_method) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationMethod\":", args->creation_method);
	   	ret += 1;
	}
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->destination_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationServiceId\":", args->destination_service_id);
	   	ret += 1;
	}
	if (args->gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"GatewayId\":", args->gateway_id);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetAccessPointId\":", args->net_access_point_id);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->vm_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmAccountId\":", args->vm_account_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}

	return !!ret;
}
static int route_light_setter(struct route_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->route_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteType\":", args->route_type);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}

	return !!ret;
}
static int route_propagating_virtual_gateway_setter(struct route_propagating_virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}

	return !!ret;
}
static int route_table_setter(struct route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->link_route_tables) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkRouteTables\":[" ));
		for (int i = 0; i < args->nb_link_route_tables; ++i) {
	       	    struct link_route_table *p = &args->link_route_tables[i];
		    if (p != args->link_route_tables)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(link_route_table_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->link_route_tables_str) {
		ARG_TO_JSON(LinkRouteTables, string, args->link_route_tables_str);
		ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
        if (args->route_propagating_virtual_gateways) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RoutePropagatingVirtualGateways\":[" ));
		for (int i = 0; i < args->nb_route_propagating_virtual_gateways; ++i) {
	       	    struct route_propagating_virtual_gateway *p = &args->route_propagating_virtual_gateways[i];
		    if (p != args->route_propagating_virtual_gateways)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(route_propagating_virtual_gateway_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->route_propagating_virtual_gateways_str) {
		ARG_TO_JSON(RoutePropagatingVirtualGateways, string, args->route_propagating_virtual_gateways_str);
		ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
        if (args->routes) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Routes\":[" ));
		for (int i = 0; i < args->nb_routes; ++i) {
	       	    struct route *p = &args->routes[i];
		    if (p != args->routes)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(route_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->routes_str) {
		ARG_TO_JSON(Routes, string, args->routes_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int security_group_setter(struct security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
        if (args->inbound_rules) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRules\":[" ));
		for (int i = 0; i < args->nb_inbound_rules; ++i) {
	       	    struct security_group_rule *p = &args->inbound_rules[i];
		    if (p != args->inbound_rules)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_rule_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->inbound_rules_str) {
		ARG_TO_JSON(InboundRules, string, args->inbound_rules_str);
		ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
        if (args->outbound_rules) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRules\":[" ));
		for (int i = 0; i < args->nb_outbound_rules; ++i) {
	       	    struct security_group_rule *p = &args->outbound_rules[i];
		    if (p != args->outbound_rules)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_rule_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->outbound_rules_str) {
		ARG_TO_JSON(OutboundRules, string, args->outbound_rules_str);
		ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int security_group_light_setter(struct security_group_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}

	return !!ret;
}
static int security_group_rule_setter(struct security_group_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_from_port_range || args->from_port_range) {
		ARG_TO_JSON(FromPortRange, int, args->from_port_range);
	   	ret += 1;
	}
	if (args->ip_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpProtocol\":", args->ip_protocol);
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
        if (args->security_groups_members) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupsMembers\":[" ));
		for (int i = 0; i < args->nb_security_groups_members; ++i) {
	       	    struct security_groups_member *p = &args->security_groups_members[i];
		    if (p != args->security_groups_members)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_groups_member_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->security_groups_members_str) {
		ARG_TO_JSON(SecurityGroupsMembers, string, args->security_groups_members_str);
		ret += 1;
	}
	if (args->service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ServiceIds\":[" ));
		for (as = args->service_ids; *as; ++as) {
			if (as != args->service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->service_ids_str) {
		ARG_TO_JSON(ServiceIds, string, args->service_ids_str);
		ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		ARG_TO_JSON(ToPortRange, int, args->to_port_range);
	   	ret += 1;
	}

	return !!ret;
}
static int security_groups_member_setter(struct security_groups_member *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}

	return !!ret;
}
static int server_certificate_setter(struct server_certificate *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Id\":", args->id);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Orn\":", args->orn);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->upload_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UploadDate\":", args->upload_date);
	   	ret += 1;
	}

	return !!ret;
}
static int service_setter(struct service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	if (args->service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServiceId\":", args->service_id);
	   	ret += 1;
	}
	if (args->service_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServiceName\":", args->service_name);
	   	ret += 1;
	}

	return !!ret;
}
static int snapshot_setter(struct snapshot *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_alias) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountAlias\":", args->account_alias);
	   	ret += 1;
	}
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->permissions_to_create_volume_str) {
		ARG_TO_JSON(PermissionsToCreateVolume, string, args->permissions_to_create_volume_str);
		ret += 1;
	} else if (args->is_set_permissions_to_create_volume) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"PermissionsToCreateVolume\": { " ));
	       STRY(permissions_on_resource_setter(&args->permissions_to_create_volume, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		ARG_TO_JSON(Progress, int, args->progress);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		ARG_TO_JSON(VolumeSize, int, args->volume_size);
	   	ret += 1;
	}

	return !!ret;
}
static int snapshot_export_task_setter(struct snapshot_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->comment) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Comment\":", args->comment);
	   	ret += 1;
	}
	if (args->osu_export_str) {
		ARG_TO_JSON(OsuExport, string, args->osu_export_str);
		ret += 1;
	} else if (args->is_set_osu_export) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuExport\": { " ));
	       STRY(osu_export_snapshot_export_task_setter(&args->osu_export, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		ARG_TO_JSON(Progress, int, args->progress);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->task_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"TaskId\":", args->task_id);
	   	ret += 1;
	}

	return !!ret;
}
static int source_net_setter(struct source_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}

	return !!ret;
}
static int source_security_group_setter(struct source_security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->security_group_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupAccountId\":", args->security_group_account_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}

	return !!ret;
}
static int state_comment_setter(struct state_comment *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->state_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateCode\":", args->state_code);
	   	ret += 1;
	}
	if (args->state_message) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateMessage\":", args->state_message);
	   	ret += 1;
	}

	return !!ret;
}
static int subnet_setter(struct subnet *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_available_ips_count || args->available_ips_count) {
		ARG_TO_JSON(AvailableIpsCount, int, args->available_ips_count);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->is_set_map_public_ip_on_launch) {
		ARG_TO_JSON(MapPublicIpOnLaunch, bool, args->map_public_ip_on_launch);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}

	return !!ret;
}
static int subregion_setter(struct subregion *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->location_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LocationCode\":", args->location_code);
	   	ret += 1;
	}
	if (args->region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RegionName\":", args->region_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}

	return !!ret;
}
static int tag_setter(struct tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Key\":", args->key);
	   	ret += 1;
	}
	if (args->resource_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ResourceId\":", args->resource_id);
	   	ret += 1;
	}
	if (args->resource_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ResourceType\":", args->resource_type);
	   	ret += 1;
	}
	if (args->value) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Value\":", args->value);
	   	ret += 1;
	}

	return !!ret;
}
static int unit_price_entry_setter(struct unit_price_entry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->currency) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Currency\":", args->currency);
	   	ret += 1;
	}
	if (args->operation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Operation\":", args->operation);
	   	ret += 1;
	}
	if (args->service) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Service\":", args->service);
	   	ret += 1;
	}
	if (args->type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Type\":", args->type);
	   	ret += 1;
	}
	if (args->unit) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Unit\":", args->unit);
	   	ret += 1;
	}
	if (args->is_set_unit_price || args->unit_price) {
		ARG_TO_JSON(UnitPrice, double, args->unit_price);
	   	ret += 1;
	}

	return !!ret;
}
static int user_setter(struct user *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->is_set_outscale_login_allowed) {
		ARG_TO_JSON(OutscaleLoginAllowed, bool, args->outscale_login_allowed);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserEmail\":", args->user_email);
	   	ret += 1;
	}
	if (args->user_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserId\":", args->user_id);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}

	return !!ret;
}
static int user_group_setter(struct user_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Orn\":", args->orn);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupId\":", args->user_group_id);
	   	ret += 1;
	}

	return !!ret;
}
static int vgw_telemetry_setter(struct vgw_telemetry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_accepted_route_count || args->accepted_route_count) {
		ARG_TO_JSON(AcceptedRouteCount, int, args->accepted_route_count);
	   	ret += 1;
	}
	if (args->last_state_change_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastStateChangeDate\":", args->last_state_change_date);
	   	ret += 1;
	}
	if (args->outside_ip_address) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OutsideIpAddress\":", args->outside_ip_address);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->state_description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateDescription\":", args->state_description);
	   	ret += 1;
	}

	return !!ret;
}
static int virtual_gateway_setter(struct virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
        if (args->net_to_virtual_gateway_links) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetToVirtualGatewayLinks\":[" ));
		for (int i = 0; i < args->nb_net_to_virtual_gateway_links; ++i) {
	       	    struct net_to_virtual_gateway_link *p = &args->net_to_virtual_gateway_links[i];
		    if (p != args->net_to_virtual_gateway_links)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(net_to_virtual_gateway_link_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->net_to_virtual_gateway_links_str) {
		ARG_TO_JSON(NetToVirtualGatewayLinks, string, args->net_to_virtual_gateway_links_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}

	return !!ret;
}
static int vm_setter(struct vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->actions_on_next_boot_str) {
		ARG_TO_JSON(ActionsOnNextBoot, string, args->actions_on_next_boot_str);
		ret += 1;
	} else if (args->is_set_actions_on_next_boot) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"ActionsOnNextBoot\": { " ));
	       STRY(actions_on_next_boot_setter(&args->actions_on_next_boot, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->architecture) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Architecture\":", args->architecture);
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_created *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_created_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->boot_mode) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BootMode\":", args->boot_mode);
	   	ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		ARG_TO_JSON(DeletionProtection, bool, args->deletion_protection);
	   	ret += 1;
	}
	if (args->hypervisor) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Hypervisor\":", args->hypervisor);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_launch_number || args->launch_number) {
		ARG_TO_JSON(LaunchNumber, int, args->launch_number);
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		ARG_TO_JSON(NestedVirtualization, bool, args->nested_virtualization);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
        if (args->nics) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Nics\":[" ));
		for (int i = 0; i < args->nb_nics; ++i) {
	       	    struct nic_light *p = &args->nics[i];
		    if (p != args->nics)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(nic_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->nics_str) {
		ARG_TO_JSON(Nics, string, args->nics_str);
		ret += 1;
	}
	if (args->os_family) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsFamily\":", args->os_family);
	   	ret += 1;
	}
	if (args->performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Performance\":", args->performance);
	   	ret += 1;
	}
	if (args->placement_str) {
		ARG_TO_JSON(Placement, string, args->placement_str);
		ret += 1;
	} else if (args->is_set_placement) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Placement\": { " ));
	       STRY(placement_setter(&args->placement, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->public_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicDnsName\":", args->public_dns_name);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->reservation_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ReservationId\":", args->reservation_id);
	   	ret += 1;
	}
	if (args->root_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceName\":", args->root_device_name);
	   	ret += 1;
	}
	if (args->root_device_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceType\":", args->root_device_type);
	   	ret += 1;
	}
        if (args->security_groups) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->state_reason) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateReason\":", args->state_reason);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->user_data) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserData\":", args->user_data);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmInitiatedShutdownBehavior\":", args->vm_initiated_shutdown_behavior);
	   	ret += 1;
	}
	if (args->vm_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmType\":", args->vm_type);
	   	ret += 1;
	}

	return !!ret;
}
static int vm_group_setter(struct vm_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->positioning_strategy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PositioningStrategy\":", args->positioning_strategy);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->is_set_vm_count || args->vm_count) {
		ARG_TO_JSON(VmCount, int, args->vm_count);
	   	ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	if (args->vm_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupName\":", args->vm_group_name);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}

	return !!ret;
}
static int vm_state_setter(struct vm_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->current_state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CurrentState\":", args->current_state);
	   	ret += 1;
	}
	if (args->previous_state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PreviousState\":", args->previous_state);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}

	return !!ret;
}
static int vm_states_setter(struct vm_states *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->maintenance_events) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEvents\":[" ));
		for (int i = 0; i < args->nb_maintenance_events; ++i) {
	       	    struct maintenance_event *p = &args->maintenance_events[i];
		    if (p != args->maintenance_events)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(maintenance_event_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->maintenance_events_str) {
		ARG_TO_JSON(MaintenanceEvents, string, args->maintenance_events_str);
		ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->vm_state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmState\":", args->vm_state);
	   	ret += 1;
	}

	return !!ret;
}
static int vm_template_setter(struct vm_template *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_cpu_cores || args->cpu_cores) {
		ARG_TO_JSON(CpuCores, int, args->cpu_cores);
	   	ret += 1;
	}
	if (args->cpu_generation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CpuGeneration\":", args->cpu_generation);
	   	ret += 1;
	}
	if (args->cpu_performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CpuPerformance\":", args->cpu_performance);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_ram || args->ram) {
		ARG_TO_JSON(Ram, int, args->ram);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	if (args->vm_template_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateName\":", args->vm_template_name);
	   	ret += 1;
	}

	return !!ret;
}
static int vm_type_setter(struct vm_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->ephemerals_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"EphemeralsType\":", args->ephemerals_type);
	   	ret += 1;
	}
	if (args->is_set_eth || args->eth) {
		ARG_TO_JSON(Eth, int, args->eth);
	   	ret += 1;
	}
	if (args->is_set_gpu || args->gpu) {
		ARG_TO_JSON(Gpu, int, args->gpu);
	   	ret += 1;
	}
	if (args->is_set_max_private_ips || args->max_private_ips) {
		ARG_TO_JSON(MaxPrivateIps, int, args->max_private_ips);
	   	ret += 1;
	}
	if (args->is_set_memory_size || args->memory_size) {
		ARG_TO_JSON(MemorySize, double, args->memory_size);
	   	ret += 1;
	}
	if (args->is_set_vcore_count || args->vcore_count) {
		ARG_TO_JSON(VcoreCount, int, args->vcore_count);
	   	ret += 1;
	}
	if (args->vm_type_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTypeName\":", args->vm_type_name);
	   	ret += 1;
	}
	if (args->is_set_volume_count || args->volume_count) {
		ARG_TO_JSON(VolumeCount, int, args->volume_count);
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		ARG_TO_JSON(VolumeSize, int, args->volume_size);
	   	ret += 1;
	}

	return !!ret;
}
static int volume_setter(struct volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		ARG_TO_JSON(Iops, int, args->iops);
	   	ret += 1;
	}
        if (args->linked_volumes) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkedVolumes\":[" ));
		for (int i = 0; i < args->nb_linked_volumes; ++i) {
	       	    struct linked_volume *p = &args->linked_volumes[i];
		    if (p != args->linked_volumes)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(linked_volume_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->linked_volumes_str) {
		ARG_TO_JSON(LinkedVolumes, string, args->linked_volumes_str);
		ret += 1;
	}
	if (args->is_set_size || args->size) {
		ARG_TO_JSON(Size, int, args->size);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	if (args->volume_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeType\":", args->volume_type);
	   	ret += 1;
	}

	return !!ret;
}
static int vpn_connection_setter(struct vpn_connection *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->client_gateway_configuration) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayConfiguration\":", args->client_gateway_configuration);
	   	ret += 1;
	}
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
        if (args->routes) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Routes\":[" ));
		for (int i = 0; i < args->nb_routes; ++i) {
	       	    struct route_light *p = &args->routes[i];
		    if (p != args->routes)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(route_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->routes_str) {
		ARG_TO_JSON(Routes, string, args->routes_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->is_set_static_routes_only) {
		ARG_TO_JSON(StaticRoutesOnly, bool, args->static_routes_only);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
        if (args->vgw_telemetries) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VgwTelemetries\":[" ));
		for (int i = 0; i < args->nb_vgw_telemetries; ++i) {
	       	    struct vgw_telemetry *p = &args->vgw_telemetries[i];
		    if (p != args->vgw_telemetries)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(vgw_telemetry_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->vgw_telemetries_str) {
		ARG_TO_JSON(VgwTelemetries, string, args->vgw_telemetries_str);
		ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	if (args->vpn_options_str) {
		ARG_TO_JSON(VpnOptions, string, args->vpn_options_str);
		ret += 1;
	} else if (args->is_set_vpn_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"VpnOptions\": { " ));
	       STRY(vpn_options_setter(&args->vpn_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}

	return !!ret;
}
static int vpn_options_setter(struct vpn_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->phase1_options_str) {
		ARG_TO_JSON(Phase1Options, string, args->phase1_options_str);
		ret += 1;
	} else if (args->is_set_phase1_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Phase1Options\": { " ));
	       STRY(phase1_options_setter(&args->phase1_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->phase2_options_str) {
		ARG_TO_JSON(Phase2Options, string, args->phase2_options_str);
		ret += 1;
	} else if (args->is_set_phase2_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Phase2Options\": { " ));
	       STRY(phase2_options_setter(&args->phase2_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->tunnel_inside_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"TunnelInsideIpRange\":", args->tunnel_inside_ip_range);
	   	ret += 1;
	}

	return !!ret;
}
static int with_setter(struct with *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_account_id) {
		ARG_TO_JSON(AccountId, bool, args->account_id);
	   	ret += 1;
	}
	if (args->is_set_call_duration) {
		ARG_TO_JSON(CallDuration, bool, args->call_duration);
	   	ret += 1;
	}
	if (args->is_set_query_access_key) {
		ARG_TO_JSON(QueryAccessKey, bool, args->query_access_key);
	   	ret += 1;
	}
	if (args->is_set_query_api_name) {
		ARG_TO_JSON(QueryApiName, bool, args->query_api_name);
	   	ret += 1;
	}
	if (args->is_set_query_api_version) {
		ARG_TO_JSON(QueryApiVersion, bool, args->query_api_version);
	   	ret += 1;
	}
	if (args->is_set_query_call_name) {
		ARG_TO_JSON(QueryCallName, bool, args->query_call_name);
	   	ret += 1;
	}
	if (args->is_set_query_date) {
		ARG_TO_JSON(QueryDate, bool, args->query_date);
	   	ret += 1;
	}
	if (args->is_set_query_header_raw) {
		ARG_TO_JSON(QueryHeaderRaw, bool, args->query_header_raw);
	   	ret += 1;
	}
	if (args->is_set_query_header_size) {
		ARG_TO_JSON(QueryHeaderSize, bool, args->query_header_size);
	   	ret += 1;
	}
	if (args->is_set_query_ip_address) {
		ARG_TO_JSON(QueryIpAddress, bool, args->query_ip_address);
	   	ret += 1;
	}
	if (args->is_set_query_payload_raw) {
		ARG_TO_JSON(QueryPayloadRaw, bool, args->query_payload_raw);
	   	ret += 1;
	}
	if (args->is_set_query_payload_size) {
		ARG_TO_JSON(QueryPayloadSize, bool, args->query_payload_size);
	   	ret += 1;
	}
	if (args->is_set_query_user_agent) {
		ARG_TO_JSON(QueryUserAgent, bool, args->query_user_agent);
	   	ret += 1;
	}
	if (args->is_set_request_id) {
		ARG_TO_JSON(RequestId, bool, args->request_id);
	   	ret += 1;
	}
	if (args->is_set_response_size) {
		ARG_TO_JSON(ResponseSize, bool, args->response_size);
	   	ret += 1;
	}
	if (args->is_set_response_status_code) {
		ARG_TO_JSON(ResponseStatusCode, bool, args->response_status_code);
	   	ret += 1;
	}

	return !!ret;
}

static  int accept_net_peering_data(struct osc_env *e, struct osc_accept_net_peering_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/AcceptNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_accept_net_peering(struct osc_env *e, struct osc_str *out, struct osc_accept_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = accept_net_peering_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int add_user_to_user_group_data(struct osc_env *e, struct osc_add_user_to_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	if (args->user_group_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupPath\":", args->user_group_path);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	if (args->user_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserPath\":", args->user_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/AddUserToUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_add_user_to_user_group(struct osc_env *e, struct osc_str *out, struct osc_add_user_to_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = add_user_to_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int check_authentication_data(struct osc_env *e, struct osc_check_authentication_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->login) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Login\":", args->login);
	   	ret += 1;
	}
	if (args->password) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Password\":", args->password);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CheckAuthentication");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_check_authentication(struct osc_env *e, struct osc_str *out, struct osc_check_authentication_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = check_authentication_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_access_key_data(struct osc_env *e, struct osc_create_access_key_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->tag) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tag\":", args->tag);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_access_key(struct osc_env *e, struct osc_str *out, struct osc_create_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_access_key_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_account_data(struct osc_env *e, struct osc_create_account_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->additional_emails) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AdditionalEmails\":[" ));
		for (as = args->additional_emails; *as; ++as) {
			if (as != args->additional_emails)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->additional_emails_str) {
		ARG_TO_JSON(AdditionalEmails, string, args->additional_emails_str);
		ret += 1;
	}
	if (args->city) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"City\":", args->city);
	   	ret += 1;
	}
	if (args->company_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CompanyName\":", args->company_name);
	   	ret += 1;
	}
	if (args->country) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Country\":", args->country);
	   	ret += 1;
	}
	if (args->customer_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CustomerId\":", args->customer_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Email\":", args->email);
	   	ret += 1;
	}
	if (args->first_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FirstName\":", args->first_name);
	   	ret += 1;
	}
	if (args->job_title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"JobTitle\":", args->job_title);
	   	ret += 1;
	}
	if (args->last_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastName\":", args->last_name);
	   	ret += 1;
	}
	if (args->mobile_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MobileNumber\":", args->mobile_number);
	   	ret += 1;
	}
	if (args->phone_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PhoneNumber\":", args->phone_number);
	   	ret += 1;
	}
	if (args->state_province) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateProvince\":", args->state_province);
	   	ret += 1;
	}
	if (args->vat_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VatNumber\":", args->vat_number);
	   	ret += 1;
	}
	if (args->zip_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ZipCode\":", args->zip_code);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_account(struct osc_env *e, struct osc_str *out, struct osc_create_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_account_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_api_access_rule_data(struct osc_env *e, struct osc_create_api_access_rule_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->cns) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Cns\":[" ));
		for (as = args->cns; *as; ++as) {
			if (as != args->cns)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cns_str) {
		ARG_TO_JSON(Cns, string, args->cns_str);
		ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_create_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_api_access_rule_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_ca_data(struct osc_env *e, struct osc_create_ca_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->ca_pem) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaPem\":", args->ca_pem);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_ca(struct osc_env *e, struct osc_str *out, struct osc_create_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_ca_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_client_gateway_data(struct osc_env *e, struct osc_create_client_gateway_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_bgp_asn || args->bgp_asn) {
		ARG_TO_JSON(BgpAsn, int, args->bgp_asn);
	   	ret += 1;
	}
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateClientGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_client_gateway(struct osc_env *e, struct osc_str *out, struct osc_create_client_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_client_gateway_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_dedicated_group_data(struct osc_env *e, struct osc_create_dedicated_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_cpu_generation || args->cpu_generation) {
		ARG_TO_JSON(CpuGeneration, int, args->cpu_generation);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateDedicatedGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_create_dedicated_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_dedicated_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_dhcp_options_data(struct osc_env *e, struct osc_create_dhcp_options_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->domain_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DomainName\":", args->domain_name);
	   	ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DomainNameServers\":[" ));
		for (as = args->domain_name_servers; *as; ++as) {
			if (as != args->domain_name_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->domain_name_servers_str) {
		ARG_TO_JSON(DomainNameServers, string, args->domain_name_servers_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->log_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LogServers\":[" ));
		for (as = args->log_servers; *as; ++as) {
			if (as != args->log_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->log_servers_str) {
		ARG_TO_JSON(LogServers, string, args->log_servers_str);
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NtpServers\":[" ));
		for (as = args->ntp_servers; *as; ++as) {
			if (as != args->ntp_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ntp_servers_str) {
		ARG_TO_JSON(NtpServers, string, args->ntp_servers_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_create_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_dhcp_options_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_direct_link_interface_data(struct osc_env *e, struct osc_create_direct_link_interface_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->direct_link_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkId\":", args->direct_link_id);
	   	ret += 1;
	}
	if (args->direct_link_interface_str) {
		ARG_TO_JSON(DirectLinkInterface, string, args->direct_link_interface_str);
		ret += 1;
	} else if (args->is_set_direct_link_interface) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"DirectLinkInterface\": { " ));
	       STRY(direct_link_interface_setter(&args->direct_link_interface, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_create_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_direct_link_interface_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_direct_link_data(struct osc_env *e, struct osc_create_direct_link_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->bandwidth) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Bandwidth\":", args->bandwidth);
	   	ret += 1;
	}
	if (args->direct_link_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkName\":", args->direct_link_name);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Location\":", args->location);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateDirectLink");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_direct_link(struct osc_env *e, struct osc_str *out, struct osc_create_direct_link_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_direct_link_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_flexible_gpu_data(struct osc_env *e, struct osc_create_flexible_gpu_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->generation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Generation\":", args->generation);
	   	ret += 1;
	}
	if (args->model_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ModelName\":", args->model_name);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_create_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_flexible_gpu_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_image_export_task_data(struct osc_env *e, struct osc_create_image_export_task_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->osu_export_str) {
		ARG_TO_JSON(OsuExport, string, args->osu_export_str);
		ret += 1;
	} else if (args->is_set_osu_export) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuExport\": { " ));
	       STRY(osu_export_to_create_setter(&args->osu_export, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateImageExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_image_export_task(struct osc_env *e, struct osc_str *out, struct osc_create_image_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_image_export_task_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_image_data(struct osc_env *e, struct osc_create_image_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->architecture) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Architecture\":", args->architecture);
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_image *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_image_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->boot_modes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BootModes\":[" ));
		for (as = args->boot_modes; *as; ++as) {
			if (as != args->boot_modes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->boot_modes_str) {
		ARG_TO_JSON(BootModes, string, args->boot_modes_str);
		ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->file_location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FileLocation\":", args->file_location);
	   	ret += 1;
	}
	if (args->image_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageName\":", args->image_name);
	   	ret += 1;
	}
	if (args->is_set_no_reboot) {
		ARG_TO_JSON(NoReboot, bool, args->no_reboot);
	   	ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->root_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceName\":", args->root_device_name);
	   	ret += 1;
	}
	if (args->source_image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceImageId\":", args->source_image_id);
	   	ret += 1;
	}
	if (args->source_region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceRegionName\":", args->source_region_name);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_image(struct osc_env *e, struct osc_str *out, struct osc_create_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_image_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_internet_service_data(struct osc_env *e, struct osc_create_internet_service_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_internet_service(struct osc_env *e, struct osc_str *out, struct osc_create_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_internet_service_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_keypair_data(struct osc_env *e, struct osc_create_keypair_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->public_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicKey\":", args->public_key);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateKeypair");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_keypair(struct osc_env *e, struct osc_str *out, struct osc_create_keypair_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_keypair_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_listener_rule_data(struct osc_env *e, struct osc_create_listener_rule_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->listener_str) {
		ARG_TO_JSON(Listener, string, args->listener_str);
		ret += 1;
	} else if (args->is_set_listener) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Listener\": { " ));
	       STRY(load_balancer_light_setter(&args->listener, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->listener_rule_str) {
		ARG_TO_JSON(ListenerRule, string, args->listener_rule_str);
		ret += 1;
	} else if (args->is_set_listener_rule) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"ListenerRule\": { " ));
	       STRY(listener_rule_for_creation_setter(&args->listener_rule, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_create_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_listener_rule_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_listeners_data(struct osc_env *e, struct osc_create_load_balancer_listeners_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->listeners) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Listeners\":[" ));
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener_for_creation *p = &args->listeners[i];
		    if (p != args->listeners)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(listener_for_creation_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->listeners_str) {
		ARG_TO_JSON(Listeners, string, args->listeners_str);
		ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerListeners");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_load_balancer_listeners(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_listeners_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_load_balancer_listeners_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_policy_data(struct osc_env *e, struct osc_create_load_balancer_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_cookie_expiration_period || args->cookie_expiration_period) {
		ARG_TO_JSON(CookieExpirationPeriod, int, args->cookie_expiration_period);
	   	ret += 1;
	}
	if (args->cookie_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CookieName\":", args->cookie_name);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->policy_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyType\":", args->policy_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_load_balancer_policy(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_load_balancer_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_data(struct osc_env *e, struct osc_create_load_balancer_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->listeners) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Listeners\":[" ));
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener_for_creation *p = &args->listeners[i];
		    if (p != args->listeners)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(listener_for_creation_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->listeners_str) {
		ARG_TO_JSON(Listeners, string, args->listeners_str);
		ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->load_balancer_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerType\":", args->load_balancer_type);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (as = args->security_groups; *as; ++as) {
			if (as != args->security_groups)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->subnets) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Subnets\":[" ));
		for (as = args->subnets; *as; ++as) {
			if (as != args->subnets)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnets_str) {
		ARG_TO_JSON(Subnets, string, args->subnets_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_load_balancer_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_tags_data(struct osc_env *e, struct osc_create_load_balancer_tags_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerNames\":[" ));
		for (as = args->load_balancer_names; *as; ++as) {
			if (as != args->load_balancer_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_names_str) {
		ARG_TO_JSON(LoadBalancerNames, string, args->load_balancer_names_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_load_balancer_tags_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_nat_service_data(struct osc_env *e, struct osc_create_nat_service_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateNatService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_nat_service(struct osc_env *e, struct osc_str *out, struct osc_create_nat_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_nat_service_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_net_access_point_data(struct osc_env *e, struct osc_create_net_access_point_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteTableIds\":[" ));
		for (as = args->route_table_ids; *as; ++as) {
			if (as != args->route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_table_ids_str) {
		ARG_TO_JSON(RouteTableIds, string, args->route_table_ids_str);
		ret += 1;
	}
	if (args->service_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServiceName\":", args->service_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_create_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_net_access_point_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_net_peering_data(struct osc_env *e, struct osc_create_net_peering_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->accepter_net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccepterNetId\":", args->accepter_net_id);
	   	ret += 1;
	}
	if (args->accepter_owner_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccepterOwnerId\":", args->accepter_owner_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->source_net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceNetId\":", args->source_net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_net_peering(struct osc_env *e, struct osc_str *out, struct osc_create_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_net_peering_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_net_data(struct osc_env *e, struct osc_create_net_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->tenancy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tenancy\":", args->tenancy);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_net(struct osc_env *e, struct osc_str *out, struct osc_create_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_net_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_nic_data(struct osc_env *e, struct osc_create_nic_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->private_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(private_ip_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_nic(struct osc_env *e, struct osc_str *out, struct osc_create_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_nic_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_policy_data(struct osc_env *e, struct osc_create_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->document) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Document\":", args->document);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreatePolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_policy(struct osc_env *e, struct osc_str *out, struct osc_create_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_policy_version_data(struct osc_env *e, struct osc_create_policy_version_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->document) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Document\":", args->document);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->is_set_set_as_default) {
		ARG_TO_JSON(SetAsDefault, bool, args->set_as_default);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreatePolicyVersion");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_policy_version(struct osc_env *e, struct osc_str *out, struct osc_create_policy_version_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_policy_version_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_product_type_data(struct osc_env *e, struct osc_create_product_type_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vendor) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Vendor\":", args->vendor);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateProductType");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_product_type(struct osc_env *e, struct osc_str *out, struct osc_create_product_type_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_product_type_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_public_ip_data(struct osc_env *e, struct osc_create_public_ip_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreatePublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_public_ip(struct osc_env *e, struct osc_str *out, struct osc_create_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_public_ip_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_route_data(struct osc_env *e, struct osc_create_route_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"GatewayId\":", args->gateway_id);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_route(struct osc_env *e, struct osc_str *out, struct osc_create_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_route_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_route_table_data(struct osc_env *e, struct osc_create_route_table_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_route_table(struct osc_env *e, struct osc_str *out, struct osc_create_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_route_table_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_security_group_data(struct osc_env *e, struct osc_create_security_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateSecurityGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_security_group(struct osc_env *e, struct osc_str *out, struct osc_create_security_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_security_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_security_group_rule_data(struct osc_env *e, struct osc_create_security_group_rule_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flow) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Flow\":", args->flow);
	   	ret += 1;
	}
	if (args->is_set_from_port_range || args->from_port_range) {
		ARG_TO_JSON(FromPortRange, int, args->from_port_range);
	   	ret += 1;
	}
	if (args->ip_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpProtocol\":", args->ip_protocol);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
        if (args->rules) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Rules\":[" ));
		for (int i = 0; i < args->nb_rules; ++i) {
	       	    struct security_group_rule *p = &args->rules[i];
		    if (p != args->rules)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_rule_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->rules_str) {
		ARG_TO_JSON(Rules, string, args->rules_str);
		ret += 1;
	}
	if (args->security_group_account_id_to_link) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupAccountIdToLink\":", args->security_group_account_id_to_link);
	   	ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name_to_link) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupNameToLink\":", args->security_group_name_to_link);
	   	ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		ARG_TO_JSON(ToPortRange, int, args->to_port_range);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateSecurityGroupRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_security_group_rule(struct osc_env *e, struct osc_str *out, struct osc_create_security_group_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_security_group_rule_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_server_certificate_data(struct osc_env *e, struct osc_create_server_certificate_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->body) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Body\":", args->body);
	   	ret += 1;
	}
	if (args->chain) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Chain\":", args->chain);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->private_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateKey\":", args->private_key);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_create_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_server_certificate_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_snapshot_export_task_data(struct osc_env *e, struct osc_create_snapshot_export_task_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->osu_export_str) {
		ARG_TO_JSON(OsuExport, string, args->osu_export_str);
		ret += 1;
	} else if (args->is_set_osu_export) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuExport\": { " ));
	       STRY(osu_export_to_create_setter(&args->osu_export, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateSnapshotExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_snapshot_export_task(struct osc_env *e, struct osc_str *out, struct osc_create_snapshot_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_snapshot_export_task_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_snapshot_data(struct osc_env *e, struct osc_create_snapshot_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->file_location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FileLocation\":", args->file_location);
	   	ret += 1;
	}
	if (args->is_set_snapshot_size || args->snapshot_size) {
		ARG_TO_JSON(SnapshotSize, int, args->snapshot_size);
	   	ret += 1;
	}
	if (args->source_region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceRegionName\":", args->source_region_name);
	   	ret += 1;
	}
	if (args->source_snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceSnapshotId\":", args->source_snapshot_id);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_snapshot(struct osc_env *e, struct osc_str *out, struct osc_create_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_snapshot_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_subnet_data(struct osc_env *e, struct osc_create_subnet_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_subnet(struct osc_env *e, struct osc_str *out, struct osc_create_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_subnet_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_tags_data(struct osc_env *e, struct osc_create_tags_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->resource_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResourceIds\":[" ));
		for (as = args->resource_ids; *as; ++as) {
			if (as != args->resource_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->resource_ids_str) {
		ARG_TO_JSON(ResourceIds, string, args->resource_ids_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_tags(struct osc_env *e, struct osc_str *out, struct osc_create_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_tags_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_user_group_data(struct osc_env *e, struct osc_create_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_user_group(struct osc_env *e, struct osc_str *out, struct osc_create_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_user_data(struct osc_env *e, struct osc_create_user_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserEmail\":", args->user_email);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateUser");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_user(struct osc_env *e, struct osc_str *out, struct osc_create_user_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_user_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_virtual_gateway_data(struct osc_env *e, struct osc_create_virtual_gateway_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_create_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_virtual_gateway_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_vm_group_data(struct osc_env *e, struct osc_create_vm_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->positioning_strategy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PositioningStrategy\":", args->positioning_strategy);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->is_set_vm_count || args->vm_count) {
		ARG_TO_JSON(VmCount, int, args->vm_count);
	   	ret += 1;
	}
	if (args->vm_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupName\":", args->vm_group_name);
	   	ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_vm_group(struct osc_env *e, struct osc_str *out, struct osc_create_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_vm_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_vm_template_data(struct osc_env *e, struct osc_create_vm_template_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_cpu_cores || args->cpu_cores) {
		ARG_TO_JSON(CpuCores, int, args->cpu_cores);
	   	ret += 1;
	}
	if (args->cpu_generation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CpuGeneration\":", args->cpu_generation);
	   	ret += 1;
	}
	if (args->cpu_performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CpuPerformance\":", args->cpu_performance);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_ram || args->ram) {
		ARG_TO_JSON(Ram, int, args->ram);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_template_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateName\":", args->vm_template_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateVmTemplate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_vm_template(struct osc_env *e, struct osc_str *out, struct osc_create_vm_template_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_vm_template_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_vms_data(struct osc_env *e, struct osc_create_vms_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->actions_on_next_boot_str) {
		ARG_TO_JSON(ActionsOnNextBoot, string, args->actions_on_next_boot_str);
		ret += 1;
	} else if (args->is_set_actions_on_next_boot) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"ActionsOnNextBoot\": { " ));
	       STRY(actions_on_next_boot_setter(&args->actions_on_next_boot, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_vm_creation *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_vm_creation_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->boot_mode) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BootMode\":", args->boot_mode);
	   	ret += 1;
	}
	if (args->is_set_boot_on_creation) {
		ARG_TO_JSON(BootOnCreation, bool, args->boot_on_creation);
	   	ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		ARG_TO_JSON(DeletionProtection, bool, args->deletion_protection);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_max_vms_count || args->max_vms_count) {
		ARG_TO_JSON(MaxVmsCount, int, args->max_vms_count);
	   	ret += 1;
	}
	if (args->is_set_min_vms_count || args->min_vms_count) {
		ARG_TO_JSON(MinVmsCount, int, args->min_vms_count);
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		ARG_TO_JSON(NestedVirtualization, bool, args->nested_virtualization);
	   	ret += 1;
	}
        if (args->nics) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Nics\":[" ));
		for (int i = 0; i < args->nb_nics; ++i) {
	       	    struct nic_for_vm_creation *p = &args->nics[i];
		    if (p != args->nics)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(nic_for_vm_creation_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->nics_str) {
		ARG_TO_JSON(Nics, string, args->nics_str);
		ret += 1;
	}
	if (args->performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Performance\":", args->performance);
	   	ret += 1;
	}
	if (args->placement_str) {
		ARG_TO_JSON(Placement, string, args->placement_str);
		ret += 1;
	} else if (args->is_set_placement) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Placement\": { " ));
	       STRY(placement_setter(&args->placement, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->security_groups) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (as = args->security_groups; *as; ++as) {
			if (as != args->security_groups)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	if (args->user_data) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserData\":", args->user_data);
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmInitiatedShutdownBehavior\":", args->vm_initiated_shutdown_behavior);
	   	ret += 1;
	}
	if (args->vm_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmType\":", args->vm_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_vms(struct osc_env *e, struct osc_str *out, struct osc_create_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_vms_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_volume_data(struct osc_env *e, struct osc_create_volume_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		ARG_TO_JSON(Iops, int, args->iops);
	   	ret += 1;
	}
	if (args->is_set_size || args->size) {
		ARG_TO_JSON(Size, int, args->size);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->volume_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeType\":", args->volume_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_volume(struct osc_env *e, struct osc_str *out, struct osc_create_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_volume_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_vpn_connection_data(struct osc_env *e, struct osc_create_vpn_connection_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_static_routes_only) {
		ARG_TO_JSON(StaticRoutesOnly, bool, args->static_routes_only);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_create_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_vpn_connection_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int create_vpn_connection_route_data(struct osc_env *e, struct osc_create_vpn_connection_route_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/CreateVpnConnectionRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_create_vpn_connection_route(struct osc_env *e, struct osc_str *out, struct osc_create_vpn_connection_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = create_vpn_connection_route_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_access_key_data(struct osc_env *e, struct osc_delete_access_key_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_access_key(struct osc_env *e, struct osc_str *out, struct osc_delete_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_access_key_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_api_access_rule_data(struct osc_env *e, struct osc_delete_api_access_rule_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->api_access_rule_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ApiAccessRuleId\":", args->api_access_rule_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_api_access_rule_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_ca_data(struct osc_env *e, struct osc_delete_ca_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->ca_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaId\":", args->ca_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_ca(struct osc_env *e, struct osc_str *out, struct osc_delete_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_ca_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_client_gateway_data(struct osc_env *e, struct osc_delete_client_gateway_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteClientGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_client_gateway(struct osc_env *e, struct osc_str *out, struct osc_delete_client_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_client_gateway_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_dedicated_group_data(struct osc_env *e, struct osc_delete_dedicated_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->dedicated_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DedicatedGroupId\":", args->dedicated_group_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_force) {
		ARG_TO_JSON(Force, bool, args->force);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteDedicatedGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_delete_dedicated_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_dedicated_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_dhcp_options_data(struct osc_env *e, struct osc_delete_dhcp_options_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->dhcp_options_set_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DhcpOptionsSetId\":", args->dhcp_options_set_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_delete_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_dhcp_options_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_direct_link_interface_data(struct osc_env *e, struct osc_delete_direct_link_interface_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->direct_link_interface_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceId\":", args->direct_link_interface_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_delete_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_direct_link_interface_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_direct_link_data(struct osc_env *e, struct osc_delete_direct_link_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->direct_link_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkId\":", args->direct_link_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteDirectLink");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_direct_link(struct osc_env *e, struct osc_str *out, struct osc_delete_direct_link_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_direct_link_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_export_task_data(struct osc_env *e, struct osc_delete_export_task_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->export_task_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExportTaskId\":", args->export_task_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_export_task(struct osc_env *e, struct osc_str *out, struct osc_delete_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_export_task_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_flexible_gpu_data(struct osc_env *e, struct osc_delete_flexible_gpu_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_delete_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_flexible_gpu_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_image_data(struct osc_env *e, struct osc_delete_image_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_image(struct osc_env *e, struct osc_str *out, struct osc_delete_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_image_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_internet_service_data(struct osc_env *e, struct osc_delete_internet_service_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->internet_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InternetServiceId\":", args->internet_service_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_internet_service(struct osc_env *e, struct osc_str *out, struct osc_delete_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_internet_service_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_keypair_data(struct osc_env *e, struct osc_delete_keypair_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->keypair_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairId\":", args->keypair_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteKeypair");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_keypair(struct osc_env *e, struct osc_str *out, struct osc_delete_keypair_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_keypair_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_listener_rule_data(struct osc_env *e, struct osc_delete_listener_rule_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ListenerRuleName\":", args->listener_rule_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_listener_rule_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_listeners_data(struct osc_env *e, struct osc_delete_load_balancer_listeners_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->load_balancer_ports) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerPorts\":[" ));
		for (ip = args->load_balancer_ports; *ip > 0; ++ip) {
			if (ip != args->load_balancer_ports)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_ports_str) {
		ARG_TO_JSON(LoadBalancerPorts, string, args->load_balancer_ports_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerListeners");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_load_balancer_listeners(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_listeners_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_load_balancer_listeners_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_policy_data(struct osc_env *e, struct osc_delete_load_balancer_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_load_balancer_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_load_balancer_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_data(struct osc_env *e, struct osc_delete_load_balancer_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_load_balancer_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_tags_data(struct osc_env *e, struct osc_delete_load_balancer_tags_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerNames\":[" ));
		for (as = args->load_balancer_names; *as; ++as) {
			if (as != args->load_balancer_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_names_str) {
		ARG_TO_JSON(LoadBalancerNames, string, args->load_balancer_names_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_load_balancer_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_load_balancer_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_load_balancer_tags_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_nat_service_data(struct osc_env *e, struct osc_delete_nat_service_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteNatService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_nat_service(struct osc_env *e, struct osc_str *out, struct osc_delete_nat_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_nat_service_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_access_point_data(struct osc_env *e, struct osc_delete_net_access_point_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetAccessPointId\":", args->net_access_point_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_delete_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_net_access_point_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_peering_data(struct osc_env *e, struct osc_delete_net_peering_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_net_peering(struct osc_env *e, struct osc_str *out, struct osc_delete_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_net_peering_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_data(struct osc_env *e, struct osc_delete_net_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_net(struct osc_env *e, struct osc_str *out, struct osc_delete_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_net_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_nic_data(struct osc_env *e, struct osc_delete_nic_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_nic(struct osc_env *e, struct osc_str *out, struct osc_delete_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_nic_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_policy_data(struct osc_env *e, struct osc_delete_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeletePolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_policy_version_data(struct osc_env *e, struct osc_delete_policy_version_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VersionId\":", args->version_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeletePolicyVersion");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_policy_version(struct osc_env *e, struct osc_str *out, struct osc_delete_policy_version_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_policy_version_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_product_type_data(struct osc_env *e, struct osc_delete_product_type_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_force) {
		ARG_TO_JSON(Force, bool, args->force);
	   	ret += 1;
	}
	if (args->product_type_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ProductTypeId\":", args->product_type_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteProductType");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_product_type(struct osc_env *e, struct osc_str *out, struct osc_delete_product_type_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_product_type_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_public_ip_data(struct osc_env *e, struct osc_delete_public_ip_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeletePublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_public_ip(struct osc_env *e, struct osc_str *out, struct osc_delete_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_public_ip_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_route_data(struct osc_env *e, struct osc_delete_route_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_route(struct osc_env *e, struct osc_str *out, struct osc_delete_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_route_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_route_table_data(struct osc_env *e, struct osc_delete_route_table_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_route_table(struct osc_env *e, struct osc_str *out, struct osc_delete_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_route_table_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_security_group_data(struct osc_env *e, struct osc_delete_security_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteSecurityGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_security_group(struct osc_env *e, struct osc_str *out, struct osc_delete_security_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_security_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_security_group_rule_data(struct osc_env *e, struct osc_delete_security_group_rule_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flow) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Flow\":", args->flow);
	   	ret += 1;
	}
	if (args->is_set_from_port_range || args->from_port_range) {
		ARG_TO_JSON(FromPortRange, int, args->from_port_range);
	   	ret += 1;
	}
	if (args->ip_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpProtocol\":", args->ip_protocol);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
        if (args->rules) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Rules\":[" ));
		for (int i = 0; i < args->nb_rules; ++i) {
	       	    struct security_group_rule *p = &args->rules[i];
		    if (p != args->rules)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_rule_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->rules_str) {
		ARG_TO_JSON(Rules, string, args->rules_str);
		ret += 1;
	}
	if (args->security_group_account_id_to_unlink) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupAccountIdToUnlink\":", args->security_group_account_id_to_unlink);
	   	ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name_to_unlink) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupNameToUnlink\":", args->security_group_name_to_unlink);
	   	ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		ARG_TO_JSON(ToPortRange, int, args->to_port_range);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteSecurityGroupRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_security_group_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_security_group_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_security_group_rule_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_server_certificate_data(struct osc_env *e, struct osc_delete_server_certificate_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_delete_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_server_certificate_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_snapshot_data(struct osc_env *e, struct osc_delete_snapshot_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_snapshot(struct osc_env *e, struct osc_str *out, struct osc_delete_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_snapshot_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_subnet_data(struct osc_env *e, struct osc_delete_subnet_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_subnet(struct osc_env *e, struct osc_str *out, struct osc_delete_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_subnet_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_tags_data(struct osc_env *e, struct osc_delete_tags_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->resource_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResourceIds\":[" ));
		for (as = args->resource_ids; *as; ++as) {
			if (as != args->resource_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->resource_ids_str) {
		ARG_TO_JSON(ResourceIds, string, args->resource_ids_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_tags(struct osc_env *e, struct osc_str *out, struct osc_delete_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_tags_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_user_group_policy_data(struct osc_env *e, struct osc_delete_user_group_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	if (args->user_group_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupPath\":", args->user_group_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteUserGroupPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_user_group_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_user_group_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_user_group_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_user_group_data(struct osc_env *e, struct osc_delete_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_force) {
		ARG_TO_JSON(Force, bool, args->force);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_user_group(struct osc_env *e, struct osc_str *out, struct osc_delete_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_user_policy_data(struct osc_env *e, struct osc_delete_user_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteUserPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_user_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_user_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_user_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_user_data(struct osc_env *e, struct osc_delete_user_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteUser");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_user(struct osc_env *e, struct osc_str *out, struct osc_delete_user_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_user_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_virtual_gateway_data(struct osc_env *e, struct osc_delete_virtual_gateway_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_delete_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_virtual_gateway_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_vm_group_data(struct osc_env *e, struct osc_delete_vm_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_vm_group(struct osc_env *e, struct osc_str *out, struct osc_delete_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_vm_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_vm_template_data(struct osc_env *e, struct osc_delete_vm_template_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteVmTemplate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_vm_template(struct osc_env *e, struct osc_str *out, struct osc_delete_vm_template_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_vm_template_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_vms_data(struct osc_env *e, struct osc_delete_vms_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_vms(struct osc_env *e, struct osc_str *out, struct osc_delete_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_vms_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_volume_data(struct osc_env *e, struct osc_delete_volume_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_volume(struct osc_env *e, struct osc_str *out, struct osc_delete_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_volume_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_vpn_connection_data(struct osc_env *e, struct osc_delete_vpn_connection_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_delete_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_vpn_connection_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int delete_vpn_connection_route_data(struct osc_env *e, struct osc_delete_vpn_connection_route_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeleteVpnConnectionRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_delete_vpn_connection_route(struct osc_env *e, struct osc_str *out, struct osc_delete_vpn_connection_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = delete_vpn_connection_route_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int deregister_vms_in_load_balancer_data(struct osc_env *e, struct osc_deregister_vms_in_load_balancer_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DeregisterVmsInLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_deregister_vms_in_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_deregister_vms_in_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = deregister_vms_in_load_balancer_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int disable_outscale_login_for_users_data(struct osc_env *e, struct osc_disable_outscale_login_for_users_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DisableOutscaleLoginForUsers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_disable_outscale_login_for_users(struct osc_env *e, struct osc_str *out, struct osc_disable_outscale_login_for_users_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = disable_outscale_login_for_users_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int disable_outscale_login_per_users_data(struct osc_env *e, struct osc_disable_outscale_login_per_users_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"UserNames\":[" ));
		for (as = args->user_names; *as; ++as) {
			if (as != args->user_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->user_names_str) {
		ARG_TO_JSON(UserNames, string, args->user_names_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DisableOutscaleLoginPerUsers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_disable_outscale_login_per_users(struct osc_env *e, struct osc_str *out, struct osc_disable_outscale_login_per_users_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = disable_outscale_login_per_users_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int disable_outscale_login_data(struct osc_env *e, struct osc_disable_outscale_login_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/DisableOutscaleLogin");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_disable_outscale_login(struct osc_env *e, struct osc_str *out, struct osc_disable_outscale_login_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = disable_outscale_login_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int enable_outscale_login_for_users_data(struct osc_env *e, struct osc_enable_outscale_login_for_users_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/EnableOutscaleLoginForUsers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_enable_outscale_login_for_users(struct osc_env *e, struct osc_str *out, struct osc_enable_outscale_login_for_users_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = enable_outscale_login_for_users_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int enable_outscale_login_per_users_data(struct osc_env *e, struct osc_enable_outscale_login_per_users_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"UserNames\":[" ));
		for (as = args->user_names; *as; ++as) {
			if (as != args->user_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->user_names_str) {
		ARG_TO_JSON(UserNames, string, args->user_names_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/EnableOutscaleLoginPerUsers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_enable_outscale_login_per_users(struct osc_env *e, struct osc_str *out, struct osc_enable_outscale_login_per_users_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = enable_outscale_login_per_users_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int enable_outscale_login_data(struct osc_env *e, struct osc_enable_outscale_login_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/EnableOutscaleLogin");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_enable_outscale_login(struct osc_env *e, struct osc_str *out, struct osc_enable_outscale_login_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = enable_outscale_login_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_flexible_gpu_data(struct osc_env *e, struct osc_link_flexible_gpu_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_link_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_flexible_gpu_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_internet_service_data(struct osc_env *e, struct osc_link_internet_service_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->internet_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InternetServiceId\":", args->internet_service_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_internet_service(struct osc_env *e, struct osc_str *out, struct osc_link_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_internet_service_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_load_balancer_backend_machines_data(struct osc_env *e, struct osc_link_load_balancer_backend_machines_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->backend_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendIps\":[" ));
		for (as = args->backend_ips; *as; ++as) {
			if (as != args->backend_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_ips_str) {
		ARG_TO_JSON(BackendIps, string, args->backend_ips_str);
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkLoadBalancerBackendMachines");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_load_balancer_backend_machines(struct osc_env *e, struct osc_str *out, struct osc_link_load_balancer_backend_machines_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_load_balancer_backend_machines_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_managed_policy_to_user_group_data(struct osc_env *e, struct osc_link_managed_policy_to_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkManagedPolicyToUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_managed_policy_to_user_group(struct osc_env *e, struct osc_str *out, struct osc_link_managed_policy_to_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_managed_policy_to_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_nic_data(struct osc_env *e, struct osc_link_nic_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_device_number || args->device_number) {
		ARG_TO_JSON(DeviceNumber, int, args->device_number);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_nic(struct osc_env *e, struct osc_str *out, struct osc_link_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_nic_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_policy_data(struct osc_env *e, struct osc_link_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_policy(struct osc_env *e, struct osc_str *out, struct osc_link_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_private_ips_data(struct osc_env *e, struct osc_link_private_ips_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_allow_relink) {
		ARG_TO_JSON(AllowRelink, bool, args->allow_relink);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->is_set_secondary_private_ip_count || args->secondary_private_ip_count) {
		ARG_TO_JSON(SecondaryPrivateIpCount, int, args->secondary_private_ip_count);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkPrivateIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_private_ips(struct osc_env *e, struct osc_str *out, struct osc_link_private_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_private_ips_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_public_ip_data(struct osc_env *e, struct osc_link_public_ip_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_allow_relink) {
		ARG_TO_JSON(AllowRelink, bool, args->allow_relink);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkPublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_public_ip(struct osc_env *e, struct osc_str *out, struct osc_link_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_public_ip_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_route_table_data(struct osc_env *e, struct osc_link_route_table_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_route_table(struct osc_env *e, struct osc_str *out, struct osc_link_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_route_table_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_virtual_gateway_data(struct osc_env *e, struct osc_link_virtual_gateway_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_link_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_virtual_gateway_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int link_volume_data(struct osc_env *e, struct osc_link_volume_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/LinkVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_link_volume(struct osc_env *e, struct osc_str *out, struct osc_link_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = link_volume_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int put_user_group_policy_data(struct osc_env *e, struct osc_put_user_group_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_document) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyDocument\":", args->policy_document);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	if (args->user_group_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupPath\":", args->user_group_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/PutUserGroupPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_put_user_group_policy(struct osc_env *e, struct osc_str *out, struct osc_put_user_group_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = put_user_group_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int put_user_policy_data(struct osc_env *e, struct osc_put_user_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_document) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyDocument\":", args->policy_document);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/PutUserPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_put_user_policy(struct osc_env *e, struct osc_str *out, struct osc_put_user_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = put_user_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_access_keys_data(struct osc_env *e, struct osc_read_access_keys_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_access_keys_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->tag) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tag\":", args->tag);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadAccessKeys");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_access_keys(struct osc_env *e, struct osc_str *out, struct osc_read_access_keys_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_access_keys_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_accounts_data(struct osc_env *e, struct osc_read_accounts_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadAccounts");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_accounts(struct osc_env *e, struct osc_str *out, struct osc_read_accounts_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_accounts_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_admin_password_data(struct osc_env *e, struct osc_read_admin_password_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadAdminPassword");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_admin_password(struct osc_env *e, struct osc_str *out, struct osc_read_admin_password_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_admin_password_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_api_access_policy_data(struct osc_env *e, struct osc_read_api_access_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadApiAccessPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_api_access_policy(struct osc_env *e, struct osc_str *out, struct osc_read_api_access_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_api_access_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_api_access_rules_data(struct osc_env *e, struct osc_read_api_access_rules_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_api_access_rule_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadApiAccessRules");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_api_access_rules(struct osc_env *e, struct osc_str *out, struct osc_read_api_access_rules_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_api_access_rules_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_api_logs_data(struct osc_env *e, struct osc_read_api_logs_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_api_log_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	if (args->with_str) {
		ARG_TO_JSON(With, string, args->with_str);
		ret += 1;
	} else if (args->is_set_with) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"With\": { " ));
	       STRY(with_setter(&args->with, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadApiLogs");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_api_logs(struct osc_env *e, struct osc_str *out, struct osc_read_api_logs_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_api_logs_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_cas_data(struct osc_env *e, struct osc_read_cas_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_ca_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadCas");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_cas(struct osc_env *e, struct osc_str *out, struct osc_read_cas_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_cas_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_catalog_data(struct osc_env *e, struct osc_read_catalog_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_catalog_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_catalogs_data(struct osc_env *e, struct osc_read_catalogs_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_catalogs_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadCatalogs");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_catalogs(struct osc_env *e, struct osc_str *out, struct osc_read_catalogs_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_catalogs_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_client_gateways_data(struct osc_env *e, struct osc_read_client_gateways_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_client_gateway_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadClientGateways");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_client_gateways(struct osc_env *e, struct osc_str *out, struct osc_read_client_gateways_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_client_gateways_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_console_output_data(struct osc_env *e, struct osc_read_console_output_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadConsoleOutput");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_console_output(struct osc_env *e, struct osc_str *out, struct osc_read_console_output_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_console_output_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_consumption_account_data(struct osc_env *e, struct osc_read_consumption_account_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->from_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromDate\":", args->from_date);
	   	ret += 1;
	}
	if (args->is_set_overall) {
		ARG_TO_JSON(Overall, bool, args->overall);
	   	ret += 1;
	}
	if (args->is_set_show_price) {
		ARG_TO_JSON(ShowPrice, bool, args->show_price);
	   	ret += 1;
	}
	if (args->to_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToDate\":", args->to_date);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadConsumptionAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_consumption_account(struct osc_env *e, struct osc_str *out, struct osc_read_consumption_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_consumption_account_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_dedicated_groups_data(struct osc_env *e, struct osc_read_dedicated_groups_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_dedicated_group_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadDedicatedGroups");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_dedicated_groups(struct osc_env *e, struct osc_str *out, struct osc_read_dedicated_groups_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_dedicated_groups_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_dhcp_options_data(struct osc_env *e, struct osc_read_dhcp_options_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_dhcp_options_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_read_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_dhcp_options_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_direct_link_interfaces_data(struct osc_env *e, struct osc_read_direct_link_interfaces_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_direct_link_interface_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadDirectLinkInterfaces");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_direct_link_interfaces(struct osc_env *e, struct osc_str *out, struct osc_read_direct_link_interfaces_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_direct_link_interfaces_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_direct_links_data(struct osc_env *e, struct osc_read_direct_links_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_direct_link_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadDirectLinks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_direct_links(struct osc_env *e, struct osc_str *out, struct osc_read_direct_links_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_direct_links_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_entities_linked_to_policy_data(struct osc_env *e, struct osc_read_entities_linked_to_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->entities_type) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"EntitiesType\":[" ));
		for (as = args->entities_type; *as; ++as) {
			if (as != args->entities_type)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->entities_type_str) {
		ARG_TO_JSON(EntitiesType, string, args->entities_type_str);
		ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadEntitiesLinkedToPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_entities_linked_to_policy(struct osc_env *e, struct osc_str *out, struct osc_read_entities_linked_to_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_entities_linked_to_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_flexible_gpu_catalog_data(struct osc_env *e, struct osc_read_flexible_gpu_catalog_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadFlexibleGpuCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_flexible_gpu_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_flexible_gpu_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_flexible_gpu_catalog_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_flexible_gpus_data(struct osc_env *e, struct osc_read_flexible_gpus_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_flexible_gpu_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadFlexibleGpus");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_flexible_gpus(struct osc_env *e, struct osc_str *out, struct osc_read_flexible_gpus_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_flexible_gpus_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_image_export_tasks_data(struct osc_env *e, struct osc_read_image_export_tasks_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_export_task_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadImageExportTasks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_image_export_tasks(struct osc_env *e, struct osc_str *out, struct osc_read_image_export_tasks_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_image_export_tasks_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_images_data(struct osc_env *e, struct osc_read_images_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_image_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadImages");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_images(struct osc_env *e, struct osc_str *out, struct osc_read_images_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_images_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_internet_services_data(struct osc_env *e, struct osc_read_internet_services_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_internet_service_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadInternetServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_internet_services(struct osc_env *e, struct osc_str *out, struct osc_read_internet_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_internet_services_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_keypairs_data(struct osc_env *e, struct osc_read_keypairs_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_keypair_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadKeypairs");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_keypairs(struct osc_env *e, struct osc_str *out, struct osc_read_keypairs_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_keypairs_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_linked_policies_data(struct osc_env *e, struct osc_read_linked_policies_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(read_linked_policies_filters_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadLinkedPolicies");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_linked_policies(struct osc_env *e, struct osc_str *out, struct osc_read_linked_policies_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_linked_policies_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_listener_rules_data(struct osc_env *e, struct osc_read_listener_rules_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_listener_rule_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadListenerRules");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_listener_rules(struct osc_env *e, struct osc_str *out, struct osc_read_listener_rules_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_listener_rules_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_load_balancer_tags_data(struct osc_env *e, struct osc_read_load_balancer_tags_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerNames\":[" ));
		for (as = args->load_balancer_names; *as; ++as) {
			if (as != args->load_balancer_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_names_str) {
		ARG_TO_JSON(LoadBalancerNames, string, args->load_balancer_names_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_read_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_load_balancer_tags_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_load_balancers_data(struct osc_env *e, struct osc_read_load_balancers_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_load_balancer_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadLoadBalancers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_load_balancers(struct osc_env *e, struct osc_str *out, struct osc_read_load_balancers_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_load_balancers_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_locations_data(struct osc_env *e, struct osc_read_locations_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadLocations");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_locations(struct osc_env *e, struct osc_str *out, struct osc_read_locations_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_locations_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_managed_policies_linked_to_user_group_data(struct osc_env *e, struct osc_read_managed_policies_linked_to_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_user_group_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadManagedPoliciesLinkedToUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_managed_policies_linked_to_user_group(struct osc_env *e, struct osc_str *out, struct osc_read_managed_policies_linked_to_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_managed_policies_linked_to_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_nat_services_data(struct osc_env *e, struct osc_read_nat_services_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_nat_service_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadNatServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_nat_services(struct osc_env *e, struct osc_str *out, struct osc_read_nat_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_nat_services_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_net_access_point_services_data(struct osc_env *e, struct osc_read_net_access_point_services_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_service_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadNetAccessPointServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_net_access_point_services(struct osc_env *e, struct osc_str *out, struct osc_read_net_access_point_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_net_access_point_services_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_net_access_points_data(struct osc_env *e, struct osc_read_net_access_points_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_net_access_point_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadNetAccessPoints");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_net_access_points(struct osc_env *e, struct osc_str *out, struct osc_read_net_access_points_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_net_access_points_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_net_peerings_data(struct osc_env *e, struct osc_read_net_peerings_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_net_peering_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadNetPeerings");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_net_peerings(struct osc_env *e, struct osc_str *out, struct osc_read_net_peerings_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_net_peerings_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_nets_data(struct osc_env *e, struct osc_read_nets_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_net_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadNets");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_nets(struct osc_env *e, struct osc_str *out, struct osc_read_nets_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_nets_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_nics_data(struct osc_env *e, struct osc_read_nics_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_nic_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadNics");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_nics(struct osc_env *e, struct osc_str *out, struct osc_read_nics_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_nics_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_policies_data(struct osc_env *e, struct osc_read_policies_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(read_policies_filters_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadPolicies");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_policies(struct osc_env *e, struct osc_str *out, struct osc_read_policies_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_policies_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_policy_data(struct osc_env *e, struct osc_read_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_policy(struct osc_env *e, struct osc_str *out, struct osc_read_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_policy_version_data(struct osc_env *e, struct osc_read_policy_version_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VersionId\":", args->version_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadPolicyVersion");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_policy_version(struct osc_env *e, struct osc_str *out, struct osc_read_policy_version_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_policy_version_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_policy_versions_data(struct osc_env *e, struct osc_read_policy_versions_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadPolicyVersions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_policy_versions(struct osc_env *e, struct osc_str *out, struct osc_read_policy_versions_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_policy_versions_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_product_types_data(struct osc_env *e, struct osc_read_product_types_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_product_type_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadProductTypes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_product_types(struct osc_env *e, struct osc_str *out, struct osc_read_product_types_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_product_types_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_public_catalog_data(struct osc_env *e, struct osc_read_public_catalog_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadPublicCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_public_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_public_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_public_catalog_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_public_ip_ranges_data(struct osc_env *e, struct osc_read_public_ip_ranges_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadPublicIpRanges");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_public_ip_ranges(struct osc_env *e, struct osc_str *out, struct osc_read_public_ip_ranges_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_public_ip_ranges_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_public_ips_data(struct osc_env *e, struct osc_read_public_ips_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_public_ip_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadPublicIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_public_ips(struct osc_env *e, struct osc_str *out, struct osc_read_public_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_public_ips_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_quotas_data(struct osc_env *e, struct osc_read_quotas_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_quota_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadQuotas");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_quotas(struct osc_env *e, struct osc_str *out, struct osc_read_quotas_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_quotas_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_regions_data(struct osc_env *e, struct osc_read_regions_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadRegions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_regions(struct osc_env *e, struct osc_str *out, struct osc_read_regions_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_regions_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_route_tables_data(struct osc_env *e, struct osc_read_route_tables_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_route_table_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadRouteTables");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_route_tables(struct osc_env *e, struct osc_str *out, struct osc_read_route_tables_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_route_tables_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_security_groups_data(struct osc_env *e, struct osc_read_security_groups_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_security_group_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadSecurityGroups");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_security_groups(struct osc_env *e, struct osc_str *out, struct osc_read_security_groups_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_security_groups_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_server_certificates_data(struct osc_env *e, struct osc_read_server_certificates_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_server_certificate_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadServerCertificates");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_server_certificates(struct osc_env *e, struct osc_str *out, struct osc_read_server_certificates_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_server_certificates_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_snapshot_export_tasks_data(struct osc_env *e, struct osc_read_snapshot_export_tasks_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_export_task_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadSnapshotExportTasks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_snapshot_export_tasks(struct osc_env *e, struct osc_str *out, struct osc_read_snapshot_export_tasks_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_snapshot_export_tasks_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_snapshots_data(struct osc_env *e, struct osc_read_snapshots_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_snapshot_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadSnapshots");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_snapshots(struct osc_env *e, struct osc_str *out, struct osc_read_snapshots_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_snapshots_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_subnets_data(struct osc_env *e, struct osc_read_subnets_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_subnet_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadSubnets");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_subnets(struct osc_env *e, struct osc_str *out, struct osc_read_subnets_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_subnets_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_subregions_data(struct osc_env *e, struct osc_read_subregions_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_subregion_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadSubregions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_subregions(struct osc_env *e, struct osc_str *out, struct osc_read_subregions_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_subregions_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_tags_data(struct osc_env *e, struct osc_read_tags_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_tag_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_tags(struct osc_env *e, struct osc_str *out, struct osc_read_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_tags_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_unit_price_data(struct osc_env *e, struct osc_read_unit_price_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->operation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Operation\":", args->operation);
	   	ret += 1;
	}
	if (args->service) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Service\":", args->service);
	   	ret += 1;
	}
	if (args->type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Type\":", args->type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUnitPrice");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_unit_price(struct osc_env *e, struct osc_str *out, struct osc_read_unit_price_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_unit_price_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_user_group_policies_data(struct osc_env *e, struct osc_read_user_group_policies_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	if (args->user_group_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupPath\":", args->user_group_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUserGroupPolicies");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_user_group_policies(struct osc_env *e, struct osc_str *out, struct osc_read_user_group_policies_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_user_group_policies_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_user_group_policy_data(struct osc_env *e, struct osc_read_user_group_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	if (args->user_group_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupPath\":", args->user_group_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUserGroupPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_user_group_policy(struct osc_env *e, struct osc_str *out, struct osc_read_user_group_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_user_group_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_user_group_data(struct osc_env *e, struct osc_read_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_user_group(struct osc_env *e, struct osc_str *out, struct osc_read_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_user_groups_per_user_data(struct osc_env *e, struct osc_read_user_groups_per_user_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	if (args->user_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserPath\":", args->user_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUserGroupsPerUser");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_user_groups_per_user(struct osc_env *e, struct osc_str *out, struct osc_read_user_groups_per_user_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_user_groups_per_user_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_user_groups_data(struct osc_env *e, struct osc_read_user_groups_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_user_group_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUserGroups");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_user_groups(struct osc_env *e, struct osc_str *out, struct osc_read_user_groups_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_user_groups_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_user_policies_data(struct osc_env *e, struct osc_read_user_policies_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUserPolicies");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_user_policies(struct osc_env *e, struct osc_str *out, struct osc_read_user_policies_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_user_policies_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_user_policy_data(struct osc_env *e, struct osc_read_user_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUserPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_user_policy(struct osc_env *e, struct osc_str *out, struct osc_read_user_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_user_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_users_data(struct osc_env *e, struct osc_read_users_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_users_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadUsers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_users(struct osc_env *e, struct osc_str *out, struct osc_read_users_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_users_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_virtual_gateways_data(struct osc_env *e, struct osc_read_virtual_gateways_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_virtual_gateway_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVirtualGateways");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_virtual_gateways(struct osc_env *e, struct osc_str *out, struct osc_read_virtual_gateways_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_virtual_gateways_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_vm_groups_data(struct osc_env *e, struct osc_read_vm_groups_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vm_group_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVmGroups");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_vm_groups(struct osc_env *e, struct osc_str *out, struct osc_read_vm_groups_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_vm_groups_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_vm_templates_data(struct osc_env *e, struct osc_read_vm_templates_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vm_template_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVmTemplates");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_vm_templates(struct osc_env *e, struct osc_str *out, struct osc_read_vm_templates_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_vm_templates_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_vm_types_data(struct osc_env *e, struct osc_read_vm_types_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vm_type_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVmTypes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_vm_types(struct osc_env *e, struct osc_str *out, struct osc_read_vm_types_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_vm_types_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_health_data(struct osc_env *e, struct osc_read_vms_health_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVmsHealth");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_vms_health(struct osc_env *e, struct osc_str *out, struct osc_read_vms_health_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_vms_health_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_data(struct osc_env *e, struct osc_read_vms_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vm_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_vms(struct osc_env *e, struct osc_str *out, struct osc_read_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_vms_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_state_data(struct osc_env *e, struct osc_read_vms_state_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_all_vms) {
		ARG_TO_JSON(AllVms, bool, args->all_vms);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vms_state_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVmsState");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_vms_state(struct osc_env *e, struct osc_str *out, struct osc_read_vms_state_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_vms_state_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_volumes_data(struct osc_env *e, struct osc_read_volumes_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_volume_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVolumes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_volumes(struct osc_env *e, struct osc_str *out, struct osc_read_volumes_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_volumes_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int read_vpn_connections_data(struct osc_env *e, struct osc_read_vpn_connections_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vpn_connection_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ReadVpnConnections");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_read_vpn_connections(struct osc_env *e, struct osc_str *out, struct osc_read_vpn_connections_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = read_vpn_connections_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int reboot_vms_data(struct osc_env *e, struct osc_reboot_vms_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/RebootVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_reboot_vms(struct osc_env *e, struct osc_str *out, struct osc_reboot_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = reboot_vms_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int register_vms_in_load_balancer_data(struct osc_env *e, struct osc_register_vms_in_load_balancer_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/RegisterVmsInLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_register_vms_in_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_register_vms_in_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = register_vms_in_load_balancer_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int reject_net_peering_data(struct osc_env *e, struct osc_reject_net_peering_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/RejectNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_reject_net_peering(struct osc_env *e, struct osc_str *out, struct osc_reject_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = reject_net_peering_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int remove_user_from_user_group_data(struct osc_env *e, struct osc_remove_user_from_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	if (args->user_group_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupPath\":", args->user_group_path);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	if (args->user_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserPath\":", args->user_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/RemoveUserFromUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_remove_user_from_user_group(struct osc_env *e, struct osc_str *out, struct osc_remove_user_from_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = remove_user_from_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int scale_down_vm_group_data(struct osc_env *e, struct osc_scale_down_vm_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	if (args->is_set_vm_subtraction || args->vm_subtraction) {
		ARG_TO_JSON(VmSubtraction, int, args->vm_subtraction);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ScaleDownVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_scale_down_vm_group(struct osc_env *e, struct osc_str *out, struct osc_scale_down_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = scale_down_vm_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int scale_up_vm_group_data(struct osc_env *e, struct osc_scale_up_vm_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_vm_addition || args->vm_addition) {
		ARG_TO_JSON(VmAddition, int, args->vm_addition);
	   	ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/ScaleUpVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_scale_up_vm_group(struct osc_env *e, struct osc_str *out, struct osc_scale_up_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = scale_up_vm_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int set_default_policy_version_data(struct osc_env *e, struct osc_set_default_policy_version_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VersionId\":", args->version_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/SetDefaultPolicyVersion");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_set_default_policy_version(struct osc_env *e, struct osc_str *out, struct osc_set_default_policy_version_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = set_default_policy_version_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int start_vms_data(struct osc_env *e, struct osc_start_vms_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/StartVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_start_vms(struct osc_env *e, struct osc_str *out, struct osc_start_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = start_vms_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int stop_vms_data(struct osc_env *e, struct osc_stop_vms_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_force_stop) {
		ARG_TO_JSON(ForceStop, bool, args->force_stop);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/StopVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_stop_vms(struct osc_env *e, struct osc_str *out, struct osc_stop_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = stop_vms_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_flexible_gpu_data(struct osc_env *e, struct osc_unlink_flexible_gpu_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_unlink_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_flexible_gpu_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_internet_service_data(struct osc_env *e, struct osc_unlink_internet_service_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->internet_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InternetServiceId\":", args->internet_service_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_internet_service(struct osc_env *e, struct osc_str *out, struct osc_unlink_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_internet_service_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_load_balancer_backend_machines_data(struct osc_env *e, struct osc_unlink_load_balancer_backend_machines_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->backend_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendIps\":[" ));
		for (as = args->backend_ips; *as; ++as) {
			if (as != args->backend_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_ips_str) {
		ARG_TO_JSON(BackendIps, string, args->backend_ips_str);
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkLoadBalancerBackendMachines");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_load_balancer_backend_machines(struct osc_env *e, struct osc_str *out, struct osc_unlink_load_balancer_backend_machines_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_load_balancer_backend_machines_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_managed_policy_from_user_group_data(struct osc_env *e, struct osc_unlink_managed_policy_from_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkManagedPolicyFromUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_managed_policy_from_user_group(struct osc_env *e, struct osc_str *out, struct osc_unlink_managed_policy_from_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_managed_policy_from_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_nic_data(struct osc_env *e, struct osc_unlink_nic_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkNicId\":", args->link_nic_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_nic(struct osc_env *e, struct osc_str *out, struct osc_unlink_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_nic_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_policy_data(struct osc_env *e, struct osc_unlink_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_policy(struct osc_env *e, struct osc_str *out, struct osc_unlink_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_private_ips_data(struct osc_env *e, struct osc_unlink_private_ips_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkPrivateIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_private_ips(struct osc_env *e, struct osc_str *out, struct osc_unlink_private_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_private_ips_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_public_ip_data(struct osc_env *e, struct osc_unlink_public_ip_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkPublicIpId\":", args->link_public_ip_id);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkPublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_public_ip(struct osc_env *e, struct osc_str *out, struct osc_unlink_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_public_ip_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_route_table_data(struct osc_env *e, struct osc_unlink_route_table_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkRouteTableId\":", args->link_route_table_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_route_table(struct osc_env *e, struct osc_str *out, struct osc_unlink_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_route_table_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_virtual_gateway_data(struct osc_env *e, struct osc_unlink_virtual_gateway_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_unlink_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_virtual_gateway_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int unlink_volume_data(struct osc_env *e, struct osc_unlink_volume_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_force_unlink) {
		ARG_TO_JSON(ForceUnlink, bool, args->force_unlink);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UnlinkVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_unlink_volume(struct osc_env *e, struct osc_str *out, struct osc_unlink_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = unlink_volume_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_access_key_data(struct osc_env *e, struct osc_update_access_key_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_access_key(struct osc_env *e, struct osc_str *out, struct osc_update_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_access_key_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_account_data(struct osc_env *e, struct osc_update_account_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->additional_emails) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AdditionalEmails\":[" ));
		for (as = args->additional_emails; *as; ++as) {
			if (as != args->additional_emails)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->additional_emails_str) {
		ARG_TO_JSON(AdditionalEmails, string, args->additional_emails_str);
		ret += 1;
	}
	if (args->city) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"City\":", args->city);
	   	ret += 1;
	}
	if (args->company_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CompanyName\":", args->company_name);
	   	ret += 1;
	}
	if (args->country) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Country\":", args->country);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Email\":", args->email);
	   	ret += 1;
	}
	if (args->first_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FirstName\":", args->first_name);
	   	ret += 1;
	}
	if (args->job_title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"JobTitle\":", args->job_title);
	   	ret += 1;
	}
	if (args->last_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastName\":", args->last_name);
	   	ret += 1;
	}
	if (args->mobile_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MobileNumber\":", args->mobile_number);
	   	ret += 1;
	}
	if (args->phone_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PhoneNumber\":", args->phone_number);
	   	ret += 1;
	}
	if (args->state_province) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateProvince\":", args->state_province);
	   	ret += 1;
	}
	if (args->vat_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VatNumber\":", args->vat_number);
	   	ret += 1;
	}
	if (args->zip_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ZipCode\":", args->zip_code);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_account(struct osc_env *e, struct osc_str *out, struct osc_update_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_account_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_api_access_policy_data(struct osc_env *e, struct osc_update_api_access_policy_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_max_access_key_expiration_seconds || args->max_access_key_expiration_seconds) {
		ARG_TO_JSON(MaxAccessKeyExpirationSeconds, int, args->max_access_key_expiration_seconds);
	   	ret += 1;
	}
	if (args->is_set_require_trusted_env) {
		ARG_TO_JSON(RequireTrustedEnv, bool, args->require_trusted_env);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateApiAccessPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_api_access_policy(struct osc_env *e, struct osc_str *out, struct osc_update_api_access_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_api_access_policy_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_api_access_rule_data(struct osc_env *e, struct osc_update_api_access_rule_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->api_access_rule_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ApiAccessRuleId\":", args->api_access_rule_id);
	   	ret += 1;
	}
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->cns) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Cns\":[" ));
		for (as = args->cns; *as; ++as) {
			if (as != args->cns)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cns_str) {
		ARG_TO_JSON(Cns, string, args->cns_str);
		ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_update_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_api_access_rule_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_ca_data(struct osc_env *e, struct osc_update_ca_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->ca_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaId\":", args->ca_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_ca(struct osc_env *e, struct osc_str *out, struct osc_update_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_ca_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_dedicated_group_data(struct osc_env *e, struct osc_update_dedicated_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->dedicated_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DedicatedGroupId\":", args->dedicated_group_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateDedicatedGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_update_dedicated_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_dedicated_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_direct_link_interface_data(struct osc_env *e, struct osc_update_direct_link_interface_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->direct_link_interface_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceId\":", args->direct_link_interface_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_mtu || args->mtu) {
		ARG_TO_JSON(Mtu, int, args->mtu);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_update_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_direct_link_interface_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_flexible_gpu_data(struct osc_env *e, struct osc_update_flexible_gpu_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_update_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_flexible_gpu_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_image_data(struct osc_env *e, struct osc_update_image_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->permissions_to_launch_str) {
		ARG_TO_JSON(PermissionsToLaunch, string, args->permissions_to_launch_str);
		ret += 1;
	} else if (args->is_set_permissions_to_launch) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"PermissionsToLaunch\": { " ));
	       STRY(permissions_on_resource_creation_setter(&args->permissions_to_launch, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_image(struct osc_env *e, struct osc_str *out, struct osc_update_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_image_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_listener_rule_data(struct osc_env *e, struct osc_update_listener_rule_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->host_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"HostPattern\":", args->host_pattern);
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ListenerRuleName\":", args->listener_rule_name);
	   	ret += 1;
	}
	if (args->path_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPattern\":", args->path_pattern);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_update_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_listener_rule_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_load_balancer_data(struct osc_env *e, struct osc_update_load_balancer_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->access_log_str) {
		ARG_TO_JSON(AccessLog, string, args->access_log_str);
		ret += 1;
	} else if (args->is_set_access_log) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"AccessLog\": { " ));
	       STRY(access_log_setter(&args->access_log, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->health_check_str) {
		ARG_TO_JSON(HealthCheck, string, args->health_check_str);
		ret += 1;
	} else if (args->is_set_health_check) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"HealthCheck\": { " ));
	       STRY(health_check_setter(&args->health_check, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		ARG_TO_JSON(LoadBalancerPort, int, args->load_balancer_port);
	   	ret += 1;
	}
	if (args->policy_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PolicyNames\":[" ));
		for (as = args->policy_names; *as; ++as) {
			if (as != args->policy_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->policy_names_str) {
		ARG_TO_JSON(PolicyNames, string, args->policy_names_str);
		ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->is_set_secured_cookies) {
		ARG_TO_JSON(SecuredCookies, bool, args->secured_cookies);
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (as = args->security_groups; *as; ++as) {
			if (as != args->security_groups)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->server_certificate_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServerCertificateId\":", args->server_certificate_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_update_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_load_balancer_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_net_access_point_data(struct osc_env *e, struct osc_update_net_access_point_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->add_route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AddRouteTableIds\":[" ));
		for (as = args->add_route_table_ids; *as; ++as) {
			if (as != args->add_route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->add_route_table_ids_str) {
		ARG_TO_JSON(AddRouteTableIds, string, args->add_route_table_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetAccessPointId\":", args->net_access_point_id);
	   	ret += 1;
	}
	if (args->remove_route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RemoveRouteTableIds\":[" ));
		for (as = args->remove_route_table_ids; *as; ++as) {
			if (as != args->remove_route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->remove_route_table_ids_str) {
		ARG_TO_JSON(RemoveRouteTableIds, string, args->remove_route_table_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_update_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_net_access_point_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_net_data(struct osc_env *e, struct osc_update_net_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->dhcp_options_set_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DhcpOptionsSetId\":", args->dhcp_options_set_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_net(struct osc_env *e, struct osc_str *out, struct osc_update_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_net_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_nic_data(struct osc_env *e, struct osc_update_nic_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_nic_str) {
		ARG_TO_JSON(LinkNic, string, args->link_nic_str);
		ret += 1;
	} else if (args->is_set_link_nic) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkNic\": { " ));
	       STRY(link_nic_to_update_setter(&args->link_nic, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_nic(struct osc_env *e, struct osc_str *out, struct osc_update_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_nic_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_route_propagation_data(struct osc_env *e, struct osc_update_route_propagation_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_enable) {
		ARG_TO_JSON(Enable, bool, args->enable);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateRoutePropagation");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_route_propagation(struct osc_env *e, struct osc_str *out, struct osc_update_route_propagation_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_route_propagation_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_route_data(struct osc_env *e, struct osc_update_route_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"GatewayId\":", args->gateway_id);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_route(struct osc_env *e, struct osc_str *out, struct osc_update_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_route_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_route_table_link_data(struct osc_env *e, struct osc_update_route_table_link_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkRouteTableId\":", args->link_route_table_id);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateRouteTableLink");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_route_table_link(struct osc_env *e, struct osc_str *out, struct osc_update_route_table_link_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_route_table_link_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_server_certificate_data(struct osc_env *e, struct osc_update_server_certificate_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->new_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewName\":", args->new_name);
	   	ret += 1;
	}
	if (args->new_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewPath\":", args->new_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_update_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_server_certificate_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_snapshot_data(struct osc_env *e, struct osc_update_snapshot_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->permissions_to_create_volume_str) {
		ARG_TO_JSON(PermissionsToCreateVolume, string, args->permissions_to_create_volume_str);
		ret += 1;
	} else if (args->is_set_permissions_to_create_volume) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"PermissionsToCreateVolume\": { " ));
	       STRY(permissions_on_resource_creation_setter(&args->permissions_to_create_volume, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_snapshot(struct osc_env *e, struct osc_str *out, struct osc_update_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_snapshot_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_subnet_data(struct osc_env *e, struct osc_update_subnet_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_map_public_ip_on_launch) {
		ARG_TO_JSON(MapPublicIpOnLaunch, bool, args->map_public_ip_on_launch);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_subnet(struct osc_env *e, struct osc_str *out, struct osc_update_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_subnet_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_user_group_data(struct osc_env *e, struct osc_update_user_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->new_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewPath\":", args->new_path);
	   	ret += 1;
	}
	if (args->new_user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewUserGroupName\":", args->new_user_group_name);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserGroupName\":", args->user_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateUserGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_user_group(struct osc_env *e, struct osc_str *out, struct osc_update_user_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_user_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_user_data(struct osc_env *e, struct osc_update_user_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->new_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewPath\":", args->new_path);
	   	ret += 1;
	}
	if (args->new_user_email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewUserEmail\":", args->new_user_email);
	   	ret += 1;
	}
	if (args->new_user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewUserName\":", args->new_user_name);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateUser");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_user(struct osc_env *e, struct osc_str *out, struct osc_update_user_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_user_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_vm_group_data(struct osc_env *e, struct osc_update_vm_group_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	if (args->vm_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupName\":", args->vm_group_name);
	   	ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_vm_group(struct osc_env *e, struct osc_str *out, struct osc_update_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_vm_group_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_vm_data(struct osc_env *e, struct osc_update_vm_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->actions_on_next_boot_str) {
		ARG_TO_JSON(ActionsOnNextBoot, string, args->actions_on_next_boot_str);
		ret += 1;
	} else if (args->is_set_actions_on_next_boot) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"ActionsOnNextBoot\": { " ));
	       STRY(actions_on_next_boot_setter(&args->actions_on_next_boot, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_vm_update *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_vm_update_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		ARG_TO_JSON(DeletionProtection, bool, args->deletion_protection);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		ARG_TO_JSON(NestedVirtualization, bool, args->nested_virtualization);
	   	ret += 1;
	}
	if (args->performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Performance\":", args->performance);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->user_data) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserData\":", args->user_data);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmInitiatedShutdownBehavior\":", args->vm_initiated_shutdown_behavior);
	   	ret += 1;
	}
	if (args->vm_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmType\":", args->vm_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateVm");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_vm(struct osc_env *e, struct osc_str *out, struct osc_update_vm_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_vm_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_vm_template_data(struct osc_env *e, struct osc_update_vm_template_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	if (args->vm_template_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateName\":", args->vm_template_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateVmTemplate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_vm_template(struct osc_env *e, struct osc_str *out, struct osc_update_vm_template_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_vm_template_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_volume_data(struct osc_env *e, struct osc_update_volume_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		ARG_TO_JSON(Iops, int, args->iops);
	   	ret += 1;
	}
	if (args->is_set_size || args->size) {
		ARG_TO_JSON(Size, int, args->size);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	if (args->volume_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeType\":", args->volume_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_volume(struct osc_env *e, struct osc_str *out, struct osc_update_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_volume_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}
static  int update_vpn_connection_data(struct osc_env *e, struct osc_update_vpn_connection_arg *args, struct osc_str *data)
{
	struct osc_str end_call;
	int ret = 0;
	int count_args = 0;

	(void)count_args; /* if use only query/header and path, this is unused */
	osc_init_str(&end_call);
	osc_str_append_string(&end_call, e->endpoint.buf);
	if (!args)
		goto no_data;

	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	if (args->vpn_options_str) {
		ARG_TO_JSON(VpnOptions, string, args->vpn_options_str);
		ret += 1;
	} else if (args->is_set_vpn_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"VpnOptions\": { " ));
	       STRY(vpn_options_setter(&args->vpn_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");

no_data:
	osc_str_append_string(&end_call, "/api/v1/UpdateVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	osc_deinit_str(&end_call);
	return !!ret;
}

int osc_update_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_update_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	int r;

	osc_init_str(&data);
	r = update_vpn_connection_data(e, args, &data);
	if (r < 0)
		goto out;

        curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = osc_easy_perform(e);
	if (res != CURLE_OK)
		goto out;

	long statuscode = 200;
	res = curl_easy_getinfo(e->c, CURLINFO_RESPONSE_CODE, &statuscode);
	if (res != CURLE_OK)
		goto out;

	if (statuscode >= 400)
		res = 1;
out:
	osc_deinit_str(&data);
	return res;
}


int osc_sdk_set_useragent(struct osc_env *e, const char *str)
{
	return curl_easy_setopt(e->c, CURLOPT_USERAGENT, str);
}

static inline char *cfg_login(struct osc_env_conf *cfg)
{
	if (!cfg)
		return NULL;
	return cfg->login;
}

static inline char *cfg_pass(struct osc_env_conf *cfg)
{
	if (!cfg)
		return NULL;
	return cfg->password;
}

int osc_init_sdk_ext(struct osc_env *e, const char *profile, unsigned int flag,
		     struct osc_env_conf *cfg)
{
	*e = (struct osc_env){0};
	char *ca = getenv("CURL_CA_BUNDLE");
	char *endpoint;
	char user_agent[sizeof "osc-sdk-c/" + OSC_SDK_VERSON_L];
	char *cert = getenv("OSC_X509_CLIENT_CERT");
	char *sslkey = getenv("OSC_X509_CLIENT_KEY");
	char *auth = getenv("OSC_AUTH_METHOD");
	char *force_log = cfg_login(cfg);
	char *force_pass = cfg_pass(cfg);
	char *max_retries = getenv("OSC_MAX_RETRIES");
	char *retry_backoff_jitter = getenv("OSC_RETRY_BACKOFF_JITTER");
	char *retry_backoff_factor = getenv("OSC_RETRY_BACKOFF_FACTOR");

	strcpy(stpcpy(user_agent, "osc-sdk-c/"), osc_sdk_version_str());
	e->region = getenv("OSC_REGION");
	e->flag = flag;
	e->auth_method = cfg ? cfg->auth_method : OSC_AKSK_METHOD;
	e->max_retries = 3;
	e->retry_backoff_factor = 1.0;
	e->retry_backoff_jitter = 3.0;
	endpoint = getenv("OSC_ENDPOINT_API");
	osc_init_str(&e->endpoint);

	if (auth && (!strcmp(auth, "password") || !strcmp(auth, "basic"))) {
		e->auth_method = OSC_PASSWORD_METHOD;
	} else if (auth && !strcmp(auth, "none")) {
		e->auth_method = OSC_NONE_METHOD;
	} else if (auth && strcmp(auth, "accesskey")) {
		fprintf(stderr, "'%s' invalid authentication method\n", auth);
		return -1;
	}

	if (max_retries)
		e->max_retries = (int)strtol(max_retries, NULL, 10);
	if (retry_backoff_factor)
		e->retry_backoff_factor = (float)strtod(retry_backoff_factor, NULL);
	if (retry_backoff_jitter)
		e->retry_backoff_jitter = (float)strtod(retry_backoff_jitter, NULL);

	if (force_log)
		e->ak = force_log;
	if (force_pass)
		e->sk = force_pass;
	if (!profile && e->auth_method != OSC_NONE_METHOD) {
		profile = getenv("OSC_PROFILE");
		if (e->auth_method == OSC_PASSWORD_METHOD) {
			if (!force_log)
				e->ak = getenv("OSC_LOGIN");
			if (!force_pass)
				e->sk =  getenv("OSC_PASSWORD");
		} else {
			if (!force_log)
				e->ak = getenv("OSC_ACCESS_KEY");
			if (!force_pass)
				e->sk = getenv("OSC_SECRET_KEY");
		}
		if (!profile && (!e->ak || !e->sk))
			profile = "default";
	}

	if (profile && e->auth_method != OSC_NONE_METHOD) {
		int f;

		if (e->auth_method == OSC_PASSWORD_METHOD) {
			STRY(osc_load_loging_password_from_conf(
				    profile, force_log ? NULL : &e->ak,
				    force_pass ? NULL : &e->sk) < 0);
			if (!force_log)
				e->flag |= OSC_ENV_FREE_AK;
			if (!force_pass) {
				if (!e->sk)
					e->sk = getenv("OSC_PASSWORD");
				else
					e->flag |= OSC_ENV_FREE_SK;
			}
		} else {
			STRY(osc_load_ak_sk_from_conf(
				    profile, force_log ? NULL : &e->ak,
				    force_pass ? NULL : &e->sk) < 0);
			if (!force_log)
				e->flag |= OSC_ENV_FREE_AK;
			if (!force_pass)
				e->flag |= OSC_ENV_FREE_SK;
		}
		if (!osc_load_region_from_conf(profile, &e->region))
			e->flag |= OSC_ENV_FREE_REGION;
		f = osc_load_cert_from_conf_(profile, &e->cert, &e->sslkey,
					     &e->proxy, &e->endpoint_allocated_);
		if (e->cert)
			cert = e->cert;
		if (e->sslkey)
			sslkey = e->sslkey;
		if (f < 0)
			return -1;
		e->flag |= f;
		osc_set_extra_flag_from_conf(profile, &flag);
	}

	if (!e->region)
		e->region = "eu-west-2";

	if (!endpoint && !e->endpoint_allocated_) {
	osc_str_append_string(&e->endpoint, "https://api.");
	osc_str_append_string(&e->endpoint, e->region);
	osc_str_append_string(&e->endpoint, ".outscale.com");
	} else {
		if (e->endpoint_allocated_) {
			osc_str_append_string(&e->endpoint,
					      e->endpoint_allocated_);
		} else {
			osc_str_append_string(&e->endpoint, endpoint);
		}
	}

	if (e->auth_method == OSC_AKSK_METHOD) {
		if (!e->ak || !e->sk) {
			fprintf(stderr, "access key and secret key needed\n");
			return -1;
		}

		if (strlen(e->ak) != AK_SIZE || strlen(e->sk) != SK_SIZE) {
			fprintf(stderr, "wrong access key or secret key size\n");
			return -1;
		}
	} else if (e->auth_method == OSC_PASSWORD_METHOD) {
		if (!e->ak || !e->sk) {
			fprintf(stderr, "login and password needed\n");
			return -1;
		}
	}

	e->headers = NULL;
	e->c = curl_easy_init();

	#ifdef _WIN32
	curl_easy_setopt(e->c, CURLOPT_SSL_OPTIONS, (long)CURLSSLOPT_NATIVE_CA);
	#endif

	/* Setting HEADERS */
	if (flag & OSC_VERBOSE_MODE)
		curl_easy_setopt(e->c, CURLOPT_VERBOSE, 1);
	if (flag & OSC_INSECURE_MODE)
		curl_easy_setopt(e->c, CURLOPT_SSL_VERIFYPEER, 0);
	if (cert)
		curl_easy_setopt(e->c, CURLOPT_SSLCERT, cert);
	if (sslkey)
		curl_easy_setopt(e->c, CURLOPT_SSLKEY, sslkey);
	if (e->proxy)
		curl_easy_setopt(e->c, CURLOPT_PROXY, e->proxy);
	curl_easy_setopt(e->c, CURLOPT_WRITEFUNCTION, write_data);
	curl_easy_setopt(e->c, CURLOPT_USERAGENT, user_agent);

	/* setting CA if CURL_CA_BUNDLE is set */
	if (ca)
	  curl_easy_setopt(e->c, CURLOPT_CAINFO, ca);

	e->headers = curl_slist_append(e->headers, "Content-Type: application/json");

	/* For authentification we specify the method and our acces key / secret key */
	if (e->auth_method == OSC_AKSK_METHOD) {
		curl_easy_setopt(e->c, CURLOPT_AWS_SIGV4, "osc");
	} else if (e->auth_method == OSC_PASSWORD_METHOD) {
		time_t clock;
		struct tm tm;
		struct tm *tmp;
		char time_hdr[TIME_HDR_KEY_L + TIMESTAMP_SIZE] = TIME_HDR_KEY;

		time(&clock);
#if SAFE_C == 1
		TRY(!gmtime_r(&clock, &tm), "failed to convert time\n");\
		tmp = &tm;
#else
		(void)tm;
		tmp = gmtime(&clock);
		TRY(!tmp, "gmtime fail\n");
#endif
		strftime(time_hdr + TIME_HDR_KEY_L - 1,
			 TIMESTAMP_SIZE, "%Y%m%dT%H%M%SZ", tmp);
		e->headers = curl_slist_append(e->headers, time_hdr);
	}
	curl_easy_setopt(e->c, CURLOPT_HTTPHEADER, e->headers);

	if (e->auth_method != OSC_NONE_METHOD) {
		curl_easy_setopt(e->c, CURLOPT_USERNAME, e->ak);
		curl_easy_setopt(e->c, CURLOPT_PASSWORD, e->sk);
	}

	return 0;
}

int osc_init_sdk(struct osc_env *e, const char *profile, unsigned int flag)
{
	return osc_init_sdk_ext(e, profile, flag, NULL);
}

void osc_deinit_sdk(struct osc_env *e)
{
	curl_slist_free_all(e->headers);
	curl_easy_cleanup(e->c);
	osc_deinit_str(&e->endpoint);
	if (e->flag & OSC_ENV_FREE_AK) {
		free(e->ak);
		e->ak = NULL;
	}
	if (e->flag & OSC_ENV_FREE_SK) {
		free(e->sk);
		e->sk = NULL;
	}
	if (e->flag & OSC_ENV_FREE_REGION) {
		free(e->region);
		e->region = NULL;
	}

	if (e->flag & OSC_ENV_FREE_CERT) {
		free(e->cert);
	}

	if (e->flag & OSC_ENV_FREE_PROXY) {
		free(e->proxy);
	}

	if (e->flag & OSC_ENV_FREE_SSLKEY) {
		free(e->sslkey);
	}

	if (e->flag & OSC_ENV_FREE_ENDPOINT) {
		free(e->endpoint_allocated_);
	}

	e->c = NULL;
	e->flag = 0;
}

static int osc_msleep(int ms) {
    struct timespec t = { .tv_sec = ms / 1000, .tv_nsec = (ms % 1000) * 1000 };
    return nanosleep(&t, NULL);
}

CURLcode osc_easy_perform(struct osc_env *e) {
    CURL *handle, *tmp;
    CURLcode ret;
    long response_code;
    int backoff;

    for (int a = 0; a < e->max_retries; a++) {
        response_code = 200;
        handle = curl_easy_duphandle(e->c);
        if (!handle)
            return -1;

        ret = curl_easy_perform(handle);
        switch (ret) {
            case CURLE_OK:
                break;
            case CURLE_NOT_BUILT_IN:
            case CURLE_WRITE_ERROR:
            case CURLE_READ_ERROR:
            case CURLE_OUT_OF_MEMORY:
            case CURLE_BAD_FUNCTION_ARGUMENT:
            case CURLE_SSL_ENGINE_NOTFOUND:
            case CURLE_SSL_ENGINE_SETFAILED:
            case CURLE_SSL_CIPHER:
            case CURLE_SSL_ENGINE_INITFAILED:
            case CURLE_SSL_CACERT_BADFILE:
            case CURLE_SSL_CLIENTCERT:
            case CURLE_AUTH_ERROR:
                goto osc_easy_perform_return;
            default:
                goto osc_easy_perform_retry;
        }

        ret = curl_easy_getinfo(handle, CURLINFO_RESPONSE_CODE, &response_code);
        if (ret !=  CURLE_OK)
            goto osc_easy_perform_retry;

        if (response_code == 429
            || response_code == 409
            || (response_code >= 500 && response_code < 600)) {
osc_easy_perform_retry:
            backoff = (int)(1000 * e->retry_backoff_factor * powf(2.0, (float)a));
            backoff += (rand() * e->retry_backoff_jitter) / (RAND_MAX / 1000);
            fprintf(stderr, "WARN: attempt %d failed. Retrying in %d ms.\n", a, backoff);
            osc_msleep(backoff);
            backoff *= e->retry_backoff_factor;
            continue;
        }

osc_easy_perform_return:
        break;
    }

    tmp = e->c;
    e->c = handle;
    curl_easy_cleanup(tmp);
    return ret;
}
