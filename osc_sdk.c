/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, Outscale SAS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

 /*
  * This code is autogenerated, don't edit it directely
  */

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "curl/curl.h"
#include <time.h>
#include <unistd.h>
#include "osc_sdk.h"
#include "json.h"

#define AK_SIZE 20
#define SK_SIZE 40
#define TIMESTAMP_SIZE 17
#define TIME_HDR_KEY "X-Osc-Date: "
#define TIME_HDR_KEY_L (sizeof TIME_HDR_KEY)

#ifdef _WIN32

#define SAFE_C 0

static inline char* stpcpy(char *dest, const char *src)
{
	for (; *src; ++src) {
		*dest++ = *src;
	}
	*dest = 0;
	return dest;
}

#define CFG_FILE "config.json"

#define LOAD_CFG_GET_HOME(buf)			\
	{					\
		strcpy(buf, CFG_FILE);		\
	}
#else

#define CFG_FILE "/.osc/config.json"

#define SAFE_C 1

#endif

#ifdef WITH_DESCRIPTION

static const char *calls_name[] = {
	"UpdateVpnConnection",
	"UpdateVolume",
	"UpdateVmTemplate",
	"UpdateVmGroup",
	"UpdateVm",
	"UpdateUser",
	"UpdateSubnet",
	"UpdateSnapshot",
	"UpdateServerCertificate",
	"UpdateRouteTableLink",
	"UpdateRoutePropagation",
	"UpdateRoute",
	"UpdateNic",
	"UpdateNetAccessPoint",
	"UpdateNet",
	"UpdateLoadBalancer",
	"UpdateListenerRule",
	"UpdateImage",
	"UpdateFlexibleGpu",
	"UpdateDirectLinkInterface",
	"UpdateDedicatedGroup",
	"UpdateCa",
	"UpdateApiAccessRule",
	"UpdateApiAccessPolicy",
	"UpdateAccount",
	"UpdateAccessKey",
	"UnlinkVolume",
	"UnlinkVirtualGateway",
	"UnlinkRouteTable",
	"UnlinkPublicIp",
	"UnlinkPrivateIps",
	"UnlinkPolicy",
	"UnlinkNic",
	"UnlinkLoadBalancerBackendMachines",
	"UnlinkInternetService",
	"UnlinkFlexibleGpu",
	"StopVms",
	"StartVms",
	"SetDefaultPolicyVersion",
	"ScaleUpVmGroup",
	"ScaleDownVmGroup",
	"RejectNetPeering",
	"RegisterVmsInLoadBalancer",
	"RebootVms",
	"ReadVpnConnections",
	"ReadVolumes",
	"ReadVmsState",
	"ReadVmsHealth",
	"ReadVms",
	"ReadVmTypes",
	"ReadVmTemplates",
	"ReadVmGroups",
	"ReadVirtualGateways",
	"ReadUsers",
	"ReadTags",
	"ReadSubregions",
	"ReadSubnets",
	"ReadSnapshots",
	"ReadSnapshotExportTasks",
	"ReadServerCertificates",
	"ReadSecurityGroups",
	"ReadSecretAccessKey",
	"ReadRouteTables",
	"ReadRegions",
	"ReadQuotas",
	"ReadPublicIps",
	"ReadPublicIpRanges",
	"ReadPublicCatalog",
	"ReadProductTypes",
	"ReadPolicyVersions",
	"ReadPolicyVersion",
	"ReadPolicy",
	"ReadPolicies",
	"ReadNics",
	"ReadNets",
	"ReadNetPeerings",
	"ReadNetAccessPoints",
	"ReadNetAccessPointServices",
	"ReadNatServices",
	"ReadLocations",
	"ReadLoadBalancers",
	"ReadLoadBalancerTags",
	"ReadListenerRules",
	"ReadLinkedPolicies",
	"ReadKeypairs",
	"ReadInternetServices",
	"ReadImages",
	"ReadImageExportTasks",
	"ReadFlexibleGpus",
	"ReadFlexibleGpuCatalog",
	"ReadDirectLinks",
	"ReadDirectLinkInterfaces",
	"ReadDhcpOptions",
	"ReadDedicatedGroups",
	"ReadConsumptionAccount",
	"ReadConsoleOutput",
	"ReadClientGateways",
	"ReadCatalogs",
	"ReadCatalog",
	"ReadCas",
	"ReadApiLogs",
	"ReadApiAccessRules",
	"ReadApiAccessPolicy",
	"ReadAdminPassword",
	"ReadAccounts",
	"ReadAccessKeys",
	"LinkVolume",
	"LinkVirtualGateway",
	"LinkRouteTable",
	"LinkPublicIp",
	"LinkPrivateIps",
	"LinkPolicy",
	"LinkNic",
	"LinkLoadBalancerBackendMachines",
	"LinkInternetService",
	"LinkFlexibleGpu",
	"DeregisterVmsInLoadBalancer",
	"DeleteVpnConnectionRoute",
	"DeleteVpnConnection",
	"DeleteVolume",
	"DeleteVms",
	"DeleteVmTemplate",
	"DeleteVmGroup",
	"DeleteVirtualGateway",
	"DeleteUser",
	"DeleteTags",
	"DeleteSubnet",
	"DeleteSnapshot",
	"DeleteServerCertificate",
	"DeleteSecurityGroupRule",
	"DeleteSecurityGroup",
	"DeleteRouteTable",
	"DeleteRoute",
	"DeletePublicIp",
	"DeletePolicyVersion",
	"DeletePolicy",
	"DeleteNic",
	"DeleteNetPeering",
	"DeleteNetAccessPoint",
	"DeleteNet",
	"DeleteNatService",
	"DeleteLoadBalancerTags",
	"DeleteLoadBalancerPolicy",
	"DeleteLoadBalancerListeners",
	"DeleteLoadBalancer",
	"DeleteListenerRule",
	"DeleteKeypair",
	"DeleteInternetService",
	"DeleteImage",
	"DeleteFlexibleGpu",
	"DeleteExportTask",
	"DeleteDirectLinkInterface",
	"DeleteDirectLink",
	"DeleteDhcpOptions",
	"DeleteDedicatedGroup",
	"DeleteClientGateway",
	"DeleteCa",
	"DeleteApiAccessRule",
	"DeleteAccessKey",
	"CreateVpnConnectionRoute",
	"CreateVpnConnection",
	"CreateVolume",
	"CreateVms",
	"CreateVmTemplate",
	"CreateVmGroup",
	"CreateVirtualGateway",
	"CreateUser",
	"CreateTags",
	"CreateSubnet",
	"CreateSnapshotExportTask",
	"CreateSnapshot",
	"CreateServerCertificate",
	"CreateSecurityGroupRule",
	"CreateSecurityGroup",
	"CreateRouteTable",
	"CreateRoute",
	"CreatePublicIp",
	"CreateProductType",
	"CreatePolicyVersion",
	"CreatePolicy",
	"CreateNic",
	"CreateNetPeering",
	"CreateNetAccessPoint",
	"CreateNet",
	"CreateNatService",
	"CreateLoadBalancerTags",
	"CreateLoadBalancerPolicy",
	"CreateLoadBalancerListeners",
	"CreateLoadBalancer",
	"CreateListenerRule",
	"CreateKeypair",
	"CreateInternetService",
	"CreateImageExportTask",
	"CreateImage",
	"CreateFlexibleGpu",
	"CreateDirectLinkInterface",
	"CreateDirectLink",
	"CreateDhcpOptions",
	"CreateDedicatedGroup",
	"CreateClientGateway",
	"CreateCa",
	"CreateApiAccessRule",
	"CreateAccount",
	"CreateAccessKey",
	"CheckAuthentication",
	"AcceptNetPeering",
	NULL
};

static const char *calls_descriptions[] = {
	"Usage: oapi-cli UpdateVpnConnection --VpnConnectionId=vpnconnectionid [OPTIONS]\n" "Modifies the specified attributes of a VPN connection.\n" "\nRequired Argument: VpnConnectionId \n"
,
	"Usage: oapi-cli UpdateVolume --VolumeId=volumeid [OPTIONS]\n" "Modifies the specified attributes of a volume.\nCold volumes are volumes that \n" "are attached to stopped or stopping VMs, or that are detached. Hot volumes are \n" "volumes that are attached to running VMs.\n\n**[NOTE]**\nWhen the modification \n" "is not instantaneous, the response displays the previous value. You can use the \n" "[ReadVolumes](#readvolumes) method to see the new value.\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli UpdateVmTemplate --VmTemplateId=vmtemplateid [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nModifies the specified attributes of a template of virtual \n" "machines (VMs).\n" "\nRequired Argument: VmTemplateId \n"
,
	"Usage: oapi-cli UpdateVmGroup --VmGroupId=vmgroupid [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nModifies the specified attributes of a group of virtual machines \n" "(VMs).\n" "\nRequired Argument: VmGroupId \n"
,
	"Usage: oapi-cli UpdateVm --VmId=vmid [OPTIONS]\n" "Modifies the specified attributes of a virtual machine (VM).\nYou must stop the \n" "VM before modifying the following attributes:\n* `NestedVirtualization`\n* \n" "`Performance`\n* `UserData`\n* `VmType`\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli UpdateUser --UserName=username [OPTIONS]\n" "Modifies the name and/or the path of a specified EIM user.\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli UpdateSubnet --SubnetId=subnetid --MapPublicIpOnLaunch=mappubliciponlaunch [OPTIONS]\n" "Modifies the specified attribute of a Subnet.\n" "\nRequired Argument: SubnetId, MapPublicIpOnLaunch \n"
,
	"Usage: oapi-cli UpdateSnapshot --SnapshotId=snapshotid --PermissionsToCreateVolume=permissionstocreatevolume [OPTIONS]\n" "Modifies the permissions for a specified snapshot.\nYou must specify either the \n" "`Additions` or the `Removals` parameter.\nAfter sharing a snapshot with an \n" "account, the other account can create a copy of it that they own. For more \n" "information about copying snapshots, see [CreateSnapshot](#createsnapshot).\n" "\nRequired Argument: SnapshotId, PermissionsToCreateVolume \n"
,
	"Usage: oapi-cli UpdateServerCertificate --Name=name [OPTIONS]\n" "Modifies the name and/or the path of a specified server certificate.\n" "\nRequired Argument: Name \n"
,
	"Usage: oapi-cli UpdateRouteTableLink --RouteTableId=routetableid --LinkRouteTableId=linkroutetableid [OPTIONS]\n" "Replaces the route table associated with a specific Subnet in a Net with \n" "another one.\nAfter the route table is replaced, the Subnet uses the routes in \n" "the new route table it is associated with.\n" "\nRequired Argument: RouteTableId, LinkRouteTableId \n"
,
	"Usage: oapi-cli UpdateRoutePropagation --Enable=enable --RouteTableId=routetableid --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "Configures the propagation of routes to a specified route table of a Net by a \n" "virtual gateway.\n" "\nRequired Argument: Enable, RouteTableId, VirtualGatewayId \n"
,
	"Usage: oapi-cli UpdateRoute --RouteTableId=routetableid --DestinationIpRange=destinationiprange [OPTIONS]\n" "Replaces an existing route within a route table in a Net.\nYou must specify one \n" "of the following elements as the target:\n\n* Net peering\n* NAT virtual \n" "machine (VM)\n* Internet service\n* Virtual gateway\n* NAT service\n* Network \n" "interface card (NIC)\n\nThe routing algorithm is based on the most specific \n" "match.\n" "\nRequired Argument: RouteTableId, DestinationIpRange \n"
,
	"Usage: oapi-cli UpdateNic --NicId=nicid [OPTIONS]\n" "Modifies the specified network interface card (NIC). You can specify only one \n" "attribute at a time.\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli UpdateNetAccessPoint --NetAccessPointId=netaccesspointid [OPTIONS]\n" "Modifies the attributes of a Net access point.\nThis action enables you to add \n" "or remove route tables associated with the specified Net access point.\n" "\nRequired Argument: NetAccessPointId \n"
,
	"Usage: oapi-cli UpdateNet --DhcpOptionsSetId=dhcpoptionssetid --NetId=netid [OPTIONS]\n" "Associates a DHCP options set with a specified Net.\n" "\nRequired Argument: DhcpOptionsSetId, NetId \n"
,
	"Usage: oapi-cli UpdateLoadBalancer --LoadBalancerName=loadbalancername [OPTIONS]\n" "Modifies the specified attribute of a load balancer. You can specify only one \n" "attribute at a time.\n\nYou can set a new SSL certificate to an SSL or HTTPS \n" "listener of a load balancer.\nThis certificate replaces any certificate used on \n" "the same load balancer and port.\n\nYou can also replace the currently enabled \n" "policy for the load balancer with another one.\nIf the `PolicyNames` parameter \n" "is empty, the currently enabled policy is disabled.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli UpdateListenerRule --ListenerRuleName=listenerrulename [OPTIONS]\n" "Updates the pattern of the listener rule.\nThis call updates the pattern \n" "matching algorithm for incoming traffic.\n" "\nRequired Argument: ListenerRuleName \n"
,
	"Usage: oapi-cli UpdateImage --ImageId=imageid --PermissionsToLaunch=permissionstolaunch [OPTIONS]\n" "Modifies the access permissions for an OUTSCALE machine image (OMI).\nYou must \n" "specify either the `Additions` or the `Removals` parameter.\nAfter sharing an \n" "OMI with an account, the other account can create a copy of it that they own. \n" "For more information about copying OMIs, see [CreateImage](#createimage).\n" "\nRequired Argument: ImageId, PermissionsToLaunch \n"
,
	"Usage: oapi-cli UpdateFlexibleGpu --FlexibleGpuId=flexiblegpuid [OPTIONS]\n" "Modifies a flexible GPU (fGPU) behavior.\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli UpdateDirectLinkInterface --DirectLinkInterfaceId=directlinkinterfaceid --Mtu=mtu [OPTIONS]\n" "Modifies the maximum transmission unit (MTU) of a DirectLink interface.\n" "\nRequired Argument: DirectLinkInterfaceId, Mtu \n"
,
	"Usage: oapi-cli UpdateDedicatedGroup --DedicatedGroupId=dedicatedgroupid --Name=name [OPTIONS]\n" "> [WARNING]\n> This feature is currently in beta.\n\nModifies the name of a \n" "specified dedicated group.\n" "\nRequired Argument: DedicatedGroupId, Name \n"
,
	"Usage: oapi-cli UpdateCa --CaId=caid [OPTIONS]\n" "Modifies the specified attribute of a Client Certificate Authority (CA).\n" "\nRequired Argument: CaId \n"
,
	"Usage: oapi-cli UpdateApiAccessRule --ApiAccessRuleId=apiaccessruleid [OPTIONS]\n" "Modifies a specified API access rule.\n\n**[WARNING]** \n- The new rule you \n" "specify fully replaces the old rule. Therefore, for a parameter that is not \n" "specified, any previously set value is deleted.\n- If, as result of your \n" "modification, you no longer have access to the APIs, you will need to contact \n" "the Support team to regain access. For more information, see [Technical \n" "Support](https://docs.outscale.com/en/userguide/Technical-Support.html).\n" "\nRequired Argument: ApiAccessRuleId \n"
,
	"Usage: oapi-cli UpdateApiAccessPolicy --MaxAccessKeyExpirationSeconds=maxaccesskeyexpirationseconds --RequireTrustedEnv=requiretrustedenv [OPTIONS]\n" "Updates the API access policy of your account.\n\n**[IMPORTANT]**\nOnly one API \n" "access policy can be associated with your account.\n" "\nRequired Argument: MaxAccessKeyExpirationSeconds, RequireTrustedEnv \n"
,
	"Usage: oapi-cli UpdateAccount [OPTIONS]\n" "Updates the account information for the account that sends the request.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli UpdateAccessKey --AccessKeyId=accesskeyid --State=state [OPTIONS]\n" "Modifies the attributes of the specified access key of either your root account \n" "or an EIM user.\n" "\nRequired Argument: AccessKeyId, State \n"
,
	"Usage: oapi-cli UnlinkVolume --VolumeId=volumeid [OPTIONS]\n" "Detaches a Block Storage Unit (BSU) volume from a virtual machine (VM).\nTo \n" "detach the root device of a VM, this VM must be stopped.\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli UnlinkVirtualGateway --NetId=netid --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "Detaches a virtual gateway from a Net.\nYou must wait until the virtual gateway \n" "is in the detached state before you can attach another Net to it or delete the \n" "Net it was previously attached to.\n" "\nRequired Argument: NetId, VirtualGatewayId \n"
,
	"Usage: oapi-cli UnlinkRouteTable --LinkRouteTableId=linkroutetableid [OPTIONS]\n" "Disassociates a Subnet from a route table.\nAfter disassociation, the Subnet \n" "can no longer use the routes in this route table, but uses the routes in the \n" "main route table of the Net instead.\n" "\nRequired Argument: LinkRouteTableId \n"
,
	"Usage: oapi-cli UnlinkPublicIp [OPTIONS]\n" "Disassociates a public IP from the virtual machine (VM) or network interface \n" "card (NIC) it is associated with.\n\n**[IMPORTANT]**\nTo disassociate the \n" "public IP from a NAT service, you need to delete the NAT service. For more \n" "information, see the [DeleteNatService](#deletenatservice) method.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli UnlinkPrivateIps --NicId=nicid --PrivateIps=privateips [OPTIONS]\n" "Unassigns one or more secondary private IPs from a network interface card (NIC).\n" "\nRequired Argument: NicId, PrivateIps \n"
,
	"Usage: oapi-cli UnlinkPolicy --PolicyOrn=policyorn --UserName=username [OPTIONS]\n" "Removes a managed policy from a specific user.\n" "\nRequired Argument: PolicyOrn, UserName \n"
,
	"Usage: oapi-cli UnlinkNic --LinkNicId=linknicid [OPTIONS]\n" "Detaches a network interface card (NIC) from a virtual machine (VM).\nThe \n" "primary NIC cannot be detached.\n" "\nRequired Argument: LinkNicId \n"
,
	"Usage: oapi-cli UnlinkLoadBalancerBackendMachines --LoadBalancerName=loadbalancername [OPTIONS]\n" "Detaches one or more back-end virtual machines (VMs) from a load balancer. You \n" "need to specify at least the `BackendIps` or the `BackendVmIds` parameter.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli UnlinkInternetService --InternetServiceId=internetserviceid --NetId=netid [OPTIONS]\n" "Detaches an Internet service from a Net.\nThis action disables and detaches an \n" "Internet service from a Net. The Net must not contain virtual machines (VMs) \n" "using public IPs nor internet-facing load balancers.\n" "\nRequired Argument: InternetServiceId, NetId \n"
,
	"Usage: oapi-cli UnlinkFlexibleGpu --FlexibleGpuId=flexiblegpuid [OPTIONS]\n" "Detaches a flexible GPU (fGPU) from a virtual machine (VM).\nThe fGPU is in the \n" "`detaching` state until the VM is stopped, after which it becomes available for \n" "allocation again.\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli StopVms --VmIds=vmids [OPTIONS]\n" "Stops one or more running virtual machines (VMs).\nYou can stop only VMs that \n" "are valid and that belong to you. Data stored in the VM RAM is lost.\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli StartVms --VmIds=vmids [OPTIONS]\n" "Start one or more virtual machines (VMs).\nYou can start only VMs that are \n" "valid and that belong to you.\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli SetDefaultPolicyVersion --PolicyOrn=policyorn --VersionId=versionid [OPTIONS]\n" "Sets a specified version of a managed policy as the default (operative) \n" "one.\nYou can modify the default version of a policy at any time.\n" "\nRequired Argument: PolicyOrn, VersionId \n"
,
	"Usage: oapi-cli ScaleUpVmGroup --VmGroupId=vmgroupid --VmAddition=vmaddition [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nCreates additional virtual machines (VMs) in a VM group.\nThe new \n" "VMs use the current version of the VM template.\n" "\nRequired Argument: VmGroupId, VmAddition \n"
,
	"Usage: oapi-cli ScaleDownVmGroup --VmGroupId=vmgroupid --VmSubtraction=vmsubtraction [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nDeletes virtual machines (VMs) from a VM group.\nThe oldest VMs \n" "are the first to be deleted.\n" "\nRequired Argument: VmGroupId, VmSubtraction \n"
,
	"Usage: oapi-cli RejectNetPeering --NetPeeringId=netpeeringid [OPTIONS]\n" "Rejects a Net peering request.\nThe Net peering must be in the \n" "`pending-acceptance` state to be rejected. The rejected Net peering is then in \n" "the `rejected` state.\n" "\nRequired Argument: NetPeeringId \n"
,
	"Usage: oapi-cli RegisterVmsInLoadBalancer --BackendVmIds=backendvmids --LoadBalancerName=loadbalancername [OPTIONS]\n" "Registers one or more virtual machines (VMs) with a specified load \n" "balancer.\nThe VMs can be in different Subnets and different Subregions than \n" "the load balancer, as long as the VMs and load balancers are all in the public \n" "Cloud or all in the same Net. It may take a little time for a VM to be \n" "registered with the load balancer. Once the VM is registered with a load \n" "balancer, it receives traffic and requests from this load balancer and is \n" "called a back-end VM.\n" "\nRequired Argument: BackendVmIds, LoadBalancerName \n"
,
	"Usage: oapi-cli RebootVms --VmIds=vmids [OPTIONS]\n" "Reboots one or more virtual machines (VMs).\nThis operation sends a reboot \n" "request to one or more specified VMs. This is an asynchronous action that \n" "queues this reboot request. This action only reboots VMs that are valid and \n" "that belong to you.\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli ReadVpnConnections [OPTIONS]\n" "Lists one or more VPN connections.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadVolumes [OPTIONS]\n" "Lists one or more specified Block Storage Unit (BSU) volumes.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadVmsState [OPTIONS]\n" "Lists the status of one or more virtual machines (VMs).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadVmsHealth --LoadBalancerName=loadbalancername [OPTIONS]\n" "Lists the state of one or more back-end virtual machines (VMs) registered with \n" "a specified load balancer.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli ReadVms [OPTIONS]\n" "Lists one or more of your virtual machines (VMs).\nIf you provide one or more \n" "VM IDs, this action returns a description for all of these VMs. If you do not \n" "provide any VM ID, this action returns a description for all of the VMs that \n" "belong to you. If you provide an invalid VM ID, an error is returned. If you \n" "provide the ID of a VM that does not belong to you, the description of this VM \n" "is not included in the response. The refresh interval for data returned by this \n" "action is one hour, meaning that a terminated VM may appear in the response.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadVmTypes [OPTIONS]\n" "Lists one or more predefined VM types.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadVmTemplates [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nLists one or more virtual machine (VM) templates.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadVmGroups [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nLists one or more group of virtual machines (VMs).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadVirtualGateways [OPTIONS]\n" "Lists one or more virtual gateways.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadUsers [OPTIONS]\n" "Lists all EIM users that have a specified path.\nIf you do not specify a path, \n" "this action returns a list of all users in the account (or an empty list if \n" "there are none).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadTags [OPTIONS]\n" "Lists one or more tags for your resources.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadSubregions [OPTIONS]\n" "Lists one or more of the enabled Subregions that you can access in the current \n" "Region.\n\nFor more information, see [About Regions, Endpoints, and \n" "Subregions](https://docs.outscale.com/en/userguide/About-Regions-Endpoints-and-S\n" "ubregions.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadSubnets [OPTIONS]\n" "Lists one or more of your Subnets.\nIf you do not specify any Subnet ID, this \n" "action describes all of your Subnets.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadSnapshots [OPTIONS]\n" "Lists one or more snapshots that are available to you and the permissions to \n" "create volumes from them.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadSnapshotExportTasks [OPTIONS]\n" "Lists one or more snapshot export tasks.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadServerCertificates [OPTIONS]\n" "Lists your server certificates.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadSecurityGroups [OPTIONS]\n" "Lists one or more security groups.\nYou can specify either the name of the \n" "security groups or their IDs.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadSecretAccessKey --AccessKeyId=accesskeyid [OPTIONS]\n" "Lists information about the specified access key of your root account, \n" "including its secret key.\n" "\nRequired Argument: AccessKeyId \n"
,
	"Usage: oapi-cli ReadRouteTables [OPTIONS]\n" "Lists one or more of your route tables.\nIn your Net, each Subnet must be \n" "associated with a route table. If a Subnet is not explicitly associated with a \n" "route table, it is implicitly associated with the main route table of the Net.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadRegions [OPTIONS]\n" "Lists one or more Regions of the OUTSCALE Cloud.\nFor more information, see \n" "[About Regions, Endpoints, and \n" "Subregions](https://docs.outscale.com/en/userguide/About-Regions-Endpoints-and-S\n" "ubregions.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadQuotas [OPTIONS]\n" "Lists one or more of your quotas.\nFor more information, see [About Your \n" "Account](https://docs.outscale.com/en/userguide/About-Your-Account.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadPublicIps [OPTIONS]\n" "Lists one or more public IPs allocated to your account.\nBy default, this \n" "action returns information about all your public IPs: available or associated \n" "with a virtual machine (VM), a network interface card (NIC) or a NAT service.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadPublicIpRanges [OPTIONS]\n" "Gets the public IPv4 addresses in CIDR notation for the Region specified in the \n" "endpoint of the request. For more information, see [Regions, Endpoints, and \n" "Subregions \n" "Reference](https://docs.outscale.com/en/userguide/Regions-Endpoints-and-Subregio\n" "ns-Reference.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadPublicCatalog [OPTIONS]\n" "Returns the price list of OUTSCALE products and services for the Region \n" "specified in the endpoint of the request. For more information, see [Regions, \n" "Endpoints, and Subregions \n" "Reference](https://docs.outscale.com/en/userguide/Regions-Endpoints-and-Subregio\n" "ns-Reference.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadProductTypes [OPTIONS]\n" "Lists one or more product types.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadPolicyVersions --PolicyOrn=policyorn [OPTIONS]\n" "Lists information about all the policy versions of a specified managed policy.\n" "\nRequired Argument: PolicyOrn \n"
,
	"Usage: oapi-cli ReadPolicyVersion --PolicyOrn=policyorn --VersionId=versionid [OPTIONS]\n" "Lists information about a specified version of a managed policy.\n" "\nRequired Argument: PolicyOrn, VersionId \n"
,
	"Usage: oapi-cli ReadPolicy --PolicyOrn=policyorn [OPTIONS]\n" "Lists information about a specified managed policy.\n" "\nRequired Argument: PolicyOrn \n"
,
	"Usage: oapi-cli ReadPolicies [OPTIONS]\n" "Lists all the managed policies available for your account.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadNics [OPTIONS]\n" "Lists one or more network interface cards (NICs).\nA NIC is a virtual network \n" "interface that you can attach to a virtual machine (VM) in a Net.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadNets [OPTIONS]\n" "Lists one or more Nets.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadNetPeerings [OPTIONS]\n" "Lists one or more peering connections between two Nets.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadNetAccessPoints [OPTIONS]\n" "Lists one or more Net access points.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadNetAccessPointServices [OPTIONS]\n" "Lists OUTSCALE services available to create Net access points.\nFor more \n" "information, see [CreateNetAccessPoint](#createnetaccesspoint).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadNatServices [OPTIONS]\n" "Lists one or more network address translation (NAT) services.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadLocations [OPTIONS]\n" "Lists the locations, corresponding to datacenters, where you can set up a \n" "DirectLink.\nFor more information, see [About \n" "DirectLink](https://docs.outscale.com/en/userguide/About-DirectLink.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadLoadBalancers [OPTIONS]\n" "Lists one or more load balancers and their attributes.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadLoadBalancerTags --LoadBalancerNames=loadbalancernames [OPTIONS]\n" "Lists the tags associated with one or more specified load balancers.\n" "\nRequired Argument: LoadBalancerNames \n"
,
	"Usage: oapi-cli ReadListenerRules [OPTIONS]\n" "Lists one or more listener rules. By default, this action returns the full list \n" "of listener rules for the account.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadLinkedPolicies [OPTIONS]\n" "Lists the managed policies linked to a specified user.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadKeypairs [OPTIONS]\n" "Lists one or more of your keypairs.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadInternetServices [OPTIONS]\n" "Lists one or more of your Internet services.\nAn Internet service enables your \n" "virtual machines (VMs) launched in a Net to connect to the Internet. By \n" "default, a Net includes an Internet service, and each Subnet is public. Every \n" "VM launched within a default Subnet has a private IP and a public IP.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadImages [OPTIONS]\n" "Lists one or more OUTSCALE machine images (OMIs) you can use.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadImageExportTasks [OPTIONS]\n" "Lists one or more image export tasks.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadFlexibleGpus [OPTIONS]\n" "Lists one or more flexible GPUs (fGPUs) allocated to your account.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadFlexibleGpuCatalog [OPTIONS]\n" "Lists all flexible GPUs available in the public catalog.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadDirectLinks [OPTIONS]\n" "Lists all DirectLinks in the Region.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadDirectLinkInterfaces [OPTIONS]\n" "Lists one or more of your DirectLink interfaces.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadDhcpOptions [OPTIONS]\n" "Gets information about the content of one or more DHCP options sets.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadDedicatedGroups [OPTIONS]\n" "> [WARNING]\n> This feature is currently in beta.\n\nList one or more dedicated \n" "groups of virtual machines (VMs).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadConsumptionAccount --FromDate=fromdate --ToDate=todate [OPTIONS]\n" "Gets information about the consumption of your account for each billable \n" "resource within the specified time period.\n" "\nRequired Argument: FromDate, ToDate \n"
,
	"Usage: oapi-cli ReadConsoleOutput --VmId=vmid [OPTIONS]\n" "Gets the console output for a virtual machine (VM). This console provides the \n" "most recent 64 KiB output.\n\n**[IMPORTANT]**\nOn Windows VMs, the console is \n" "handled only on the first boot. It returns no output after the first boot.\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli ReadClientGateways [OPTIONS]\n" "Lists one or more of your client gateways.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadCatalogs [OPTIONS]\n" "Returns the price list of OUTSCALE services for the current Region within a \n" "specific time period.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadCatalog [OPTIONS]\n" "Returns the price list of OUTSCALE services for the current Region.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadCas [OPTIONS]\n" "Gets information about one or more of your Client Certificate Authorities (CAs).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadApiLogs [OPTIONS]\n" "Lists the logs of the API calls you have performed with this \n" "account.\n\n**[IMPORTANT]**\nPast logs are accessible for up to 32 days.\nBy \n" "default, the retrieved interval is 48 hours. If neither of the \n" "`QueryDateBefore` nor `QueryDateAfter` parameters are specified, logs from the \n" "past 48 hours are retrieved. If you only specify one of two, logs are retrieved \n" "from a 2-day interval based on the date you provided. To retrieve logs beyond a \n" "2-day interval, specify both parameters.\nFor more information, see [About \n" "OUTSCALE Monitoring Services \n" "(OMS)](https://docs.outscale.com/en/userguide/About-OUTSCALE-Monitoring-Services\n" "-OMS.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadApiAccessRules [OPTIONS]\n" "Lists one or more API access rules.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadApiAccessPolicy [OPTIONS]\n" "Gets information about the API access policy of your account.\nFor more \n" "information, see [About Your API Access \n" "Policy](https://docs.outscale.com/en/userguide/About-Your-API-Access-Policy.html\n" ").\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadAdminPassword --VmId=vmid [OPTIONS]\n" "Gets the administrator password for a Windows running virtual machine \n" "(VM).\nThe administrator password is encrypted using the keypair you specified \n" "when launching the VM.\n\n**[IMPORTANT]**\n* Only RSA keypairs can decrypt the \n" "password of a Windows VM.\n* The administrator password is generated only on \n" "the first boot of the Windows VM. It is not returned after the first boot.\n" "\nRequired Argument: VmId \n"
,
	"Usage: oapi-cli ReadAccounts [OPTIONS]\n" "Gets information about the account that sent the request.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli ReadAccessKeys [OPTIONS]\n" "Lists the access key IDs of either your root account or an EIM user.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli LinkVolume --DeviceName=devicename --VmId=vmid --VolumeId=volumeid [OPTIONS]\n" "Attaches a Block Storage Unit (BSU) volume to a virtual machine (VM).\nThe \n" "volume and the VM must be in the same Subregion. The VM can be running or \n" "stopped. The volume is attached to the specified VM device.\n" "\nRequired Argument: DeviceName, VmId, VolumeId \n"
,
	"Usage: oapi-cli LinkVirtualGateway --NetId=netid --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "Attaches a virtual gateway to a Net.\n\n**[IMPORTANT]**\nThis action can be \n" "done only if the virtual gateway is in the `available` state.\n" "\nRequired Argument: NetId, VirtualGatewayId \n"
,
	"Usage: oapi-cli LinkRouteTable --RouteTableId=routetableid --SubnetId=subnetid [OPTIONS]\n" "Associates a Subnet with a route table.\nThe Subnet and the route table must be \n" "in the same Net. The traffic is routed according to the route table defined \n" "within this Net. You can associate a route table with several Subnets.\n" "\nRequired Argument: RouteTableId, SubnetId \n"
,
	"Usage: oapi-cli LinkPublicIp [OPTIONS]\n" "Associates a public IP with a virtual machine (VM) or a network interface card \n" "(NIC), in the public Cloud or in a Net. You can associate a public IP with only \n" "one VM or network interface at a time.\nTo associate a public IP in a Net, \n" "ensure that the Net has an Internet service attached. For more information, see \n" "the [LinkInternetService](#linkinternetservice) method.\nBy default, the public \n" "IP is disassociated every time you stop and start the VM. For a persistent \n" "association, you can add the `osc.fcu.eip.auto-attach` tag to the VM with the \n" "public IP as value. For more information, see the [CreateTags](#createtags) \n" "method.\n\n**[IMPORTANT]**\nYou can associate a public IP with a network \n" "address translation (NAT) service only when creating the NAT service. To modify \n" "its public IP, you need to delete the NAT service and re-create it with the new \n" "public IP. For more information, see the [CreateNatService](#createnatservice) \n" "method.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli LinkPrivateIps --NicId=nicid [OPTIONS]\n" "Assigns one or more secondary private IPs to a specified network interface card \n" "(NIC). This action is only available in a Net. The private IPs to be assigned \n" "can be added individually using the `PrivateIps` parameter, or you can specify \n" "the number of private IPs to be automatically chosen within the Subnet range \n" "using the `SecondaryPrivateIpCount` parameter. You can specify only one of \n" "these two parameters. If none of these parameters are specified, a private IP \n" "is chosen within the Subnet range.\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli LinkPolicy --PolicyOrn=policyorn --UserName=username [OPTIONS]\n" "Links a managed policy to a specific user.\n" "\nRequired Argument: PolicyOrn, UserName \n"
,
	"Usage: oapi-cli LinkNic --DeviceNumber=devicenumber --VmId=vmid --NicId=nicid [OPTIONS]\n" "Attaches a network interface card (NIC) to a virtual machine (VM).\nThe \n" "interface and the VM must be in the same Subregion. The VM can be either \n" "`running` or `stopped`. The NIC must be in the `available` state. For more \n" "information, see [Attaching a NIC to a \n" "VM](https://docs.outscale.com/en/userguide/Attaching-a-NIC-to-a-VM.html).\n" "\nRequired Argument: DeviceNumber, VmId, NicId \n"
,
	"Usage: oapi-cli LinkLoadBalancerBackendMachines --LoadBalancerName=loadbalancername [OPTIONS]\n" "Attaches one or more virtual machines (VMs) to a specified load balancer. You \n" "need to specify at least the `BackendIps` or the `BackendVmIds` parameter.\nThe \n" "VMs can be in different Subnets and different Subregions than the load \n" "balancer, as long as the VMs and load balancers are all in the public Cloud or \n" "all in the same Net. It may take a little time for a VM to be registered with \n" "the load balancer. Once the VM is registered with a load balancer, it receives \n" "traffic and requests from this load balancer and is called a back-end VM.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli LinkInternetService --InternetServiceId=internetserviceid --NetId=netid [OPTIONS]\n" "Attaches an Internet service to a Net.\nTo enable the connection between the \n" "Internet and a Net, you must attach an Internet service to this Net.\n" "\nRequired Argument: InternetServiceId, NetId \n"
,
	"Usage: oapi-cli LinkFlexibleGpu --FlexibleGpuId=flexiblegpuid --VmId=vmid [OPTIONS]\n" "Attaches one of your allocated flexible GPUs (fGPUs) to one of your virtual \n" "machines (VMs).\nThe fGPU is in the `attaching` state until the VM is stopped, \n" "after which it becomes `attached`.\n" "\nRequired Argument: FlexibleGpuId, VmId \n"
,
	"Usage: oapi-cli DeregisterVmsInLoadBalancer --BackendVmIds=backendvmids --LoadBalancerName=loadbalancername [OPTIONS]\n" "Deregisters a specified virtual machine (VM) from a load balancer.\n" "\nRequired Argument: BackendVmIds, LoadBalancerName \n"
,
	"Usage: oapi-cli DeleteVpnConnectionRoute --DestinationIpRange=destinationiprange --VpnConnectionId=vpnconnectionid [OPTIONS]\n" "Deletes a static route to a VPN connection previously created using the \n" "CreateVpnConnectionRoute method.\n" "\nRequired Argument: DestinationIpRange, VpnConnectionId \n"
,
	"Usage: oapi-cli DeleteVpnConnection --VpnConnectionId=vpnconnectionid [OPTIONS]\n" "Deletes a specified VPN connection.\nIf you want to delete a Net and all its \n" "dependencies, we recommend to detach the virtual gateway from the Net and \n" "delete the Net before deleting the VPN connection. This enables you to delete \n" "the Net without waiting for the VPN connection to be deleted.\n" "\nRequired Argument: VpnConnectionId \n"
,
	"Usage: oapi-cli DeleteVolume --VolumeId=volumeid [OPTIONS]\n" "Deletes a specified Block Storage Unit (BSU) volume.\nYou can delete available \n" "volumes only, that is, volumes that are not attached to a virtual machine (VM).\n" "\nRequired Argument: VolumeId \n"
,
	"Usage: oapi-cli DeleteVms --VmIds=vmids [OPTIONS]\n" "Terminates one or more virtual machines (VMs).\nThis operation is idempotent, \n" "that means that all calls succeed if you terminate a VM more than once.\n" "\nRequired Argument: VmIds \n"
,
	"Usage: oapi-cli DeleteVmTemplate --VmTemplateId=vmtemplateid [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nDeletes a virtual machine (VM) template.\nYou cannot delete a \n" "template currently used by a VM group.\n" "\nRequired Argument: VmTemplateId \n"
,
	"Usage: oapi-cli DeleteVmGroup --VmGroupId=vmgroupid [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nDeletes a specified VM group.\n" "\nRequired Argument: VmGroupId \n"
,
	"Usage: oapi-cli DeleteVirtualGateway --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "Deletes a specified virtual gateway.\nBefore deleting a virtual gateway, we \n" "recommend to detach it from the Net and delete the VPN connection.\n" "\nRequired Argument: VirtualGatewayId \n"
,
	"Usage: oapi-cli DeleteUser --UserName=username [OPTIONS]\n" "Deletes a specified EIM user. The EIM user must not belong to any group, nor \n" "have any key or attached policy.\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli DeleteTags --ResourceIds=resourceids --Tags=tags [OPTIONS]\n" "Deletes one or more tags from the specified resources.\n" "\nRequired Argument: ResourceIds, Tags \n"
,
	"Usage: oapi-cli DeleteSubnet --SubnetId=subnetid [OPTIONS]\n" "Deletes a specified Subnet.\nBefore deleting the Subnet, you need to delete all \n" "resources associated with the Subnet:\n\n* Virtual machines (VMs)\n* Network \n" "Interface Cards (NICs)\n* NAT services\n* Load balancers\n" "\nRequired Argument: SubnetId \n"
,
	"Usage: oapi-cli DeleteSnapshot --SnapshotId=snapshotid [OPTIONS]\n" "Deletes a specified snapshot.\nYou cannot delete a snapshot that is currently \n" "used by an OUTSCALE machine image (OMI). To do so, you first need to delete the \n" "corresponding OMI. For more information, see the [DeleteImage](#deleteimage) \n" "method.\n" "\nRequired Argument: SnapshotId \n"
,
	"Usage: oapi-cli DeleteServerCertificate --Name=name [OPTIONS]\n" "Deletes a specified server certificate.\n" "\nRequired Argument: Name \n"
,
	"Usage: oapi-cli DeleteSecurityGroupRule --SecurityGroupId=securitygroupid --Flow=flow [OPTIONS]\n" "Deletes one or more inbound or outbound rules from a security group. For the \n" "rule to be deleted, the values specified in the deletion request must exactly \n" "match the value of the existing rule.\nIn case of TCP and UDP protocols, you \n" "have to indicate the destination port or range of ports. In case of ICMP \n" "protocol, you have to specify the ICMP type and code numbers.\nRules (IP \n" "permissions) consist of the protocol, IP range or source security group.\nTo \n" "remove outbound access to a destination security group, we recommend to use a \n" "set of IP permissions. We also recommend to specify the protocol in a set of IP \n" "permissions.\n" "\nRequired Argument: SecurityGroupId, Flow \n"
,
	"Usage: oapi-cli DeleteSecurityGroup [OPTIONS]\n" "Deletes a specified security group.\nYou can specify either the name of the \n" "security group or its ID.\nThis action fails if the specified group is \n" "associated with a virtual machine (VM) or referenced by another security group.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli DeleteRouteTable --RouteTableId=routetableid [OPTIONS]\n" "Deletes a specified route table.\nBefore deleting a route table, you must \n" "disassociate it from any Subnet. You cannot delete the main route table.\n" "\nRequired Argument: RouteTableId \n"
,
	"Usage: oapi-cli DeleteRoute --RouteTableId=routetableid --DestinationIpRange=destinationiprange [OPTIONS]\n" "Deletes a route from a specified route table.\n" "\nRequired Argument: RouteTableId, DestinationIpRange \n"
,
	"Usage: oapi-cli DeletePublicIp [OPTIONS]\n" "Releases a public IP.\nYou can release a public IP associated with your \n" "account. This address is released in the public IP pool and can be used by \n" "someone else. Before releasing a public IP, ensure you updated all your \n" "resources communicating with this address.\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli DeletePolicyVersion --PolicyOrn=policyorn --VersionId=versionid [OPTIONS]\n" "Deletes a specified version of a managed policy, if it is not set as the \n" "default one.\n" "\nRequired Argument: PolicyOrn, VersionId \n"
,
	"Usage: oapi-cli DeletePolicy --PolicyOrn=policyorn [OPTIONS]\n" "Deletes a managed policy.\nBefore deleting a managed policy, you must unlink \n" "all users linked to it and delete all the versions of the policy using the \n" "`DeletePolicyVersion` method.\n" "\nRequired Argument: PolicyOrn \n"
,
	"Usage: oapi-cli DeleteNic --NicId=nicid [OPTIONS]\n" "Deletes the specified network interface card (NIC).\nThe network interface must \n" "not be attached to any virtual machine (VM).\n" "\nRequired Argument: NicId \n"
,
	"Usage: oapi-cli DeleteNetPeering --NetPeeringId=netpeeringid [OPTIONS]\n" "Deletes a Net peering.\nIf the Net peering is in the `active` state, it can be \n" "deleted either by the owner of the requester Net or the owner of the peer \n" "Net.\nIf it is in the `pending-acceptance` state, it can be deleted only by the \n" "owner of the requester Net.\nIf it is in the `rejected`, `failed`, or `expired` \n" "states, it cannot be deleted.\n" "\nRequired Argument: NetPeeringId \n"
,
	"Usage: oapi-cli DeleteNetAccessPoint --NetAccessPointId=netaccesspointid [OPTIONS]\n" "Deletes a specified Net access point.\nThis action also deletes the \n" "corresponding routes added to the route tables you specified for the Net access \n" "point.\n" "\nRequired Argument: NetAccessPointId \n"
,
	"Usage: oapi-cli DeleteNet --NetId=netid [OPTIONS]\n" "Deletes a specified Net.\nBefore deleting the Net, you need to delete or detach \n" "all the resources associated with the Net:\n\n* Virtual machines (VMs)\n* Net \n" "peerings\n* Custom route tables\n* Public IPs allocated to resources in the \n" "Net\n* Network Interface Cards (NICs) created in the Subnets\n* Virtual \n" "gateways, Internet services and NAT services\n* Load balancers\n* Security \n" "groups\n* Subnets\n" "\nRequired Argument: NetId \n"
,
	"Usage: oapi-cli DeleteNatService --NatServiceId=natserviceid [OPTIONS]\n" "Deletes a specified network address translation (NAT) service.\nThis action \n" "disassociates the public IP from the NAT service, but does not release this \n" "public IP from your account. However, it does not delete any NAT service routes \n" "in your route tables.\n" "\nRequired Argument: NatServiceId \n"
,
	"Usage: oapi-cli DeleteLoadBalancerTags --LoadBalancerNames=loadbalancernames --Tags=tags [OPTIONS]\n" "Deletes one or more tags from the specified load balancers.\n" "\nRequired Argument: LoadBalancerNames, Tags \n"
,
	"Usage: oapi-cli DeleteLoadBalancerPolicy --LoadBalancerName=loadbalancername --PolicyName=policyname [OPTIONS]\n" "Deletes a specified policy from a load balancer.\nIn order to be deleted, the \n" "policy must not be enabled for any listener.\n" "\nRequired Argument: LoadBalancerName, PolicyName \n"
,
	"Usage: oapi-cli DeleteLoadBalancerListeners --LoadBalancerName=loadbalancername --LoadBalancerPorts=loadbalancerports [OPTIONS]\n" "Deletes listeners of a specified load balancer.\n" "\nRequired Argument: LoadBalancerName, LoadBalancerPorts \n"
,
	"Usage: oapi-cli DeleteLoadBalancer --LoadBalancerName=loadbalancername [OPTIONS]\n" "Deletes a specified load balancer.\n" "\nRequired Argument: LoadBalancerName \n"
,
	"Usage: oapi-cli DeleteListenerRule --ListenerRuleName=listenerrulename [OPTIONS]\n" "Deletes a listener rule.\nThe previously active rule is disabled after deletion.\n" "\nRequired Argument: ListenerRuleName \n"
,
	"Usage: oapi-cli DeleteKeypair --KeypairName=keypairname [OPTIONS]\n" "Deletes the specified keypair.\nThis action deletes the public key stored by \n" "3DS OUTSCALE, thus deleting the keypair.\n" "\nRequired Argument: KeypairName \n"
,
	"Usage: oapi-cli DeleteInternetService --InternetServiceId=internetserviceid [OPTIONS]\n" "Deletes an Internet service.\nBefore deleting an Internet service, you must \n" "detach it from any Net it is attached to.\n" "\nRequired Argument: InternetServiceId \n"
,
	"Usage: oapi-cli DeleteImage --ImageId=imageid [OPTIONS]\n" "Deletes an OUTSCALE machine image (OMI) so that you cannot use it anymore to \n" "launch virtual machines (VMs). However, you can still use VMs already launched \n" "from this OMI.\n" "\nRequired Argument: ImageId \n"
,
	"Usage: oapi-cli DeleteFlexibleGpu --FlexibleGpuId=flexiblegpuid [OPTIONS]\n" "Releases a flexible GPU (fGPU) from your account.\nThe fGPU becomes free to be \n" "used by someone else.\n" "\nRequired Argument: FlexibleGpuId \n"
,
	"Usage: oapi-cli DeleteExportTask --ExportTaskId=exporttaskid [OPTIONS]\n" "Deletes an export task.\nIf the export task is not running, the command fails \n" "and an error is returned.\n" "\nRequired Argument: ExportTaskId \n"
,
	"Usage: oapi-cli DeleteDirectLinkInterface --DirectLinkInterfaceId=directlinkinterfaceid [OPTIONS]\n" "Deletes a specified DirectLink interface.\n" "\nRequired Argument: DirectLinkInterfaceId \n"
,
	"Usage: oapi-cli DeleteDirectLink --DirectLinkId=directlinkid [OPTIONS]\n" "Deletes a specified DirectLink.\nBefore deleting a DirectLink, ensure that all \n" "your DirectLink interfaces related to this DirectLink are deleted.\n" "\nRequired Argument: DirectLinkId \n"
,
	"Usage: oapi-cli DeleteDhcpOptions --DhcpOptionsSetId=dhcpoptionssetid [OPTIONS]\n" "Deletes a specified DHCP options set.\nBefore deleting a DHCP options set, you \n" "must disassociate it from the Nets you associated it with. To do so, you need \n" "to associate with each Net a new set of DHCP options, or the `default` one if \n" "you do not want to associate any DHCP options with the \n" "Net.\n\n**[IMPORTANT]**\nYou cannot delete the `default` set.\n" "\nRequired Argument: DhcpOptionsSetId \n"
,
	"Usage: oapi-cli DeleteDedicatedGroup --DedicatedGroupId=dedicatedgroupid [OPTIONS]\n" "> [WARNING]\n> This feature is currently in beta.\n\nDeletes a specified \n" "dedicated group of virtual machines (VMs).\n\n**[WARNING]**\nA dedicated group \n" "can be deleted only if no VM or Net is in the dedicated group. Otherwise, you \n" "need to force the deletion.\nIf you force the deletion:\n- all VMs are \n" "terminated.\n- all Nets are deleted, and all resources associated with Nets are \n" "detached.\n" "\nRequired Argument: DedicatedGroupId \n"
,
	"Usage: oapi-cli DeleteClientGateway --ClientGatewayId=clientgatewayid [OPTIONS]\n" "Deletes a client gateway.\nYou must delete the VPN connection before deleting \n" "the client gateway.\n" "\nRequired Argument: ClientGatewayId \n"
,
	"Usage: oapi-cli DeleteCa --CaId=caid [OPTIONS]\n" "Deletes a specified Client Certificate Authority (CA).\n" "\nRequired Argument: CaId \n"
,
	"Usage: oapi-cli DeleteApiAccessRule --ApiAccessRuleId=apiaccessruleid [OPTIONS]\n" "Deletes a specified API access rule.\n\n**[IMPORTANT]** \nYou cannot delete the \n" "last remaining API access rule. However, if you delete all the API access rules \n" "that allow you to access the APIs, you need to contact the Support team to \n" "regain access. For more information, see [Technical \n" "Support](https://docs.outscale.com/en/userguide/Technical-Support.html).\n" "\nRequired Argument: ApiAccessRuleId \n"
,
	"Usage: oapi-cli DeleteAccessKey --AccessKeyId=accesskeyid [OPTIONS]\n" "Deletes the specified access key of either your root account or an EIM \n" "user.\nThe access key of an EIM user must be in the `INACTIVE` state to be \n" "deleted.\n" "\nRequired Argument: AccessKeyId \n"
,
	"Usage: oapi-cli CreateVpnConnectionRoute --DestinationIpRange=destinationiprange --VpnConnectionId=vpnconnectionid [OPTIONS]\n" "Creates a static route to a VPN connection.\nThis enables you to select the \n" "network flows sent by the virtual gateway to the target VPN connection.\nFor \n" "more information, see [About Routing Configuration for VPN \n" "Connections](https://docs.outscale.com/en/userguide/About-Routing-Configuration-\n" "for-VPN-Connections.html).\n" "\nRequired Argument: DestinationIpRange, VpnConnectionId \n"
,
	"Usage: oapi-cli CreateVpnConnection --ClientGatewayId=clientgatewayid --ConnectionType=connectiontype --VirtualGatewayId=virtualgatewayid [OPTIONS]\n" "Creates a VPN connection between a specified virtual gateway and a specified \n" "client gateway.\nYou can create only one VPN connection between a virtual \n" "gateway and a client gateway.\n\n**[IMPORTANT]**\nThis action can be done only \n" "if the virtual gateway is in the `available` state.\nFor more information, see \n" "[About VPN \n" "Connections](https://docs.outscale.com/en/userguide/About-VPN-Connections.html).\n" "\nRequired Argument: ClientGatewayId, ConnectionType, VirtualGatewayId \n"
,
	"Usage: oapi-cli CreateVolume --SubregionName=subregionname [OPTIONS]\n" "Creates a Block Storage Unit (BSU) volume in a specified Region.\nBSU volumes \n" "can be attached to a virtual machine (VM) in the same Subregion. You can create \n" "an empty volume or restore a volume from an existing snapshot.\nYou can create \n" "the following volume types: Enterprise (`io1`) for provisioned IOPS SSD \n" "volumes, Performance (`gp2`) for general purpose SSD volumes, or Magnetic \n" "(`standard`) volumes.\nFor more information, see [About \n" "Volumes](https://docs.outscale.com/en/userguide/About-Volumes.html).\n" "\nRequired Argument: SubregionName \n"
,
	"Usage: oapi-cli CreateVms --ImageId=imageid [OPTIONS]\n" "Creates virtual machines (VMs), and then launches them.\nThis action enables \n" "you to create a specified number of VMs using an OUTSCALE machine image (OMI) \n" "that you are allowed to use, and then to automatically launch them.\nThe VMs \n" "remain in the `pending` state until they are created and ready to be used. Once \n" "automatically launched, they are in the `running` state.\nTo check the state of \n" "your VMs, call the [ReadVms](#readvms) method.\nIf not specified, the security \n" "group used by the service is the default one.\nThe metadata server enables you \n" "to get the public key provided when the VM is launched. Official OMIs contain a \n" "script to get this public key and put it inside the VM to provide secure access \n" "without password.\nFor more information, see [About \n" "VMs](https://docs.outscale.com/en/userguide/About-VMs.html).\n" "\nRequired Argument: ImageId \n"
,
	"Usage: oapi-cli CreateVmTemplate --CpuCores=cpucores --CpuGeneration=cpugeneration --ImageId=imageid --Ram=ram --VmTemplateName=vmtemplatename [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nCreates a virtual machine (VM) template. You can then use the VM \n" "template to create VM groups.\nYou can create up to 50 VM templates in your \n" "account.\n" "\nRequired Argument: CpuCores, CpuGeneration, ImageId, Ram, VmTemplateName \n"
,
	"Usage: oapi-cli CreateVmGroup --SecurityGroupIds=securitygroupids --SubnetId=subnetid --VmGroupName=vmgroupname --VmTemplateId=vmtemplateid --VmCount=vmcount [OPTIONS]\n" "> [WARNING]\n> This feature is currently under development and may not function \n" "properly.\n\nCreates a group of virtual machines (VMs) containing the same \n" "characteristics as a specified VM template, and then launches them.\nYou can \n" "create up to 100 VM groups in your account.\n" "\nRequired Argument: SecurityGroupIds, SubnetId, VmGroupName, VmTemplateId, VmCount \n"
,
	"Usage: oapi-cli CreateVirtualGateway --ConnectionType=connectiontype [OPTIONS]\n" "Creates a virtual gateway.\nA virtual gateway is the access point on the Net \n" "side of a VPN connection.\nFor more information, see [About Virtual \n" "Gateways](https://docs.outscale.com/en/userguide/About-Virtual-Gateways.html).\n" "\nRequired Argument: ConnectionType \n"
,
	"Usage: oapi-cli CreateUser --UserName=username [OPTIONS]\n" "Creates an EIM user for your account.\nFor more information, see [About EIM \n" "Users](https://docs.outscale.com/en/userguide/About-EIM-Users.html).\n" "\nRequired Argument: UserName \n"
,
	"Usage: oapi-cli CreateTags --ResourceIds=resourceids --Tags=tags [OPTIONS]\n" "Adds one or more tags to the specified resources.\nIf a tag with the same key \n" "already exists for the resource, the tag value is replaced.\nYou can tag the \n" "following resources using their IDs:\n\n* Virtual machines (VMs) \n" "(i-xxxxxxxx)\n* OMIs (ami-xxxxxxxx)\n* Volumes (vol-xxxxxxxx)\n* Snapshots \n" "(snap-xxxxxxxx)\n* Public IPs (eipalloc-xxxxxxxx)\n* Security groups \n" "(sg-xxxxxxxx)\n* Route tables (rtb-xxxxxxxx)\n* Network interface cards (NIC) \n" "(eni-xxxxxxxx)\n* Nets (vpc-xxxxxxxx)\n* Subnets (subnet-xxxxxxxx)\n* Net \n" "peerings (vpcx-xxxxxxxx)\n* Net endpoints (vpce-xxxxxxxx)\n* NAT services \n" "(nat-xxxxxxxx)\n* Internet services (igw-xxxxxxxx)\n* Client gateways \n" "(cgw-xxxxxxxx)\n* Virtual gateways (vgw-xxxxxxxx)\n* VPN connections \n" "(vpn-xxxxxxxx)\n* DHCP options (dopt-xxxxxxxx)\n* OMI export tasks \n" "(image-export-xxxxxxxx)\n* Snapshot export tasks (snap-export-xxxxxxxx)\n\nFor \n" "more information, see [About \n" "Tags](https://docs.outscale.com/en/userguide/About-Tags.html).\n" "\nRequired Argument: ResourceIds, Tags \n"
,
	"Usage: oapi-cli CreateSubnet --IpRange=iprange --NetId=netid [OPTIONS]\n" "Creates a Subnet in an existing Net.\nTo create a Subnet in a Net, you have to \n" "provide the ID of the Net and the IP range for the Subnet (its network range). \n" "Once the Subnet is created, you cannot modify its IP range.\nFor more \n" "information, see [About \n" "Nets](https://docs.outscale.com/en/userguide/About-Nets.html).\n" "\nRequired Argument: IpRange, NetId \n"
,
	"Usage: oapi-cli CreateSnapshotExportTask --OsuExport=osuexport --SnapshotId=snapshotid [OPTIONS]\n" "Exports a snapshot to an OUTSCALE Object Storage (OOS) bucket.\nThis action \n" "enables you to create a backup of your snapshot or to copy it to another \n" "account. You, or other accounts you send a pre-signed URL to, can then download \n" "this snapshot from the bucket using the [CreateSnapshot](#createsnapshot) \n" "method.\nThis procedure enables you to copy a snapshot between accounts within \n" "the same Region or in different Regions. To copy a snapshot within the same \n" "Region, you can also use the [CreateSnapshot](#createsnapshot) direct method. \n" "The copy of the source snapshot is independent and belongs to you.\nFor more \n" "information, see [About \n" "Snapshots](https://docs.outscale.com/en/userguide/About-Snapshots.html).\n" "\nRequired Argument: OsuExport, SnapshotId \n"
,
	"Usage: oapi-cli CreateSnapshot [OPTIONS]\n" "Creates a snapshot. Snapshots are point-in-time images of a volume that you can \n" "use to back up your data or to create replicas of this volume.\nYou can use \n" "this method in three different ways:\n* **Creating from a volume**: You create \n" "a snapshot from one of your volumes.\n* **Copying a snapshot**: You copy an \n" "existing snapshot. The source snapshot can be one of your own snapshots, or a \n" "snapshot owned by another account that has granted you permission via the \n" "[UpdateSnapshot](#updatesnapshot) method.\n* **Importing from a bucket**: You \n" "import a snapshot located in an OUTSCALE Object Storage (OOS) bucket. First, \n" "the owner of the source snapshot must export it to the bucket by using the \n" "[CreateSnapshotExportTask](#createsnapshotexporttask) method. Then, they must \n" "grant you permission to read the snapshot via a pre-signed URL or Access \n" "Control Lists. For more information, see [Managing Access to Your Buckets and \n" "Objects](https://docs.outscale.com/en/userguide/Managing-Access-to-Your-Buckets-\n" "and-Objects.html).\n\nFor more information, see [About \n" "Snapshots](https://docs.outscale.com/en/userguide/About-Snapshots.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli CreateServerCertificate --Body=body --PrivateKey=privatekey --Name=name [OPTIONS]\n" "Creates a server certificate and its matching private key.\nThese elements can \n" "be used with other services (for example, to configure SSL termination on load \n" "balancers).\nYou can also specify the chain of intermediate certification \n" "authorities if your certificate is not directly signed by a root one. You can \n" "specify multiple intermediate certification authorities in the \n" "`CertificateChain` parameter. To do so, concatenate all certificates in the \n" "correct order (the first certificate must be the authority of your certificate, \n" "the second must the the authority of the first one, and so on).\nThe private \n" "key must be a RSA key in PKCS1 form. To check this, open the PEM file and \n" "ensure its header reads as follows: BEGIN RSA PRIVATE KEY.\n[IMPORTANT]\nThis \n" "private key must not be protected by a password or a passphrase.\nFor more \n" "information, see [About Server Certificates in \n" "EIM](https://docs.outscale.com/en/userguide/About-Server-Certificates-in-EIM.htm\n" "l).\n" "\nRequired Argument: Body, PrivateKey, Name \n"
,
	"Usage: oapi-cli CreateSecurityGroupRule --SecurityGroupId=securitygroupid --Flow=flow [OPTIONS]\n" "Adds one or more rules to a security group.\nUse the `SecurityGroupId` \n" "parameter to specify the security group for which you want to create a \n" "rule.\nUse the `Flow` parameter to specify if you want an inbound rule or an \n" "outbound rule.\nAn inbound rule allows the security group to receive \n" "traffic:\n* Either from a specific IP range (`IpRange` parameter) on a specific \n" "port range (`FromPortRange` and `ToPortRange` parameters) and specific protocol \n" "(`IpProtocol` parameter).\n* Or from another specific security group \n" "(`SecurityGroupAccountIdToLink` and `SecurityGroupNameToLink` \n" "parameters).\n\n(Net only) An outbound rule works similarly but allows the \n" "security group to send traffic rather than receive traffic.\n\nAlternatively, \n" "you can use the `Rules` parameter to add several rules at the same \n" "time.\n\n**[NOTE]**\n* The modifications are effective as quickly as possible, \n" "but a small delay may occur.\n* By default, traffic between two security groups \n" "is allowed through both public and private IPs. To restrict traffic to private \n" "IPs only, contact our Support team at support@outscale.com.\n\nFor more \n" "information, see [About Security Group \n" "Rules](https://docs.outscale.com/en/userguide/About-Security-Group-Rules.html).\n" "\nRequired Argument: SecurityGroupId, Flow \n"
,
	"Usage: oapi-cli CreateSecurityGroup --Description=description --SecurityGroupName=securitygroupname [OPTIONS]\n" "Creates a security group.\nThis action creates a security group either in the \n" "public Cloud or in a specified Net. By default, a default security group for \n" "use in the public Cloud and a default security group for use in a Net are \n" "created.\nWhen launching a virtual machine (VM), if no security group is \n" "explicitly specified, the appropriate default security group is assigned to the \n" "VM. Default security groups include a default rule granting VMs network access \n" "to each other.\nWhen creating a security group, you specify a name. Two \n" "security groups for use in the public Cloud or for use in a Net cannot have the \n" "same name.\nYou can have up to 500 security groups in the public Cloud. You can \n" "create up to 500 security groups per Net.\nTo add or remove rules, use the \n" "[CreateSecurityGroupRule](#createsecuritygrouprule) method.\nFor more \n" "information, see [About Security \n" "Groups](https://docs.outscale.com/en/userguide/About-Security-Groups.html).\n" "\nRequired Argument: Description, SecurityGroupName \n"
,
	"Usage: oapi-cli CreateRouteTable --NetId=netid [OPTIONS]\n" "Creates a route table for a specified Net.\nYou can then add routes and \n" "associate this route table with a Subnet.\nFor more information, see [About \n" "Route Tables](https://docs.outscale.com/en/userguide/About-Route-Tables.html).\n" "\nRequired Argument: NetId \n"
,
	"Usage: oapi-cli CreateRoute --DestinationIpRange=destinationiprange --RouteTableId=routetableid [OPTIONS]\n" "Creates a route in a specified route table within a specified Net.\nYou must \n" "specify one of the following elements as the target:\n\n* Net peering\n* NAT \n" "VM\n* Internet service\n* Virtual gateway\n* NAT service\n* Network interface \n" "card (NIC)\n\nThe routing algorithm is based on the most specific match.\nFor \n" "more information, see [About Route \n" "Tables](https://docs.outscale.com/en/userguide/About-Route-Tables.html).\n" "\nRequired Argument: DestinationIpRange, RouteTableId \n"
,
	"Usage: oapi-cli CreatePublicIp [OPTIONS]\n" "Acquires a public IP for your account.\nA public IP is a static IP designed for \n" "dynamic Cloud computing. It can be associated with a virtual machine (VM) in \n" "the public Cloud or in a Net, a network interface card (NIC), a NAT \n" "service.\nFor more information, see [About Public \n" "IPs](https://docs.outscale.com/en/userguide/About-Public-IPs.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli CreateProductType --Description=description [OPTIONS]\n" "Creates a product type you can associate with an OMI for consumption monitoring \n" "and billing purposes.\n" "\nRequired Argument: Description \n"
,
	"Usage: oapi-cli CreatePolicyVersion --Document=document --PolicyOrn=policyorn [OPTIONS]\n" "Creates a version of a specified managed policy.\nA managed policy can have up \n" "to five versions.\n" "\nRequired Argument: Document, PolicyOrn \n"
,
	"Usage: oapi-cli CreatePolicy --Document=document --PolicyName=policyname [OPTIONS]\n" "Creates a managed policy to apply to a user.\nThis action creates a policy \n" "version and sets v1 as the default one.\n" "\nRequired Argument: Document, PolicyName \n"
,
	"Usage: oapi-cli CreateNic --SubnetId=subnetid [OPTIONS]\n" "Creates a network interface card (NIC) in the specified Subnet.\nFor more \n" "information, see [About \n" "NICs](https://docs.outscale.com/en/userguide/About-NICs.html).\n" "\nRequired Argument: SubnetId \n"
,
	"Usage: oapi-cli CreateNetPeering --AccepterNetId=accepternetid --SourceNetId=sourcenetid [OPTIONS]\n" "Requests a Net peering between a Net you own and a peer Net that belongs to you \n" "or another account.\nThis action creates a Net peering that remains in the \n" "`pending-acceptance` state until it is accepted by the owner of the peer Net. \n" "If the owner of the peer Net does not accept the request within 7 days, the \n" "state of the Net peering becomes `expired`. For more information, see \n" "[AcceptNetPeering](#acceptnetpeering).\n\n**[IMPORTANT]**\n* Peered Nets must \n" "contain at least one virtual machine (VM) each before the creation of the Net \n" "peering.\n* The two Nets must not have overlapping IP ranges. Otherwise, the \n" "Net peering is in the `failed` state.\n* A peering connection between two Nets \n" "works both ways. Therefore, you do not need to create a B-to-A connection if an \n" "A-to-B connection is created and accepted.\n\nFor more information, see [About \n" "Net Peerings](https://docs.outscale.com/en/userguide/About-Net-Peerings.html).\n" "\nRequired Argument: AccepterNetId, SourceNetId \n"
,
	"Usage: oapi-cli CreateNetAccessPoint --ServiceName=servicename --NetId=netid [OPTIONS]\n" "Creates a Net access point to access an OUTSCALE service from this Net without \n" "using the Internet and public IPs.\nYou specify the service using its name. For \n" "more information about the available services, see \n" "[ReadNetAccessPointServices](#readnetaccesspointservices).\nTo control the \n" "routing of traffic between the Net and the specified service, you can specify \n" "one or more route tables. Virtual machines placed in Subnets associated with \n" "the specified route table thus use the Net access point to access the service. \n" "When you specify a route table, a route is automatically added to it with the \n" "destination set to the prefix list ID of the service, and the target set to the \n" "ID of the access point.\nFor more information, see [About Net Access \n" "Points](https://docs.outscale.com/en/userguide/About-Net-Access-Points.html).\n" "\nRequired Argument: ServiceName, NetId \n"
,
	"Usage: oapi-cli CreateNet --IpRange=iprange [OPTIONS]\n" "Creates a Net with a specified IP range.\nThe IP range (network range) of your \n" "Net must be between a /28 netmask (16 IPs) and a /16 netmask (65536 IPs).\nFor \n" "more information, see [About \n" "Nets](https://docs.outscale.com/en/userguide/About-Nets.html).\n" "\nRequired Argument: IpRange \n"
,
	"Usage: oapi-cli CreateNatService --PublicIpId=publicipid --SubnetId=subnetid [OPTIONS]\n" "Creates a network address translation (NAT) service in the specified public \n" "Subnet of a Net.\nA NAT service enables virtual machines (VMs) placed in the \n" "private Subnet of this Net to connect to the Internet, without being accessible \n" "from the Internet.\nWhen creating a NAT service, you specify the allocation ID \n" "of the public IP you want to use as public IP for the NAT service. Once the NAT \n" "service is created, you need to create a route in the route table of the \n" "private Subnet, with 0.0.0.0/0 as destination and the ID of the NAT service as \n" "target. For more information, see [LinkPublicIP](#linkpublicip) and \n" "[CreateRoute](#createroute).\nThis action also enables you to create multiple \n" "NAT services in the same Net (one per public Subnet).\n\n**[IMPORTANT]**\nYou \n" "cannot modify the public IP associated with a NAT service after its creation. \n" "To do so, you need to delete the NAT service and create a new one with another \n" "public IP.\nFor more information, see [About NAT \n" "Services](https://docs.outscale.com/en/userguide/About-NAT-Services.html).\n" "\nRequired Argument: PublicIpId, SubnetId \n"
,
	"Usage: oapi-cli CreateLoadBalancerTags --LoadBalancerNames=loadbalancernames --Tags=tags [OPTIONS]\n" "Adds one or more tags to the specified load balancers.\nIf a tag with the same \n" "key already exists for the load balancer, the tag value is replaced.\nFor more \n" "information, see [About \n" "Tags](https://docs.outscale.com/en/userguide/About-Tags.html).\n" "\nRequired Argument: LoadBalancerNames, Tags \n"
,
	"Usage: oapi-cli CreateLoadBalancerPolicy --PolicyType=policytype --LoadBalancerName=loadbalancername --PolicyName=policyname [OPTIONS]\n" "Creates a stickiness policy with sticky session lifetimes defined by the \n" "browser lifetime.\nThe created policy can be used with HTTP or HTTPS listeners \n" "only.\nIf this policy is implemented by a load balancer, this load balancer \n" "uses this cookie in all incoming requests to direct them to the specified \n" "back-end server virtual machine (VM). If this cookie is not present, the load \n" "balancer sends the request to any other server according to its load-balancing \n" "algorithm.\n\nYou can also create a stickiness policy with sticky session \n" "lifetimes following the lifetime of an application-generated cookie.\nUnlike \n" "the other type of stickiness policy, the lifetime of the special Load Balancer \n" "Unit (LBU) cookie follows the lifetime of the application-generated cookie \n" "specified in the policy configuration. The load balancer inserts a new \n" "stickiness cookie only when the application response includes a new application \n" "cookie.\nThe session stops being sticky if the application cookie is removed or \n" "expires, until a new application cookie is issued.\nFor more information, see \n" "[About Load \n" "Balancers](https://docs.outscale.com/en/userguide/About-Load-Balancers.html).\n" "\nRequired Argument: PolicyType, LoadBalancerName, PolicyName \n"
,
	"Usage: oapi-cli CreateLoadBalancerListeners --Listeners=listeners --LoadBalancerName=loadbalancername [OPTIONS]\n" "Creates one or more listeners for a specified load balancer.\nFor more \n" "information, see [About Load \n" "Balancers](https://docs.outscale.com/en/userguide/About-Load-Balancers.html).\n" "\nRequired Argument: Listeners, LoadBalancerName \n"
,
	"Usage: oapi-cli CreateLoadBalancer --Listeners=listeners --LoadBalancerName=loadbalancername [OPTIONS]\n" "Creates a load balancer.\nThe load balancer is created with a unique Domain \n" "Name Service (DNS) name. It receives the incoming traffic and routes it to its \n" "registered virtual machines (VMs).\nBy default, this action creates an \n" "Internet-facing load balancer, resolving to public IPs. To create an internal \n" "load balancer in a Net, resolving to private IPs, use the `LoadBalancerType` \n" "parameter.\nYou must specify either the `Subnets` or the `SubregionNames` \n" "parameters.\nFor more information, see [About Load \n" "Balancers](https://docs.outscale.com/en/userguide/About-Load-Balancers.html).\n" "\nRequired Argument: Listeners, LoadBalancerName \n"
,
	"Usage: oapi-cli CreateListenerRule --VmIds=vmids --Listener=listener --ListenerRule=listenerrule [OPTIONS]\n" "Creates a rule for traffic redirection for the specified listener. Each rule \n" "must have either the `HostNamePattern` or `PathPattern` parameter specified. \n" "Rules are treated in priority order, from the highest value to the lowest \n" "value.\nOnce the rule is created, you need to register backend VMs with it. For \n" "more information, see the \n" "[RegisterVmsInLoadBalancer](#registervmsinloadbalancer) method.\nFor more \n" "information, see [About Load \n" "Balancers](https://docs.outscale.com/en/userguide/About-Load-Balancers.html).\n" "\nRequired Argument: VmIds, Listener, ListenerRule \n"
,
	"Usage: oapi-cli CreateKeypair --KeypairName=keypairname [OPTIONS]\n" "Creates a keypair to use with your virtual machines (VMs).\nYou can use this \n" "method in two different ways:\n* **Creating a keypair**: In that case, 3DS \n" "OUTSCALE creates a 2048-bit RSA keypair, stores its public key in your account, \n" "and returns its private key in the response of the call so that you can save it \n" "in a file.\nWhen you save the returned private key, make sure you replace the \n" "`\\n` escape sequences with real line breaks.\n* **Importing a keypair created \n" "locally**: If you already have a keypair that you have created locally with a \n" "third-party tool, you can import its public key in your account. The following \n" "types of key can be imported: RSA (2048 bits or preferably 4096 bits), Ed25519, \n" "and ECDSA (256 bits, 384 bits, or 521 bits). The following formats can be used: \n" "PEM, PKCS8, RFC4716, and OpenSSH.\n\nFor more information, see [About \n" "Keypairs](https://docs.outscale.com/en/userguide/About-Keypairs.html).\n" "\nRequired Argument: KeypairName \n"
,
	"Usage: oapi-cli CreateInternetService [OPTIONS]\n" "Creates an Internet service you can use with a Net.\nAn Internet service \n" "enables your virtual machines (VMs) launched in a Net to connect to the \n" "Internet. By default, a Net includes an Internet service, and each Subnet is \n" "public. Every VM launched within a default Subnet has a private IP and a public \n" "IP.\nFor more information, see [About Internet \n" "Services](https://docs.outscale.com/en/userguide/About-Internet-Services.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli CreateImageExportTask --OsuExport=osuexport --ImageId=imageid [OPTIONS]\n" "Exports an Outscale machine image (OMI) to an OUTSCALE Object Storage (OOS) \n" "bucket.\nThis action enables you to copy an OMI between accounts in different \n" "Regions. To copy an OMI in the same Region, you can also use the \n" "[CreateImage](#createimage) method.\nThe copy of the OMI belongs to you and is \n" "independent from the source OMI.\n\n**[IMPORTANT]**\nYou cannot export a shared \n" "or public OMI, as they do not belong to you. To do so, you must first copy it \n" "to your account. The copy then belongs to you and you can export it.\nFor more \n" "information, see [About \n" "OMIs](https://docs.outscale.com/en/userguide/About-OMIs.html).\n" "\nRequired Argument: OsuExport, ImageId \n"
,
	"Usage: oapi-cli CreateImage [OPTIONS]\n" "Creates an OUTSCALE machine image (OMI).\nYou can use this method in different \n" "ways:\n* **Creating from a VM**: You create an OMI from one of your virtual \n" "machines (VMs).<br>\n* **Copying an OMI**: You copy an existing OMI. The source \n" "OMI can be one of your own OMIs, or an OMI owned by another account that has \n" "granted you permission via the [UpdateImage](#updateimage) method.<br>\n* \n" "**Registering from a snapshot**: You register an OMI from an existing snapshot. \n" "The source snapshot can be one of your own snapshots, or a snapshot owned by \n" "another account that has granted you permission via the \n" "[UpdateSnapshot](#updatesnapshot) method.<br>\n* **Registering from a bucket by \n" "using a manifest file**: You register an OMI from the manifest file of an OMI \n" "that was exported to an OUTSCALE Object Storage (OOS) bucket. First, the owner \n" "of the source OMI must export it to the bucket by using the \n" "[CreateImageExportTask](#createimageexporttask) method. Then, they must grant \n" "you permission to read the manifest file via a pre-signed URL or Access Control \n" "Lists. For more information, see [Managing Access to Your Buckets and \n" "Objects](https://docs.outscale.com/en/userguide/Managing-Access-to-Your-Buckets-\n" "and-Objects.html).\n* **Registering from a bucket without using a manifest \n" "file**: This is similar to the previous case but you manually specify all the \n" "information that would be in a manifest file instead of using a manifest \n" "file.\n\n**[TIP]**\nRegistering from a bucket enables you to copy an OMI across \n" "Regions.\n\nFor more information, see [About \n" "OMIs](https://docs.outscale.com/en/userguide/About-OMIs.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli CreateFlexibleGpu --ModelName=modelname --SubregionName=subregionname [OPTIONS]\n" "Allocates a flexible GPU (fGPU) to your account.\nYou can then attach this fGPU \n" "to a virtual machine (VM).\nFor more information, see [About Flexible \n" "GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).\n" "\nRequired Argument: ModelName, SubregionName \n"
,
	"Usage: oapi-cli CreateDirectLinkInterface --DirectLinkId=directlinkid --DirectLinkInterface=directlinkinterface [OPTIONS]\n" "Creates a DirectLink interface.\nDirectLink interfaces enable you to reach one \n" "of your Nets through a virtual gateway.\nFor more information, see [About \n" "DirectLink](https://docs.outscale.com/en/userguide/About-DirectLink.html).\n" "\nRequired Argument: DirectLinkId, DirectLinkInterface \n"
,
	"Usage: oapi-cli CreateDirectLink --Bandwidth=bandwidth --DirectLinkName=directlinkname --Location=location [OPTIONS]\n" "Creates a DirectLink between a customer network and a specified DirectLink \n" "location.\nFor more information, see [About \n" "DirectLink](https://docs.outscale.com/en/userguide/About-DirectLink.html).\n" "\nRequired Argument: Bandwidth, DirectLinkName, Location \n"
,
	"Usage: oapi-cli CreateDhcpOptions [OPTIONS]\n" "Creates a set of DHCP options, that you can then associate with a Net using the \n" "[UpdateNet](#updatenet) method.\nFor more information, see [About DHCP \n" "Options](https://docs.outscale.com/en/userguide/About-DHCP-Options.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli CreateDedicatedGroup --CpuGeneration=cpugeneration --Name=name --SubregionName=subregionname [OPTIONS]\n" "> [WARNING]\n> This feature is currently in beta.\n\nCreates a dedicated group \n" "for virtual machines (VMs).\nFor more information, see [About Dedicated \n" "Groups](https://docs.outscale.com/en/userguide/About-Dedicated-Groups.html).\n" "\nRequired Argument: CpuGeneration, Name, SubregionName \n"
,
	"Usage: oapi-cli CreateClientGateway --BgpAsn=bgpasn --PublicIp=publicip --ConnectionType=connectiontype [OPTIONS]\n" "Provides information about your client gateway.\nThis action registers \n" "information to identify the client gateway that you deployed in your \n" "network.\nTo open a tunnel to the client gateway, you must provide the \n" "communication protocol type, the fixed public IP of the gateway, and an \n" "Autonomous System Number (ASN).\nFor more information, see [About Client \n" "Gateways](https://docs.outscale.com/en/userguide/About-Client-Gateways.html).\n" "\nRequired Argument: BgpAsn, PublicIp, ConnectionType \n"
,
	"Usage: oapi-cli CreateCa --CaPem=capem [OPTIONS]\n" "Creates a Client Certificate Authority (CA).\nFor more information, see [About \n" "API Access \n" "Rules](https://docs.outscale.com/en/userguide/About-API-Access-Rules.html).\n" "\nRequired Argument: CaPem \n"
,
	"Usage: oapi-cli CreateApiAccessRule [OPTIONS]\n" "Creates a rule to allow access to the API from your account.\nYou need to \n" "specify at least the `CaIds` or the `IpRanges` parameter.\n\n**[NOTE]**\nBy \n" "default, your account has a set of rules allowing global access, that you can \n" "delete.\nFor more information, see [About API Access \n" "Rules](https://docs.outscale.com/en/userguide/About-API-Access-Rules.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli CreateAccount --City=city --CompanyName=companyname --Country=country --CustomerId=customerid --Email=email --FirstName=firstname --LastName=lastname --ZipCode=zipcode [OPTIONS]\n" "Creates an OUTSCALE account.\n\n**[IMPORTANT]**\n* You need OUTSCALE \n" "credentials and the appropriate quotas to create an account via API. To get \n" "quotas, you can send an email to sales@outscale.com.\n* If you want to pass a \n" "numeral value as a string instead of an integer, you must wrap your string in \n" "additional quotes (for example, `'&quot;92000&quot;'`).\n\nFor more \n" "information, see [About Your \n" "Account](https://docs.outscale.com/en/userguide/About-Your-Account.html).\n" "\nRequired Argument: City, CompanyName, Country, CustomerId, Email, FirstName, LastName, ZipCode \n"
,
	"Usage: oapi-cli CreateAccessKey [OPTIONS]\n" "Creates an access key for either your root account or an EIM user. The new key \n" "is automatically set to `ACTIVE`.\nFor more information, see [About Access \n" "Keys](https://docs.outscale.com/en/userguide/About-Access-Keys.html).\n" "\nRequired Argument: \n"
,
	"Usage: oapi-cli CheckAuthentication --Login=login --Password=password [OPTIONS]\n" "Validates the authenticity of the account.\n" "\nRequired Argument: Login, Password \n"
,
	"Usage: oapi-cli AcceptNetPeering --NetPeeringId=netpeeringid [OPTIONS]\n" "Accepts a Net peering request.\nTo accept this request, you must be the owner \n" "of the peer Net. If you do not accept the request within 7 days, the state of \n" "the Net peering becomes `expired`.\n\n**[NOTE]**\nA peering connection between \n" "two Nets works both ways. Therefore, when an A-to-B peering connection is \n" "accepted, any pending B-to-A peering connection is automatically rejected as \n" "redundant.\n" "\nRequired Argument: NetPeeringId \n"
,
	NULL
};

static const char *calls_args_descriptions[] = {
	"ClientGatewayId: string\n"
	"  The ID of the client gateway.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
"VpnConnectionId: string\n"
	"  The ID of the VPN connection you want to modify.\n"
"VpnOptions: ref VpnOptionsToUpdate\n"
	"    Information about the VPN options.\n"
	"    -Phase2Options: ref Phase2OptionsToUpdate\n"
	"        Information about Phase 2 of the Internet Key Exchange (IKE) \n"
	"        negotiation. \n"
	"        -PreSharedKey: string\n"
	"          The pre-shared key to establish the initial authentication \n"
	"          between the client gateway and the virtual gateway. This key \n"
	"          can contain any character except line breaks and double quotes \n"
	"          (\").\n"
	"    -TunnelInsideIpRange: string\n"
	"      The range of inside IPs for the tunnel. This must be a /30 \n"
	"      CIDR block from the 169.254.254.0/24 range.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Iops: int\n"
	"  **Cold volume**: the new number of I/O operations per second (IOPS). \n"
	"  This parameter can be specified only if you update an `io1` volume or \n"
	"  if you change the type of the volume for an `io1`. This modification is \n"
	"  instantaneous. \n**Hot volume**: the new number of I/O operations per \n"
	"  second (IOPS). This parameter can be specified only if you update an \n"
	"  `io1` volume. This modification is not instantaneous. \nThe maximum \n"
	"  number of IOPS allowed for `io1` volumes is `13000` with a maximum \n"
	"  performance ratio of 300 IOPS per gibibyte.\n"
"Size: int\n"
	"  **Cold volume**: the new size of the volume, in gibibytes (GiB). This \n"
	"  value must be equal to or greater than the current size of the volume. \n"
	"  This modification is not instantaneous. \n**Hot volume**: you cannot \n"
	"  change the size of a hot volume.\n"
"VolumeId: string\n"
	"  The ID of the volume you want to update.\n"
"VolumeType: string\n"
	"  **Cold volume**: the new type of the volume (`standard` \\| `io1` \\| \n"
	"  `gp2`). This modification is instantaneous. If you update to an `io1` \n"
	"  volume, you must also specify the `Iops` parameter.\n**Hot volume**: \n"
	"  you cannot change the type of a hot volume.\n"
,
	"Description: string\n"
	"  A new description for the VM template.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Tags: array ref ResourceTag\n"
	"  New tags for your VM template.\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    -Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
"VmTemplateId: string\n"
	"  The ID of the VM template you want to update.\n"
"VmTemplateName: string\n"
	"  A new name for your VM template.\n"
,
	"Description: string\n"
	"  A new description for the VM group.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Tags: array ref ResourceTag\n"
	"  New tags for your VM group.\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    -Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
"VmGroupId: string\n"
	"  The ID of the VM group you want to update.\n"
"VmGroupName: string\n"
	"  A new name for your VM group.\n"
"VmTemplateId: string\n"
	"  A new VM template ID for your VM group.\n"
,
	"BlockDeviceMappings: array ref BlockDeviceMappingVmUpdate\n"
	"  One or more block device mappings of the VM.\n"
	"    Information about the block device mapping.\n"
	"    -Bsu: ref BsuToUpdateVm\n"
	"        Information about the BSU volume.\n"
	"        -DeleteOnVmDeletion: bool\n"
	"          If set to true, the volume is deleted when terminating the VM. \n"
	"          If set to false, the volume is not deleted when terminating the \n"
	"          VM.\n"
	"        -VolumeId: string\n"
	"          The ID of the volume.\n"
	"    -DeviceName: string\n"
	"      The device name for the volume. For a root device, you must \n"
	"      use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, \n"
	"      `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` \n"
	"      is a letter between `b` and `z`, and the second `X` is a letter \n"
	"      between `a` and `z`).\n"
	"    -NoDevice: string\n"
	"      Removes the device which is included in the block device \n"
	"      mapping of the OMI.\n"
	"    -VirtualDeviceName: string\n"
	"      The name of the virtual device (`ephemeralN`).\n"
"BsuOptimized: bool\n"
	"  This parameter is not available. It is present in our API for the sake \n"
	"  of historical compatibility with AWS.\n"
"DeletionProtection: bool\n"
	"  If true, you cannot delete the VM unless you change this parameter back \n"
	"  to false.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"IsSourceDestChecked: bool\n"
	"  (Net only) If true, the source/destination check is enabled. If false, \n"
	"  it is disabled. This value must be false for a NAT VM to perform \n"
	"  network address translation (NAT) in a Net.\n"
"KeypairName: string\n"
	"  The name of a keypair you want to associate with the VM.\nWhen you \n"
	"  replace the keypair of a VM with another one, the metadata of the VM is \n"
	"  modified to reflect the new public key, but the replacement is still \n"
	"  not effective in the operating system of the VM. To complete the \n"
	"  replacement and effectively apply the new keypair, you need to perform \n"
	"  other actions inside the VM. For more information, see [Modifying the \n"
	"  Keypair of a \n"
	"  VM](https://docs.outscale.com/en/userguide/Modifying-the-Keypair-of-a-VM\n"
	"  .html).\n"
"NestedVirtualization: bool\n"
	"  (dedicated tenancy only) If true, nested virtualization is enabled. If \n"
	"  false, it is disabled.\n"
"Performance: string\n"
	"  The performance of the VM (`medium` \\| `high` \\| `highest`).\n"
"SecurityGroupIds: array string\n"
	"  One or more IDs of security groups for the VM.\n"
"UserData: string\n"
	"  The Base64-encoded MIME user data, limited to 500 kibibytes (KiB).\n"
"VmId: string\n"
	"  The ID of the VM.\n"
"VmInitiatedShutdownBehavior: string\n"
	"  The VM behavior when you stop it. If set to `stop`, the VM stops. If \n"
	"  set to `restart`, the VM stops then automatically restarts. If set to \n"
	"  `terminate`, the VM stops and is terminated.\n"
"VmType: string\n"
	"  The type of VM. For more information, see [VM \n"
	"  Types](https://docs.outscale.com/en/userguide/VM-Types.html).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NewPath: string\n"
	"  A new path for the EIM user.\n"
"NewUserName: string\n"
	"  A new name for the EIM user.\n"
"UserName: string\n"
	"  The name of the EIM user you want to modify.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"MapPublicIpOnLaunch: bool\n"
	"  If true, a public IP is assigned to the network interface cards (NICs) \n"
	"  created in the specified Subnet.\n"
"SubnetId: string\n"
	"  The ID of the Subnet.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PermissionsToCreateVolume: ref PermissionsOnResourceCreation\n"
	"    Information about the permissions for the resource.<br \n"
	"    />\nSpecify either the `Additions` or the `Removals` parameter.\n"
	"    -Additions: ref PermissionsOnResource\n"
	"        Permissions for the resource.\n"
	"        -AccountIds: array string\n"
	"          One or more account IDs that the permission is associated \n"
	"          with.\n"
	"        -GlobalPermission: bool\n"
	"          A global permission for all accounts.\n(Request) Set \n"
	"          this parameter to true to make the resource public (if the \n"
	"          parent parameter is `Additions`) or to make the resource \n"
	"          private (if the parent parameter is `Removals`).<br \n"
	"          />\n(Response) If true, the resource is public. If false, the \n"
	"          resource is private.\n"
	"    -Removals: ref PermissionsOnResource\n"
	"        Permissions for the resource.\n"
	"        -AccountIds: array string\n"
	"          One or more account IDs that the permission is associated \n"
	"          with.\n"
	"        -GlobalPermission: bool\n"
	"          A global permission for all accounts.\n(Request) Set \n"
	"          this parameter to true to make the resource public (if the \n"
	"          parent parameter is `Additions`) or to make the resource \n"
	"          private (if the parent parameter is `Removals`).<br \n"
	"          />\n(Response) If true, the resource is public. If false, the \n"
	"          resource is private.\n"
"SnapshotId: string\n"
	"  The ID of the snapshot.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Name: string\n"
	"  The name of the server certificate you want to modify.\n"
"NewName: string\n"
	"  A new name for the server certificate.\n"
"NewPath: string\n"
	"  A new path for the server certificate.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LinkRouteTableId: string\n"
	"  The ID of the current route table link.\n"
"RouteTableId: string\n"
	"  The ID of the new route table to associate with the Subnet.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Enable: bool\n"
	"  If true, a virtual gateway can propagate routes to a specified route \n"
	"  table of a Net. If false, the propagation is disabled.\n"
"RouteTableId: string\n"
	"  The ID of the route table.\n"
"VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
,
	"DestinationIpRange: string\n"
	"  The IP range used for the destination match, in CIDR notation (for \n"
	"  example, `10.0.0.0/24`).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"GatewayId: string\n"
	"  The ID of an Internet service or virtual gateway attached to your Net.\n"
"NatServiceId: string\n"
	"  The ID of a NAT service.\n"
"NetPeeringId: string\n"
	"  The ID of a Net peering.\n"
"NicId: string\n"
	"  The ID of a network interface card (NIC).\n"
"RouteTableId: string\n"
	"  The ID of the route table.\n"
"VmId: string\n"
	"  The ID of a NAT VM in your Net.\n"
,
	"Description: string\n"
	"  A new description for the NIC.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LinkNic: ref LinkNicToUpdate\n"
	"    Information about the NIC attachment. If you are modifying the \n"
	"    `DeleteOnVmDeletion` attribute, you must specify the ID of the \n"
	"    NIC attachment.\n"
	"    -DeleteOnVmDeletion: bool\n"
	"      If true, the NIC is deleted when the VM is terminated. If \n"
	"      false, the NIC is detached from the VM.\n"
	"    -LinkNicId: string\n"
	"      The ID of the NIC attachment.\n"
"NicId: string\n"
	"  The ID of the NIC you want to modify.\n"
"SecurityGroupIds: array string\n"
	"  One or more IDs of security groups for the NIC.\nYou must specify at \n"
	"  least one group, even if you use the default security group in the Net.\n"
,
	"AddRouteTableIds: array string\n"
	"  One or more IDs of route tables to associate with the specified Net \n"
	"  access point.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetAccessPointId: string\n"
	"  The ID of the Net access point.\n"
"RemoveRouteTableIds: array string\n"
	"  One or more IDs of route tables to disassociate from the specified Net \n"
	"  access point.\n"
,
	"DhcpOptionsSetId: string\n"
	"  The ID of the DHCP options set (or `default` if you want to associate \n"
	"  the default one).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetId: string\n"
	"  The ID of the Net.\n"
,
	"AccessLog: ref AccessLog\n"
	"    Information about access logs.\n"
	"    -IsEnabled: bool\n"
	"      If true, access logs are enabled for your load balancer. If \n"
	"      false, they are not. If you set this to true in your request, \n"
	"      the `OsuBucketName` parameter is required.\n"
	"    -OsuBucketName: string\n"
	"      The name of the OOS bucket for the access logs.\n"
	"    -OsuBucketPrefix: string\n"
	"      The path to the folder of the access logs in your OOS bucket \n"
	"      (by default, the `root` level of your bucket).\n"
	"    -PublicationInterval: int\n"
	"      The time interval for the publication of access logs in the \n"
	"      OOS bucket, in minutes. This value can be either `5` or `60` \n"
	"      (by default, `60`).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"HealthCheck: ref HealthCheck\n"
	"    Information about the health check configuration.\n"
	"    -CheckInterval: int\n"
	"      The number of seconds between two requests (between `5` and \n"
	"      `600` both included).\n"
	"    -HealthyThreshold: int\n"
	"      The number of consecutive successful requests before \n"
	"      considering the VM as healthy (between `2` and `10` both \n"
	"      included).\n"
	"    -Path: string\n"
	"      If you use the HTTP or HTTPS protocols, the request URL path.\n"
	"    -Port: int\n"
	"      The port number (between `1` and `65535`, both included).\n"
	"    -Protocol: string\n"
	"      The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| \n"
	"      `TCP` \\| `SSL`).\n"
	"    -Timeout: int\n"
	"      The maximum waiting time for a response before considering the \n"
	"      VM as unhealthy, in seconds (between `2` and `60` both \n"
	"      included).\n"
	"    -UnhealthyThreshold: int\n"
	"      The number of consecutive failed requests before considering \n"
	"      the VM as unhealthy (between `2` and `10` both included).\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
"LoadBalancerPort: int\n"
	"  The port on which the load balancer is listening (between `1` and \n"
	"  `65535`, both included). This parameter is required if you want to \n"
	"  update the server certificate.\n"
"PolicyNames: array string\n"
	"  The name of the policy you want to enable for the listener.\n"
"PublicIp: string\n"
	"  (internet-facing only) The public IP you want to associate with the \n"
	"  load balancer. The former public IP of the load balancer is then \n"
	"  disassociated. If you specify an empty string and the former public IP \n"
	"  belonged to you, it is disassociated and replaced by a public IP owned \n"
	"  by 3DS OUTSCALE.\n"
"SecuredCookies: bool\n"
	"  If true, secure cookies are enabled for the load balancer.\n"
"SecurityGroups: array string\n"
	"  (Net only) One or more IDs of security groups you want to assign to the \n"
	"  load balancer. You need to specify the already assigned security groups \n"
	"  that you want to keep along with the new ones you are assigning. If the \n"
	"  list is empty, the default security group of the Net is assigned to the \n"
	"  load balancer.\n"
"ServerCertificateId: string\n"
	"  The Outscale Resource Name (ORN) of the server certificate. For more \n"
	"  information, see [Resource Identifiers > Outscale Resource Names \n"
	"  (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html\n"
	"  #_outscale_resource_names_orns). If this parameter is specified, you \n"
	"  must also specify the `LoadBalancerPort` parameter.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"HostPattern: string\n"
	"  A host-name pattern for the rule, with a maximum length of 128 \n"
	"  characters. This host-name pattern supports maximum three wildcards, \n"
	"  and must not contain any special characters except [-.?].\n"
"ListenerRuleName: string\n"
	"  The name of the listener rule.\n"
"PathPattern: string\n"
	"  A path pattern for the rule, with a maximum length of 128 characters. \n"
	"  This path pattern supports maximum three wildcards, and must not \n"
	"  contain any special characters except [_-.$/~\"'@:+?].\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ImageId: string\n"
	"  The ID of the OMI you want to modify.\n"
"PermissionsToLaunch: ref PermissionsOnResourceCreation\n"
	"    Information about the permissions for the resource.<br \n"
	"    />\nSpecify either the `Additions` or the `Removals` parameter.\n"
	"    -Additions: ref PermissionsOnResource\n"
	"        Permissions for the resource.\n"
	"        -AccountIds: array string\n"
	"          One or more account IDs that the permission is associated \n"
	"          with.\n"
	"        -GlobalPermission: bool\n"
	"          A global permission for all accounts.\n(Request) Set \n"
	"          this parameter to true to make the resource public (if the \n"
	"          parent parameter is `Additions`) or to make the resource \n"
	"          private (if the parent parameter is `Removals`).<br \n"
	"          />\n(Response) If true, the resource is public. If false, the \n"
	"          resource is private.\n"
	"    -Removals: ref PermissionsOnResource\n"
	"        Permissions for the resource.\n"
	"        -AccountIds: array string\n"
	"          One or more account IDs that the permission is associated \n"
	"          with.\n"
	"        -GlobalPermission: bool\n"
	"          A global permission for all accounts.\n(Request) Set \n"
	"          this parameter to true to make the resource public (if the \n"
	"          parent parameter is `Additions`) or to make the resource \n"
	"          private (if the parent parameter is `Removals`).<br \n"
	"          />\n(Response) If true, the resource is public. If false, the \n"
	"          resource is private.\n"
,
	"DeleteOnVmDeletion: bool\n"
	"  If true, the fGPU is deleted when the VM is terminated.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"FlexibleGpuId: string\n"
	"  The ID of the fGPU you want to modify.\n"
,
	"DirectLinkInterfaceId: string\n"
	"  The ID of the DirectLink interface you want to update.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Mtu: int\n"
	"  The maximum transmission unit (MTU) of the DirectLink interface, in \n"
	"  bytes (always `1500`).\n"
,
	"DedicatedGroupId: string\n"
	"  The ID of the dedicated group you want to update.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Name: string\n"
	"  The new name of the dedicated group.\n"
,
	"CaId: string\n"
	"  The ID of the CA.\n"
"Description: string\n"
	"  The description of the CA.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"ApiAccessRuleId: string\n"
	"  The ID of the API access rule you want to update.\n"
"CaIds: array string\n"
	"  One or more IDs of Client Certificate Authorities (CAs).\n"
"Cns: array string\n"
	"  One or more Client Certificate Common Names (CNs).\n"
"Description: string\n"
	"  A new description for the API access rule.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"IpRanges: array string\n"
	"  One or more IP addresses or CIDR blocks (for example, `192.0.2.0/16`).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"MaxAccessKeyExpirationSeconds: int\n"
	"  The maximum possible lifetime for your access keys, in seconds (between \n"
	"  `0` and `3153600000`, both included). If set to `O`, your access keys \n"
	"  can have unlimited lifetimes, but a trusted session cannot be \n"
	"  activated. Otherwise, all your access keys must have an expiration \n"
	"  date. This value must be greater than the remaining lifetime of each \n"
	"  access key of your account.\n"
"RequireTrustedEnv: bool\n"
	"  If true, a trusted session is activated, provided that you specify the \n"
	"  `MaxAccessKeyExpirationSeconds` parameter with a value greater than \n"
	"  `0`.\nEnabling this will require you and all your users to log in to \n"
	"  Cockpit v2 using the WebAuthn method for multi-factor authentication. \n"
	"  For more information, see [About Authentication > Multi-Factor \n"
	"  Authentication](https://docs.outscale.com/en/userguide/About-Authenticat\n"
	"  ion.html#_multi_factor_authentication).\n"
,
	"AdditionalEmails: array string\n"
	"  One or more additional email addresses for the account. These addresses \n"
	"  are used for notifications only. If you already have a list of \n"
	"  additional emails registered, you cannot add to it, only replace it. To \n"
	"  remove all registered additional emails, specify an empty list.\n"
"City: string\n"
	"  The new city of the account owner.\n"
"CompanyName: string\n"
	"  The new name of the company for the account.\n"
"Country: string\n"
	"  The new country of the account owner.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Email: string\n"
	"  The main email address for the account. This address is used for your \n"
	"  credentials and notifications.\n"
"FirstName: string\n"
	"  The new first name of the account owner.\n"
"JobTitle: string\n"
	"  The new job title of the account owner.\n"
"LastName: string\n"
	"  The new last name of the account owner.\n"
"MobileNumber: string\n"
	"  The new mobile phone number of the account owner.\n"
"PhoneNumber: string\n"
	"  The new landline phone number of the account owner.\n"
"StateProvince: string\n"
	"  The new state/province of the account owner.\n"
"VatNumber: string\n"
	"  The new value added tax (VAT) number for the account.\n"
"ZipCode: string\n"
	"  The new ZIP code of the city.\n"
,
	"AccessKeyId: string\n"
	"  The ID of the access key.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ExpirationDate: string\n"
	"  The date and time, or the date, at which you want the access key to \n"
	"  expire, in ISO 8601 format (for example, `2020-06-14T00:00:00.000Z` or \n"
	"  `2020-06-14`). If not specified, the access key is set to not expire.\n"
"State: string\n"
	"  The new state for the access key (`ACTIVE` \\| `INACTIVE`). When set to \n"
	"  `ACTIVE`, the access key is enabled and can be used to send requests. \n"
	"  When set to `INACTIVE`, the access key is disabled.\n"
"UserName: string\n"
	"  The name of the EIM user that the access key you want to modify is \n"
	"  associated with. If you do not specify a user name, this action \n"
	"  modifies the access key of the user who sends the request (which can be \n"
	"  the root account).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ForceUnlink: bool\n"
	"  Forces the detachment of the volume in case of previous failure. \n"
	"  Important: This action may damage your data or file systems.\n"
"VolumeId: string\n"
	"  The ID of the volume you want to detach.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetId: string\n"
	"  The ID of the Net from which you want to detach the virtual gateway.\n"
"VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LinkRouteTableId: string\n"
	"  The ID of the association between the route table and the Subnet.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LinkPublicIpId: string\n"
	"  The ID representing the association of the public IP with the VM or the \n"
	"  NIC. This parameter is required unless you use the `PublicIp` parameter.\n"
"PublicIp: string\n"
	"  The public IP. This parameter is required unless you use the \n"
	"  `LinkPublicIpId` parameter.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NicId: string\n"
	"  The ID of the NIC.\n"
"PrivateIps: array string\n"
	"  One or more secondary private IPs you want to unassign from the NIC.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
"UserName: string\n"
	"  The name of the user you want to detach the policy from.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LinkNicId: string\n"
	"  The ID of the attachment operation.\n"
,
	"BackendIps: array string\n"
	"   One or more public IPs of back-end VMs.\n"
"BackendVmIds: array string\n"
	"   One or more IDs of back-end VMs.\n"
"DryRun: bool\n"
	"   If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"   The name of the load balancer.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"InternetServiceId: string\n"
	"  The ID of the Internet service you want to detach.\n"
"NetId: string\n"
	"  The ID of the Net from which you want to detach the Internet service.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"FlexibleGpuId: string\n"
	"  The ID of the fGPU you want to detach from your VM.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ForceStop: bool\n"
	"  Forces the VM to stop.\n"
"VmIds: array string\n"
	"  One or more IDs of VMs.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmIds: array string\n"
	"  One or more IDs of VMs.\n"
,
	"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
"VersionId: string\n"
	"  The ID of the version.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmAddition: int\n"
	"  The number of VMs you want to add to the VM group.\n"
"VmGroupId: string\n"
	"  The ID of the VM group you want to scale up.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmGroupId: string\n"
	"  The ID of the VM group you want to scale down.\n"
"VmSubtraction: int\n"
	"  The number of VMs you want to delete from the VM group.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetPeeringId: string\n"
	"  The ID of the Net peering you want to reject.\n"
,
	"BackendVmIds: array string\n"
	"  One or more IDs of back-end VMs.\nSpecifying the same ID several times \n"
	"  has no effect as each back-end VM has equal weight.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmIds: array string\n"
	"  One or more IDs of the VMs you want to reboot.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersVpnConnection\n"
	"    One or more filters.\n"
	"    -BgpAsns: array integer\n"
	"      The Border Gateway Protocol (BGP) Autonomous System Numbers \n"
	"      (ASNs) of the connections.\n"
	"    -ClientGatewayIds: array string\n"
	"      The IDs of the client gateways.\n"
	"    -ConnectionTypes: array string\n"
	"      The types of the VPN connections (only `ipsec.1` is \n"
	"      supported).\n"
	"    -RouteDestinationIpRanges: array string\n"
	"      The destination IP ranges.\n"
	"    -States: array string\n"
	"      The states of the VPN connections (`pending` \\| `available` \n"
	"      \\| `deleting` \\| `deleted`).\n"
	"    -StaticRoutesOnly: bool\n"
	"      If false, the VPN connection uses dynamic routing with Border \n"
	"      Gateway Protocol (BGP). If true, routing is controlled using \n"
	"      static routes. For more information about how to create and \n"
	"      delete static routes, see \n"
	"      [CreateVpnConnectionRoute](#createvpnconnectionroute) and \n"
	"      [DeleteVpnConnectionRoute](#deletevpnconnectionroute).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the VPN connections.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the VPN connections.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the VPN \n"
	"      connections, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -VirtualGatewayIds: array string\n"
	"      The IDs of the virtual gateways.\n"
	"    -VpnConnectionIds: array string\n"
	"      The IDs of the VPN connections.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersVolume\n"
	"    One or more filters.\n"
	"    -CreationDates: array string\n"
	"      The dates and times of creation of the volumes, in ISO 8601 \n"
	"      date-time format (for example, `2020-06-30T00:00:00.000Z`).\n"
	"    -LinkVolumeDeleteOnVmDeletion: bool\n"
	"      Whether the volumes are deleted or not when terminating the \n"
	"      VMs.\n"
	"    -LinkVolumeDeviceNames: array string\n"
	"      The VM device names.\n"
	"    -LinkVolumeLinkDates: array string\n"
	"      The dates and times of creation of the volumes, in ISO 8601 \n"
	"      date-time format (for example, `2020-06-30T00:00:00.000Z`).\n"
	"    -LinkVolumeLinkStates: array string\n"
	"      The attachment states of the volumes (`attaching` \\| \n"
	"      `detaching` \\| `attached` \\| `detached`).\n"
	"    -LinkVolumeVmIds: array string\n"
	"      One or more IDs of VMs.\n"
	"    -SnapshotIds: array string\n"
	"      The snapshots from which the volumes were created.\n"
	"    -SubregionNames: array string\n"
	"      The names of the Subregions in which the volumes were created.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the volumes.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the volumes.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      volumes, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -VolumeIds: array string\n"
	"      The IDs of the volumes.\n"
	"    -VolumeSizes: array integer\n"
	"      The sizes of the volumes, in gibibytes (GiB).\n"
	"    -VolumeStates: array string\n"
	"      The states of the volumes (`creating` \\| `available` \\| \n"
	"      `in-use` \\| `updating` \\| `deleting` \\| `error`).\n"
	"    -VolumeTypes: array string\n"
	"      The types of the volumes (`standard` \\| `gp2` \\| `io1`).\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"AllVms: bool\n"
	"  If true, includes the status of all VMs. By default or if set to false, \n"
	"  only includes the status of running VMs.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersVmsState\n"
	"    One or more filters.\n"
	"    -MaintenanceEventCodes: array string\n"
	"      The code for the scheduled event (`system-reboot` \\| \n"
	"      `system-maintenance`).\n"
	"    -MaintenanceEventDescriptions: array string\n"
	"      The description of the scheduled event.\n"
	"    -MaintenanceEventsNotAfter: array string\n"
	"      The latest time the event can end.\n"
	"    -MaintenanceEventsNotBefore: array string\n"
	"      The earliest time the event can start.\n"
	"    -SubregionNames: array string\n"
	"      The names of the Subregions of the VMs.\n"
	"    -VmIds: array string\n"
	"      One or more IDs of VMs.\n"
	"    -VmStates: array string\n"
	"      The states of the VMs (`pending` \\| `running` \\| `stopping` \n"
	"      \\| `stopped` \\| `shutting-down` \\| `terminated` \\| \n"
	"      `quarantine`).\n"
,
	"BackendVmIds: array string\n"
	"  One or more IDs of back-end VMs.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersVm\n"
	"    One or more filters.\n"
	"    -Architectures: array string\n"
	"      The architectures of the VMs (`i386` \\| `x86_64`).\n"
	"    -BlockDeviceMappingDeleteOnVmDeletion: bool\n"
	"      Whether the BSU volumes are deleted when terminating the VMs.\n"
	"    -BlockDeviceMappingDeviceNames: array string\n"
	"      The device names for the BSU volumes (in the format \n"
	"      `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX`).\n"
	"    -BlockDeviceMappingLinkDates: array string\n"
	"      The link dates for the BSU volumes mapped to the VMs (for \n"
	"      example, `2016-01-23T18:45:30.000Z`).\n"
	"    -BlockDeviceMappingStates: array string\n"
	"      The states for the BSU volumes (`attaching` \\| `attached` \\| \n"
	"      `detaching` \\| `detached`).\n"
	"    -BlockDeviceMappingVolumeIds: array string\n"
	"      The volume IDs of the BSU volumes.\n"
	"    -ClientTokens: array string\n"
	"      The idempotency tokens provided when launching the VMs.\n"
	"    -CreationDates: array string\n"
	"      The dates when the VMs were launched.\n"
	"    -ImageIds: array string\n"
	"      The IDs of the OMIs used to launch the VMs.\n"
	"    -IsSourceDestChecked: bool\n"
	"      Whether the source/destination checking is enabled (true) or \n"
	"      disabled (false).\n"
	"    -KeypairNames: array string\n"
	"      The names of the keypairs used when launching the VMs.\n"
	"    -LaunchNumbers: array integer\n"
	"      The numbers for the VMs when launching a group of several VMs \n"
	"      (for example, `0`, `1`, `2`, and so on).\n"
	"    -Lifecycles: array string\n"
	"      Whether the VMs are Spot Instances (spot).\n"
	"    -NetIds: array string\n"
	"      The IDs of the Nets in which the VMs are running.\n"
	"    -NicAccountIds: array string\n"
	"      The IDs of the NICs.\n"
	"    -NicDescriptions: array string\n"
	"      The descriptions of the NICs.\n"
	"    -NicIsSourceDestChecked: bool\n"
	"      Whether the source/destination checking is enabled (true) or \n"
	"      disabled (false).\n"
	"    -NicLinkNicDeleteOnVmDeletion: bool\n"
	"      Whether the NICs are deleted when the VMs they are attached to \n"
	"      are deleted.\n"
	"    -NicLinkNicDeviceNumbers: array integer\n"
	"      The device numbers the NICs are attached to.\n"
	"    -NicLinkNicLinkNicDates: array string\n"
	"      The dates and time when the NICs were attached to the VMs.\n"
	"    -NicLinkNicLinkNicIds: array string\n"
	"      The IDs of the NIC attachments.\n"
	"    -NicLinkNicStates: array string\n"
	"      The states of the attachments.\n"
	"    -NicLinkNicVmAccountIds: array string\n"
	"      The account IDs of the owners of the VMs the NICs are attached \n"
	"      to.\n"
	"    -NicLinkNicVmIds: array string\n"
	"      The IDs of the VMs the NICs are attached to.\n"
	"    -NicLinkPublicIpAccountIds: array string\n"
	"      The account IDs of the owners of the public IPs associated \n"
	"      with the NICs.\n"
	"    -NicLinkPublicIpLinkPublicIpIds: array string\n"
	"      The association IDs returned when the public IPs were \n"
	"      associated with the NICs.\n"
	"    -NicLinkPublicIpPublicIpIds: array string\n"
	"      The allocation IDs returned when the public IPs were allocated \n"
	"      to their accounts.\n"
	"    -NicLinkPublicIpPublicIps: array string\n"
	"      The public IPs associated with the NICs.\n"
	"    -NicMacAddresses: array string\n"
	"      The Media Access Control (MAC) addresses of the NICs.\n"
	"    -NicNetIds: array string\n"
	"      The IDs of the Nets where the NICs are located.\n"
	"    -NicNicIds: array string\n"
	"      The IDs of the NICs.\n"
	"    -NicPrivateIpsLinkPublicIpAccountIds: array string\n"
	"      The account IDs of the owner of the public IPs associated with \n"
	"      the private IPs.\n"
	"    -NicPrivateIpsLinkPublicIpIds: array string\n"
	"      The public IPs associated with the private IPs.\n"
	"    -NicPrivateIpsPrimaryIp: bool\n"
	"      Whether the private IPs are the primary IPs associated with \n"
	"      the NICs.\n"
	"    -NicPrivateIpsPrivateIps: array string\n"
	"      The private IPs of the NICs.\n"
	"    -NicSecurityGroupIds: array string\n"
	"      The IDs of the security groups associated with the NICs.\n"
	"    -NicSecurityGroupNames: array string\n"
	"      The names of the security groups associated with the NICs.\n"
	"    -NicStates: array string\n"
	"      The states of the NICs (`available` \\| `in-use`).\n"
	"    -NicSubnetIds: array string\n"
	"      The IDs of the Subnets for the NICs.\n"
	"    -NicSubregionNames: array string\n"
	"      The Subregions where the NICs are located.\n"
	"    -Platforms: array string\n"
	"      The platforms. Use windows if you have Windows VMs. Otherwise, \n"
	"      leave this filter blank.\n"
	"    -PrivateIps: array string\n"
	"      The private IPs of the VMs.\n"
	"    -ProductCodes: array string\n"
	"      The product codes associated with the OMI used to create the \n"
	"      VMs.\n"
	"    -PublicIps: array string\n"
	"      The public IPs of the VMs.\n"
	"    -ReservationIds: array string\n"
	"      The IDs of the reservation of the VMs, created every time you \n"
	"      launch VMs. These reservation IDs can be associated with \n"
	"      several VMs when you lauch a group of VMs using the same launch \n"
	"      request.\n"
	"    -RootDeviceNames: array string\n"
	"      The names of the root devices for the VMs (for example, \n"
	"      `/dev/sda1`)\n"
	"    -RootDeviceTypes: array string\n"
	"      The root devices types used by the VMs (always `ebs`)\n"
	"    -SecurityGroupIds: array string\n"
	"      The IDs of the security groups for the VMs (only in the public \n"
	"      Cloud).\n"
	"    -SecurityGroupNames: array string\n"
	"      The names of the security groups for the VMs (only in the \n"
	"      public Cloud).\n"
	"    -StateReasonCodes: array integer\n"
	"      The reason codes for the state changes.\n"
	"    -StateReasonMessages: array string\n"
	"      The messages describing the state changes.\n"
	"    -StateReasons: array string\n"
	"      The reasons explaining the current states of the VMs. This \n"
	"      filter is like the `StateReasonCodes` one.\n"
	"    -SubnetIds: array string\n"
	"      The IDs of the Subnets for the VMs.\n"
	"    -SubregionNames: array string\n"
	"      The names of the Subregions of the VMs.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the VMs.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the VMs.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the VMs, \n"
	"      in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -Tenancies: array string\n"
	"      The tenancies of the VMs (`dedicated` \\| `default` \\| \n"
	"      `host`).\n"
	"    -VmIds: array string\n"
	"      One or more IDs of VMs.\n"
	"    -VmSecurityGroupIds: array string\n"
	"      The IDs of the security groups for the VMs.\n"
	"    -VmSecurityGroupNames: array string\n"
	"      The names of the security group for the VMs.\n"
	"    -VmStateCodes: array integer\n"
	"      The state codes of the VMs: `-1` (quarantine), `0` (pending), \n"
	"      `16` (running), `32` (shutting-down), `48` (terminated), `64` \n"
	"      (stopping), and `80` (stopped).\n"
	"    -VmStateNames: array string\n"
	"      The state names of the VMs (`pending` \\| `running` \\| \n"
	"      `stopping` \\| `stopped` \\| `shutting-down` \\| `terminated` \n"
	"      \\| `quarantine`).\n"
	"    -VmTypes: array string\n"
	"      The VM types (for example, t2.micro). For more information, \n"
	"      see [VM \n"
	"      Types](https://docs.outscale.com/en/userguide/VM-Types.html).\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersVmType\n"
	"    One or more filters.\n"
	"    -BsuOptimized: bool\n"
	"      This parameter is not available. It is present in our API for \n"
	"      the sake of historical compatibility with AWS.\n"
	"    -EphemeralsTypes: array string\n"
	"      The types of ephemeral storage disk.\n"
	"    -Eths: array integer\n"
	"      The number of Ethernet interfaces available.\n"
	"    -Gpus: array integer\n"
	"      The number of GPUs available.\n"
	"    -MemorySizes: array double\n"
	"      The amounts of memory, in gibibytes (GiB).\n"
	"    -VcoreCounts: array integer\n"
	"      The numbers of vCores.\n"
	"    -VmTypeNames: array string\n"
	"      The names of the VM types. For more information, see [VM \n"
	"      Types](https://docs.outscale.com/en/userguide/VM-Types.html).\n"
	"    -VolumeCounts: array integer\n"
	"      The maximum number of ephemeral storage disks.\n"
	"    -VolumeSizes: array integer\n"
	"      The size of one ephemeral storage disk, in gibibytes (GiB).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersVmTemplate\n"
	"    One or more filters.\n"
	"    -CpuCores: array integer\n"
	"      The number of vCores.\n"
	"    -CpuGenerations: array string\n"
	"      The processor generations (for example, `v4`).\n"
	"    -CpuPerformances: array string\n"
	"      The performances of the VMs.\n"
	"    -Descriptions: array string\n"
	"      The descriptions of the VM templates.\n"
	"    -ImageIds: array string\n"
	"      The IDs of the OMIs.\n"
	"    -KeypairNames: array string\n"
	"      The names of the keypairs.\n"
	"    -Rams: array integer\n"
	"      The amount of RAM.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the VM templates.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the VM templates.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the VM \n"
	"      templates, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -VmTemplateIds: array string\n"
	"      The IDs of the VM templates.\n"
	"    -VmTemplateNames: array string\n"
	"      The names of the VM templates.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersVmGroup\n"
	"    One or more filters.\n"
	"    -Descriptions: array string\n"
	"      The descriptions of the VM groups.\n"
	"    -SecurityGroupIds: array string\n"
	"      The IDs of the security groups.\n"
	"    -SubnetIds: array string\n"
	"      The IDs of the Subnets.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the VM groups.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the VM groups.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the VMs, \n"
	"      in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -VmCounts: array integer\n"
	"      The number of VMs in the VM group.\n"
	"    -VmGroupIds: array string\n"
	"      The IDs of the VM groups.\n"
	"    -VmGroupNames: array string\n"
	"      The names of the VM groups.\n"
	"    -VmTemplateIds: array string\n"
	"      The IDs of the VM templates.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersVirtualGateway\n"
	"    One or more filters.\n"
	"    -ConnectionTypes: array string\n"
	"      The types of the virtual gateways (only `ipsec.1` is \n"
	"      supported).\n"
	"    -LinkNetIds: array string\n"
	"      The IDs of the Nets the virtual gateways are attached to.\n"
	"    -LinkStates: array string\n"
	"      The current states of the attachments between the virtual \n"
	"      gateways and the Nets (`attaching` \\| `attached` \\| \n"
	"      `detaching` \\| `detached`).\n"
	"    -States: array string\n"
	"      The states of the virtual gateways (`pending` \\| `available` \n"
	"      \\| `deleting` \\| `deleted`).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the virtual gateways.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the virtual gateways.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      virtual gateways, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -VirtualGatewayIds: array string\n"
	"      The IDs of the virtual gateways.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersTag\n"
	"    One or more filters.\n"
	"    -Keys: array string\n"
	"      The keys of the tags that are assigned to the resources. You \n"
	"      can use this filter alongside the `Values` filter. In that \n"
	"      case, you filter the resources corresponding to each tag, \n"
	"      regardless of the other filter.\n"
	"    -ResourceIds: array string\n"
	"      The IDs of the resources with which the tags are associated.\n"
	"    -ResourceTypes: array string\n"
	"      The resource type (`vm` \\| `image` \\| `volume` \\| \n"
	"      `snapshot` \\| `public-ip` \\| `security-group` \\| \n"
	"      `route-table` \\| `nic` \\| `net` \\| `subnet` \\| \n"
	"      `net-peering` \\| `net-access-point` \\| `nat-service` \\| \n"
	"      `internet-service` \\| `client-gateway` \\| `virtual-gateway` \n"
	"      \\| `vpn-connection` \\| `dhcp-options` \\| `task`).\n"
	"    -Values: array string\n"
	"      The values of the tags that are assigned to the resources. You \n"
	"      can use this filter alongside the `TagKeys` filter. In that \n"
	"      case, you filter the resources corresponding to each tag, \n"
	"      regardless of the other filter.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersSubregion\n"
	"    One or more filters.\n"
	"    -RegionNames: array string\n"
	"      The names of the Regions containing the Subregions.\n"
	"    -States: array string\n"
	"      The states of the Subregions.\n"
	"    -SubregionNames: array string\n"
	"      The names of the Subregions.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersSubnet\n"
	"    One or more filters.\n"
	"    -AvailableIpsCounts: array integer\n"
	"      The number of available IPs.\n"
	"    -IpRanges: array string\n"
	"      The IP ranges in the Subnets, in CIDR notation (for example, \n"
	"      `10.0.0.0/16`).\n"
	"    -NetIds: array string\n"
	"      The IDs of the Nets in which the Subnets are.\n"
	"    -States: array string\n"
	"      The states of the Subnets (`pending` \\| `available` \\| \n"
	"      `deleted`).\n"
	"    -SubnetIds: array string\n"
	"      The IDs of the Subnets.\n"
	"    -SubregionNames: array string\n"
	"      The names of the Subregions in which the Subnets are located.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the Subnets.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the Subnets.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      Subnets, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersSnapshot\n"
	"    One or more filters.\n"
	"    -AccountAliases: array string\n"
	"      The account aliases of the owners of the snapshots.\n"
	"    -AccountIds: array string\n"
	"      The account IDs of the owners of the snapshots.\n"
	"    -Descriptions: array string\n"
	"      The descriptions of the snapshots.\n"
	"    -FromCreationDate: string\n"
	"      The beginning of the time period, in ISO 8601 date-time format \n"
	"      (for example, `2020-06-14T00:00:00.000Z`).\n"
	"    -PermissionsToCreateVolumeAccountIds: array string\n"
	"      The account IDs which have permissions to create volumes.\n"
	"    -PermissionsToCreateVolumeGlobalPermission: bool\n"
	"      If true, lists all public volumes. If false, lists all private \n"
	"      volumes.\n"
	"    -Progresses: array integer\n"
	"      The progresses of the snapshots, as a percentage.\n"
	"    -SnapshotIds: array string\n"
	"      The IDs of the snapshots.\n"
	"    -States: array string\n"
	"      The states of the snapshots (`in-queue` \\| `completed` \\| \n"
	"      `error`).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the snapshots.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the snapshots.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      snapshots, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -ToCreationDate: string\n"
	"      The end of the time period, in ISO 8601 date-time format (for \n"
	"      example, `2020-06-30T00:00:00.000Z`).\n"
	"    -VolumeIds: array string\n"
	"      The IDs of the volumes used to create the snapshots.\n"
	"    -VolumeSizes: array integer\n"
	"      The sizes of the volumes used to create the snapshots, in \n"
	"      gibibytes (GiB).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersExportTask\n"
	"    One or more filters.\n"
	"    -TaskIds: array string\n"
	"      The IDs of the export tasks.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersServerCertificate\n"
	"    One or more filters.\n"
	"    -Paths: array string\n"
	"      The paths to the server certificates.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersSecurityGroup\n"
	"    One or more filters.\n"
	"    -Descriptions: array string\n"
	"      The descriptions of the security groups.\n"
	"    -InboundRuleAccountIds: array string\n"
	"      The account IDs that have been granted permissions.\n"
	"    -InboundRuleFromPortRanges: array integer\n"
	"      The beginnings of the port ranges for the TCP and UDP \n"
	"      protocols, or the ICMP type numbers.\n"
	"    -InboundRuleIpRanges: array string\n"
	"      The IP ranges that have been granted permissions, in CIDR \n"
	"      notation (for example, `10.0.0.0/24`).\n"
	"    -InboundRuleProtocols: array string\n"
	"      The IP protocols for the permissions (`tcp` \\| `udp` \\| \n"
	"      `icmp`, or a protocol number, or `-1` for all protocols).\n"
	"    -InboundRuleSecurityGroupIds: array string\n"
	"      The IDs of the security groups that have been granted \n"
	"      permissions.\n"
	"    -InboundRuleSecurityGroupNames: array string\n"
	"      The names of the security groups that have been granted \n"
	"      permissions.\n"
	"    -InboundRuleToPortRanges: array integer\n"
	"      The ends of the port ranges for the TCP and UDP protocols, or \n"
	"      the ICMP code numbers.\n"
	"    -NetIds: array string\n"
	"      The IDs of the Nets specified when the security groups were \n"
	"      created.\n"
	"    -OutboundRuleAccountIds: array string\n"
	"      The account IDs that have been granted permissions.\n"
	"    -OutboundRuleFromPortRanges: array integer\n"
	"      The beginnings of the port ranges for the TCP and UDP \n"
	"      protocols, or the ICMP type numbers.\n"
	"    -OutboundRuleIpRanges: array string\n"
	"      The IP ranges that have been granted permissions, in CIDR \n"
	"      notation (for example, `10.0.0.0/24`).\n"
	"    -OutboundRuleProtocols: array string\n"
	"      The IP protocols for the permissions (`tcp` \\| `udp` \\| \n"
	"      `icmp`, or a protocol number, or `-1` for all protocols).\n"
	"    -OutboundRuleSecurityGroupIds: array string\n"
	"      The IDs of the security groups that have been granted \n"
	"      permissions.\n"
	"    -OutboundRuleSecurityGroupNames: array string\n"
	"      The names of the security groups that have been granted \n"
	"      permissions.\n"
	"    -OutboundRuleToPortRanges: array integer\n"
	"      The ends of the port ranges for the TCP and UDP protocols, or \n"
	"      the ICMP code numbers.\n"
	"    -SecurityGroupIds: array string\n"
	"      The IDs of the security groups.\n"
	"    -SecurityGroupNames: array string\n"
	"      The names of the security groups.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the security groups.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the security groups.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      security groups, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
,
	"AccessKeyId: string\n"
	"  The ID of the access key.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersRouteTable\n"
	"    One or more filters.\n"
	"    -LinkRouteTableIds: array string\n"
	"      The IDs of the route tables involved in the associations.\n"
	"    -LinkRouteTableLinkRouteTableIds: array string\n"
	"      The IDs of the associations between the route tables and the \n"
	"      Subnets.\n"
	"    -LinkRouteTableMain: bool\n"
	"      If true, the route tables are the main ones for their Nets.\n"
	"    -LinkSubnetIds: array string\n"
	"      The IDs of the Subnets involved in the associations.\n"
	"    -NetIds: array string\n"
	"      The IDs of the Nets for the route tables.\n"
	"    -RouteCreationMethods: array string\n"
	"      The methods used to create a route.\n"
	"    -RouteDestinationIpRanges: array string\n"
	"      The IP ranges specified in routes in the tables.\n"
	"    -RouteDestinationServiceIds: array string\n"
	"      The service IDs specified in routes in the tables.\n"
	"    -RouteGatewayIds: array string\n"
	"      The IDs of the gateways specified in routes in the tables.\n"
	"    -RouteNatServiceIds: array string\n"
	"      The IDs of the NAT services specified in routes in the tables.\n"
	"    -RouteNetPeeringIds: array string\n"
	"      The IDs of the Net peerings specified in routes in the tables.\n"
	"    -RouteStates: array string\n"
	"      The states of routes in the route tables (always `active`).\n"
	"    -RouteTableIds: array string\n"
	"      The IDs of the route tables.\n"
	"    -RouteVmIds: array string\n"
	"      The IDs of the VMs specified in routes in the tables.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the route tables.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the route tables.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      route tables, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersQuota\n"
	"    One or more filters.\n"
	"    -Collections: array string\n"
	"      The group names of the quotas.\n"
	"    -QuotaNames: array string\n"
	"      The names of the quotas.\n"
	"    -QuotaTypes: array string\n"
	"      The resource IDs if these are resource-specific quotas, \n"
	"      `global` if they are not.\n"
	"    -ShortDescriptions: array string\n"
	"      The description of the quotas.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersPublicIp\n"
	"    One or more filters.\n"
	"    -LinkPublicIpIds: array string\n"
	"      The IDs representing the associations of public IPs with VMs \n"
	"      or NICs.\n"
	"    -NicAccountIds: array string\n"
	"      The account IDs of the owners of the NICs.\n"
	"    -NicIds: array string\n"
	"      The IDs of the NICs.\n"
	"    -Placements: array string\n"
	"      Whether the public IPs are for use in the public Cloud or in a \n"
	"      Net.\n"
	"    -PrivateIps: array string\n"
	"      The private IPs associated with the public IPs.\n"
	"    -PublicIpIds: array string\n"
	"      The IDs of the public IPs.\n"
	"    -PublicIps: array string\n"
	"      The public IPs.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the public IPs.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the public IPs.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      public IPs, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -VmIds: array string\n"
	"      The IDs of the VMs.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersProductType\n"
	"    One or more filters.\n"
	"    -ProductTypeIds: array string\n"
	"      The IDs of the product types.\n"
,
	"FirstItem: int\n"
	"  The item starting the list of policies requested.\n"
"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
"ResultsPerPage: int\n"
	"  The maximum number of items that can be returned in a single response \n"
	"  (by default, 100).\n"
,
	"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
"VersionId: string\n"
	"  The ID of the policy version.\n"
,
	"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref ReadPoliciesFilters\n"
	"    One or more filters.\n"
	"    -OnlyLinked: bool\n"
	"      If set to true, lists only the policies attached to a user.\n"
	"    -PathPrefix: string\n"
	"      The path prefix you can use to filter the results, set to a \n"
	"      slash (`/`) by default.\n"
	"    -Scope: string\n"
	"      The scope to filter policies (`OWS` \\| `LOCAL`).\n"
"FirstItem: int\n"
	"  The item starting the list of policies requested.\n"
"ResultsPerPage: int\n"
	"  The maximum number of items that can be returned in a single response \n"
	"  (by default, 100).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersNic\n"
	"    One or more filters.\n"
	"    -Descriptions: array string\n"
	"      The descriptions of the NICs.\n"
	"    -IsSourceDestCheck: bool\n"
	"      Whether the source/destination checking is enabled (true) or \n"
	"      disabled (false).\n"
	"    -LinkNicDeleteOnVmDeletion: bool\n"
	"      Whether the NICs are deleted when the VMs they are attached to \n"
	"      are terminated.\n"
	"    -LinkNicDeviceNumbers: array integer\n"
	"      The device numbers the NICs are attached to.\n"
	"    -LinkNicLinkNicIds: array string\n"
	"      The attachment IDs of the NICs.\n"
	"    -LinkNicStates: array string\n"
	"      The states of the attachments.\n"
	"    -LinkNicVmAccountIds: array string\n"
	"      The account IDs of the owners of the VMs the NICs are attached \n"
	"      to.\n"
	"    -LinkNicVmIds: array string\n"
	"      The IDs of the VMs the NICs are attached to.\n"
	"    -LinkPublicIpAccountIds: array string\n"
	"      The account IDs of the owners of the public IPs associated \n"
	"      with the NICs.\n"
	"    -LinkPublicIpLinkPublicIpIds: array string\n"
	"      The association IDs returned when the public IPs were \n"
	"      associated with the NICs.\n"
	"    -LinkPublicIpPublicIpIds: array string\n"
	"      The allocation IDs returned when the public IPs were allocated \n"
	"      to their accounts.\n"
	"    -LinkPublicIpPublicIps: array string\n"
	"      The public IPs associated with the NICs.\n"
	"    -MacAddresses: array string\n"
	"      The Media Access Control (MAC) addresses of the NICs.\n"
	"    -NetIds: array string\n"
	"      The IDs of the Nets where the NICs are located.\n"
	"    -NicIds: array string\n"
	"      The IDs of the NICs.\n"
	"    -PrivateDnsNames: array string\n"
	"      The private DNS names associated with the primary private IPs.\n"
	"    -PrivateIpsLinkPublicIpAccountIds: array string\n"
	"      The account IDs of the owner of the public IPs associated with \n"
	"      the private IPs.\n"
	"    -PrivateIpsLinkPublicIpPublicIps: array string\n"
	"      The public IPs associated with the private IPs.\n"
	"    -PrivateIpsPrimaryIp: bool\n"
	"      Whether the private IP is the primary IP associated with the \n"
	"      NIC.\n"
	"    -PrivateIpsPrivateIps: array string\n"
	"      The private IPs of the NICs.\n"
	"    -SecurityGroupIds: array string\n"
	"      The IDs of the security groups associated with the NICs.\n"
	"    -SecurityGroupNames: array string\n"
	"      The names of the security groups associated with the NICs.\n"
	"    -States: array string\n"
	"      The states of the NICs.\n"
	"    -SubnetIds: array string\n"
	"      The IDs of the Subnets for the NICs.\n"
	"    -SubregionNames: array string\n"
	"      The Subregions where the NICs are located.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the NICs.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the NICs.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      NICs, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersNet\n"
	"    One or more filters.\n"
	"    -DhcpOptionsSetIds: array string\n"
	"      The IDs of the DHCP options sets.\n"
	"    -IpRanges: array string\n"
	"      The IP ranges for the Nets, in CIDR notation (for example, \n"
	"      `10.0.0.0/16`).\n"
	"    -IsDefault: bool\n"
	"      If true, the Net used is the default one.\n"
	"    -NetIds: array string\n"
	"      The IDs of the Nets.\n"
	"    -States: array string\n"
	"      The states of the Nets (`pending` \\| `available` \\| \n"
	"      `deleting`).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the Nets.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the Nets.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      Nets, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersNetPeering\n"
	"    One or more filters.\n"
	"    -AccepterNetAccountIds: array string\n"
	"      The account IDs of the owners of the peer Nets.\n"
	"    -AccepterNetIpRanges: array string\n"
	"      The IP ranges of the peer Nets, in CIDR notation (for example, \n"
	"      `10.0.0.0/24`).\n"
	"    -AccepterNetNetIds: array string\n"
	"      The IDs of the peer Nets.\n"
	"    -ExpirationDates: array string\n"
	"      The dates and times at which the Net peerings expire, in ISO \n"
	"      8601 date-time format (for example, \n"
	"      `2020-06-14T00:00:00.000Z`).\n"
	"    -NetPeeringIds: array string\n"
	"      The IDs of the Net peerings.\n"
	"    -SourceNetAccountIds: array string\n"
	"      The account IDs of the owners of the peer Nets.\n"
	"    -SourceNetIpRanges: array string\n"
	"      The IP ranges of the peer Nets.\n"
	"    -SourceNetNetIds: array string\n"
	"      The IDs of the peer Nets.\n"
	"    -StateMessages: array string\n"
	"      Additional information about the states of the Net peerings.\n"
	"    -StateNames: array string\n"
	"      The states of the Net peerings (`pending-acceptance` \\| \n"
	"      `active` \\| `rejected` \\| `failed` \\| `expired` \\| \n"
	"      `deleted`).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the Net peerings.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the Net peerings.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the Net \n"
	"      peerings, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersNetAccessPoint\n"
	"    One or more filters.\n"
	"    -NetAccessPointIds: array string\n"
	"      The IDs of the Net access points.\n"
	"    -NetIds: array string\n"
	"      The IDs of the Nets.\n"
	"    -ServiceNames: array string\n"
	"      The names of the services. For more information, see \n"
	"      [ReadNetAccessPointServices](#readnetaccesspointservices).\n"
	"    -States: array string\n"
	"      The states of the Net access points (`pending` \\| `available` \n"
	"      \\| `deleting` \\| `deleted`).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the Net access points.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the Net access points.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the Net \n"
	"      access points, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersService\n"
	"    One or more filters.\n"
	"    -ServiceIds: array string\n"
	"      The IDs of the services.\n"
	"    -ServiceNames: array string\n"
	"      The names of the services.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersNatService\n"
	"    One or more filters.\n"
	"    -NatServiceIds: array string\n"
	"      The IDs of the NAT services.\n"
	"    -NetIds: array string\n"
	"      The IDs of the Nets in which the NAT services are.\n"
	"    -States: array string\n"
	"      The states of the NAT services (`pending` \\| `available` \\| \n"
	"      `deleting` \\| `deleted`).\n"
	"    -SubnetIds: array string\n"
	"      The IDs of the Subnets in which the NAT services are.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the NAT services.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the NAT services.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the NAT \n"
	"      services, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersLoadBalancer\n"
	"    One or more filters.\n"
	"    -LoadBalancerNames: array string\n"
	"      The names of the load balancers.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerNames: array string\n"
	"  One or more load balancer names.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersListenerRule\n"
	"    One or more filters.\n"
	"    -ListenerRuleNames: array string\n"
	"      The names of the listener rules.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref ReadLinkedPoliciesFilters\n"
	"    One or more filters.\n"
	"    -PathPrefix: string\n"
	"      The path prefix of the policies, set to a slash (`/`) by \n"
	"      default.\n"
"FirstItem: int\n"
	"  The item starting the list of policies requested.\n"
"ResultsPerPage: int\n"
	"  The maximum number of items that can be returned in a single response \n"
	"  (by default, 100).\n"
"UserName: string\n"
	"  The name of the user the policies are linked to.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersKeypair\n"
	"    One or more filters.\n"
	"    -KeypairFingerprints: array string\n"
	"      The fingerprints of the keypairs.\n"
	"    -KeypairNames: array string\n"
	"      The names of the keypairs.\n"
	"    -KeypairTypes: array string\n"
	"      The types of the keypairs (`ssh-rsa`, `ssh-ed25519`, \n"
	"      `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or \n"
	"      `ecdsa-sha2-nistp521`).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersInternetService\n"
	"    One or more filters.\n"
	"    -InternetServiceIds: array string\n"
	"      The IDs of the Internet services.\n"
	"    -LinkNetIds: array string\n"
	"      The IDs of the Nets the Internet services are attached to.\n"
	"    -LinkStates: array string\n"
	"      The current states of the attachments between the Internet \n"
	"      services and the Nets (only `available`, if the Internet \n"
	"      gateway is attached to a Net).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the Internet services.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the Internet services.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      Internet services, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersImage\n"
	"    One or more filters.\n"
	"    -AccountAliases: array string\n"
	"      The account aliases of the owners of the OMIs.\n"
	"    -AccountIds: array string\n"
	"      The account IDs of the owners of the OMIs. By default, all the \n"
	"      OMIs for which you have launch permissions are described.\n"
	"    -Architectures: array string\n"
	"      The architectures of the OMIs (`i386` \\| `x86_64`).\n"
	"    -BlockDeviceMappingDeleteOnVmDeletion: bool\n"
	"      Whether the volumes are deleted or not when terminating the \n"
	"      VM.\n"
	"    -BlockDeviceMappingDeviceNames: array string\n"
	"      The device names for the volumes.\n"
	"    -BlockDeviceMappingSnapshotIds: array string\n"
	"      The IDs of the snapshots used to create the volumes.\n"
	"    -BlockDeviceMappingVolumeSizes: array integer\n"
	"      The sizes of the volumes, in gibibytes (GiB).\n"
	"    -BlockDeviceMappingVolumeTypes: array string\n"
	"      The types of volumes (`standard` \\| `gp2` \\| `io1`).\n"
	"    -Descriptions: array string\n"
	"      The descriptions of the OMIs, provided when they were created.\n"
	"    -FileLocations: array string\n"
	"      The locations of the buckets where the OMI files are stored.\n"
	"    -Hypervisors: array string\n"
	"      The hypervisor type of the OMI (always `xen`).\n"
	"    -ImageIds: array string\n"
	"      The IDs of the OMIs.\n"
	"    -ImageNames: array string\n"
	"      The names of the OMIs, provided when they were created.\n"
	"    -PermissionsToLaunchAccountIds: array string\n"
	"      The account IDs which have launch permissions for the OMIs.\n"
	"    -PermissionsToLaunchGlobalPermission: bool\n"
	"      If true, lists all public OMIs. If false, lists all private \n"
	"      OMIs.\n"
	"    -ProductCodeNames: array string\n"
	"      The names of the product codes associated with the OMI.\n"
	"    -ProductCodes: array string\n"
	"      The product codes associated with the OMI.\n"
	"    -RootDeviceNames: array string\n"
	"      The name of the root device. This value must be /dev/sda1.\n"
	"    -RootDeviceTypes: array string\n"
	"      The types of root device used by the OMIs (`bsu` or `ebs`).\n"
	"    -States: array string\n"
	"      The states of the OMIs (`pending` \\| `available` \\| \n"
	"      `failed`).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the OMIs.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the OMIs.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      OMIs, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
	"    -VirtualizationTypes: array string\n"
	"      The virtualization types (always `hvm`).\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersExportTask\n"
	"    One or more filters.\n"
	"    -TaskIds: array string\n"
	"      The IDs of the export tasks.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersFlexibleGpu\n"
	"    One or more filters.\n"
	"    -DeleteOnVmDeletion: bool\n"
	"      Indicates whether the fGPU is deleted when terminating the VM.\n"
	"    -FlexibleGpuIds: array string\n"
	"      One or more IDs of fGPUs.\n"
	"    -Generations: array string\n"
	"      The processor generations that the fGPUs are compatible with.\n"
	"    -ModelNames: array string\n"
	"      One or more models of fGPUs. For more information, see [About \n"
	"      Flexible \n"
	"      GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs\n"
	"      .html).\n"
	"    -States: array string\n"
	"      The states of the fGPUs (`allocated` \\| `attaching` \\| \n"
	"      `attached` \\| `detaching`).\n"
	"    -SubregionNames: array string\n"
	"      The Subregions where the fGPUs are located.\n"
	"    -VmIds: array string\n"
	"      One or more IDs of VMs.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersDirectLink\n"
	"    One or more filters.\n"
	"    -DirectLinkIds: array string\n"
	"      The IDs of the DirectLinks.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersDirectLinkInterface\n"
	"    One or more filters.\n"
	"    -DirectLinkIds: array string\n"
	"      The IDs of the DirectLinks.\n"
	"    -DirectLinkInterfaceIds: array string\n"
	"      The IDs of the DirectLink interfaces.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersDhcpOptions\n"
	"    One or more filters.\n"
	"    -Default: bool\n"
	"      If true, lists all default DHCP options set. If false, lists \n"
	"      all non-default DHCP options set.\n"
	"    -DhcpOptionsSetIds: array string\n"
	"      The IDs of the DHCP options sets.\n"
	"    -DomainNameServers: array string\n"
	"      The IPs of the domain name servers used for the DHCP options \n"
	"      sets.\n"
	"    -DomainNames: array string\n"
	"      The domain names used for the DHCP options sets.\n"
	"    -LogServers: array string\n"
	"      The IPs of the log servers used for the DHCP options sets.\n"
	"    -NtpServers: array string\n"
	"      The IPs of the Network Time Protocol (NTP) servers used for \n"
	"      the DHCP options sets.\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the DHCP options sets.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the DHCP options sets.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the DHCP \n"
	"      options sets, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersDedicatedGroup\n"
	"    One or more filters.\n"
	"    -CpuGenerations: array integer\n"
	"      The processor generation for the VMs in the dedicated group \n"
	"      (for example, `4`).\n"
	"    -DedicatedGroupIds: array string\n"
	"      The IDs of the dedicated groups.\n"
	"    -Names: array string\n"
	"      The names of the dedicated groups.\n"
	"    -SubregionNames: array string\n"
	"      The names of the Subregions in which the dedicated groups are \n"
	"      located.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"FromDate: string\n"
	"  The beginning of the time period, in ISO 8601 date format (for example, \n"
	"  `2020-06-14`). The date-time format is also accepted, but only with a \n"
	"  time set to midnight (for example, `2020-06-14T00:00:00.000Z`).\n"
"Overall: bool\n"
	"  By default or if false, returns only the consumption of the specific \n"
	"  account that sends this request. If true, returns either the overall \n"
	"  consumption of your paying account and all linked accounts (if the \n"
	"  account that sends this request is a paying account) or returns nothing \n"
	"  (if the account that sends this request is a linked account).\n"
"ShowPrice: bool\n"
	"  If true, the response also includes the unit price of the consumed \n"
	"  resource (`UnitPrice`) and the total price of the consumed resource \n"
	"  during the specified time period (`Price`), in the currency of the \n"
	"  Region's catalog.\n"
"ToDate: string\n"
	"  The end of the time period, in ISO 8601 date format (for example, \n"
	"  `2020-06-30`). The date-time format is also accepted, but only with a \n"
	"  time set to midnight (for example, `2020-06-30T00:00:00.000Z`).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmId: string\n"
	"  The ID of the VM.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersClientGateway\n"
	"    One or more filters.\n"
	"    -BgpAsns: array integer\n"
	"      The Border Gateway Protocol (BGP) Autonomous System Numbers \n"
	"      (ASNs) of the connections.\n"
	"    -ClientGatewayIds: array string\n"
	"      The IDs of the client gateways.\n"
	"    -ConnectionTypes: array string\n"
	"      The types of communication tunnels used by the client gateways \n"
	"      (only `ipsec.1` is supported).\n"
	"    -PublicIps: array string\n"
	"      The public IPv4 addresses of the client gateways.\n"
	"    -States: array string\n"
	"      The states of the client gateways (`pending` \\| `available` \n"
	"      \\| `deleting` \\| `deleted`).\n"
	"    -TagKeys: array string\n"
	"      The keys of the tags associated with the client gateways.\n"
	"    -TagValues: array string\n"
	"      The values of the tags associated with the client gateways.\n"
	"    -Tags: array string\n"
	"      The key/value combination of the tags associated with the \n"
	"      client gateways, in the following format: \n"
	"      \"Filters\":{\"Tags\":[\"TAGKEY=TAGVALUE&quo\n"
	"      t;]}.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersCatalogs\n"
	"    One or more filters.\n"
	"    -CurrentCatalogOnly: bool\n"
	"      By default or if set to true, only returns the current \n"
	"      catalog. If false, returns the current catalog and past \n"
	"      catalogs.\n"
	"    -FromDate: string\n"
	"      The beginning of the time period, in ISO 8601 date format (for \n"
	"      example, `2020-06-14`). This date cannot be older than 3 years. \n"
	"      You must specify the parameters `FromDate` and `ToDate` \n"
	"      together.\n"
	"    -ToDate: string\n"
	"      The end of the time period, in ISO 8601 date format (for \n"
	"      example, `2020-06-30`). You must specify the parameters \n"
	"      `FromDate` and `ToDate` together.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersCa\n"
	"    One or more filters.\n"
	"    -CaFingerprints: array string\n"
	"      The fingerprints of the CAs.\n"
	"    -CaIds: array string\n"
	"      The IDs of the CAs.\n"
	"    -Descriptions: array string\n"
	"      The descriptions of the CAs.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersApiLog\n"
	"    One or more filters.\n"
	"    -QueryAccessKeys: array string\n"
	"      The access keys used for the logged calls.\n"
	"    -QueryApiNames: array string\n"
	"      The names of the APIs of the logged calls (always `oapi` for \n"
	"      the OUTSCALE API).\n"
	"    -QueryCallNames: array string\n"
	"      The names of the logged calls.\n"
	"    -QueryDateAfter: string\n"
	"      The date and time, or the date, after which you want to \n"
	"      retrieve logged calls, in ISO 8601 format (for example, \n"
	"      `2020-06-14T00:00:00.000Z` or `2020-06-14`). By default, this \n"
	"      date is set to 48 hours before the `QueryDateBefore` parameter \n"
	"      value.\n"
	"    -QueryDateBefore: string\n"
	"      The date and time, or the date, before which you want to \n"
	"      retrieve logged calls, in ISO 8601 format (for example, \n"
	"      `2020-06-30T00:00:00.000Z` or `2020-06-14`). By default, this \n"
	"      date is set to now, or 48 hours after the `QueryDateAfter` \n"
	"      parameter value.\n"
	"    -QueryIpAddresses: array string\n"
	"      The IPs used for the logged calls.\n"
	"    -QueryUserAgents: array string\n"
	"      The user agents of the HTTP requests of the logged calls.\n"
	"    -RequestIds: array string\n"
	"      The request IDs provided in the responses of the logged calls.\n"
	"    -ResponseStatusCodes: array integer\n"
	"      The HTTP status codes of the logged calls.\n"
"NextPageToken: string\n"
	"  The token to request the next page of results. Each token refers to a \n"
	"  specific page.\n"
"ResultsPerPage: int\n"
	"  The maximum number of logs returned in a single response (between \n"
	"  `1`and `1000`, both included). By default, `100`.\n"
"With: ref With\n"
	"    The information to display in each returned log.\n"
	"    -AccountId: bool\n"
	"      By default or if set to true, the account ID is displayed.\n"
	"    -CallDuration: bool\n"
	"      By default or if set to true, the duration of the call is \n"
	"      displayed.\n"
	"    -QueryAccessKey: bool\n"
	"      By default or if set to true, the access key is displayed.\n"
	"    -QueryApiName: bool\n"
	"      By default or if set to true, the name of the API is \n"
	"      displayed.\n"
	"    -QueryApiVersion: bool\n"
	"      By default or if set to true, the version of the API is \n"
	"      displayed.\n"
	"    -QueryCallName: bool\n"
	"      By default or if set to true, the name of the call is \n"
	"      displayed.\n"
	"    -QueryDate: bool\n"
	"      By default or if set to true, the date of the call is \n"
	"      displayed.\n"
	"    -QueryHeaderRaw: bool\n"
	"      By default or if set to true, the raw header of the HTTP \n"
	"      request is displayed.\n"
	"    -QueryHeaderSize: bool\n"
	"      By default or if set to true, the size of the raw header of \n"
	"      the HTTP request is displayed.\n"
	"    -QueryIpAddress: bool\n"
	"      By default or if set to true, the IP is displayed.\n"
	"    -QueryPayloadRaw: bool\n"
	"      By default or if set to true, the raw payload of the HTTP \n"
	"      request is displayed.\n"
	"    -QueryPayloadSize: bool\n"
	"      By default or if set to true, the size of the raw payload of \n"
	"      the HTTP request is displayed.\n"
	"    -QueryUserAgent: bool\n"
	"      By default or if set to true, the user agent of the HTTP \n"
	"      request is displayed.\n"
	"    -RequestId: bool\n"
	"      By default or if set to true, the request ID is displayed.\n"
	"    -ResponseSize: bool\n"
	"      By default or if set to true, the size of the response is \n"
	"      displayed.\n"
	"    -ResponseStatusCode: bool\n"
	"      By default or if set to true, the HTTP status code of the \n"
	"      response is displayed.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersApiAccessRule\n"
	"    One or more filters.\n"
	"    -ApiAccessRuleIds: array string\n"
	"      One or more IDs of API access rules.\n"
	"    -CaIds: array string\n"
	"      One or more IDs of Client Certificate Authorities (CAs).\n"
	"    -Cns: array string\n"
	"      One or more Client Certificate Common Names (CNs).\n"
	"    -Descriptions: array string\n"
	"      One or more descriptions of API access rules.\n"
	"    -IpRanges: array string\n"
	"      One or more IP addresses or CIDR blocks (for example, \n"
	"      `192.0.2.0/16`).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmId: string\n"
	"  The ID of the VM.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Filters: ref FiltersAccessKeys\n"
	"    One or more filters.\n"
	"    -AccessKeyIds: array string\n"
	"      The IDs of the access keys.\n"
	"    -States: array string\n"
	"      The states of the access keys (`ACTIVE` \\| `INACTIVE`).\n"
"UserName: string\n"
	"  The name of the EIM user. By default, the user who sends the request \n"
	"  (which can be the root account).\n"
,
	"DeviceName: string\n"
	"  The name of the device. For a root device, you must use `/dev/sda1`. \n"
	"  For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, \n"
	"  or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, \n"
	"  and the second `X` is a letter between `a` and `z`).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmId: string\n"
	"  The ID of the VM you want to attach the volume to.\n"
"VolumeId: string\n"
	"  The ID of the volume you want to attach.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetId: string\n"
	"  The ID of the Net to which you want to attach the virtual gateway.\n"
"VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"RouteTableId: string\n"
	"  The ID of the route table.\n"
"SubnetId: string\n"
	"  The ID of the Subnet.\n"
,
	"AllowRelink: bool\n"
	"  If true, allows the public IP to be associated with the VM or NIC that \n"
	"  you specify even if it is already associated with another VM or NIC. If \n"
	"  false, prevents the public IP from being associated with the VM or NIC \n"
	"  that you specify if it is already associated with another VM or NIC. \n"
	"  (By default, true in the public Cloud, false in a Net.)\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NicId: string\n"
	"  (Net only) The ID of the NIC. This parameter is required if the VM has \n"
	"  more than one NIC attached. Otherwise, you need to specify the `VmId` \n"
	"  parameter instead. You cannot specify both parameters at the same time.\n"
"PrivateIp: string\n"
	"  (Net only) The primary or secondary private IP of the specified NIC. By \n"
	"  default, the primary private IP.\n"
"PublicIp: string\n"
	"  The public IP. This parameter is required unless you use the \n"
	"  `PublicIpId` parameter.\n"
"PublicIpId: string\n"
	"  The allocation ID of the public IP. This parameter is required unless \n"
	"  you use the `PublicIp` parameter.\n"
"VmId: string\n"
	"  The ID of the VM.\n- In the public Cloud, this parameter is \n"
	"  required.\n- In a Net, this parameter is required if the VM has only \n"
	"  one NIC. Otherwise, you need to specify the `NicId` parameter instead. \n"
	"  You cannot specify both parameters at the same time.\n"
,
	"AllowRelink: bool\n"
	"  If true, allows an IP that is already assigned to another NIC in the \n"
	"  same Subnet to be assigned to the NIC you specified.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NicId: string\n"
	"  The ID of the NIC.\n"
"PrivateIps: array string\n"
	"  The secondary private IP or IPs you want to assign to the NIC within \n"
	"  the IP range of the Subnet.\n"
"SecondaryPrivateIpCount: int\n"
	"  The number of secondary private IPs to assign to the NIC.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
"UserName: string\n"
	"  The name of the user you want to link the policy to (between 1 and 64 \n"
	"  characters).\n"
,
	"DeviceNumber: int\n"
	"  The index of the VM device for the NIC attachment (between `1` and `7`, \n"
	"  both included).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NicId: string\n"
	"  The ID of the NIC you want to attach.\n"
"VmId: string\n"
	"  The ID of the VM to which you want to attach the NIC.\n"
,
	"BackendIps: array string\n"
	"   One or more public IPs of back-end VMs.\n"
"BackendVmIds: array string\n"
	"   One or more IDs of back-end VMs.\n"
"DryRun: bool\n"
	"   If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"   The name of the load balancer. \n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"InternetServiceId: string\n"
	"  The ID of the Internet service you want to attach.\n"
"NetId: string\n"
	"  The ID of the Net to which you want to attach the Internet service.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"FlexibleGpuId: string\n"
	"  The ID of the fGPU you want to attach.\n"
"VmId: string\n"
	"  The ID of the VM you want to attach the fGPU to.\n"
,
	"BackendVmIds: array string\n"
	"  One or more IDs of back-end VMs.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer.\n"
,
	"DestinationIpRange: string\n"
	"  The network prefix of the route to delete, in CIDR notation (for \n"
	"  example, `10.12.0.0/16`).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VpnConnectionId: string\n"
	"  The ID of the target VPN connection of the static route to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VpnConnectionId: string\n"
	"  The ID of the VPN connection you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VolumeId: string\n"
	"  The ID of the volume you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmIds: array string\n"
	"  One or more IDs of VMs.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmTemplateId: string\n"
	"  The ID of the VM template you want to delete. \n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VmGroupId: string\n"
	"  The ID of the VM group you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VirtualGatewayId: string\n"
	"  The ID of the virtual gateway you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"UserName: string\n"
	"  The name of the EIM user you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ResourceIds: array string\n"
	"  One or more resource IDs.\n"
"Tags: array ref ResourceTag\n"
	"  One or more tags to delete (if you set a tag value, only the tags \n"
	"  matching exactly this value are deleted).\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    -Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"SubnetId: string\n"
	"  The ID of the Subnet you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"SnapshotId: string\n"
	"  The ID of the snapshot you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Name: string\n"
	"  The name of the server certificate you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Flow: string\n"
	"  The direction of the flow: `Inbound` or `Outbound`. You can specify \n"
	"  `Outbound` for Nets only.\n"
"FromPortRange: int\n"
	"  The beginning of the port range for the TCP and UDP protocols, or an \n"
	"  ICMP type number.\n"
"IpProtocol: string\n"
	"  The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). \n"
	"  By default, `-1`. In a Net, this can also be an IP protocol number. For \n"
	"  more information, see the [IANA.org \n"
	"  website](https://www.iana.org/assignments/protocol-numbers/protocol-numb\n"
	"  ers.xhtml).\n"
"IpRange: string\n"
	"  The IP range for the security group rule, in CIDR notation (for \n"
	"  example, `10.0.0.0/16`).\n"
"Rules: array ref SecurityGroupRule\n"
	"  One or more rules you want to delete from the security group.\n"
	"    Information about the security group rule.\n"
	"    -FromPortRange: int\n"
	"      The beginning of the port range for the TCP and UDP protocols, \n"
	"      or an ICMP type number.\n"
	"    -IpProtocol: string\n"
	"      The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all \n"
	"      protocols). By default, `-1`. In a Net, this can also be an IP \n"
	"      protocol number. For more information, see the [IANA.org \n"
	"      website](https://www.iana.org/assignments/protocol-numbers/proto\n"
	"      col-numbers.xhtml).\n"
	"    -IpRanges: array string\n"
	"      One or more IP ranges for the security group rules, in CIDR \n"
	"      notation (for example, `10.0.0.0/16`).\n"
	"    -SecurityGroupsMembers: array ref SecurityGroupsMember\n"
	"      Information about one or more source or destination security \n"
	"      groups.\n"
	"        Information about a source or destination security group.\n"
	"        -AccountId: string\n"
	"          The account ID that owns the source or destination security \n"
	"          group.\n"
	"        -SecurityGroupId: string\n"
	"          The ID of a source or destination security group that you want \n"
	"          to link to the security group of the rule.\n"
	"        -SecurityGroupName: string\n"
	"          (Public Cloud only) The name of a source or destination \n"
	"          security group that you want to link to the security group of \n"
	"          the rule.\n"
	"    -ServiceIds: array string\n"
	"      One or more service IDs to allow traffic from a Net to access \n"
	"      the corresponding OUTSCALE services. For more information, see \n"
	"      [ReadNetAccessPointServices](#readnetaccesspointservices).\n"
	"    -ToPortRange: int\n"
	"      The end of the port range for the TCP and UDP protocols, or an \n"
	"      ICMP code number.\n"
"SecurityGroupAccountIdToUnlink: string\n"
	"  The account ID of the owner of the security group you want to delete a \n"
	"  rule from.\n"
"SecurityGroupId: string\n"
	"  The ID of the security group you want to delete a rule from.\n"
"SecurityGroupNameToUnlink: string\n"
	"  The ID of the source security group. If you are in the Public Cloud, \n"
	"  you can also specify the name of the source security group.\n"
"ToPortRange: int\n"
	"  The end of the port range for the TCP and UDP protocols, or an ICMP \n"
	"  code number.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"SecurityGroupId: string\n"
	"  The ID of the security group you want to delete.\n"
"SecurityGroupName: string\n"
	"  The name of the security group.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"RouteTableId: string\n"
	"  The ID of the route table you want to delete.\n"
,
	"DestinationIpRange: string\n"
	"  The exact IP range for the route.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"RouteTableId: string\n"
	"  The ID of the route table from which you want to delete a route.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PublicIp: string\n"
	"  The public IP. In the public Cloud, this parameter is required.\n"
"PublicIpId: string\n"
	"  The ID representing the association of the public IP with the VM or the \n"
	"  NIC. In a Net, this parameter is required.\n"
,
	"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
"VersionId: string\n"
	"  The ID of the version of the policy you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy you want to delete. For \n"
	"  more information, see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NicId: string\n"
	"  The ID of the NIC you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetPeeringId: string\n"
	"  The ID of the Net peering you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetAccessPointId: string\n"
	"  The ID of the Net access point.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetId: string\n"
	"  The ID of the Net you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NatServiceId: string\n"
	"  The ID of the NAT service you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerNames: array string\n"
	"  One or more load balancer names.\n"
"Tags: array ref ResourceLoadBalancerTag\n"
	"  One or more tags to delete from the load balancers.\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer for which you want to delete a policy.\n"
"PolicyName: string\n"
	"  The name of the policy you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer for which you want to delete listeners.\n"
"LoadBalancerPorts: array integer\n"
	"  One or more port numbers of the listeners you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ListenerRuleName: string\n"
	"  The name of the rule you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"KeypairName: string\n"
	"  The name of the keypair you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"InternetServiceId: string\n"
	"  The ID of the Internet service you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ImageId: string\n"
	"  The ID of the OMI you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"FlexibleGpuId: string\n"
	"  The ID of the fGPU you want to delete.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ExportTaskId: string\n"
	"  The ID of the export task to delete.\n"
,
	"DirectLinkInterfaceId: string\n"
	"  The ID of the DirectLink interface you want to delete.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DirectLinkId: string\n"
	"  The ID of the DirectLink you want to delete.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DhcpOptionsSetId: string\n"
	"  The ID of the DHCP options set you want to delete.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DedicatedGroupId: string\n"
	"  The ID of the dedicated group you want to delete.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Force: bool\n"
	"  If true, forces the deletion of the dedicated group and all its \n"
	"  dependencies.\n"
,
	"ClientGatewayId: string\n"
	"  The ID of the client gateway you want to delete.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"CaId: string\n"
	"  The ID of the CA you want to delete.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"ApiAccessRuleId: string\n"
	"  The ID of the API access rule you want to delete.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"AccessKeyId: string\n"
	"  The ID of the access key you want to delete.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"UserName: string\n"
	"  The name of the EIM user the access key you want to delete is \n"
	"  associated with. By default, the user who sends the request (which can \n"
	"  be the root account).\n"
,
	"DestinationIpRange: string\n"
	"  The network prefix of the route, in CIDR notation (for example, \n"
	"  `10.12.0.0/16`).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"VpnConnectionId: string\n"
	"  The ID of the target VPN connection of the static route.\n"
,
	"ClientGatewayId: string\n"
	"  The ID of the client gateway.\n"
"ConnectionType: string\n"
	"  The type of VPN connection (only `ipsec.1` is supported).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"StaticRoutesOnly: bool\n"
	"  By default or if false, the VPN connection uses dynamic routing with \n"
	"  Border Gateway Protocol (BGP). If true, routing is controlled using \n"
	"  static routes. For more information about how to create and delete \n"
	"  static routes, see \n"
	"  [CreateVpnConnectionRoute](#createvpnconnectionroute) and \n"
	"  [DeleteVpnConnectionRoute](#deletevpnconnectionroute).\n"
"VirtualGatewayId: string\n"
	"  The ID of the virtual gateway.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Iops: int\n"
	"  The number of I/O operations per second (IOPS). This parameter must be \n"
	"  specified only if you create an `io1` volume. The maximum number of \n"
	"  IOPS allowed for `io1` volumes is `13000` with a maximum performance \n"
	"  ratio of 300 IOPS per gibibyte.\n"
"Size: int\n"
	"  The size of the volume, in gibibytes (GiB). The maximum allowed size \n"
	"  for a volume is 14901 GiB. This parameter is required if the volume is \n"
	"  not created from a snapshot (`SnapshotId` unspecified). \n"
"SnapshotId: string\n"
	"  The ID of the snapshot from which you want to create the volume.\n"
"SubregionName: string\n"
	"  The Subregion in which you want to create the volume.\n"
"VolumeType: string\n"
	"  The type of volume you want to create (`io1` \\| `gp2` \\| `standard`). \n"
	"  If not specified, a `standard` volume is created.\nFor more information \n"
	"  about volume types, see [About Volumes > Volume Types and \n"
	"  IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_\n"
	"  types_and_iops).\n"
,
	"BlockDeviceMappings: array ref BlockDeviceMappingVmCreation\n"
	"  One or more block device mappings.\n"
	"    Information about the block device mapping.\n"
	"    -Bsu: ref BsuToCreate\n"
	"        Information about the BSU volume to create.\n"
	"        -DeleteOnVmDeletion: bool\n"
	"          By default or if set to true, the volume is deleted when \n"
	"          terminating the VM. If false, the volume is not deleted when \n"
	"          terminating the VM.\n"
	"        -Iops: int\n"
	"          The number of I/O operations per second (IOPS). This parameter \n"
	"          must be specified only if you create an `io1` volume. The \n"
	"          maximum number of IOPS allowed for `io1` volumes is `13000` \n"
	"          with a maximum performance ratio of 300 IOPS per gibibyte.\n"
	"        -SnapshotId: string\n"
	"          The ID of the snapshot used to create the volume.\n"
	"        -VolumeSize: int\n"
	"          The size of the volume, in gibibytes (GiB).\nIf you \n"
	"          specify a snapshot ID, the volume size must be at least equal \n"
	"          to the snapshot size.\nIf you specify a snapshot ID but \n"
	"          no volume size, the volume is created with a size similar to \n"
	"          the snapshot one.\n"
	"        -VolumeType: string\n"
	"          The type of the volume (`standard` \\| `io1` \\| `gp2`). If \n"
	"          not specified in the request, a `standard` volume is \n"
	"          created.\nFor more information about volume types, see \n"
	"          [About Volumes > Volume Types and \n"
	"          IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#\n"
	"          _volume_types_and_iops).\n"
	"    -DeviceName: string\n"
	"      The device name for the volume. For a root device, you must \n"
	"      use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, \n"
	"      `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` \n"
	"      is a letter between `b` and `z`, and the second `X` is a letter \n"
	"      between `a` and `z`).\n"
	"    -NoDevice: string\n"
	"      Removes the device which is included in the block device \n"
	"      mapping of the OMI.\n"
	"    -VirtualDeviceName: string\n"
	"      The name of the virtual device (`ephemeralN`).\n"
"BootOnCreation: bool\n"
	"  By default or if true, the VM is started on creation. If false, the VM \n"
	"  is stopped on creation.\n"
"BsuOptimized: bool\n"
	"  This parameter is not available. It is present in our API for the sake \n"
	"  of historical compatibility with AWS.\n"
"ClientToken: string\n"
	"  A unique identifier which enables you to manage the idempotency.\n"
"DeletionProtection: bool\n"
	"  If true, you cannot delete the VM unless you change this parameter back \n"
	"  to false.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ImageId: string\n"
	"  The ID of the OMI used to create the VM. You can find the list of OMIs \n"
	"  by calling the [ReadImages](#readimages) method.\n"
"KeypairName: string\n"
	"  The name of the keypair.\n"
"MaxVmsCount: int\n"
	"  The maximum number of VMs you want to create. If all the VMs cannot be \n"
	"  created, the largest possible number of VMs above MinVmsCount is \n"
	"  created.\n"
"MinVmsCount: int\n"
	"  The minimum number of VMs you want to create. If this number of VMs \n"
	"  cannot be created, no VMs are created.\n"
"NestedVirtualization: bool\n"
	"  (dedicated tenancy only) If true, nested virtualization is enabled. If \n"
	"  false, it is disabled.\n"
"Nics: array ref NicForVmCreation\n"
	"  One or more NICs. If you specify this parameter, you must not specify \n"
	"  the `SubnetId` and `SubregionName` parameters. You also must define one \n"
	"  NIC as the primary network interface of the VM with `0` as its device \n"
	"  number.\n"
	"    Information about the network interface card (NIC) when \n"
	"    creating a virtual machine (VM).\n"
	"    -DeleteOnVmDeletion: bool\n"
	"      If true, the NIC is deleted when the VM is terminated. You can \n"
	"      specify this parameter only for a new NIC. To modify this value \n"
	"      for an existing NIC, see [UpdateNic](#updatenic).\n"
	"    -Description: string\n"
	"      The description of the NIC, if you are creating a NIC when \n"
	"      creating the VM.\n"
	"    -DeviceNumber: int\n"
	"      The index of the VM device for the NIC attachment (between `0` \n"
	"      and `7`, both included). This parameter is required if you \n"
	"      create a NIC when creating the VM.\n"
	"    -NicId: string\n"
	"      The ID of the NIC, if you are attaching an existing NIC when \n"
	"      creating a VM.\n"
	"    -PrivateIps: array ref PrivateIpLight\n"
	"      One or more private IPs to assign to the NIC, if you create a \n"
	"      NIC when creating a VM. Only one private IP can be the primary \n"
	"      private IP.\n"
	"        Information about the private IP.\n"
	"        -IsPrimary: bool\n"
	"          If true, the IP is the primary private IP of the NIC.\n"
	"        -PrivateIp: string\n"
	"          The private IP of the NIC.\n"
	"    -SecondaryPrivateIpCount: int\n"
	"      The number of secondary private IPs, if you create a NIC when \n"
	"      creating a VM. This parameter cannot be specified if you \n"
	"      specified more than one private IP in the `PrivateIps` \n"
	"      parameter.\n"
	"    -SecurityGroupIds: array string\n"
	"      One or more IDs of security groups for the NIC, if you create \n"
	"      a NIC when creating a VM.\n"
	"    -SubnetId: string\n"
	"      The ID of the Subnet for the NIC, if you create a NIC when \n"
	"      creating a VM. This parameter is required if you create a NIC \n"
	"      when creating the VM.\n"
"Performance: string\n"
	"  The performance of the VM (`medium` \\| `high` \\| `highest`). By \n"
	"  default, `high`. This parameter is ignored if you specify a performance \n"
	"  flag directly in the `VmType` parameter.\n"
"Placement: ref Placement\n"
	"    Information about the placement of the VM.\n"
	"    -SubregionName: string\n"
	"      The name of the Subregion. If you specify this parameter, you \n"
	"      must not specify the `Nics` parameter.\n"
	"    -Tenancy: string\n"
	"      The tenancy of the VM (`default`, `dedicated`, or a dedicated \n"
	"      group ID).\n"
"PrivateIps: array string\n"
	"  One or more private IPs of the VM.\n"
"SecurityGroupIds: array string\n"
	"  One or more IDs of security group for the VMs.\n"
"SecurityGroups: array string\n"
	"  One or more names of security groups for the VMs.\n"
"SubnetId: string\n"
	"  The ID of the Subnet in which you want to create the VM. If you specify \n"
	"  this parameter, you must not specify the `Nics` parameter.\n"
"UserData: string\n"
	"  Data or script used to add a specific configuration to the VM. It must \n"
	"  be Base64-encoded and is limited to 500 kibibytes (KiB).\n"
"VmInitiatedShutdownBehavior: string\n"
	"  The VM behavior when you stop it. By default or if set to `stop`, the \n"
	"  VM stops. If set to `restart`, the VM stops then automatically \n"
	"  restarts. If set to `terminate`, the VM stops and is terminated.\n"
"VmType: string\n"
	"  The type of VM. You can specify a TINA type (in the `tinavW.cXrYpZ` or \n"
	"  `tinavW.cXrY` format), or an AWS type (for example, `t2.small`, which \n"
	"  is the default value).\nIf you specify an AWS type, it is converted in \n"
	"  the background to its corresponding TINA type, but the AWS type is \n"
	"  still returned. If the specified or converted TINA type includes a \n"
	"  performance flag, this performance flag is applied regardless of the \n"
	"  value you may have provided in the `Performance` parameter. For more \n"
	"  information, see [VM \n"
	"  Types](https://docs.outscale.com/en/userguide/VM-Types.html).\n"
,
	"CpuCores: int\n"
	"  The number of vCores to use for each VM.\n"
"CpuGeneration: string\n"
	"  The processor generation to use for each VM (for example, `v4`).\n"
"CpuPerformance: string\n"
	"  The performance of the VMs (`medium` \\| `high` \\| `highest`). \n"
"Description: string\n"
	"  A description for the VM template.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ImageId: string\n"
	"  The ID of the OMI to use for each VM. You can find a list of OMIs by \n"
	"  calling the [ReadImages](#readimages) method.\n"
"KeypairName: string\n"
	"  The name of the keypair to use for each VM.\n"
"Ram: int\n"
	"  The amount of RAM to use for each VM.\n"
"Tags: array ref ResourceTag\n"
	"  One or more tags to add to the VM template.\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    -Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
"VmTemplateName: string\n"
	"  The name of the VM template.\n"
,
	"Description: string\n"
	"  A description for the VM group.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PositioningStrategy: string\n"
	"  The positioning strategy of VMs on hypervisors. By default, or if set \n"
	"  to `no-strategy` our orchestrator determines the most adequate position \n"
	"  for your VMs. If set to `attract`, your VMs are deployed on the same \n"
	"  hypervisor, which improves network performance. If set to `repulse`, \n"
	"  your VMs are deployed on a different hypervisor, which improves fault \n"
	"  tolerance.\n"
"SecurityGroupIds: array string\n"
	"  One or more IDs of security groups for the VM group.\n"
"SubnetId: string\n"
	"  The ID of the Subnet in which you want to create the VM group.\n"
"Tags: array ref ResourceTag\n"
	"  One or more tags to add to the VM group.\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    -Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
"VmCount: int\n"
	"  The number of VMs deployed in the VM group.\n"
"VmGroupName: string\n"
	"  The name of the VM group.\n"
"VmTemplateId: string\n"
	"  The ID of the VM template used to launch VMs in the VM group.\n"
,
	"ConnectionType: string\n"
	"  The type of VPN connection supported by the virtual gateway (only \n"
	"  `ipsec.1` is supported).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Path: string\n"
	"  The path to the EIM user you want to create (by default, `/`). This \n"
	"  path name must begin and end with a slash (/), and contain between 1 \n"
	"  and 512 alphanumeric characters and/or slashes (/), or underscores (_).\n"
"UserName: string\n"
	"  The name of the EIM user you want to create. This user name must \n"
	"  contain between 1 and 64 alphanumeric characters and/or pluses (+), \n"
	"  equals (=), commas (,), periods (.), at signs (@), dashes (-), or \n"
	"  underscores (_).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ResourceIds: array string\n"
	"  One or more resource IDs.\n"
"Tags: array ref ResourceTag\n"
	"  One or more tags to add to the specified resources.\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    -Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"IpRange: string\n"
	"  The IP range in the Subnet, in CIDR notation (for example, \n"
	"  `10.0.0.0/16`).\nThe IP range of the Subnet can be either the same as \n"
	"  the Net one if you create only a single Subnet in this Net, or a subset \n"
	"  of the Net one. In case of several Subnets in a Net, their IP ranges \n"
	"  must not overlap. The smallest Subnet you can create uses a /29 netmask \n"
	"  (eight IPs). For more information, see [About \n"
	"  Nets](https://docs.outscale.com/en/userguide/About-Nets.html).\n"
"NetId: string\n"
	"  The ID of the Net for which you want to create a Subnet.\n"
"SubregionName: string\n"
	"  The name of the Subregion in which you want to create the Subnet.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"OsuExport: ref OsuExportToCreate\n"
	"    Information about the OOS export task to create.\n"
	"    -DiskImageFormat: string\n"
	"      The format of the export disk (`qcow2` \\| `raw`).\n"
	"    -OsuApiKey: ref OsuApiKey\n"
	"        Information about the OOS API key.\n"
	"        -ApiKeyId: string\n"
	"          The API key of the OOS account that enables you to access the \n"
	"          bucket.\n"
	"        -SecretKey: string\n"
	"          The secret key of the OOS account that enables you to access \n"
	"          the bucket.\n"
	"    -OsuBucket: string\n"
	"      The name of the OOS bucket where you want to export the \n"
	"      object.\n"
	"    -OsuManifestUrl: string\n"
	"      The URL of the manifest file.\n"
	"    -OsuPrefix: string\n"
	"      The prefix for the key of the OOS object.\n"
"SnapshotId: string\n"
	"  The ID of the snapshot to export.\n"
,
	"Description: string\n"
	"  A description for the snapshot.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"FileLocation: string\n"
	"  **(when importing from a bucket)** The pre-signed URL of the snapshot \n"
	"  you want to import, or the normal URL of the snapshot if you have \n"
	"  permission on the OOS bucket. For more information, see [Configuring a \n"
	"  Pre-signed \n"
	"  URL](https://docs.outscale.com/en/userguide/Configuring-a-Pre-signed-URL\n"
	"  .html) or [Managing Access to Your Buckets and \n"
	"  Objects](https://docs.outscale.com/en/userguide/Managing-Access-to-Your-\n"
	"  Buckets-and-Objects.html).\n"
"SnapshotSize: int\n"
	"  **(when importing from a bucket)** The size of the snapshot you want to \n"
	"  create in your account, in bytes. This size must be greater than or \n"
	"  equal to the size of the original, uncompressed snapshot.\n"
"SourceRegionName: string\n"
	"  **(when copying a snapshot)** The name of the source Region, which must \n"
	"  be the same as the Region of your account.\n"
"SourceSnapshotId: string\n"
	"  **(when copying a snapshot)** The ID of the snapshot you want to copy.\n"
"VolumeId: string\n"
	"  **(when creating from a volume)** The ID of the volume you want to \n"
	"  create a snapshot of.\n"
,
	"Body: string\n"
	"  The PEM-encoded X509 certificate.With OSC CLI, use the following syntax \n"
	"  to make sure your CA file is correctly parsed: `--CaPem=\"$(cat \n"
	"  FILENAME)\"`.\n"
"Chain: string\n"
	"  The PEM-encoded intermediate certification authorities.With OSC CLI, \n"
	"  use the following syntax to make sure your CA file is correctly parsed: \n"
	"  `--CaPem=\"$(cat FILENAME)\"`.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Name: string\n"
	"  A unique name for the certificate. Constraints: 1-128 alphanumeric \n"
	"  characters, pluses (+), equals (=), commas (,), periods (.), at signs \n"
	"  (@), minuses (-), or underscores (_).\n"
"Path: string\n"
	"  The path to the server certificate, set to a slash (/) if not specified.\n"
"PrivateKey: string\n"
	"  The PEM-encoded private key matching the certificate.With OSC CLI, use \n"
	"  the following syntax to make sure your CA file is correctly parsed: \n"
	"  `--CaPem=\"$(cat FILENAME)\"`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Flow: string\n"
	"  The direction of the flow: `Inbound` or `Outbound`. You can specify \n"
	"  `Outbound` for Nets only.\n"
"FromPortRange: int\n"
	"  The beginning of the port range for the TCP and UDP protocols, or an \n"
	"  ICMP type number. If you specify this parameter, you cannot specify the \n"
	"  `Rules` parameter and its subparameters.\n"
"IpProtocol: string\n"
	"  The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). \n"
	"  By default, `-1`. In a Net, this can also be an IP protocol number. For \n"
	"  more information, see the [IANA.org \n"
	"  website](https://www.iana.org/assignments/protocol-numbers/protocol-numb\n"
	"  ers.xhtml). If you specify this parameter, you cannot specify the \n"
	"  `Rules` parameter and its subparameters.\n"
"IpRange: string\n"
	"  The IP range for the security group rule, in CIDR notation (for \n"
	"  example, 10.0.0.0/16). If you specify this parameter, you cannot \n"
	"  specify the `Rules` parameter and its subparameters.\n"
"Rules: array ref SecurityGroupRule\n"
	"  Information about the security group rule to create. If you specify \n"
	"  this parent parameter and its subparameters, you cannot specify the \n"
	"  following parent parameters: `FromPortRange`, `IpProtocol`, `IpRange`, \n"
	"  and `ToPortRange`.\n"
	"    Information about the security group rule.\n"
	"    -FromPortRange: int\n"
	"      The beginning of the port range for the TCP and UDP protocols, \n"
	"      or an ICMP type number.\n"
	"    -IpProtocol: string\n"
	"      The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all \n"
	"      protocols). By default, `-1`. In a Net, this can also be an IP \n"
	"      protocol number. For more information, see the [IANA.org \n"
	"      website](https://www.iana.org/assignments/protocol-numbers/proto\n"
	"      col-numbers.xhtml).\n"
	"    -IpRanges: array string\n"
	"      One or more IP ranges for the security group rules, in CIDR \n"
	"      notation (for example, `10.0.0.0/16`).\n"
	"    -SecurityGroupsMembers: array ref SecurityGroupsMember\n"
	"      Information about one or more source or destination security \n"
	"      groups.\n"
	"        Information about a source or destination security group.\n"
	"        -AccountId: string\n"
	"          The account ID that owns the source or destination security \n"
	"          group.\n"
	"        -SecurityGroupId: string\n"
	"          The ID of a source or destination security group that you want \n"
	"          to link to the security group of the rule.\n"
	"        -SecurityGroupName: string\n"
	"          (Public Cloud only) The name of a source or destination \n"
	"          security group that you want to link to the security group of \n"
	"          the rule.\n"
	"    -ServiceIds: array string\n"
	"      One or more service IDs to allow traffic from a Net to access \n"
	"      the corresponding OUTSCALE services. For more information, see \n"
	"      [ReadNetAccessPointServices](#readnetaccesspointservices).\n"
	"    -ToPortRange: int\n"
	"      The end of the port range for the TCP and UDP protocols, or an \n"
	"      ICMP code number.\n"
"SecurityGroupAccountIdToLink: string\n"
	"  The account ID that owns the source or destination security group \n"
	"  specified in the `SecurityGroupNameToLink` parameter.\n"
"SecurityGroupId: string\n"
	"  The ID of the security group for which you want to create a rule.\n"
"SecurityGroupNameToLink: string\n"
	"  The ID of a source or destination security group that you want to link \n"
	"  to the security group of the rule.\n"
"ToPortRange: int\n"
	"  The end of the port range for the TCP and UDP protocols, or an ICMP \n"
	"  code number. If you specify this parameter, you cannot specify the \n"
	"  `Rules` parameter and its subparameters.\n"
,
	"Description: string\n"
	"  A description for the security group.\nThis description can contain \n"
	"  between 1 and 255 characters. Allowed characters are `a-z`, `A-Z`, \n"
	"  `0-9`, accented letters, spaces, and `_.-:/()#,@[]+=&;{}!$*`.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetId: string\n"
	"  The ID of the Net for the security group.\n"
"SecurityGroupName: string\n"
	"  The name of the security group.\nThis name must not start with \n"
	"  `sg-`.\nThis name must be unique and contain between 1 and 255 \n"
	"  characters. Allowed characters are `a-z`, `A-Z`, `0-9`, spaces, and \n"
	"  `_.-:/()#,@[]+=&;{}!$*`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetId: string\n"
	"  The ID of the Net for which you want to create a route table.\n"
,
	"DestinationIpRange: string\n"
	"  The IP range used for the destination match, in CIDR notation (for \n"
	"  example, `10.0.0.0/24`).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"GatewayId: string\n"
	"  The ID of an Internet service or virtual gateway attached to your Net.\n"
"NatServiceId: string\n"
	"  The ID of a NAT service.\n"
"NetPeeringId: string\n"
	"  The ID of a Net peering.\n"
"NicId: string\n"
	"  The ID of a NIC.\n"
"RouteTableId: string\n"
	"  The ID of the route table for which you want to create a route.\n"
"VmId: string\n"
	"  The ID of a NAT VM in your Net (attached to exactly one NIC).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"Description: string\n"
	"  The description of the product type.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Vendor: string\n"
	"  The vendor of the product type.\n"
,
	"Document: string\n"
	"  The policy document, corresponding to a JSON string that contains the \n"
	"  policy. For more information, see [EIM Reference \n"
	"  Information](https://docs.outscale.com/en/userguide/EIM-Reference-Inform\n"
	"  ation.html).\n"
"PolicyOrn: string\n"
	"  The OUTSCALE Resource Name (ORN) of the policy. For more information, \n"
	"  see [Resource \n"
	"  Identifiers](https://docs.outscale.com/en/userguide/Resource-Identifiers\n"
	"  .html).\n"
"SetAsDefault: bool\n"
	"  If set to true, the new policy version is set as the default version \n"
	"  and becomes the operative one.\n"
,
	"Description: string\n"
	"  A description for the policy.\n"
"Document: string\n"
	"  The policy document, corresponding to a JSON string that contains the \n"
	"  policy. For more information, see [EIM Reference \n"
	"  Information](https://docs.outscale.com/en/userguide/EIM-Reference-Inform\n"
	"  ation.html).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Path: string\n"
	"  The path of the policy.\n"
"PolicyName: string\n"
	"  The name of the policy.\n"
,
	"Description: string\n"
	"  A description for the NIC.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PrivateIps: array ref PrivateIpLight\n"
	"  The primary private IP for the NIC.\nThis IP must be within the IP \n"
	"  range of the Subnet that you specify with the `SubnetId` attribute.\nIf \n"
	"  you do not specify this attribute, a random private IP is selected \n"
	"  within the IP range of the Subnet.\n"
	"    Information about the private IP.\n"
	"    -IsPrimary: bool\n"
	"      If true, the IP is the primary private IP of the NIC.\n"
	"    -PrivateIp: string\n"
	"      The private IP of the NIC.\n"
"SecurityGroupIds: array string\n"
	"  One or more IDs of security groups for the NIC.\n"
"SubnetId: string\n"
	"  The ID of the Subnet in which you want to create the NIC.\n"
,
	"AccepterNetId: string\n"
	"  The ID of the Net you want to connect with.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"SourceNetId: string\n"
	"  The ID of the Net you send the peering request from.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetId: string\n"
	"  The ID of the Net.\n"
"RouteTableIds: array string\n"
	"  One or more IDs of route tables to use for the connection.\n"
"ServiceName: string\n"
	"  The name of the service (in the format `com.outscale.region.service`).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"IpRange: string\n"
	"  The IP range for the Net, in CIDR notation (for example, `10.0.0.0/16`).\n"
"Tenancy: string\n"
	"  The tenancy options for the VMs:\n- `default` if a VM created in a Net \n"
	"  can be launched with any tenancy.\n- `dedicated` if it can be launched \n"
	"  with dedicated tenancy VMs running on single-tenant hardware.\n- \n"
	"  `dedicated group ID`: if it can be launched in a dedicated group on \n"
	"  single-tenant hardware.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PublicIpId: string\n"
	"  The allocation ID of the public IP to associate with the NAT \n"
	"  service.\nIf the public IP is already associated with another resource, \n"
	"  you must first disassociate it.\n"
"SubnetId: string\n"
	"  The ID of the Subnet in which you want to create the NAT service.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerNames: array string\n"
	"  One or more load balancer names.\n"
"Tags: array ref ResourceTag\n"
	"  One or more tags to add to the specified load balancers.\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    -Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
,
	"CookieExpirationPeriod: int\n"
	"  The lifetime of the cookie, in seconds. If not specified, the default \n"
	"  value of this parameter is `1`, which means that the sticky session \n"
	"  lasts for the duration of the browser session.\n"
"CookieName: string\n"
	"  The name of the application cookie used for stickiness. This parameter \n"
	"  is required if you create a stickiness policy based on an \n"
	"  application-generated cookie.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer for which you want to create a policy.\n"
"PolicyName: string\n"
	"  The name of the policy. This name must be unique and consist of \n"
	"  alphanumeric characters and dashes (-).\n"
"PolicyType: string\n"
	"  The type of stickiness policy you want to create: `app` or \n"
	"  `load_balancer`.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Listeners: array ref ListenerForCreation\n"
	"  One or more listeners for the load balancer.\n"
	"    Information about the listener to create.\n"
	"    -BackendPort: int\n"
	"      The port on which the back-end VM is listening (between `1` \n"
	"      and `65535`, both included).\n"
	"    -BackendProtocol: string\n"
	"      The protocol for routing traffic to back-end VMs (`HTTP` \\| \n"
	"      `HTTPS` \\| `TCP` \\| `SSL`).\n"
	"    -LoadBalancerPort: int\n"
	"      The port on which the load balancer is listening (between `1` \n"
	"      and `65535`, both included).\n"
	"    -LoadBalancerProtocol: string\n"
	"      The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).\n"
	"    -ServerCertificateId: string\n"
	"      The OUTSCALE Resource Name (ORN) of the server certificate. \n"
	"      For more information, see [Resource Identifiers > OUTSCALE \n"
	"      Resource Names \n"
	"      (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifi\n"
	"      ers.html#_outscale_resource_names_orns).\n"
"LoadBalancerName: string\n"
	"  The name of the load balancer for which you want to create listeners.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Listeners: array ref ListenerForCreation\n"
	"  One or more listeners to create.\n"
	"    Information about the listener to create.\n"
	"    -BackendPort: int\n"
	"      The port on which the back-end VM is listening (between `1` \n"
	"      and `65535`, both included).\n"
	"    -BackendProtocol: string\n"
	"      The protocol for routing traffic to back-end VMs (`HTTP` \\| \n"
	"      `HTTPS` \\| `TCP` \\| `SSL`).\n"
	"    -LoadBalancerPort: int\n"
	"      The port on which the load balancer is listening (between `1` \n"
	"      and `65535`, both included).\n"
	"    -LoadBalancerProtocol: string\n"
	"      The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).\n"
	"    -ServerCertificateId: string\n"
	"      The OUTSCALE Resource Name (ORN) of the server certificate. \n"
	"      For more information, see [Resource Identifiers > OUTSCALE \n"
	"      Resource Names \n"
	"      (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifi\n"
	"      ers.html#_outscale_resource_names_orns).\n"
"LoadBalancerName: string\n"
	"  The unique name of the load balancer (32 alphanumeric or hyphen \n"
	"  characters maximum, but cannot start or end with a hyphen).\n"
"LoadBalancerType: string\n"
	"  The type of load balancer: `internet-facing` or `internal`. Use this \n"
	"  parameter only for load balancers in a Net.\n"
"PublicIp: string\n"
	"  (internet-facing only) The public IP you want to associate with the \n"
	"  load balancer. If not specified, a public IP owned by 3DS OUTSCALE is \n"
	"  associated.\n"
"SecurityGroups: array string\n"
	"  (Net only) One or more IDs of security groups you want to assign to the \n"
	"  load balancer. If not specified, the default security group of the Net \n"
	"  is assigned to the load balancer.\n"
"Subnets: array string\n"
	"  (Net only) The ID of the Subnet in which you want to create the load \n"
	"  balancer. Regardless of this Subnet, the load balancer can distribute \n"
	"  traffic to all Subnets. This parameter is required in a Net.\n"
"SubregionNames: array string\n"
	"  (public Cloud only) The Subregion in which you want to create the load \n"
	"  balancer. Regardless of this Subregion, the load balancer can \n"
	"  distribute traffic to all Subregions. This parameter is required in the \n"
	"  public Cloud.\n"
"Tags: array ref ResourceTag\n"
	"  One or more tags assigned to the load balancer.\n"
	"    Information about the tag.\n"
	"    -Key: string\n"
	"      The key of the tag, with a minimum of 1 character.\n"
	"    -Value: string\n"
	"      The value of the tag, between 0 and 255 characters.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Listener: ref LoadBalancerLight\n"
	"    Information about the load balancer.\n"
	"    -LoadBalancerName: string\n"
	"      The name of the load balancer to which the listener is \n"
	"      attached.\n"
	"    -LoadBalancerPort: int\n"
	"      The port of load balancer on which the load balancer is \n"
	"      listening (between `1` and `65535` both included).\n"
"ListenerRule: ref ListenerRuleForCreation\n"
	"    Information about the listener rule.\n"
	"    -Action: string\n"
	"      The type of action for the rule (always `forward`).\n"
	"    -HostNamePattern: string\n"
	"      A host-name pattern for the rule, with a maximum length of 128 \n"
	"      characters. This host-name pattern supports maximum three \n"
	"      wildcards, and must not contain any special characters except \n"
	"      [-.?]. \n"
	"    -ListenerRuleName: string\n"
	"      A human-readable name for the listener rule.\n"
	"    -PathPattern: string\n"
	"      A path pattern for the rule, with a maximum length of 128 \n"
	"      characters. This path pattern supports maximum three wildcards, \n"
	"      and must not contain any special characters except \n"
	"      [_-.$/~\"'@:+?].\n"
	"    -Priority: int\n"
	"      The priority level of the listener rule, between `1` and \n"
	"      `19999` both included. Each rule must have a unique priority \n"
	"      level. Otherwise, an error is returned.\n"
"VmIds: array string\n"
	"  The IDs of the backend VMs.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"KeypairName: string\n"
	"  A unique name for the keypair, with a maximum length of 255 [ASCII \n"
	"  printable \n"
	"  characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\n"
"PublicKey: string\n"
	"  The public key to import in your account, if you are importing an \n"
	"  existing keypair. This value must be Base64-encoded.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ImageId: string\n"
	"  The ID of the OMI to export.\n"
"OsuExport: ref OsuExportToCreate\n"
	"    Information about the OOS export task to create.\n"
	"    -DiskImageFormat: string\n"
	"      The format of the export disk (`qcow2` \\| `raw`).\n"
	"    -OsuApiKey: ref OsuApiKey\n"
	"        Information about the OOS API key.\n"
	"        -ApiKeyId: string\n"
	"          The API key of the OOS account that enables you to access the \n"
	"          bucket.\n"
	"        -SecretKey: string\n"
	"          The secret key of the OOS account that enables you to access \n"
	"          the bucket.\n"
	"    -OsuBucket: string\n"
	"      The name of the OOS bucket where you want to export the \n"
	"      object.\n"
	"    -OsuManifestUrl: string\n"
	"      The URL of the manifest file.\n"
	"    -OsuPrefix: string\n"
	"      The prefix for the key of the OOS object.\n"
,
	"Architecture: string\n"
	"  **(when registering from a snapshot, or from a bucket without using a \n"
	"  manifest file)** The architecture of the OMI (`i386` or `x86_64`).\n"
"BlockDeviceMappings: array ref BlockDeviceMappingImage\n"
	"  **(when registering from a snapshot, or from a bucket without using a \n"
	"  manifest file)** One or more block device mappings.\n"
	"    One or more parameters used to automatically set up volumes \n"
	"    when the VM is created.\n"
	"    -Bsu: ref BsuToCreate\n"
	"        Information about the BSU volume to create.\n"
	"        -DeleteOnVmDeletion: bool\n"
	"          By default or if set to true, the volume is deleted when \n"
	"          terminating the VM. If false, the volume is not deleted when \n"
	"          terminating the VM.\n"
	"        -Iops: int\n"
	"          The number of I/O operations per second (IOPS). This parameter \n"
	"          must be specified only if you create an `io1` volume. The \n"
	"          maximum number of IOPS allowed for `io1` volumes is `13000` \n"
	"          with a maximum performance ratio of 300 IOPS per gibibyte.\n"
	"        -SnapshotId: string\n"
	"          The ID of the snapshot used to create the volume.\n"
	"        -VolumeSize: int\n"
	"          The size of the volume, in gibibytes (GiB).\nIf you \n"
	"          specify a snapshot ID, the volume size must be at least equal \n"
	"          to the snapshot size.\nIf you specify a snapshot ID but \n"
	"          no volume size, the volume is created with a size similar to \n"
	"          the snapshot one.\n"
	"        -VolumeType: string\n"
	"          The type of the volume (`standard` \\| `io1` \\| `gp2`). If \n"
	"          not specified in the request, a `standard` volume is \n"
	"          created.\nFor more information about volume types, see \n"
	"          [About Volumes > Volume Types and \n"
	"          IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#\n"
	"          _volume_types_and_iops).\n"
	"    -DeviceName: string\n"
	"      The device name for the volume. For a root device, you must \n"
	"      use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, \n"
	"      `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` \n"
	"      is a letter between `b` and `z`, and the second `X` is a letter \n"
	"      between `a` and `z`).\n"
	"    -VirtualDeviceName: string\n"
	"      The name of the virtual device (`ephemeralN`).\n"
"Description: string\n"
	"  A description for the new OMI.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"FileLocation: string\n"
	"  **(when registering from a bucket by using a manifest file)** The \n"
	"  pre-signed URL of the manifest file for the OMI you want to register. \n"
	"  For more information, see [Configuring a Pre-signed \n"
	"  URL](https://docs.outscale.com/en/userguide/Configuring-a-Pre-signed-URL\n"
	"  .html) or [Managing Access to Your Buckets and \n"
	"  Objects](https://docs.outscale.com/en/userguide/Managing-Access-to-Your-\n"
	"  Buckets-and-Objects.html).\nYou can also specify the normal URL of the \n"
	"  OMI if you have permission on the OOS bucket, without using the \n"
	"  manifest file, but in that case, you need to manually specify through \n"
	"  the other parameters all the information that would otherwise be read \n"
	"  from the manifest file.\n"
"ImageName: string\n"
	"  A unique name for the new OMI.\nConstraints: 3-128 alphanumeric \n"
	"  characters, underscores (`_`), spaces (` `), parentheses (`()`), \n"
	"  slashes (`/`), periods (`.`), or dashes (`-`).\n"
"NoReboot: bool\n"
	"  **(when creating from a VM)** If false, the VM shuts down before \n"
	"  creating the OMI and then reboots. If true, the VM does not.\n"
"ProductCodes: array string\n"
	"  The product codes associated with the OMI.\n"
"RootDeviceName: string\n"
	"  **(when registering from a snapshot, or from a bucket without using a \n"
	"  manifest file)** The name of the root device for the new OMI.\n"
"SourceImageId: string\n"
	"  **(when copying an OMI)** The ID of the OMI you want to copy.\n"
"SourceRegionName: string\n"
	"  **(when copying an OMI)** The name of the source Region (always the \n"
	"  same as the Region of your account).\n"
"VmId: string\n"
	"  **(when creating from a VM)** The ID of the VM from which you want to \n"
	"  create the OMI.\n"
,
	"DeleteOnVmDeletion: bool\n"
	"  If true, the fGPU is deleted when the VM is terminated.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Generation: string\n"
	"  The processor generation that the fGPU must be compatible with. If not \n"
	"  specified, the oldest possible processor generation is selected (as \n"
	"  provided by [ReadFlexibleGpuCatalog](#readflexiblegpucatalog) for the \n"
	"  specified model of fGPU).\n"
"ModelName: string\n"
	"  The model of fGPU you want to allocate. For more information, see \n"
	"  [About Flexible \n"
	"  GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).\n"
"SubregionName: string\n"
	"  The Subregion in which you want to create the fGPU.\n"
,
	"DirectLinkId: string\n"
	"  The ID of the existing DirectLink for which you want to create the \n"
	"  DirectLink interface.\n"
"DirectLinkInterface: ref DirectLinkInterface\n"
	"    Information about the DirectLink interface.\n"
	"    -BgpAsn: int\n"
	"      The BGP (Border Gateway Protocol) ASN (Autonomous System \n"
	"      Number) on the customer's side of the DirectLink interface. \n"
	"      This number must be between `64512` and `65534`.\n"
	"    -BgpKey: string\n"
	"      The BGP authentication key.\n"
	"    -ClientPrivateIp: string\n"
	"      The IP on the customer's side of the DirectLink interface.\n"
	"    -DirectLinkInterfaceName: string\n"
	"      The name of the DirectLink interface.\n"
	"    -OutscalePrivateIp: string\n"
	"      The IP on the OUTSCALE side of the DirectLink interface.\n"
	"    -VirtualGatewayId: string\n"
	"      The ID of the target virtual gateway.\n"
	"    -Vlan: int\n"
	"      The VLAN number associated with the DirectLink interface. This \n"
	"      number must be unique and be between `2` and `4094`.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"Bandwidth: string\n"
	"  The bandwidth of the DirectLink (`1Gbps` \\| `10Gbps`).\n"
"DirectLinkName: string\n"
	"  The name of the DirectLink.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Location: string\n"
	"  The code of the requested location for the DirectLink, returned by the \n"
	"  [ReadLocations](#readlocations) method.\n"
,
	"DomainName: string\n"
	"  Specify a domain name (for example, `MyCompany.com`). You can specify \n"
	"  only one domain name. You must specify at least one of the following \n"
	"  parameters: `DomainName`, `DomainNameServers`, `LogServers`, or \n"
	"  `NtpServers`.\n"
"DomainNameServers: array string\n"
	"  The IPs of domain name servers. If no IPs are specified, the \n"
	"  `OutscaleProvidedDNS` value is set by default. You must specify at \n"
	"  least one of the following parameters: `DomainName`, \n"
	"  `DomainNameServers`, `LogServers`, or `NtpServers`.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"LogServers: array string\n"
	"  The IPs of the log servers. You must specify at least one of the \n"
	"  following parameters: `DomainName`, `DomainNameServers`, `LogServers`, \n"
	"  or `NtpServers`.\n"
"NtpServers: array string\n"
	"  The IPs of the Network Time Protocol (NTP) servers. You must specify at \n"
	"  least one of the following parameters: `DomainName`, \n"
	"  `DomainNameServers`, `LogServers`, or `NtpServers`.\n"
,
	"CpuGeneration: int\n"
	"  The processor generation for the VMs in the dedicated group (for \n"
	"  example, `4`).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Name: string\n"
	"  A name for the dedicated group.\n"
"SubregionName: string\n"
	"  The Subregion in which you want to create the dedicated group.\n"
,
	"BgpAsn: int\n"
	"  The Autonomous System Number (ASN) used by the Border Gateway Protocol \n"
	"  (BGP) to find the path to your client gateway through the Internet. \n"
	"  <br/>\nThis number must be between `1` and `4294967295`. If you do not \n"
	"  have an ASN, you can choose one between 64512 and 65534, or between \n"
	"  4200000000 and 4294967294.\n"
"ConnectionType: string\n"
	"  The communication protocol used to establish tunnel with your client \n"
	"  gateway (only `ipsec.1` is supported).\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"PublicIp: string\n"
	"  The public fixed IPv4 address of your client gateway.\n"
,
	"CaPem: string\n"
	"  The CA in PEM format.With OSC CLI, use the following syntax to make \n"
	"  sure your CA file is correctly parsed: `--CaPem=\"$(cat \n"
	"  FILENAME)\"`.\n"
"Description: string\n"
	"  The description of the CA.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
,
	"CaIds: array string\n"
	"   One or more IDs of Client Certificate Authorities (CAs).\n"
"Cns: array string\n"
	"  One or more Client Certificate Common Names (CNs). If this parameter is \n"
	"  specified, you must also specify the `CaIds` parameter.\n"
"Description: string\n"
	"  A description for the API access rule.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"IpRanges: array string\n"
	"  One or more IP addresses or CIDR blocks (for example, `192.0.2.0/16`).\n"
,
	"AdditionalEmails: array string\n"
	"  One or more additional email addresses for the account. These addresses \n"
	"  are used for notifications only. If you already have a list of \n"
	"  additional emails registered, you cannot add to it, only replace it. To \n"
	"  remove all registered additional emails, specify an empty list.\n"
"City: string\n"
	"  The city of the account owner.\n"
"CompanyName: string\n"
	"  The name of the company for the account.\n"
"Country: string\n"
	"  The country of the account owner.\n"
"CustomerId: string\n"
	"  The ID of the customer. It must be 8 digits.\n"
"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Email: string\n"
	"  The main email address for the account. This address is used for your \n"
	"  credentials and notifications.\n"
"FirstName: string\n"
	"  The first name of the account owner.\n"
"JobTitle: string\n"
	"  The job title of the account owner.\n"
"LastName: string\n"
	"  The last name of the account owner.\n"
"MobileNumber: string\n"
	"  The mobile phone number of the account owner.\n"
"PhoneNumber: string\n"
	"  The landline phone number of the account owner.\n"
"StateProvince: string\n"
	"  The state/province of the account.\n"
"VatNumber: string\n"
	"  The value added tax (VAT) number for the account.\n"
"ZipCode: string\n"
	"  The ZIP code of the city.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"ExpirationDate: string\n"
	"  The date and time, or the date, at which you want the access key to \n"
	"  expire, in ISO 8601 format (for example, `2020-06-14T00:00:00.000Z`, or \n"
	"  `2020-06-14`). To remove an existing expiration date, use the method \n"
	"  without specifying this parameter.\n"
"UserName: string\n"
	"  The name of the EIM user that owns the key to be created. If you do not \n"
	"  specify a user name, this action creates an access key for the user who \n"
	"  sends the request (which can be the root account).\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"Login: string\n"
	"  The email address of the account.\n"
"Password: string\n"
	"  The password of the account.\n"
,
	"DryRun: bool\n"
	"  If true, checks whether you have the required permissions to perform \n"
	"  the action.\n"
"NetPeeringId: string\n"
	"  The ID of the Net peering you want to accept.\n"
,
	NULL
};

const char *osc_find_description(const char *call_name)
{
	const char **c;
	int i = 0;

	for (c = calls_name; *c; ++c) {
		if (!strcmp(*c, call_name))
			return calls_descriptions[i];
		++i;
	}
	return NULL;
}

const char *osc_find_args_description(const char *call_name)
{
	const char **c;
	int i = 0;

	for (c = calls_name; *c; ++c) {
		if (!strcmp(*c, call_name))
			return calls_args_descriptions[i];
		++i;
	}
	return NULL;
}

const char **osc_calls_name(void)
{
	return calls_name;
}

#endif  /* WITH_DESCRIPTION */

#ifdef WITH_C11_THREAD_LOCAL
#define THREAD_LOCAL _Thread_local
#else
#define THREAD_LOCAL
#endif

static THREAD_LOCAL const char *cfg_path;

void osc_set_cfg_path(const char *cfg)
{
	cfg_path = cfg;
}

const char *osc_set_get_path(void)
{
	return cfg_path;
}

void *osc_realloc(void *buf, size_t l)
{
	void *ret = realloc(buf, l);

	if (!ret)
		free(buf);
	return ret;
}

/* We don't use _Bool as we try to be C89 compatible */
int osc_str_append_bool(struct osc_str *osc_str, int bool)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->len = len + (bool ? 4 : 5);
	osc_str->buf = osc_realloc(osc_str->buf, osc_str->len + 1);
	if (!osc_str->buf)
		return -1;
	strcpy(osc_str->buf + len, (bool ? "true" : "false"));
	return 0;
}

int osc_str_append_int(struct osc_str *osc_str, int i)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->buf = osc_realloc(osc_str->buf, len + 64);
	if (!osc_str->buf)
		return -1;
	osc_str->len = len + snprintf(osc_str->buf + len, 64, "%d", i);
	osc_str->buf[osc_str->len] = 0;
	return 0;
}

int osc_str_append_double(struct osc_str *osc_str, double i)
{
	int len = osc_str->len;
	assert(osc_str);

	osc_str->buf = osc_realloc(osc_str->buf, len + 64);
	if (!osc_str->buf)
		return -1;
	osc_str->len = len + snprintf(osc_str->buf + len, 64, "%f", i);
	osc_str->buf[osc_str->len] = 0;
	return 0;
}

int osc_str_append_string(struct osc_str *osc_str, const char *str)
{
	if (!str)
		return 0;
	assert(osc_str);

	int len = osc_str->len;
	int dlen = strlen(str);

	osc_str->len = osc_str->len + dlen;
	osc_str->buf = osc_realloc(osc_str->buf, osc_str->len + 1);
	if (!osc_str->buf)
		return -1;
	memcpy(osc_str->buf + len, str, dlen + 1);
	return 0;
}

int osc_str_append_n_string(struct osc_str *osc_str, const char *str, int l)
{
	if (!str)
		return 0;
	assert(osc_str);

	int len = osc_str->len;

	osc_str->len = osc_str->len + l;
	osc_str->buf = osc_realloc(osc_str->buf, osc_str->len + 1);
	if (!osc_str->buf)
		return -1;
	memcpy(osc_str->buf + len, str, l);
	osc_str->buf[len + l] = 0;
	return 0;
}

static char *osc_strdup(const char *str) {
	if (!str)
		return NULL;
	return strdup(str);
}

#define TRY(test,  ...)						\
	if (test) { fprintf(stderr, __VA_ARGS__); return -1; }

#define STRY(test,  ...)					\
	if (test) return -1

#define TRY_APPEND_COL(count_args, data)			\
	if (count_args++ > 0)					\
		STRY(osc_str_append_string(data, "," ));

#ifndef LOAD_CFG_GET_HOME
#define LOAD_CFG_GET_HOME(buf)						\
	{								\
		const char *dest = CFG_FILE;				\
		char *home = getenv("HOME");				\
									\
		TRY(strlen(home) + sizeof CFG_FILE > sizeof buf,	\
		    "home path too big");				\
		strcpy(stpcpy(buf, home), dest);			\
	}
#endif

#define ARG_TO_JSON_STR(separator, what) do {				\
		auto_osc_str struct osc_str s;				\
		char *tmp = what;					\
		char *endl;						\
									\
		osc_init_str(&s);					\
		while((endl = strchr(tmp, '\n')) != NULL) {		\
			int l = endl - tmp;				\
									\
			osc_str_append_n_string(&s, tmp, l);		\
			osc_str_append_string(&s, "\\n");		\
			tmp = endl + 1;					\
		}							\
		osc_str_append_string(&s, tmp);				\
		STRY(osc_str_append_string(data, separator));		\
		STRY(osc_str_append_string(data, "\"" ));		\
		STRY(osc_str_append_string(data, s.buf));		\
		STRY(osc_str_append_string(data, "\"" ));		\
	} while (0)

#define ARG_TO_JSON(name, type, what) do {				\
		TRY_APPEND_COL(count_args, data);			\
		STRY(osc_str_append_string(data, "\""#name"\":" ));	\
		STRY(osc_str_append_##type(data, what));		\
	} while (0)


int osc_load_ak_sk_from_conf(const char *profile, char **ak, char **sk)
{
	char buf[1024];
	const char *cfg = cfg_path;
	struct json_object *js, *ak_js, *sk_js;
	auto_osc_json_c struct json_object *to_free = NULL;

	if (!ak && !sk)
		return 0;
	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	if (sk)
		*sk = NULL;
	if (ak)
		*ak = NULL;
	TRY(access(cfg, R_OK), "can't open/read %s\n", cfg);
	js = json_object_from_file(cfg);
	TRY(!js, "can't load json-file %s (json might have incorect syntaxe)\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	TRY(!js, "can't find profile %s\n", profile);
	if (ak) {
		ak_js = json_object_object_get(js, "access_key");
		TRY(!ak_js, "can't find 'access_key' in profile '%s'\n", profile);
		*ak = strdup(json_object_get_string(json_object_object_get(js, "access_key")));
	}
	if (sk) {
		sk_js = json_object_object_get(js, "secret_key");
		TRY(!sk_js, "can't find 'secret_key' in profile '%s'\n", profile);
		*sk = strdup(json_object_get_string(json_object_object_get(js, "secret_key")));
	}
	return 0;
}

int osc_load_loging_password_from_conf(const char *profile,
				       char **email, char **password)
{
	char buf[1024];
	const char *cfg = cfg_path;
	auto_osc_json_c struct json_object *to_free = NULL;
	struct json_object *js, *login_js, *pass_js;

	if (!email && !password)
		return 0;
	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	if (password)
		*password = NULL;
	if (email)
		*email = NULL;
	js = json_object_from_file(cfg);
	TRY(!js, "can't open %s\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	TRY(!js, "can't find profile '%s'\n", profile);
	if (email) {
		login_js = json_object_object_get(js, "login");
		TRY(!login_js, "can't find 'login' in profile '%s'\n", profile);
		*email = osc_strdup(json_object_get_string(login_js));
	}

	if (password) {
		pass_js = json_object_object_get(js, "password");
		if (!pass_js) {
			return 0; /* is optional */
		}
		*password = osc_strdup(json_object_get_string(pass_js));
	}
	return 0;
}

int osc_load_region_from_conf(const char *profile, char **region)
{
	struct json_object *region_obj;
	const char *cfg = cfg_path;
	char buf[1024];
	struct json_object *js;
	auto_osc_json_c struct json_object *to_free = NULL;

	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	js = json_object_from_file(cfg);
	TRY(!js, "can't open %s\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	if (!js)
		return -1;

	region_obj = json_object_object_get(js, "region");
	if (!region_obj) {
		return -1;
	}
	*region = osc_strdup(json_object_get_string(region_obj));
	return 0;
}

int osc_load_cert_from_conf(const char *profile, char **cert, char **key)
{
	struct json_object *cert_obj, *key_obj, *js;
	const char *cfg = cfg_path;
	auto_osc_json_c struct json_object *to_free = NULL;
	char buf[1024];
	int ret = 0;

	if (!cfg) {
		LOAD_CFG_GET_HOME(buf);
		cfg = buf;
	}
	js = json_object_from_file(cfg);
	TRY(!js, "can't open %s\n", cfg);
	to_free = js;
	js = json_object_object_get(js, profile);
	if (!js)
		return 0;

	cert_obj = json_object_object_get(js, "x509_client_cert");
	if (!cert_obj)
		cert_obj = json_object_object_get(js, "client_certificate");
	if (cert_obj) {
		*cert = osc_strdup(json_object_get_string(cert_obj));
		ret |= OSC_ENV_FREE_CERT;
	}

	key_obj = json_object_object_get(js, "x509_client_sslkey");
	if (key_obj) {
		*key = osc_strdup(json_object_get_string(key_obj));
		ret |= OSC_ENV_FREE_SSLKEY;
	}

	return 0;
}

/* Function that will write the data inside a variable */
static size_t write_data(void *data, size_t size, size_t nmemb, void *userp)
{
	size_t bufsize = size * nmemb;
	struct osc_str *response = userp;
	int olen = response->len;

	response->len = response->len + bufsize;
	response->buf = osc_realloc(response->buf, response->len + 1);
	memcpy(response->buf + olen, data, bufsize);
	response->buf[response->len] = 0;
	return bufsize;
}

void osc_init_str(struct osc_str *r)
{
	r->len = 0;
	r->buf = NULL;
}

void osc_deinit_json_c(json_object **j)
{
	if (j && *j)
		json_object_put(*j);
}

void osc_deinit_str(struct osc_str *r)
{
	free(r->buf);
	osc_init_str(r);
}

static int accepter_net_setter(struct accepter_net *args, struct osc_str *data);
static int access_key_setter(struct access_key *args, struct osc_str *data);
static int access_key_secret_key_setter(struct access_key_secret_key *args, struct osc_str *data);
static int access_log_setter(struct access_log *args, struct osc_str *data);
static int account_setter(struct account *args, struct osc_str *data);
static int api_access_policy_setter(struct api_access_policy *args, struct osc_str *data);
static int api_access_rule_setter(struct api_access_rule *args, struct osc_str *data);
static int application_sticky_cookie_policy_setter(struct application_sticky_cookie_policy *args, struct osc_str *data);
static int backend_vm_health_setter(struct backend_vm_health *args, struct osc_str *data);
static int block_device_mapping_created_setter(struct block_device_mapping_created *args, struct osc_str *data);
static int block_device_mapping_image_setter(struct block_device_mapping_image *args, struct osc_str *data);
static int block_device_mapping_vm_creation_setter(struct block_device_mapping_vm_creation *args, struct osc_str *data);
static int block_device_mapping_vm_update_setter(struct block_device_mapping_vm_update *args, struct osc_str *data);
static int bsu_created_setter(struct bsu_created *args, struct osc_str *data);
static int bsu_to_create_setter(struct bsu_to_create *args, struct osc_str *data);
static int bsu_to_update_vm_setter(struct bsu_to_update_vm *args, struct osc_str *data);
static int ca_setter(struct ca *args, struct osc_str *data);
static int catalog_setter(struct catalog *args, struct osc_str *data);
static int catalog_entry_setter(struct catalog_entry *args, struct osc_str *data);
static int catalogs_setter(struct catalogs *args, struct osc_str *data);
static int client_gateway_setter(struct client_gateway *args, struct osc_str *data);
static int consumption_entry_setter(struct consumption_entry *args, struct osc_str *data);
static int dedicated_group_setter(struct dedicated_group *args, struct osc_str *data);
static int dhcp_options_set_setter(struct dhcp_options_set *args, struct osc_str *data);
static int direct_link_setter(struct direct_link *args, struct osc_str *data);
static int direct_link_interface_setter(struct direct_link_interface *args, struct osc_str *data);
static int direct_link_interfaces_setter(struct direct_link_interfaces *args, struct osc_str *data);
static int errors_setter(struct errors *args, struct osc_str *data);
static int filters_access_keys_setter(struct filters_access_keys *args, struct osc_str *data);
static int filters_api_access_rule_setter(struct filters_api_access_rule *args, struct osc_str *data);
static int filters_api_log_setter(struct filters_api_log *args, struct osc_str *data);
static int filters_ca_setter(struct filters_ca *args, struct osc_str *data);
static int filters_catalogs_setter(struct filters_catalogs *args, struct osc_str *data);
static int filters_client_gateway_setter(struct filters_client_gateway *args, struct osc_str *data);
static int filters_dedicated_group_setter(struct filters_dedicated_group *args, struct osc_str *data);
static int filters_dhcp_options_setter(struct filters_dhcp_options *args, struct osc_str *data);
static int filters_direct_link_setter(struct filters_direct_link *args, struct osc_str *data);
static int filters_direct_link_interface_setter(struct filters_direct_link_interface *args, struct osc_str *data);
static int filters_export_task_setter(struct filters_export_task *args, struct osc_str *data);
static int filters_flexible_gpu_setter(struct filters_flexible_gpu *args, struct osc_str *data);
static int filters_image_setter(struct filters_image *args, struct osc_str *data);
static int filters_internet_service_setter(struct filters_internet_service *args, struct osc_str *data);
static int filters_keypair_setter(struct filters_keypair *args, struct osc_str *data);
static int filters_listener_rule_setter(struct filters_listener_rule *args, struct osc_str *data);
static int filters_load_balancer_setter(struct filters_load_balancer *args, struct osc_str *data);
static int filters_nat_service_setter(struct filters_nat_service *args, struct osc_str *data);
static int filters_net_setter(struct filters_net *args, struct osc_str *data);
static int filters_net_access_point_setter(struct filters_net_access_point *args, struct osc_str *data);
static int filters_net_peering_setter(struct filters_net_peering *args, struct osc_str *data);
static int filters_nic_setter(struct filters_nic *args, struct osc_str *data);
static int filters_product_type_setter(struct filters_product_type *args, struct osc_str *data);
static int filters_public_ip_setter(struct filters_public_ip *args, struct osc_str *data);
static int filters_quota_setter(struct filters_quota *args, struct osc_str *data);
static int filters_route_table_setter(struct filters_route_table *args, struct osc_str *data);
static int filters_security_group_setter(struct filters_security_group *args, struct osc_str *data);
static int filters_server_certificate_setter(struct filters_server_certificate *args, struct osc_str *data);
static int filters_service_setter(struct filters_service *args, struct osc_str *data);
static int filters_snapshot_setter(struct filters_snapshot *args, struct osc_str *data);
static int filters_subnet_setter(struct filters_subnet *args, struct osc_str *data);
static int filters_subregion_setter(struct filters_subregion *args, struct osc_str *data);
static int filters_tag_setter(struct filters_tag *args, struct osc_str *data);
static int filters_virtual_gateway_setter(struct filters_virtual_gateway *args, struct osc_str *data);
static int filters_vm_setter(struct filters_vm *args, struct osc_str *data);
static int filters_vm_group_setter(struct filters_vm_group *args, struct osc_str *data);
static int filters_vm_template_setter(struct filters_vm_template *args, struct osc_str *data);
static int filters_vm_type_setter(struct filters_vm_type *args, struct osc_str *data);
static int filters_vms_state_setter(struct filters_vms_state *args, struct osc_str *data);
static int filters_volume_setter(struct filters_volume *args, struct osc_str *data);
static int filters_vpn_connection_setter(struct filters_vpn_connection *args, struct osc_str *data);
static int flexible_gpu_setter(struct flexible_gpu *args, struct osc_str *data);
static int flexible_gpu_catalog_setter(struct flexible_gpu_catalog *args, struct osc_str *data);
static int health_check_setter(struct health_check *args, struct osc_str *data);
static int image_setter(struct image *args, struct osc_str *data);
static int image_export_task_setter(struct image_export_task *args, struct osc_str *data);
static int internet_service_setter(struct internet_service *args, struct osc_str *data);
static int keypair_setter(struct keypair *args, struct osc_str *data);
static int keypair_created_setter(struct keypair_created *args, struct osc_str *data);
static int link_nic_setter(struct link_nic *args, struct osc_str *data);
static int link_nic_light_setter(struct link_nic_light *args, struct osc_str *data);
static int link_nic_to_update_setter(struct link_nic_to_update *args, struct osc_str *data);
static int link_public_ip_setter(struct link_public_ip *args, struct osc_str *data);
static int link_public_ip_light_for_vm_setter(struct link_public_ip_light_for_vm *args, struct osc_str *data);
static int link_route_table_setter(struct link_route_table *args, struct osc_str *data);
static int linked_policy_setter(struct linked_policy *args, struct osc_str *data);
static int linked_volume_setter(struct linked_volume *args, struct osc_str *data);
static int listener_setter(struct listener *args, struct osc_str *data);
static int listener_for_creation_setter(struct listener_for_creation *args, struct osc_str *data);
static int listener_rule_setter(struct listener_rule *args, struct osc_str *data);
static int listener_rule_for_creation_setter(struct listener_rule_for_creation *args, struct osc_str *data);
static int load_balancer_setter(struct load_balancer *args, struct osc_str *data);
static int load_balancer_light_setter(struct load_balancer_light *args, struct osc_str *data);
static int load_balancer_sticky_cookie_policy_setter(struct load_balancer_sticky_cookie_policy *args, struct osc_str *data);
static int load_balancer_tag_setter(struct load_balancer_tag *args, struct osc_str *data);
static int location_setter(struct location *args, struct osc_str *data);
static int log_setter(struct log *args, struct osc_str *data);
static int maintenance_event_setter(struct maintenance_event *args, struct osc_str *data);
static int nat_service_setter(struct nat_service *args, struct osc_str *data);
static int net_setter(struct net *args, struct osc_str *data);
static int net_access_point_setter(struct net_access_point *args, struct osc_str *data);
static int net_peering_setter(struct net_peering *args, struct osc_str *data);
static int net_peering_state_setter(struct net_peering_state *args, struct osc_str *data);
static int net_to_virtual_gateway_link_setter(struct net_to_virtual_gateway_link *args, struct osc_str *data);
static int nic_setter(struct nic *args, struct osc_str *data);
static int nic_for_vm_creation_setter(struct nic_for_vm_creation *args, struct osc_str *data);
static int nic_light_setter(struct nic_light *args, struct osc_str *data);
static int osu_api_key_setter(struct osu_api_key *args, struct osc_str *data);
static int osu_export_image_export_task_setter(struct osu_export_image_export_task *args, struct osc_str *data);
static int osu_export_snapshot_export_task_setter(struct osu_export_snapshot_export_task *args, struct osc_str *data);
static int osu_export_to_create_setter(struct osu_export_to_create *args, struct osc_str *data);
static int permissions_on_resource_setter(struct permissions_on_resource *args, struct osc_str *data);
static int permissions_on_resource_creation_setter(struct permissions_on_resource_creation *args, struct osc_str *data);
static int phase1_options_setter(struct phase1_options *args, struct osc_str *data);
static int phase2_options_setter(struct phase2_options *args, struct osc_str *data);
static int phase2_options_to_update_setter(struct phase2_options_to_update *args, struct osc_str *data);
static int placement_setter(struct placement *args, struct osc_str *data);
static int policy_setter(struct policy *args, struct osc_str *data);
static int policy_version_setter(struct policy_version *args, struct osc_str *data);
static int private_ip_setter(struct private_ip *args, struct osc_str *data);
static int private_ip_light_setter(struct private_ip_light *args, struct osc_str *data);
static int private_ip_light_for_vm_setter(struct private_ip_light_for_vm *args, struct osc_str *data);
static int product_type_setter(struct product_type *args, struct osc_str *data);
static int public_ip_setter(struct public_ip *args, struct osc_str *data);
static int public_ip_light_setter(struct public_ip_light *args, struct osc_str *data);
static int quota_setter(struct quota *args, struct osc_str *data);
static int quota_types_setter(struct quota_types *args, struct osc_str *data);
static int read_linked_policies_filters_setter(struct read_linked_policies_filters *args, struct osc_str *data);
static int read_policies_filters_setter(struct read_policies_filters *args, struct osc_str *data);
static int region_setter(struct region *args, struct osc_str *data);
static int resource_load_balancer_tag_setter(struct resource_load_balancer_tag *args, struct osc_str *data);
static int resource_tag_setter(struct resource_tag *args, struct osc_str *data);
static int route_setter(struct route *args, struct osc_str *data);
static int route_light_setter(struct route_light *args, struct osc_str *data);
static int route_propagating_virtual_gateway_setter(struct route_propagating_virtual_gateway *args, struct osc_str *data);
static int route_table_setter(struct route_table *args, struct osc_str *data);
static int security_group_setter(struct security_group *args, struct osc_str *data);
static int security_group_light_setter(struct security_group_light *args, struct osc_str *data);
static int security_group_rule_setter(struct security_group_rule *args, struct osc_str *data);
static int security_groups_member_setter(struct security_groups_member *args, struct osc_str *data);
static int server_certificate_setter(struct server_certificate *args, struct osc_str *data);
static int service_setter(struct service *args, struct osc_str *data);
static int snapshot_setter(struct snapshot *args, struct osc_str *data);
static int snapshot_export_task_setter(struct snapshot_export_task *args, struct osc_str *data);
static int source_net_setter(struct source_net *args, struct osc_str *data);
static int source_security_group_setter(struct source_security_group *args, struct osc_str *data);
static int state_comment_setter(struct state_comment *args, struct osc_str *data);
static int subnet_setter(struct subnet *args, struct osc_str *data);
static int subregion_setter(struct subregion *args, struct osc_str *data);
static int tag_setter(struct tag *args, struct osc_str *data);
static int user_setter(struct user *args, struct osc_str *data);
static int vgw_telemetry_setter(struct vgw_telemetry *args, struct osc_str *data);
static int virtual_gateway_setter(struct virtual_gateway *args, struct osc_str *data);
static int vm_setter(struct vm *args, struct osc_str *data);
static int vm_group_setter(struct vm_group *args, struct osc_str *data);
static int vm_state_setter(struct vm_state *args, struct osc_str *data);
static int vm_states_setter(struct vm_states *args, struct osc_str *data);
static int vm_template_setter(struct vm_template *args, struct osc_str *data);
static int vm_type_setter(struct vm_type *args, struct osc_str *data);
static int volume_setter(struct volume *args, struct osc_str *data);
static int vpn_connection_setter(struct vpn_connection *args, struct osc_str *data);
static int vpn_options_setter(struct vpn_options *args, struct osc_str *data);
static int vpn_options_to_update_setter(struct vpn_options_to_update *args, struct osc_str *data);
static int with_setter(struct with *args, struct osc_str *data);
static int accepter_net_setter(struct accepter_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	return !!ret;
}
static int access_key_setter(struct access_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	return !!ret;
}
static int access_key_secret_key_setter(struct access_key_secret_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->secret_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecretKey\":", args->secret_key);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	return !!ret;
}
static int access_log_setter(struct access_log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_enabled) {
		ARG_TO_JSON(IsEnabled, bool, args->is_enabled);
	   	ret += 1;
	}
	if (args->osu_bucket_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucketName\":", args->osu_bucket_name);
	   	ret += 1;
	}
	if (args->osu_bucket_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucketPrefix\":", args->osu_bucket_prefix);
	   	ret += 1;
	}
	if (args->is_set_publication_interval || args->publication_interval) {
		ARG_TO_JSON(PublicationInterval, int, args->publication_interval);
	   	ret += 1;
	}
	return !!ret;
}
static int account_setter(struct account *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->additional_emails) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AdditionalEmails\":[" ));
		for (as = args->additional_emails; *as; ++as) {
			if (as != args->additional_emails)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->additional_emails_str) {
		ARG_TO_JSON(AdditionalEmails, string, args->additional_emails_str);
		ret += 1;
	}
	if (args->city) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"City\":", args->city);
	   	ret += 1;
	}
	if (args->company_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CompanyName\":", args->company_name);
	   	ret += 1;
	}
	if (args->country) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Country\":", args->country);
	   	ret += 1;
	}
	if (args->customer_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CustomerId\":", args->customer_id);
	   	ret += 1;
	}
	if (args->email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Email\":", args->email);
	   	ret += 1;
	}
	if (args->first_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FirstName\":", args->first_name);
	   	ret += 1;
	}
	if (args->job_title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"JobTitle\":", args->job_title);
	   	ret += 1;
	}
	if (args->last_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastName\":", args->last_name);
	   	ret += 1;
	}
	if (args->mobile_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MobileNumber\":", args->mobile_number);
	   	ret += 1;
	}
	if (args->phone_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PhoneNumber\":", args->phone_number);
	   	ret += 1;
	}
	if (args->state_province) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateProvince\":", args->state_province);
	   	ret += 1;
	}
	if (args->vat_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VatNumber\":", args->vat_number);
	   	ret += 1;
	}
	if (args->zip_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ZipCode\":", args->zip_code);
	   	ret += 1;
	}
	return !!ret;
}
static int api_access_policy_setter(struct api_access_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_max_access_key_expiration_seconds || args->max_access_key_expiration_seconds) {
		ARG_TO_JSON(MaxAccessKeyExpirationSeconds, int, args->max_access_key_expiration_seconds);
	   	ret += 1;
	}
	if (args->is_set_require_trusted_env) {
		ARG_TO_JSON(RequireTrustedEnv, bool, args->require_trusted_env);
	   	ret += 1;
	}
	return !!ret;
}
static int api_access_rule_setter(struct api_access_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_access_rule_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ApiAccessRuleId\":", args->api_access_rule_id);
	   	ret += 1;
	}
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->cns) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Cns\":[" ));
		for (as = args->cns; *as; ++as) {
			if (as != args->cns)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cns_str) {
		ARG_TO_JSON(Cns, string, args->cns_str);
		ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	return !!ret;
}
static int application_sticky_cookie_policy_setter(struct application_sticky_cookie_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->cookie_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CookieName\":", args->cookie_name);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	return !!ret;
}
static int backend_vm_health_setter(struct backend_vm_health *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->state_reason) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateReason\":", args->state_reason);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	return !!ret;
}
static int block_device_mapping_created_setter(struct block_device_mapping_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		ARG_TO_JSON(Bsu, string, args->bsu_str);
		ret += 1;
	} else if (args->is_set_bsu) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Bsu\": { " ));
	       STRY(bsu_created_setter(&args->bsu, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	return !!ret;
}
static int block_device_mapping_image_setter(struct block_device_mapping_image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		ARG_TO_JSON(Bsu, string, args->bsu_str);
		ret += 1;
	} else if (args->is_set_bsu) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Bsu\": { " ));
	       STRY(bsu_to_create_setter(&args->bsu, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualDeviceName\":", args->virtual_device_name);
	   	ret += 1;
	}
	return !!ret;
}
static int block_device_mapping_vm_creation_setter(struct block_device_mapping_vm_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		ARG_TO_JSON(Bsu, string, args->bsu_str);
		ret += 1;
	} else if (args->is_set_bsu) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Bsu\": { " ));
	       STRY(bsu_to_create_setter(&args->bsu, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->no_device) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NoDevice\":", args->no_device);
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualDeviceName\":", args->virtual_device_name);
	   	ret += 1;
	}
	return !!ret;
}
static int block_device_mapping_vm_update_setter(struct block_device_mapping_vm_update *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bsu_str) {
		ARG_TO_JSON(Bsu, string, args->bsu_str);
		ret += 1;
	} else if (args->is_set_bsu) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Bsu\": { " ));
	       STRY(bsu_to_update_vm_setter(&args->bsu, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->no_device) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NoDevice\":", args->no_device);
	   	ret += 1;
	}
	if (args->virtual_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualDeviceName\":", args->virtual_device_name);
	   	ret += 1;
	}
	return !!ret;
}
static int bsu_created_setter(struct bsu_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->link_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkDate\":", args->link_date);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	return !!ret;
}
static int bsu_to_create_setter(struct bsu_to_create *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		ARG_TO_JSON(Iops, int, args->iops);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		ARG_TO_JSON(VolumeSize, int, args->volume_size);
	   	ret += 1;
	}
	if (args->volume_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeType\":", args->volume_type);
	   	ret += 1;
	}
	return !!ret;
}
static int bsu_to_update_vm_setter(struct bsu_to_update_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	return !!ret;
}
static int ca_setter(struct ca *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ca_fingerprint) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaFingerprint\":", args->ca_fingerprint);
	   	ret += 1;
	}
	if (args->ca_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaId\":", args->ca_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	return !!ret;
}
static int catalog_setter(struct catalog *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->entries) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Entries\":[" ));
		for (int i = 0; i < args->nb_entries; ++i) {
	       	    struct catalog_entry *p = &args->entries[i];
		    if (p != args->entries)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(catalog_entry_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->entries_str) {
		ARG_TO_JSON(Entries, string, args->entries_str);
		ret += 1;
	}
	return !!ret;
}
static int catalog_entry_setter(struct catalog_entry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->category) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Category\":", args->category);
	   	ret += 1;
	}
	if (args->flags) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Flags\":", args->flags);
	   	ret += 1;
	}
	if (args->operation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Operation\":", args->operation);
	   	ret += 1;
	}
	if (args->service) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Service\":", args->service);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Title\":", args->title);
	   	ret += 1;
	}
	if (args->type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Type\":", args->type);
	   	ret += 1;
	}
	if (args->is_set_unit_price || args->unit_price) {
		ARG_TO_JSON(UnitPrice, double, args->unit_price);
	   	ret += 1;
	}
	return !!ret;
}
static int catalogs_setter(struct catalogs *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->entries) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Entries\":[" ));
		for (int i = 0; i < args->nb_entries; ++i) {
	       	    struct catalog_entry *p = &args->entries[i];
		    if (p != args->entries)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(catalog_entry_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->entries_str) {
		ARG_TO_JSON(Entries, string, args->entries_str);
		ret += 1;
	}
	if (args->from_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromDate\":", args->from_date);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->to_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToDate\":", args->to_date);
	   	ret += 1;
	}
	return !!ret;
}
static int client_gateway_setter(struct client_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bgp_asn || args->bgp_asn) {
		ARG_TO_JSON(BgpAsn, int, args->bgp_asn);
	   	ret += 1;
	}
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int consumption_entry_setter(struct consumption_entry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->category) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Category\":", args->category);
	   	ret += 1;
	}
	if (args->from_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromDate\":", args->from_date);
	   	ret += 1;
	}
	if (args->operation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Operation\":", args->operation);
	   	ret += 1;
	}
	if (args->paying_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PayingAccountId\":", args->paying_account_id);
	   	ret += 1;
	}
	if (args->is_set_price || args->price) {
		ARG_TO_JSON(Price, double, args->price);
	   	ret += 1;
	}
	if (args->service) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Service\":", args->service);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Title\":", args->title);
	   	ret += 1;
	}
	if (args->to_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToDate\":", args->to_date);
	   	ret += 1;
	}
	if (args->type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Type\":", args->type);
	   	ret += 1;
	}
	if (args->is_set_unit_price || args->unit_price) {
		ARG_TO_JSON(UnitPrice, double, args->unit_price);
	   	ret += 1;
	}
	if (args->is_set_value || args->value) {
		ARG_TO_JSON(Value, double, args->value);
	   	ret += 1;
	}
	return !!ret;
}
static int dedicated_group_setter(struct dedicated_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->is_set_cpu_generation || args->cpu_generation) {
		ARG_TO_JSON(CpuGeneration, int, args->cpu_generation);
	   	ret += 1;
	}
	if (args->dedicated_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DedicatedGroupId\":", args->dedicated_group_id);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int dhcp_options_set_setter(struct dhcp_options_set *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_default_arg) {
		ARG_TO_JSON(Default, bool, args->default_arg);
	   	ret += 1;
	}
	if (args->dhcp_options_set_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DhcpOptionsSetId\":", args->dhcp_options_set_id);
	   	ret += 1;
	}
	if (args->domain_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DomainName\":", args->domain_name);
	   	ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DomainNameServers\":[" ));
		for (as = args->domain_name_servers; *as; ++as) {
			if (as != args->domain_name_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->domain_name_servers_str) {
		ARG_TO_JSON(DomainNameServers, string, args->domain_name_servers_str);
		ret += 1;
	}
	if (args->log_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LogServers\":[" ));
		for (as = args->log_servers; *as; ++as) {
			if (as != args->log_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->log_servers_str) {
		ARG_TO_JSON(LogServers, string, args->log_servers_str);
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NtpServers\":[" ));
		for (as = args->ntp_servers; *as; ++as) {
			if (as != args->ntp_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ntp_servers_str) {
		ARG_TO_JSON(NtpServers, string, args->ntp_servers_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int direct_link_setter(struct direct_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->bandwidth) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Bandwidth\":", args->bandwidth);
	   	ret += 1;
	}
	if (args->direct_link_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkId\":", args->direct_link_id);
	   	ret += 1;
	}
	if (args->direct_link_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkName\":", args->direct_link_name);
	   	ret += 1;
	}
	if (args->location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Location\":", args->location);
	   	ret += 1;
	}
	if (args->region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RegionName\":", args->region_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	return !!ret;
}
static int direct_link_interface_setter(struct direct_link_interface *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bgp_asn || args->bgp_asn) {
		ARG_TO_JSON(BgpAsn, int, args->bgp_asn);
	   	ret += 1;
	}
	if (args->bgp_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BgpKey\":", args->bgp_key);
	   	ret += 1;
	}
	if (args->client_private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientPrivateIp\":", args->client_private_ip);
	   	ret += 1;
	}
	if (args->direct_link_interface_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceName\":", args->direct_link_interface_name);
	   	ret += 1;
	}
	if (args->outscale_private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OutscalePrivateIp\":", args->outscale_private_ip);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	if (args->is_set_vlan || args->vlan) {
		ARG_TO_JSON(Vlan, int, args->vlan);
	   	ret += 1;
	}
	return !!ret;
}
static int direct_link_interfaces_setter(struct direct_link_interfaces *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->is_set_bgp_asn || args->bgp_asn) {
		ARG_TO_JSON(BgpAsn, int, args->bgp_asn);
	   	ret += 1;
	}
	if (args->bgp_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BgpKey\":", args->bgp_key);
	   	ret += 1;
	}
	if (args->client_private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientPrivateIp\":", args->client_private_ip);
	   	ret += 1;
	}
	if (args->direct_link_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkId\":", args->direct_link_id);
	   	ret += 1;
	}
	if (args->direct_link_interface_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceId\":", args->direct_link_interface_id);
	   	ret += 1;
	}
	if (args->direct_link_interface_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceName\":", args->direct_link_interface_name);
	   	ret += 1;
	}
	if (args->interface_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InterfaceType\":", args->interface_type);
	   	ret += 1;
	}
	if (args->location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Location\":", args->location);
	   	ret += 1;
	}
	if (args->is_set_mtu || args->mtu) {
		ARG_TO_JSON(Mtu, int, args->mtu);
	   	ret += 1;
	}
	if (args->outscale_private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OutscalePrivateIp\":", args->outscale_private_ip);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	if (args->is_set_vlan || args->vlan) {
		ARG_TO_JSON(Vlan, int, args->vlan);
	   	ret += 1;
	}
	return !!ret;
}
static int errors_setter(struct errors *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Code\":", args->code);
	   	ret += 1;
	}
	if (args->details) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Details\":", args->details);
	   	ret += 1;
	}
	if (args->type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Type\":", args->type);
	   	ret += 1;
	}
	return !!ret;
}
static int filters_access_keys_setter(struct filters_access_keys *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_key_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccessKeyIds\":[" ));
		for (as = args->access_key_ids; *as; ++as) {
			if (as != args->access_key_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->access_key_ids_str) {
		ARG_TO_JSON(AccessKeyIds, string, args->access_key_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_api_access_rule_setter(struct filters_api_access_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_access_rule_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ApiAccessRuleIds\":[" ));
		for (as = args->api_access_rule_ids; *as; ++as) {
			if (as != args->api_access_rule_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->api_access_rule_ids_str) {
		ARG_TO_JSON(ApiAccessRuleIds, string, args->api_access_rule_ids_str);
		ret += 1;
	}
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->cns) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Cns\":[" ));
		for (as = args->cns; *as; ++as) {
			if (as != args->cns)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cns_str) {
		ARG_TO_JSON(Cns, string, args->cns_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_api_log_setter(struct filters_api_log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->query_access_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryAccessKeys\":[" ));
		for (as = args->query_access_keys; *as; ++as) {
			if (as != args->query_access_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_access_keys_str) {
		ARG_TO_JSON(QueryAccessKeys, string, args->query_access_keys_str);
		ret += 1;
	}
	if (args->query_api_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryApiNames\":[" ));
		for (as = args->query_api_names; *as; ++as) {
			if (as != args->query_api_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_api_names_str) {
		ARG_TO_JSON(QueryApiNames, string, args->query_api_names_str);
		ret += 1;
	}
	if (args->query_call_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryCallNames\":[" ));
		for (as = args->query_call_names; *as; ++as) {
			if (as != args->query_call_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_call_names_str) {
		ARG_TO_JSON(QueryCallNames, string, args->query_call_names_str);
		ret += 1;
	}
	if (args->query_date_after) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryDateAfter\":", args->query_date_after);
	   	ret += 1;
	}
	if (args->query_date_before) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryDateBefore\":", args->query_date_before);
	   	ret += 1;
	}
	if (args->query_ip_addresses) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryIpAddresses\":[" ));
		for (as = args->query_ip_addresses; *as; ++as) {
			if (as != args->query_ip_addresses)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_ip_addresses_str) {
		ARG_TO_JSON(QueryIpAddresses, string, args->query_ip_addresses_str);
		ret += 1;
	}
	if (args->query_user_agents) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QueryUserAgents\":[" ));
		for (as = args->query_user_agents; *as; ++as) {
			if (as != args->query_user_agents)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->query_user_agents_str) {
		ARG_TO_JSON(QueryUserAgents, string, args->query_user_agents_str);
		ret += 1;
	}
	if (args->request_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RequestIds\":[" ));
		for (as = args->request_ids; *as; ++as) {
			if (as != args->request_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->request_ids_str) {
		ARG_TO_JSON(RequestIds, string, args->request_ids_str);
		ret += 1;
	}
	if (args->response_status_codes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResponseStatusCodes\":[" ));
		for (ip = args->response_status_codes; *ip > 0; ++ip) {
			if (ip != args->response_status_codes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->response_status_codes_str) {
		ARG_TO_JSON(ResponseStatusCodes, string, args->response_status_codes_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_ca_setter(struct filters_ca *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ca_fingerprints) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaFingerprints\":[" ));
		for (as = args->ca_fingerprints; *as; ++as) {
			if (as != args->ca_fingerprints)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_fingerprints_str) {
		ARG_TO_JSON(CaFingerprints, string, args->ca_fingerprints_str);
		ret += 1;
	}
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_catalogs_setter(struct filters_catalogs *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_current_catalog_only) {
		ARG_TO_JSON(CurrentCatalogOnly, bool, args->current_catalog_only);
	   	ret += 1;
	}
	if (args->from_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromDate\":", args->from_date);
	   	ret += 1;
	}
	if (args->to_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToDate\":", args->to_date);
	   	ret += 1;
	}
	return !!ret;
}
static int filters_client_gateway_setter(struct filters_client_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bgp_asns) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BgpAsns\":[" ));
		for (ip = args->bgp_asns; *ip > 0; ++ip) {
			if (ip != args->bgp_asns)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->bgp_asns_str) {
		ARG_TO_JSON(BgpAsns, string, args->bgp_asns_str);
		ret += 1;
	}
	if (args->client_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientGatewayIds\":[" ));
		for (as = args->client_gateway_ids; *as; ++as) {
			if (as != args->client_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_gateway_ids_str) {
		ARG_TO_JSON(ClientGatewayIds, string, args->client_gateway_ids_str);
		ret += 1;
	}
	if (args->connection_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ConnectionTypes\":[" ));
		for (as = args->connection_types; *as; ++as) {
			if (as != args->connection_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->connection_types_str) {
		ARG_TO_JSON(ConnectionTypes, string, args->connection_types_str);
		ret += 1;
	}
	if (args->public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIps\":[" ));
		for (as = args->public_ips; *as; ++as) {
			if (as != args->public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->public_ips_str) {
		ARG_TO_JSON(PublicIps, string, args->public_ips_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_dedicated_group_setter(struct filters_dedicated_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->cpu_generations) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CpuGenerations\":[" ));
		for (ip = args->cpu_generations; *ip > 0; ++ip) {
			if (ip != args->cpu_generations)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cpu_generations_str) {
		ARG_TO_JSON(CpuGenerations, string, args->cpu_generations_str);
		ret += 1;
	}
	if (args->dedicated_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DedicatedGroupIds\":[" ));
		for (as = args->dedicated_group_ids; *as; ++as) {
			if (as != args->dedicated_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->dedicated_group_ids_str) {
		ARG_TO_JSON(DedicatedGroupIds, string, args->dedicated_group_ids_str);
		ret += 1;
	}
	if (args->names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Names\":[" ));
		for (as = args->names; *as; ++as) {
			if (as != args->names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->names_str) {
		ARG_TO_JSON(Names, string, args->names_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_dhcp_options_setter(struct filters_dhcp_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_default_arg) {
		ARG_TO_JSON(Default, bool, args->default_arg);
	   	ret += 1;
	}
	if (args->dhcp_options_set_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DhcpOptionsSetIds\":[" ));
		for (as = args->dhcp_options_set_ids; *as; ++as) {
			if (as != args->dhcp_options_set_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->dhcp_options_set_ids_str) {
		ARG_TO_JSON(DhcpOptionsSetIds, string, args->dhcp_options_set_ids_str);
		ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DomainNameServers\":[" ));
		for (as = args->domain_name_servers; *as; ++as) {
			if (as != args->domain_name_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->domain_name_servers_str) {
		ARG_TO_JSON(DomainNameServers, string, args->domain_name_servers_str);
		ret += 1;
	}
	if (args->domain_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DomainNames\":[" ));
		for (as = args->domain_names; *as; ++as) {
			if (as != args->domain_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->domain_names_str) {
		ARG_TO_JSON(DomainNames, string, args->domain_names_str);
		ret += 1;
	}
	if (args->log_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LogServers\":[" ));
		for (as = args->log_servers; *as; ++as) {
			if (as != args->log_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->log_servers_str) {
		ARG_TO_JSON(LogServers, string, args->log_servers_str);
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NtpServers\":[" ));
		for (as = args->ntp_servers; *as; ++as) {
			if (as != args->ntp_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ntp_servers_str) {
		ARG_TO_JSON(NtpServers, string, args->ntp_servers_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_direct_link_setter(struct filters_direct_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->direct_link_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DirectLinkIds\":[" ));
		for (as = args->direct_link_ids; *as; ++as) {
			if (as != args->direct_link_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->direct_link_ids_str) {
		ARG_TO_JSON(DirectLinkIds, string, args->direct_link_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_direct_link_interface_setter(struct filters_direct_link_interface *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->direct_link_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DirectLinkIds\":[" ));
		for (as = args->direct_link_ids; *as; ++as) {
			if (as != args->direct_link_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->direct_link_ids_str) {
		ARG_TO_JSON(DirectLinkIds, string, args->direct_link_ids_str);
		ret += 1;
	}
	if (args->direct_link_interface_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DirectLinkInterfaceIds\":[" ));
		for (as = args->direct_link_interface_ids; *as; ++as) {
			if (as != args->direct_link_interface_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->direct_link_interface_ids_str) {
		ARG_TO_JSON(DirectLinkInterfaceIds, string, args->direct_link_interface_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_export_task_setter(struct filters_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->task_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TaskIds\":[" ));
		for (as = args->task_ids; *as; ++as) {
			if (as != args->task_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->task_ids_str) {
		ARG_TO_JSON(TaskIds, string, args->task_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_flexible_gpu_setter(struct filters_flexible_gpu *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->flexible_gpu_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"FlexibleGpuIds\":[" ));
		for (as = args->flexible_gpu_ids; *as; ++as) {
			if (as != args->flexible_gpu_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->flexible_gpu_ids_str) {
		ARG_TO_JSON(FlexibleGpuIds, string, args->flexible_gpu_ids_str);
		ret += 1;
	}
	if (args->generations) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Generations\":[" ));
		for (as = args->generations; *as; ++as) {
			if (as != args->generations)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->generations_str) {
		ARG_TO_JSON(Generations, string, args->generations_str);
		ret += 1;
	}
	if (args->model_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ModelNames\":[" ));
		for (as = args->model_names; *as; ++as) {
			if (as != args->model_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->model_names_str) {
		ARG_TO_JSON(ModelNames, string, args->model_names_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_image_setter(struct filters_image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_aliases) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountAliases\":[" ));
		for (as = args->account_aliases; *as; ++as) {
			if (as != args->account_aliases)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_aliases_str) {
		ARG_TO_JSON(AccountAliases, string, args->account_aliases_str);
		ret += 1;
	}
	if (args->account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountIds\":[" ));
		for (as = args->account_ids; *as; ++as) {
			if (as != args->account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_ids_str) {
		ARG_TO_JSON(AccountIds, string, args->account_ids_str);
		ret += 1;
	}
	if (args->architectures) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Architectures\":[" ));
		for (as = args->architectures; *as; ++as) {
			if (as != args->architectures)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->architectures_str) {
		ARG_TO_JSON(Architectures, string, args->architectures_str);
		ret += 1;
	}
	if (args->is_set_block_device_mapping_delete_on_vm_deletion) {
		ARG_TO_JSON(BlockDeviceMappingDeleteOnVmDeletion, bool, args->block_device_mapping_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->block_device_mapping_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingDeviceNames\":[" ));
		for (as = args->block_device_mapping_device_names; *as; ++as) {
			if (as != args->block_device_mapping_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_device_names_str) {
		ARG_TO_JSON(BlockDeviceMappingDeviceNames, string, args->block_device_mapping_device_names_str);
		ret += 1;
	}
	if (args->block_device_mapping_snapshot_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingSnapshotIds\":[" ));
		for (as = args->block_device_mapping_snapshot_ids; *as; ++as) {
			if (as != args->block_device_mapping_snapshot_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_snapshot_ids_str) {
		ARG_TO_JSON(BlockDeviceMappingSnapshotIds, string, args->block_device_mapping_snapshot_ids_str);
		ret += 1;
	}
	if (args->block_device_mapping_volume_sizes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingVolumeSizes\":[" ));
		for (ip = args->block_device_mapping_volume_sizes; *ip > 0; ++ip) {
			if (ip != args->block_device_mapping_volume_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_volume_sizes_str) {
		ARG_TO_JSON(BlockDeviceMappingVolumeSizes, string, args->block_device_mapping_volume_sizes_str);
		ret += 1;
	}
	if (args->block_device_mapping_volume_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingVolumeTypes\":[" ));
		for (as = args->block_device_mapping_volume_types; *as; ++as) {
			if (as != args->block_device_mapping_volume_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_volume_types_str) {
		ARG_TO_JSON(BlockDeviceMappingVolumeTypes, string, args->block_device_mapping_volume_types_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->file_locations) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"FileLocations\":[" ));
		for (as = args->file_locations; *as; ++as) {
			if (as != args->file_locations)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->file_locations_str) {
		ARG_TO_JSON(FileLocations, string, args->file_locations_str);
		ret += 1;
	}
	if (args->hypervisors) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Hypervisors\":[" ));
		for (as = args->hypervisors; *as; ++as) {
			if (as != args->hypervisors)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->hypervisors_str) {
		ARG_TO_JSON(Hypervisors, string, args->hypervisors_str);
		ret += 1;
	}
	if (args->image_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ImageIds\":[" ));
		for (as = args->image_ids; *as; ++as) {
			if (as != args->image_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->image_ids_str) {
		ARG_TO_JSON(ImageIds, string, args->image_ids_str);
		ret += 1;
	}
	if (args->image_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ImageNames\":[" ));
		for (as = args->image_names; *as; ++as) {
			if (as != args->image_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->image_names_str) {
		ARG_TO_JSON(ImageNames, string, args->image_names_str);
		ret += 1;
	}
	if (args->permissions_to_launch_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PermissionsToLaunchAccountIds\":[" ));
		for (as = args->permissions_to_launch_account_ids; *as; ++as) {
			if (as != args->permissions_to_launch_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->permissions_to_launch_account_ids_str) {
		ARG_TO_JSON(PermissionsToLaunchAccountIds, string, args->permissions_to_launch_account_ids_str);
		ret += 1;
	}
	if (args->is_set_permissions_to_launch_global_permission) {
		ARG_TO_JSON(PermissionsToLaunchGlobalPermission, bool, args->permissions_to_launch_global_permission);
	   	ret += 1;
	}
	if (args->product_code_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodeNames\":[" ));
		for (as = args->product_code_names; *as; ++as) {
			if (as != args->product_code_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_code_names_str) {
		ARG_TO_JSON(ProductCodeNames, string, args->product_code_names_str);
		ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->root_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RootDeviceNames\":[" ));
		for (as = args->root_device_names; *as; ++as) {
			if (as != args->root_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->root_device_names_str) {
		ARG_TO_JSON(RootDeviceNames, string, args->root_device_names_str);
		ret += 1;
	}
	if (args->root_device_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RootDeviceTypes\":[" ));
		for (as = args->root_device_types; *as; ++as) {
			if (as != args->root_device_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->root_device_types_str) {
		ARG_TO_JSON(RootDeviceTypes, string, args->root_device_types_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->virtualization_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VirtualizationTypes\":[" ));
		for (as = args->virtualization_types; *as; ++as) {
			if (as != args->virtualization_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->virtualization_types_str) {
		ARG_TO_JSON(VirtualizationTypes, string, args->virtualization_types_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_internet_service_setter(struct filters_internet_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->internet_service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InternetServiceIds\":[" ));
		for (as = args->internet_service_ids; *as; ++as) {
			if (as != args->internet_service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->internet_service_ids_str) {
		ARG_TO_JSON(InternetServiceIds, string, args->internet_service_ids_str);
		ret += 1;
	}
	if (args->link_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNetIds\":[" ));
		for (as = args->link_net_ids; *as; ++as) {
			if (as != args->link_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_net_ids_str) {
		ARG_TO_JSON(LinkNetIds, string, args->link_net_ids_str);
		ret += 1;
	}
	if (args->link_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkStates\":[" ));
		for (as = args->link_states; *as; ++as) {
			if (as != args->link_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_states_str) {
		ARG_TO_JSON(LinkStates, string, args->link_states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_keypair_setter(struct filters_keypair *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprints) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairFingerprints\":[" ));
		for (as = args->keypair_fingerprints; *as; ++as) {
			if (as != args->keypair_fingerprints)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_fingerprints_str) {
		ARG_TO_JSON(KeypairFingerprints, string, args->keypair_fingerprints_str);
		ret += 1;
	}
	if (args->keypair_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairNames\":[" ));
		for (as = args->keypair_names; *as; ++as) {
			if (as != args->keypair_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_names_str) {
		ARG_TO_JSON(KeypairNames, string, args->keypair_names_str);
		ret += 1;
	}
	if (args->keypair_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairTypes\":[" ));
		for (as = args->keypair_types; *as; ++as) {
			if (as != args->keypair_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_types_str) {
		ARG_TO_JSON(KeypairTypes, string, args->keypair_types_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_listener_rule_setter(struct filters_listener_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->listener_rule_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ListenerRuleNames\":[" ));
		for (as = args->listener_rule_names; *as; ++as) {
			if (as != args->listener_rule_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->listener_rule_names_str) {
		ARG_TO_JSON(ListenerRuleNames, string, args->listener_rule_names_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_load_balancer_setter(struct filters_load_balancer *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->load_balancer_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerNames\":[" ));
		for (as = args->load_balancer_names; *as; ++as) {
			if (as != args->load_balancer_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_names_str) {
		ARG_TO_JSON(LoadBalancerNames, string, args->load_balancer_names_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_nat_service_setter(struct filters_nat_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->nat_service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NatServiceIds\":[" ));
		for (as = args->nat_service_ids; *as; ++as) {
			if (as != args->nat_service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nat_service_ids_str) {
		ARG_TO_JSON(NatServiceIds, string, args->nat_service_ids_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_net_setter(struct filters_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dhcp_options_set_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DhcpOptionsSetIds\":[" ));
		for (as = args->dhcp_options_set_ids; *as; ++as) {
			if (as != args->dhcp_options_set_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->dhcp_options_set_ids_str) {
		ARG_TO_JSON(DhcpOptionsSetIds, string, args->dhcp_options_set_ids_str);
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	if (args->is_set_is_default) {
		ARG_TO_JSON(IsDefault, bool, args->is_default);
	   	ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_net_access_point_setter(struct filters_net_access_point *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_access_point_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetAccessPointIds\":[" ));
		for (as = args->net_access_point_ids; *as; ++as) {
			if (as != args->net_access_point_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_access_point_ids_str) {
		ARG_TO_JSON(NetAccessPointIds, string, args->net_access_point_ids_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->service_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ServiceNames\":[" ));
		for (as = args->service_names; *as; ++as) {
			if (as != args->service_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->service_names_str) {
		ARG_TO_JSON(ServiceNames, string, args->service_names_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_net_peering_setter(struct filters_net_peering *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->accepter_net_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccepterNetAccountIds\":[" ));
		for (as = args->accepter_net_account_ids; *as; ++as) {
			if (as != args->accepter_net_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->accepter_net_account_ids_str) {
		ARG_TO_JSON(AccepterNetAccountIds, string, args->accepter_net_account_ids_str);
		ret += 1;
	}
	if (args->accepter_net_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccepterNetIpRanges\":[" ));
		for (as = args->accepter_net_ip_ranges; *as; ++as) {
			if (as != args->accepter_net_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->accepter_net_ip_ranges_str) {
		ARG_TO_JSON(AccepterNetIpRanges, string, args->accepter_net_ip_ranges_str);
		ret += 1;
	}
	if (args->accepter_net_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccepterNetNetIds\":[" ));
		for (as = args->accepter_net_net_ids; *as; ++as) {
			if (as != args->accepter_net_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->accepter_net_net_ids_str) {
		ARG_TO_JSON(AccepterNetNetIds, string, args->accepter_net_net_ids_str);
		ret += 1;
	}
	if (args->expiration_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ExpirationDates\":[" ));
		for (as = args->expiration_dates; *as; ++as) {
			if (as != args->expiration_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->expiration_dates_str) {
		ARG_TO_JSON(ExpirationDates, string, args->expiration_dates_str);
		ret += 1;
	}
	if (args->net_peering_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetPeeringIds\":[" ));
		for (as = args->net_peering_ids; *as; ++as) {
			if (as != args->net_peering_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_peering_ids_str) {
		ARG_TO_JSON(NetPeeringIds, string, args->net_peering_ids_str);
		ret += 1;
	}
	if (args->source_net_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SourceNetAccountIds\":[" ));
		for (as = args->source_net_account_ids; *as; ++as) {
			if (as != args->source_net_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->source_net_account_ids_str) {
		ARG_TO_JSON(SourceNetAccountIds, string, args->source_net_account_ids_str);
		ret += 1;
	}
	if (args->source_net_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SourceNetIpRanges\":[" ));
		for (as = args->source_net_ip_ranges; *as; ++as) {
			if (as != args->source_net_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->source_net_ip_ranges_str) {
		ARG_TO_JSON(SourceNetIpRanges, string, args->source_net_ip_ranges_str);
		ret += 1;
	}
	if (args->source_net_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SourceNetNetIds\":[" ));
		for (as = args->source_net_net_ids; *as; ++as) {
			if (as != args->source_net_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->source_net_net_ids_str) {
		ARG_TO_JSON(SourceNetNetIds, string, args->source_net_net_ids_str);
		ret += 1;
	}
	if (args->state_messages) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateMessages\":[" ));
		for (as = args->state_messages; *as; ++as) {
			if (as != args->state_messages)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_messages_str) {
		ARG_TO_JSON(StateMessages, string, args->state_messages_str);
		ret += 1;
	}
	if (args->state_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateNames\":[" ));
		for (as = args->state_names; *as; ++as) {
			if (as != args->state_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_names_str) {
		ARG_TO_JSON(StateNames, string, args->state_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_nic_setter(struct filters_nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->is_set_is_source_dest_check) {
		ARG_TO_JSON(IsSourceDestCheck, bool, args->is_source_dest_check);
	   	ret += 1;
	}
	if (args->is_set_link_nic_delete_on_vm_deletion) {
		ARG_TO_JSON(LinkNicDeleteOnVmDeletion, bool, args->link_nic_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->link_nic_device_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicDeviceNumbers\":[" ));
		for (ip = args->link_nic_device_numbers; *ip > 0; ++ip) {
			if (ip != args->link_nic_device_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_device_numbers_str) {
		ARG_TO_JSON(LinkNicDeviceNumbers, string, args->link_nic_device_numbers_str);
		ret += 1;
	}
	if (args->link_nic_link_nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicLinkNicIds\":[" ));
		for (as = args->link_nic_link_nic_ids; *as; ++as) {
			if (as != args->link_nic_link_nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_link_nic_ids_str) {
		ARG_TO_JSON(LinkNicLinkNicIds, string, args->link_nic_link_nic_ids_str);
		ret += 1;
	}
	if (args->link_nic_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicStates\":[" ));
		for (as = args->link_nic_states; *as; ++as) {
			if (as != args->link_nic_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_states_str) {
		ARG_TO_JSON(LinkNicStates, string, args->link_nic_states_str);
		ret += 1;
	}
	if (args->link_nic_vm_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicVmAccountIds\":[" ));
		for (as = args->link_nic_vm_account_ids; *as; ++as) {
			if (as != args->link_nic_vm_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_vm_account_ids_str) {
		ARG_TO_JSON(LinkNicVmAccountIds, string, args->link_nic_vm_account_ids_str);
		ret += 1;
	}
	if (args->link_nic_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNicVmIds\":[" ));
		for (as = args->link_nic_vm_ids; *as; ++as) {
			if (as != args->link_nic_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_nic_vm_ids_str) {
		ARG_TO_JSON(LinkNicVmIds, string, args->link_nic_vm_ids_str);
		ret += 1;
	}
	if (args->link_public_ip_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpAccountIds\":[" ));
		for (as = args->link_public_ip_account_ids; *as; ++as) {
			if (as != args->link_public_ip_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_account_ids_str) {
		ARG_TO_JSON(LinkPublicIpAccountIds, string, args->link_public_ip_account_ids_str);
		ret += 1;
	}
	if (args->link_public_ip_link_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpLinkPublicIpIds\":[" ));
		for (as = args->link_public_ip_link_public_ip_ids; *as; ++as) {
			if (as != args->link_public_ip_link_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_link_public_ip_ids_str) {
		ARG_TO_JSON(LinkPublicIpLinkPublicIpIds, string, args->link_public_ip_link_public_ip_ids_str);
		ret += 1;
	}
	if (args->link_public_ip_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpPublicIpIds\":[" ));
		for (as = args->link_public_ip_public_ip_ids; *as; ++as) {
			if (as != args->link_public_ip_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_public_ip_ids_str) {
		ARG_TO_JSON(LinkPublicIpPublicIpIds, string, args->link_public_ip_public_ip_ids_str);
		ret += 1;
	}
	if (args->link_public_ip_public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpPublicIps\":[" ));
		for (as = args->link_public_ip_public_ips; *as; ++as) {
			if (as != args->link_public_ip_public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_public_ips_str) {
		ARG_TO_JSON(LinkPublicIpPublicIps, string, args->link_public_ip_public_ips_str);
		ret += 1;
	}
	if (args->mac_addresses) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MacAddresses\":[" ));
		for (as = args->mac_addresses; *as; ++as) {
			if (as != args->mac_addresses)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->mac_addresses_str) {
		ARG_TO_JSON(MacAddresses, string, args->mac_addresses_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicIds\":[" ));
		for (as = args->nic_ids; *as; ++as) {
			if (as != args->nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_ids_str) {
		ARG_TO_JSON(NicIds, string, args->nic_ids_str);
		ret += 1;
	}
	if (args->private_dns_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateDnsNames\":[" ));
		for (as = args->private_dns_names; *as; ++as) {
			if (as != args->private_dns_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_dns_names_str) {
		ARG_TO_JSON(PrivateDnsNames, string, args->private_dns_names_str);
		ret += 1;
	}
	if (args->private_ips_link_public_ip_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIpsLinkPublicIpAccountIds\":[" ));
		for (as = args->private_ips_link_public_ip_account_ids; *as; ++as) {
			if (as != args->private_ips_link_public_ip_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_link_public_ip_account_ids_str) {
		ARG_TO_JSON(PrivateIpsLinkPublicIpAccountIds, string, args->private_ips_link_public_ip_account_ids_str);
		ret += 1;
	}
	if (args->private_ips_link_public_ip_public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIpsLinkPublicIpPublicIps\":[" ));
		for (as = args->private_ips_link_public_ip_public_ips; *as; ++as) {
			if (as != args->private_ips_link_public_ip_public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_link_public_ip_public_ips_str) {
		ARG_TO_JSON(PrivateIpsLinkPublicIpPublicIps, string, args->private_ips_link_public_ip_public_ips_str);
		ret += 1;
	}
	if (args->is_set_private_ips_primary_ip) {
		ARG_TO_JSON(PrivateIpsPrimaryIp, bool, args->private_ips_primary_ip);
	   	ret += 1;
	}
	if (args->private_ips_private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIpsPrivateIps\":[" ));
		for (as = args->private_ips_private_ips; *as; ++as) {
			if (as != args->private_ips_private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_private_ips_str) {
		ARG_TO_JSON(PrivateIpsPrivateIps, string, args->private_ips_private_ips_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupNames\":[" ));
		for (as = args->security_group_names; *as; ++as) {
			if (as != args->security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_names_str) {
		ARG_TO_JSON(SecurityGroupNames, string, args->security_group_names_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_product_type_setter(struct filters_product_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->product_type_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductTypeIds\":[" ));
		for (as = args->product_type_ids; *as; ++as) {
			if (as != args->product_type_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_type_ids_str) {
		ARG_TO_JSON(ProductTypeIds, string, args->product_type_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_public_ip_setter(struct filters_public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkPublicIpIds\":[" ));
		for (as = args->link_public_ip_ids; *as; ++as) {
			if (as != args->link_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_public_ip_ids_str) {
		ARG_TO_JSON(LinkPublicIpIds, string, args->link_public_ip_ids_str);
		ret += 1;
	}
	if (args->nic_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicAccountIds\":[" ));
		for (as = args->nic_account_ids; *as; ++as) {
			if (as != args->nic_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_account_ids_str) {
		ARG_TO_JSON(NicAccountIds, string, args->nic_account_ids_str);
		ret += 1;
	}
	if (args->nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicIds\":[" ));
		for (as = args->nic_ids; *as; ++as) {
			if (as != args->nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_ids_str) {
		ARG_TO_JSON(NicIds, string, args->nic_ids_str);
		ret += 1;
	}
	if (args->placements) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Placements\":[" ));
		for (as = args->placements; *as; ++as) {
			if (as != args->placements)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->placements_str) {
		ARG_TO_JSON(Placements, string, args->placements_str);
		ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIpIds\":[" ));
		for (as = args->public_ip_ids; *as; ++as) {
			if (as != args->public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->public_ip_ids_str) {
		ARG_TO_JSON(PublicIpIds, string, args->public_ip_ids_str);
		ret += 1;
	}
	if (args->public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIps\":[" ));
		for (as = args->public_ips; *as; ++as) {
			if (as != args->public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->public_ips_str) {
		ARG_TO_JSON(PublicIps, string, args->public_ips_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_quota_setter(struct filters_quota *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->collections) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Collections\":[" ));
		for (as = args->collections; *as; ++as) {
			if (as != args->collections)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->collections_str) {
		ARG_TO_JSON(Collections, string, args->collections_str);
		ret += 1;
	}
	if (args->quota_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QuotaNames\":[" ));
		for (as = args->quota_names; *as; ++as) {
			if (as != args->quota_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->quota_names_str) {
		ARG_TO_JSON(QuotaNames, string, args->quota_names_str);
		ret += 1;
	}
	if (args->quota_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"QuotaTypes\":[" ));
		for (as = args->quota_types; *as; ++as) {
			if (as != args->quota_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->quota_types_str) {
		ARG_TO_JSON(QuotaTypes, string, args->quota_types_str);
		ret += 1;
	}
	if (args->short_descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ShortDescriptions\":[" ));
		for (as = args->short_descriptions; *as; ++as) {
			if (as != args->short_descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->short_descriptions_str) {
		ARG_TO_JSON(ShortDescriptions, string, args->short_descriptions_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_route_table_setter(struct filters_route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkRouteTableIds\":[" ));
		for (as = args->link_route_table_ids; *as; ++as) {
			if (as != args->link_route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_route_table_ids_str) {
		ARG_TO_JSON(LinkRouteTableIds, string, args->link_route_table_ids_str);
		ret += 1;
	}
	if (args->link_route_table_link_route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkRouteTableLinkRouteTableIds\":[" ));
		for (as = args->link_route_table_link_route_table_ids; *as; ++as) {
			if (as != args->link_route_table_link_route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_route_table_link_route_table_ids_str) {
		ARG_TO_JSON(LinkRouteTableLinkRouteTableIds, string, args->link_route_table_link_route_table_ids_str);
		ret += 1;
	}
	if (args->is_set_link_route_table_main) {
		ARG_TO_JSON(LinkRouteTableMain, bool, args->link_route_table_main);
	   	ret += 1;
	}
	if (args->link_subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkSubnetIds\":[" ));
		for (as = args->link_subnet_ids; *as; ++as) {
			if (as != args->link_subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_subnet_ids_str) {
		ARG_TO_JSON(LinkSubnetIds, string, args->link_subnet_ids_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->route_creation_methods) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteCreationMethods\":[" ));
		for (as = args->route_creation_methods; *as; ++as) {
			if (as != args->route_creation_methods)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_creation_methods_str) {
		ARG_TO_JSON(RouteCreationMethods, string, args->route_creation_methods_str);
		ret += 1;
	}
	if (args->route_destination_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteDestinationIpRanges\":[" ));
		for (as = args->route_destination_ip_ranges; *as; ++as) {
			if (as != args->route_destination_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_destination_ip_ranges_str) {
		ARG_TO_JSON(RouteDestinationIpRanges, string, args->route_destination_ip_ranges_str);
		ret += 1;
	}
	if (args->route_destination_service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteDestinationServiceIds\":[" ));
		for (as = args->route_destination_service_ids; *as; ++as) {
			if (as != args->route_destination_service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_destination_service_ids_str) {
		ARG_TO_JSON(RouteDestinationServiceIds, string, args->route_destination_service_ids_str);
		ret += 1;
	}
	if (args->route_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteGatewayIds\":[" ));
		for (as = args->route_gateway_ids; *as; ++as) {
			if (as != args->route_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_gateway_ids_str) {
		ARG_TO_JSON(RouteGatewayIds, string, args->route_gateway_ids_str);
		ret += 1;
	}
	if (args->route_nat_service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteNatServiceIds\":[" ));
		for (as = args->route_nat_service_ids; *as; ++as) {
			if (as != args->route_nat_service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_nat_service_ids_str) {
		ARG_TO_JSON(RouteNatServiceIds, string, args->route_nat_service_ids_str);
		ret += 1;
	}
	if (args->route_net_peering_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteNetPeeringIds\":[" ));
		for (as = args->route_net_peering_ids; *as; ++as) {
			if (as != args->route_net_peering_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_net_peering_ids_str) {
		ARG_TO_JSON(RouteNetPeeringIds, string, args->route_net_peering_ids_str);
		ret += 1;
	}
	if (args->route_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteStates\":[" ));
		for (as = args->route_states; *as; ++as) {
			if (as != args->route_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_states_str) {
		ARG_TO_JSON(RouteStates, string, args->route_states_str);
		ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteTableIds\":[" ));
		for (as = args->route_table_ids; *as; ++as) {
			if (as != args->route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_table_ids_str) {
		ARG_TO_JSON(RouteTableIds, string, args->route_table_ids_str);
		ret += 1;
	}
	if (args->route_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteVmIds\":[" ));
		for (as = args->route_vm_ids; *as; ++as) {
			if (as != args->route_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_vm_ids_str) {
		ARG_TO_JSON(RouteVmIds, string, args->route_vm_ids_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_security_group_setter(struct filters_security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->inbound_rule_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleAccountIds\":[" ));
		for (as = args->inbound_rule_account_ids; *as; ++as) {
			if (as != args->inbound_rule_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_account_ids_str) {
		ARG_TO_JSON(InboundRuleAccountIds, string, args->inbound_rule_account_ids_str);
		ret += 1;
	}
	if (args->inbound_rule_from_port_ranges) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleFromPortRanges\":[" ));
		for (ip = args->inbound_rule_from_port_ranges; *ip > 0; ++ip) {
			if (ip != args->inbound_rule_from_port_ranges)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_from_port_ranges_str) {
		ARG_TO_JSON(InboundRuleFromPortRanges, string, args->inbound_rule_from_port_ranges_str);
		ret += 1;
	}
	if (args->inbound_rule_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleIpRanges\":[" ));
		for (as = args->inbound_rule_ip_ranges; *as; ++as) {
			if (as != args->inbound_rule_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_ip_ranges_str) {
		ARG_TO_JSON(InboundRuleIpRanges, string, args->inbound_rule_ip_ranges_str);
		ret += 1;
	}
	if (args->inbound_rule_protocols) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleProtocols\":[" ));
		for (as = args->inbound_rule_protocols; *as; ++as) {
			if (as != args->inbound_rule_protocols)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_protocols_str) {
		ARG_TO_JSON(InboundRuleProtocols, string, args->inbound_rule_protocols_str);
		ret += 1;
	}
	if (args->inbound_rule_security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleSecurityGroupIds\":[" ));
		for (as = args->inbound_rule_security_group_ids; *as; ++as) {
			if (as != args->inbound_rule_security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_security_group_ids_str) {
		ARG_TO_JSON(InboundRuleSecurityGroupIds, string, args->inbound_rule_security_group_ids_str);
		ret += 1;
	}
	if (args->inbound_rule_security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleSecurityGroupNames\":[" ));
		for (as = args->inbound_rule_security_group_names; *as; ++as) {
			if (as != args->inbound_rule_security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_security_group_names_str) {
		ARG_TO_JSON(InboundRuleSecurityGroupNames, string, args->inbound_rule_security_group_names_str);
		ret += 1;
	}
	if (args->inbound_rule_to_port_ranges) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRuleToPortRanges\":[" ));
		for (ip = args->inbound_rule_to_port_ranges; *ip > 0; ++ip) {
			if (ip != args->inbound_rule_to_port_ranges)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->inbound_rule_to_port_ranges_str) {
		ARG_TO_JSON(InboundRuleToPortRanges, string, args->inbound_rule_to_port_ranges_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->outbound_rule_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleAccountIds\":[" ));
		for (as = args->outbound_rule_account_ids; *as; ++as) {
			if (as != args->outbound_rule_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_account_ids_str) {
		ARG_TO_JSON(OutboundRuleAccountIds, string, args->outbound_rule_account_ids_str);
		ret += 1;
	}
	if (args->outbound_rule_from_port_ranges) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleFromPortRanges\":[" ));
		for (ip = args->outbound_rule_from_port_ranges; *ip > 0; ++ip) {
			if (ip != args->outbound_rule_from_port_ranges)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_from_port_ranges_str) {
		ARG_TO_JSON(OutboundRuleFromPortRanges, string, args->outbound_rule_from_port_ranges_str);
		ret += 1;
	}
	if (args->outbound_rule_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleIpRanges\":[" ));
		for (as = args->outbound_rule_ip_ranges; *as; ++as) {
			if (as != args->outbound_rule_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_ip_ranges_str) {
		ARG_TO_JSON(OutboundRuleIpRanges, string, args->outbound_rule_ip_ranges_str);
		ret += 1;
	}
	if (args->outbound_rule_protocols) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleProtocols\":[" ));
		for (as = args->outbound_rule_protocols; *as; ++as) {
			if (as != args->outbound_rule_protocols)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_protocols_str) {
		ARG_TO_JSON(OutboundRuleProtocols, string, args->outbound_rule_protocols_str);
		ret += 1;
	}
	if (args->outbound_rule_security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleSecurityGroupIds\":[" ));
		for (as = args->outbound_rule_security_group_ids; *as; ++as) {
			if (as != args->outbound_rule_security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_security_group_ids_str) {
		ARG_TO_JSON(OutboundRuleSecurityGroupIds, string, args->outbound_rule_security_group_ids_str);
		ret += 1;
	}
	if (args->outbound_rule_security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleSecurityGroupNames\":[" ));
		for (as = args->outbound_rule_security_group_names; *as; ++as) {
			if (as != args->outbound_rule_security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_security_group_names_str) {
		ARG_TO_JSON(OutboundRuleSecurityGroupNames, string, args->outbound_rule_security_group_names_str);
		ret += 1;
	}
	if (args->outbound_rule_to_port_ranges) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRuleToPortRanges\":[" ));
		for (ip = args->outbound_rule_to_port_ranges; *ip > 0; ++ip) {
			if (ip != args->outbound_rule_to_port_ranges)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->outbound_rule_to_port_ranges_str) {
		ARG_TO_JSON(OutboundRuleToPortRanges, string, args->outbound_rule_to_port_ranges_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupNames\":[" ));
		for (as = args->security_group_names; *as; ++as) {
			if (as != args->security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_names_str) {
		ARG_TO_JSON(SecurityGroupNames, string, args->security_group_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_server_certificate_setter(struct filters_server_certificate *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->paths) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Paths\":[" ));
		for (as = args->paths; *as; ++as) {
			if (as != args->paths)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->paths_str) {
		ARG_TO_JSON(Paths, string, args->paths_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_service_setter(struct filters_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ServiceIds\":[" ));
		for (as = args->service_ids; *as; ++as) {
			if (as != args->service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->service_ids_str) {
		ARG_TO_JSON(ServiceIds, string, args->service_ids_str);
		ret += 1;
	}
	if (args->service_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ServiceNames\":[" ));
		for (as = args->service_names; *as; ++as) {
			if (as != args->service_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->service_names_str) {
		ARG_TO_JSON(ServiceNames, string, args->service_names_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_snapshot_setter(struct filters_snapshot *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_aliases) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountAliases\":[" ));
		for (as = args->account_aliases; *as; ++as) {
			if (as != args->account_aliases)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_aliases_str) {
		ARG_TO_JSON(AccountAliases, string, args->account_aliases_str);
		ret += 1;
	}
	if (args->account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountIds\":[" ));
		for (as = args->account_ids; *as; ++as) {
			if (as != args->account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_ids_str) {
		ARG_TO_JSON(AccountIds, string, args->account_ids_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->from_creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromCreationDate\":", args->from_creation_date);
	   	ret += 1;
	}
	if (args->permissions_to_create_volume_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PermissionsToCreateVolumeAccountIds\":[" ));
		for (as = args->permissions_to_create_volume_account_ids; *as; ++as) {
			if (as != args->permissions_to_create_volume_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->permissions_to_create_volume_account_ids_str) {
		ARG_TO_JSON(PermissionsToCreateVolumeAccountIds, string, args->permissions_to_create_volume_account_ids_str);
		ret += 1;
	}
	if (args->is_set_permissions_to_create_volume_global_permission) {
		ARG_TO_JSON(PermissionsToCreateVolumeGlobalPermission, bool, args->permissions_to_create_volume_global_permission);
	   	ret += 1;
	}
	if (args->progresses) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Progresses\":[" ));
		for (ip = args->progresses; *ip > 0; ++ip) {
			if (ip != args->progresses)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->progresses_str) {
		ARG_TO_JSON(Progresses, string, args->progresses_str);
		ret += 1;
	}
	if (args->snapshot_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SnapshotIds\":[" ));
		for (as = args->snapshot_ids; *as; ++as) {
			if (as != args->snapshot_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->snapshot_ids_str) {
		ARG_TO_JSON(SnapshotIds, string, args->snapshot_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->to_creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToCreationDate\":", args->to_creation_date);
	   	ret += 1;
	}
	if (args->volume_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeIds\":[" ));
		for (as = args->volume_ids; *as; ++as) {
			if (as != args->volume_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_ids_str) {
		ARG_TO_JSON(VolumeIds, string, args->volume_ids_str);
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeSizes\":[" ));
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_sizes_str) {
		ARG_TO_JSON(VolumeSizes, string, args->volume_sizes_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_subnet_setter(struct filters_subnet *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->available_ips_counts) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AvailableIpsCounts\":[" ));
		for (ip = args->available_ips_counts; *ip > 0; ++ip) {
			if (ip != args->available_ips_counts)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->available_ips_counts_str) {
		ARG_TO_JSON(AvailableIpsCounts, string, args->available_ips_counts_str);
		ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_subregion_setter(struct filters_subregion *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->region_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RegionNames\":[" ));
		for (as = args->region_names; *as; ++as) {
			if (as != args->region_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->region_names_str) {
		ARG_TO_JSON(RegionNames, string, args->region_names_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_tag_setter(struct filters_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Keys\":[" ));
		for (as = args->keys; *as; ++as) {
			if (as != args->keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keys_str) {
		ARG_TO_JSON(Keys, string, args->keys_str);
		ret += 1;
	}
	if (args->resource_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResourceIds\":[" ));
		for (as = args->resource_ids; *as; ++as) {
			if (as != args->resource_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->resource_ids_str) {
		ARG_TO_JSON(ResourceIds, string, args->resource_ids_str);
		ret += 1;
	}
	if (args->resource_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResourceTypes\":[" ));
		for (as = args->resource_types; *as; ++as) {
			if (as != args->resource_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->resource_types_str) {
		ARG_TO_JSON(ResourceTypes, string, args->resource_types_str);
		ret += 1;
	}
	if (args->values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Values\":[" ));
		for (as = args->values; *as; ++as) {
			if (as != args->values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->values_str) {
		ARG_TO_JSON(Values, string, args->values_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_virtual_gateway_setter(struct filters_virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->connection_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ConnectionTypes\":[" ));
		for (as = args->connection_types; *as; ++as) {
			if (as != args->connection_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->connection_types_str) {
		ARG_TO_JSON(ConnectionTypes, string, args->connection_types_str);
		ret += 1;
	}
	if (args->link_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkNetIds\":[" ));
		for (as = args->link_net_ids; *as; ++as) {
			if (as != args->link_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_net_ids_str) {
		ARG_TO_JSON(LinkNetIds, string, args->link_net_ids_str);
		ret += 1;
	}
	if (args->link_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkStates\":[" ));
		for (as = args->link_states; *as; ++as) {
			if (as != args->link_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_states_str) {
		ARG_TO_JSON(LinkStates, string, args->link_states_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->virtual_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VirtualGatewayIds\":[" ));
		for (as = args->virtual_gateway_ids; *as; ++as) {
			if (as != args->virtual_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->virtual_gateway_ids_str) {
		ARG_TO_JSON(VirtualGatewayIds, string, args->virtual_gateway_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_vm_setter(struct filters_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->architectures) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Architectures\":[" ));
		for (as = args->architectures; *as; ++as) {
			if (as != args->architectures)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->architectures_str) {
		ARG_TO_JSON(Architectures, string, args->architectures_str);
		ret += 1;
	}
	if (args->is_set_block_device_mapping_delete_on_vm_deletion) {
		ARG_TO_JSON(BlockDeviceMappingDeleteOnVmDeletion, bool, args->block_device_mapping_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->block_device_mapping_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingDeviceNames\":[" ));
		for (as = args->block_device_mapping_device_names; *as; ++as) {
			if (as != args->block_device_mapping_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_device_names_str) {
		ARG_TO_JSON(BlockDeviceMappingDeviceNames, string, args->block_device_mapping_device_names_str);
		ret += 1;
	}
	if (args->block_device_mapping_link_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingLinkDates\":[" ));
		for (as = args->block_device_mapping_link_dates; *as; ++as) {
			if (as != args->block_device_mapping_link_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_link_dates_str) {
		ARG_TO_JSON(BlockDeviceMappingLinkDates, string, args->block_device_mapping_link_dates_str);
		ret += 1;
	}
	if (args->block_device_mapping_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingStates\":[" ));
		for (as = args->block_device_mapping_states; *as; ++as) {
			if (as != args->block_device_mapping_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_states_str) {
		ARG_TO_JSON(BlockDeviceMappingStates, string, args->block_device_mapping_states_str);
		ret += 1;
	}
	if (args->block_device_mapping_volume_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappingVolumeIds\":[" ));
		for (as = args->block_device_mapping_volume_ids; *as; ++as) {
			if (as != args->block_device_mapping_volume_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->block_device_mapping_volume_ids_str) {
		ARG_TO_JSON(BlockDeviceMappingVolumeIds, string, args->block_device_mapping_volume_ids_str);
		ret += 1;
	}
	if (args->client_tokens) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientTokens\":[" ));
		for (as = args->client_tokens; *as; ++as) {
			if (as != args->client_tokens)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_tokens_str) {
		ARG_TO_JSON(ClientTokens, string, args->client_tokens_str);
		ret += 1;
	}
	if (args->creation_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CreationDates\":[" ));
		for (as = args->creation_dates; *as; ++as) {
			if (as != args->creation_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->creation_dates_str) {
		ARG_TO_JSON(CreationDates, string, args->creation_dates_str);
		ret += 1;
	}
	if (args->image_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ImageIds\":[" ));
		for (as = args->image_ids; *as; ++as) {
			if (as != args->image_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->image_ids_str) {
		ARG_TO_JSON(ImageIds, string, args->image_ids_str);
		ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->keypair_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairNames\":[" ));
		for (as = args->keypair_names; *as; ++as) {
			if (as != args->keypair_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_names_str) {
		ARG_TO_JSON(KeypairNames, string, args->keypair_names_str);
		ret += 1;
	}
	if (args->launch_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LaunchNumbers\":[" ));
		for (ip = args->launch_numbers; *ip > 0; ++ip) {
			if (ip != args->launch_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->launch_numbers_str) {
		ARG_TO_JSON(LaunchNumbers, string, args->launch_numbers_str);
		ret += 1;
	}
	if (args->lifecycles) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Lifecycles\":[" ));
		for (as = args->lifecycles; *as; ++as) {
			if (as != args->lifecycles)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->lifecycles_str) {
		ARG_TO_JSON(Lifecycles, string, args->lifecycles_str);
		ret += 1;
	}
	if (args->net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetIds\":[" ));
		for (as = args->net_ids; *as; ++as) {
			if (as != args->net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->net_ids_str) {
		ARG_TO_JSON(NetIds, string, args->net_ids_str);
		ret += 1;
	}
	if (args->nic_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicAccountIds\":[" ));
		for (as = args->nic_account_ids; *as; ++as) {
			if (as != args->nic_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_account_ids_str) {
		ARG_TO_JSON(NicAccountIds, string, args->nic_account_ids_str);
		ret += 1;
	}
	if (args->nic_descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicDescriptions\":[" ));
		for (as = args->nic_descriptions; *as; ++as) {
			if (as != args->nic_descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_descriptions_str) {
		ARG_TO_JSON(NicDescriptions, string, args->nic_descriptions_str);
		ret += 1;
	}
	if (args->is_set_nic_is_source_dest_checked) {
		ARG_TO_JSON(NicIsSourceDestChecked, bool, args->nic_is_source_dest_checked);
	   	ret += 1;
	}
	if (args->is_set_nic_link_nic_delete_on_vm_deletion) {
		ARG_TO_JSON(NicLinkNicDeleteOnVmDeletion, bool, args->nic_link_nic_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->nic_link_nic_device_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicDeviceNumbers\":[" ));
		for (ip = args->nic_link_nic_device_numbers; *ip > 0; ++ip) {
			if (ip != args->nic_link_nic_device_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_device_numbers_str) {
		ARG_TO_JSON(NicLinkNicDeviceNumbers, string, args->nic_link_nic_device_numbers_str);
		ret += 1;
	}
	if (args->nic_link_nic_link_nic_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicLinkNicDates\":[" ));
		for (as = args->nic_link_nic_link_nic_dates; *as; ++as) {
			if (as != args->nic_link_nic_link_nic_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_link_nic_dates_str) {
		ARG_TO_JSON(NicLinkNicLinkNicDates, string, args->nic_link_nic_link_nic_dates_str);
		ret += 1;
	}
	if (args->nic_link_nic_link_nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicLinkNicIds\":[" ));
		for (as = args->nic_link_nic_link_nic_ids; *as; ++as) {
			if (as != args->nic_link_nic_link_nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_link_nic_ids_str) {
		ARG_TO_JSON(NicLinkNicLinkNicIds, string, args->nic_link_nic_link_nic_ids_str);
		ret += 1;
	}
	if (args->nic_link_nic_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicStates\":[" ));
		for (as = args->nic_link_nic_states; *as; ++as) {
			if (as != args->nic_link_nic_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_states_str) {
		ARG_TO_JSON(NicLinkNicStates, string, args->nic_link_nic_states_str);
		ret += 1;
	}
	if (args->nic_link_nic_vm_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicVmAccountIds\":[" ));
		for (as = args->nic_link_nic_vm_account_ids; *as; ++as) {
			if (as != args->nic_link_nic_vm_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_vm_account_ids_str) {
		ARG_TO_JSON(NicLinkNicVmAccountIds, string, args->nic_link_nic_vm_account_ids_str);
		ret += 1;
	}
	if (args->nic_link_nic_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkNicVmIds\":[" ));
		for (as = args->nic_link_nic_vm_ids; *as; ++as) {
			if (as != args->nic_link_nic_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_nic_vm_ids_str) {
		ARG_TO_JSON(NicLinkNicVmIds, string, args->nic_link_nic_vm_ids_str);
		ret += 1;
	}
	if (args->nic_link_public_ip_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkPublicIpAccountIds\":[" ));
		for (as = args->nic_link_public_ip_account_ids; *as; ++as) {
			if (as != args->nic_link_public_ip_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_public_ip_account_ids_str) {
		ARG_TO_JSON(NicLinkPublicIpAccountIds, string, args->nic_link_public_ip_account_ids_str);
		ret += 1;
	}
	if (args->nic_link_public_ip_link_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkPublicIpLinkPublicIpIds\":[" ));
		for (as = args->nic_link_public_ip_link_public_ip_ids; *as; ++as) {
			if (as != args->nic_link_public_ip_link_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_public_ip_link_public_ip_ids_str) {
		ARG_TO_JSON(NicLinkPublicIpLinkPublicIpIds, string, args->nic_link_public_ip_link_public_ip_ids_str);
		ret += 1;
	}
	if (args->nic_link_public_ip_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkPublicIpPublicIpIds\":[" ));
		for (as = args->nic_link_public_ip_public_ip_ids; *as; ++as) {
			if (as != args->nic_link_public_ip_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_public_ip_public_ip_ids_str) {
		ARG_TO_JSON(NicLinkPublicIpPublicIpIds, string, args->nic_link_public_ip_public_ip_ids_str);
		ret += 1;
	}
	if (args->nic_link_public_ip_public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicLinkPublicIpPublicIps\":[" ));
		for (as = args->nic_link_public_ip_public_ips; *as; ++as) {
			if (as != args->nic_link_public_ip_public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_link_public_ip_public_ips_str) {
		ARG_TO_JSON(NicLinkPublicIpPublicIps, string, args->nic_link_public_ip_public_ips_str);
		ret += 1;
	}
	if (args->nic_mac_addresses) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicMacAddresses\":[" ));
		for (as = args->nic_mac_addresses; *as; ++as) {
			if (as != args->nic_mac_addresses)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_mac_addresses_str) {
		ARG_TO_JSON(NicMacAddresses, string, args->nic_mac_addresses_str);
		ret += 1;
	}
	if (args->nic_net_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicNetIds\":[" ));
		for (as = args->nic_net_ids; *as; ++as) {
			if (as != args->nic_net_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_net_ids_str) {
		ARG_TO_JSON(NicNetIds, string, args->nic_net_ids_str);
		ret += 1;
	}
	if (args->nic_nic_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicNicIds\":[" ));
		for (as = args->nic_nic_ids; *as; ++as) {
			if (as != args->nic_nic_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_nic_ids_str) {
		ARG_TO_JSON(NicNicIds, string, args->nic_nic_ids_str);
		ret += 1;
	}
	if (args->nic_private_ips_link_public_ip_account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicPrivateIpsLinkPublicIpAccountIds\":[" ));
		for (as = args->nic_private_ips_link_public_ip_account_ids; *as; ++as) {
			if (as != args->nic_private_ips_link_public_ip_account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_private_ips_link_public_ip_account_ids_str) {
		ARG_TO_JSON(NicPrivateIpsLinkPublicIpAccountIds, string, args->nic_private_ips_link_public_ip_account_ids_str);
		ret += 1;
	}
	if (args->nic_private_ips_link_public_ip_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicPrivateIpsLinkPublicIpIds\":[" ));
		for (as = args->nic_private_ips_link_public_ip_ids; *as; ++as) {
			if (as != args->nic_private_ips_link_public_ip_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_private_ips_link_public_ip_ids_str) {
		ARG_TO_JSON(NicPrivateIpsLinkPublicIpIds, string, args->nic_private_ips_link_public_ip_ids_str);
		ret += 1;
	}
	if (args->is_set_nic_private_ips_primary_ip) {
		ARG_TO_JSON(NicPrivateIpsPrimaryIp, bool, args->nic_private_ips_primary_ip);
	   	ret += 1;
	}
	if (args->nic_private_ips_private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicPrivateIpsPrivateIps\":[" ));
		for (as = args->nic_private_ips_private_ips; *as; ++as) {
			if (as != args->nic_private_ips_private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_private_ips_private_ips_str) {
		ARG_TO_JSON(NicPrivateIpsPrivateIps, string, args->nic_private_ips_private_ips_str);
		ret += 1;
	}
	if (args->nic_security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicSecurityGroupIds\":[" ));
		for (as = args->nic_security_group_ids; *as; ++as) {
			if (as != args->nic_security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_security_group_ids_str) {
		ARG_TO_JSON(NicSecurityGroupIds, string, args->nic_security_group_ids_str);
		ret += 1;
	}
	if (args->nic_security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicSecurityGroupNames\":[" ));
		for (as = args->nic_security_group_names; *as; ++as) {
			if (as != args->nic_security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_security_group_names_str) {
		ARG_TO_JSON(NicSecurityGroupNames, string, args->nic_security_group_names_str);
		ret += 1;
	}
	if (args->nic_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicStates\":[" ));
		for (as = args->nic_states; *as; ++as) {
			if (as != args->nic_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_states_str) {
		ARG_TO_JSON(NicStates, string, args->nic_states_str);
		ret += 1;
	}
	if (args->nic_subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicSubnetIds\":[" ));
		for (as = args->nic_subnet_ids; *as; ++as) {
			if (as != args->nic_subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_subnet_ids_str) {
		ARG_TO_JSON(NicSubnetIds, string, args->nic_subnet_ids_str);
		ret += 1;
	}
	if (args->nic_subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NicSubregionNames\":[" ));
		for (as = args->nic_subregion_names; *as; ++as) {
			if (as != args->nic_subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->nic_subregion_names_str) {
		ARG_TO_JSON(NicSubregionNames, string, args->nic_subregion_names_str);
		ret += 1;
	}
	if (args->platforms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Platforms\":[" ));
		for (as = args->platforms; *as; ++as) {
			if (as != args->platforms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->platforms_str) {
		ARG_TO_JSON(Platforms, string, args->platforms_str);
		ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->public_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIps\":[" ));
		for (as = args->public_ips; *as; ++as) {
			if (as != args->public_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->public_ips_str) {
		ARG_TO_JSON(PublicIps, string, args->public_ips_str);
		ret += 1;
	}
	if (args->reservation_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ReservationIds\":[" ));
		for (as = args->reservation_ids; *as; ++as) {
			if (as != args->reservation_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->reservation_ids_str) {
		ARG_TO_JSON(ReservationIds, string, args->reservation_ids_str);
		ret += 1;
	}
	if (args->root_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RootDeviceNames\":[" ));
		for (as = args->root_device_names; *as; ++as) {
			if (as != args->root_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->root_device_names_str) {
		ARG_TO_JSON(RootDeviceNames, string, args->root_device_names_str);
		ret += 1;
	}
	if (args->root_device_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RootDeviceTypes\":[" ));
		for (as = args->root_device_types; *as; ++as) {
			if (as != args->root_device_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->root_device_types_str) {
		ARG_TO_JSON(RootDeviceTypes, string, args->root_device_types_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupNames\":[" ));
		for (as = args->security_group_names; *as; ++as) {
			if (as != args->security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_names_str) {
		ARG_TO_JSON(SecurityGroupNames, string, args->security_group_names_str);
		ret += 1;
	}
	if (args->state_reason_codes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateReasonCodes\":[" ));
		for (ip = args->state_reason_codes; *ip > 0; ++ip) {
			if (ip != args->state_reason_codes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_reason_codes_str) {
		ARG_TO_JSON(StateReasonCodes, string, args->state_reason_codes_str);
		ret += 1;
	}
	if (args->state_reason_messages) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateReasonMessages\":[" ));
		for (as = args->state_reason_messages; *as; ++as) {
			if (as != args->state_reason_messages)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_reason_messages_str) {
		ARG_TO_JSON(StateReasonMessages, string, args->state_reason_messages_str);
		ret += 1;
	}
	if (args->state_reasons) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"StateReasons\":[" ));
		for (as = args->state_reasons; *as; ++as) {
			if (as != args->state_reasons)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->state_reasons_str) {
		ARG_TO_JSON(StateReasons, string, args->state_reasons_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->tenancies) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tenancies\":[" ));
		for (as = args->tenancies; *as; ++as) {
			if (as != args->tenancies)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tenancies_str) {
		ARG_TO_JSON(Tenancies, string, args->tenancies_str);
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	if (args->vm_security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmSecurityGroupIds\":[" ));
		for (as = args->vm_security_group_ids; *as; ++as) {
			if (as != args->vm_security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_security_group_ids_str) {
		ARG_TO_JSON(VmSecurityGroupIds, string, args->vm_security_group_ids_str);
		ret += 1;
	}
	if (args->vm_security_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmSecurityGroupNames\":[" ));
		for (as = args->vm_security_group_names; *as; ++as) {
			if (as != args->vm_security_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_security_group_names_str) {
		ARG_TO_JSON(VmSecurityGroupNames, string, args->vm_security_group_names_str);
		ret += 1;
	}
	if (args->vm_state_codes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmStateCodes\":[" ));
		for (ip = args->vm_state_codes; *ip > 0; ++ip) {
			if (ip != args->vm_state_codes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_state_codes_str) {
		ARG_TO_JSON(VmStateCodes, string, args->vm_state_codes_str);
		ret += 1;
	}
	if (args->vm_state_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmStateNames\":[" ));
		for (as = args->vm_state_names; *as; ++as) {
			if (as != args->vm_state_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_state_names_str) {
		ARG_TO_JSON(VmStateNames, string, args->vm_state_names_str);
		ret += 1;
	}
	if (args->vm_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTypes\":[" ));
		for (as = args->vm_types; *as; ++as) {
			if (as != args->vm_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_types_str) {
		ARG_TO_JSON(VmTypes, string, args->vm_types_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_vm_group_setter(struct filters_vm_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->subnet_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubnetIds\":[" ));
		for (as = args->subnet_ids; *as; ++as) {
			if (as != args->subnet_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnet_ids_str) {
		ARG_TO_JSON(SubnetIds, string, args->subnet_ids_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_counts) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmCounts\":[" ));
		for (ip = args->vm_counts; *ip > 0; ++ip) {
			if (ip != args->vm_counts)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_counts_str) {
		ARG_TO_JSON(VmCounts, string, args->vm_counts_str);
		ret += 1;
	}
	if (args->vm_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmGroupIds\":[" ));
		for (as = args->vm_group_ids; *as; ++as) {
			if (as != args->vm_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_group_ids_str) {
		ARG_TO_JSON(VmGroupIds, string, args->vm_group_ids_str);
		ret += 1;
	}
	if (args->vm_group_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmGroupNames\":[" ));
		for (as = args->vm_group_names; *as; ++as) {
			if (as != args->vm_group_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_group_names_str) {
		ARG_TO_JSON(VmGroupNames, string, args->vm_group_names_str);
		ret += 1;
	}
	if (args->vm_template_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTemplateIds\":[" ));
		for (as = args->vm_template_ids; *as; ++as) {
			if (as != args->vm_template_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_template_ids_str) {
		ARG_TO_JSON(VmTemplateIds, string, args->vm_template_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_vm_template_setter(struct filters_vm_template *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->cpu_cores) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CpuCores\":[" ));
		for (ip = args->cpu_cores; *ip > 0; ++ip) {
			if (ip != args->cpu_cores)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cpu_cores_str) {
		ARG_TO_JSON(CpuCores, string, args->cpu_cores_str);
		ret += 1;
	}
	if (args->cpu_generations) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CpuGenerations\":[" ));
		for (as = args->cpu_generations; *as; ++as) {
			if (as != args->cpu_generations)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cpu_generations_str) {
		ARG_TO_JSON(CpuGenerations, string, args->cpu_generations_str);
		ret += 1;
	}
	if (args->cpu_performances) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CpuPerformances\":[" ));
		for (as = args->cpu_performances; *as; ++as) {
			if (as != args->cpu_performances)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cpu_performances_str) {
		ARG_TO_JSON(CpuPerformances, string, args->cpu_performances_str);
		ret += 1;
	}
	if (args->descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Descriptions\":[" ));
		for (as = args->descriptions; *as; ++as) {
			if (as != args->descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->descriptions_str) {
		ARG_TO_JSON(Descriptions, string, args->descriptions_str);
		ret += 1;
	}
	if (args->image_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ImageIds\":[" ));
		for (as = args->image_ids; *as; ++as) {
			if (as != args->image_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->image_ids_str) {
		ARG_TO_JSON(ImageIds, string, args->image_ids_str);
		ret += 1;
	}
	if (args->keypair_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"KeypairNames\":[" ));
		for (as = args->keypair_names; *as; ++as) {
			if (as != args->keypair_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->keypair_names_str) {
		ARG_TO_JSON(KeypairNames, string, args->keypair_names_str);
		ret += 1;
	}
	if (args->rams) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Rams\":[" ));
		for (ip = args->rams; *ip > 0; ++ip) {
			if (ip != args->rams)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->rams_str) {
		ARG_TO_JSON(Rams, string, args->rams_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_template_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTemplateIds\":[" ));
		for (as = args->vm_template_ids; *as; ++as) {
			if (as != args->vm_template_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_template_ids_str) {
		ARG_TO_JSON(VmTemplateIds, string, args->vm_template_ids_str);
		ret += 1;
	}
	if (args->vm_template_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTemplateNames\":[" ));
		for (as = args->vm_template_names; *as; ++as) {
			if (as != args->vm_template_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_template_names_str) {
		ARG_TO_JSON(VmTemplateNames, string, args->vm_template_names_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_vm_type_setter(struct filters_vm_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->ephemerals_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"EphemeralsTypes\":[" ));
		for (as = args->ephemerals_types; *as; ++as) {
			if (as != args->ephemerals_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ephemerals_types_str) {
		ARG_TO_JSON(EphemeralsTypes, string, args->ephemerals_types_str);
		ret += 1;
	}
	if (args->eths) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Eths\":[" ));
		for (ip = args->eths; *ip > 0; ++ip) {
			if (ip != args->eths)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->eths_str) {
		ARG_TO_JSON(Eths, string, args->eths_str);
		ret += 1;
	}
	if (args->gpus) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Gpus\":[" ));
		for (ip = args->gpus; *ip > 0; ++ip) {
			if (ip != args->gpus)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->gpus_str) {
		ARG_TO_JSON(Gpus, string, args->gpus_str);
		ret += 1;
	}
	if (args->memory_sizes) {
		double *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MemorySizes\":[" ));
		for (ip = args->memory_sizes; *ip > 0; ++ip) {
			if (ip != args->memory_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_double(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->memory_sizes_str) {
		ARG_TO_JSON(MemorySizes, string, args->memory_sizes_str);
		ret += 1;
	}
	if (args->vcore_counts) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VcoreCounts\":[" ));
		for (ip = args->vcore_counts; *ip > 0; ++ip) {
			if (ip != args->vcore_counts)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vcore_counts_str) {
		ARG_TO_JSON(VcoreCounts, string, args->vcore_counts_str);
		ret += 1;
	}
	if (args->vm_type_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmTypeNames\":[" ));
		for (as = args->vm_type_names; *as; ++as) {
			if (as != args->vm_type_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_type_names_str) {
		ARG_TO_JSON(VmTypeNames, string, args->vm_type_names_str);
		ret += 1;
	}
	if (args->volume_counts) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeCounts\":[" ));
		for (ip = args->volume_counts; *ip > 0; ++ip) {
			if (ip != args->volume_counts)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_counts_str) {
		ARG_TO_JSON(VolumeCounts, string, args->volume_counts_str);
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeSizes\":[" ));
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_sizes_str) {
		ARG_TO_JSON(VolumeSizes, string, args->volume_sizes_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_vms_state_setter(struct filters_vms_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->maintenance_event_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEventCodes\":[" ));
		for (as = args->maintenance_event_codes; *as; ++as) {
			if (as != args->maintenance_event_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->maintenance_event_codes_str) {
		ARG_TO_JSON(MaintenanceEventCodes, string, args->maintenance_event_codes_str);
		ret += 1;
	}
	if (args->maintenance_event_descriptions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEventDescriptions\":[" ));
		for (as = args->maintenance_event_descriptions; *as; ++as) {
			if (as != args->maintenance_event_descriptions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->maintenance_event_descriptions_str) {
		ARG_TO_JSON(MaintenanceEventDescriptions, string, args->maintenance_event_descriptions_str);
		ret += 1;
	}
	if (args->maintenance_events_not_after) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEventsNotAfter\":[" ));
		for (as = args->maintenance_events_not_after; *as; ++as) {
			if (as != args->maintenance_events_not_after)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->maintenance_events_not_after_str) {
		ARG_TO_JSON(MaintenanceEventsNotAfter, string, args->maintenance_events_not_after_str);
		ret += 1;
	}
	if (args->maintenance_events_not_before) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEventsNotBefore\":[" ));
		for (as = args->maintenance_events_not_before; *as; ++as) {
			if (as != args->maintenance_events_not_before)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->maintenance_events_not_before_str) {
		ARG_TO_JSON(MaintenanceEventsNotBefore, string, args->maintenance_events_not_before_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	if (args->vm_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmStates\":[" ));
		for (as = args->vm_states; *as; ++as) {
			if (as != args->vm_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_states_str) {
		ARG_TO_JSON(VmStates, string, args->vm_states_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_volume_setter(struct filters_volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CreationDates\":[" ));
		for (as = args->creation_dates; *as; ++as) {
			if (as != args->creation_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->creation_dates_str) {
		ARG_TO_JSON(CreationDates, string, args->creation_dates_str);
		ret += 1;
	}
	if (args->is_set_link_volume_delete_on_vm_deletion) {
		ARG_TO_JSON(LinkVolumeDeleteOnVmDeletion, bool, args->link_volume_delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->link_volume_device_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkVolumeDeviceNames\":[" ));
		for (as = args->link_volume_device_names; *as; ++as) {
			if (as != args->link_volume_device_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_volume_device_names_str) {
		ARG_TO_JSON(LinkVolumeDeviceNames, string, args->link_volume_device_names_str);
		ret += 1;
	}
	if (args->link_volume_link_dates) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkVolumeLinkDates\":[" ));
		for (as = args->link_volume_link_dates; *as; ++as) {
			if (as != args->link_volume_link_dates)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_volume_link_dates_str) {
		ARG_TO_JSON(LinkVolumeLinkDates, string, args->link_volume_link_dates_str);
		ret += 1;
	}
	if (args->link_volume_link_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkVolumeLinkStates\":[" ));
		for (as = args->link_volume_link_states; *as; ++as) {
			if (as != args->link_volume_link_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_volume_link_states_str) {
		ARG_TO_JSON(LinkVolumeLinkStates, string, args->link_volume_link_states_str);
		ret += 1;
	}
	if (args->link_volume_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkVolumeVmIds\":[" ));
		for (as = args->link_volume_vm_ids; *as; ++as) {
			if (as != args->link_volume_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->link_volume_vm_ids_str) {
		ARG_TO_JSON(LinkVolumeVmIds, string, args->link_volume_vm_ids_str);
		ret += 1;
	}
	if (args->snapshot_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SnapshotIds\":[" ));
		for (as = args->snapshot_ids; *as; ++as) {
			if (as != args->snapshot_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->snapshot_ids_str) {
		ARG_TO_JSON(SnapshotIds, string, args->snapshot_ids_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->volume_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeIds\":[" ));
		for (as = args->volume_ids; *as; ++as) {
			if (as != args->volume_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_ids_str) {
		ARG_TO_JSON(VolumeIds, string, args->volume_ids_str);
		ret += 1;
	}
	if (args->volume_sizes) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeSizes\":[" ));
		for (ip = args->volume_sizes; *ip > 0; ++ip) {
			if (ip != args->volume_sizes)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_sizes_str) {
		ARG_TO_JSON(VolumeSizes, string, args->volume_sizes_str);
		ret += 1;
	}
	if (args->volume_states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeStates\":[" ));
		for (as = args->volume_states; *as; ++as) {
			if (as != args->volume_states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_states_str) {
		ARG_TO_JSON(VolumeStates, string, args->volume_states_str);
		ret += 1;
	}
	if (args->volume_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VolumeTypes\":[" ));
		for (as = args->volume_types; *as; ++as) {
			if (as != args->volume_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->volume_types_str) {
		ARG_TO_JSON(VolumeTypes, string, args->volume_types_str);
		ret += 1;
	}
	return !!ret;
}
static int filters_vpn_connection_setter(struct filters_vpn_connection *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->bgp_asns) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BgpAsns\":[" ));
		for (ip = args->bgp_asns; *ip > 0; ++ip) {
			if (ip != args->bgp_asns)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->bgp_asns_str) {
		ARG_TO_JSON(BgpAsns, string, args->bgp_asns_str);
		ret += 1;
	}
	if (args->client_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ClientGatewayIds\":[" ));
		for (as = args->client_gateway_ids; *as; ++as) {
			if (as != args->client_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->client_gateway_ids_str) {
		ARG_TO_JSON(ClientGatewayIds, string, args->client_gateway_ids_str);
		ret += 1;
	}
	if (args->connection_types) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ConnectionTypes\":[" ));
		for (as = args->connection_types; *as; ++as) {
			if (as != args->connection_types)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->connection_types_str) {
		ARG_TO_JSON(ConnectionTypes, string, args->connection_types_str);
		ret += 1;
	}
	if (args->route_destination_ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteDestinationIpRanges\":[" ));
		for (as = args->route_destination_ip_ranges; *as; ++as) {
			if (as != args->route_destination_ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_destination_ip_ranges_str) {
		ARG_TO_JSON(RouteDestinationIpRanges, string, args->route_destination_ip_ranges_str);
		ret += 1;
	}
	if (args->states) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"States\":[" ));
		for (as = args->states; *as; ++as) {
			if (as != args->states)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->states_str) {
		ARG_TO_JSON(States, string, args->states_str);
		ret += 1;
	}
	if (args->is_set_static_routes_only) {
		ARG_TO_JSON(StaticRoutesOnly, bool, args->static_routes_only);
	   	ret += 1;
	}
	if (args->tag_keys) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagKeys\":[" ));
		for (as = args->tag_keys; *as; ++as) {
			if (as != args->tag_keys)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_keys_str) {
		ARG_TO_JSON(TagKeys, string, args->tag_keys_str);
		ret += 1;
	}
	if (args->tag_values) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"TagValues\":[" ));
		for (as = args->tag_values; *as; ++as) {
			if (as != args->tag_values)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tag_values_str) {
		ARG_TO_JSON(TagValues, string, args->tag_values_str);
		ret += 1;
	}
	if (args->tags) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (as = args->tags; *as; ++as) {
			if (as != args->tags)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->virtual_gateway_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VirtualGatewayIds\":[" ));
		for (as = args->virtual_gateway_ids; *as; ++as) {
			if (as != args->virtual_gateway_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->virtual_gateway_ids_str) {
		ARG_TO_JSON(VirtualGatewayIds, string, args->virtual_gateway_ids_str);
		ret += 1;
	}
	if (args->vpn_connection_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VpnConnectionIds\":[" ));
		for (as = args->vpn_connection_ids; *as; ++as) {
			if (as != args->vpn_connection_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vpn_connection_ids_str) {
		ARG_TO_JSON(VpnConnectionIds, string, args->vpn_connection_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int flexible_gpu_setter(struct flexible_gpu *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	if (args->generation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Generation\":", args->generation);
	   	ret += 1;
	}
	if (args->model_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ModelName\":", args->model_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	return !!ret;
}
static int flexible_gpu_catalog_setter(struct flexible_gpu_catalog *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->generations) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Generations\":[" ));
		for (as = args->generations; *as; ++as) {
			if (as != args->generations)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->generations_str) {
		ARG_TO_JSON(Generations, string, args->generations_str);
		ret += 1;
	}
	if (args->is_set_max_cpu || args->max_cpu) {
		ARG_TO_JSON(MaxCpu, int, args->max_cpu);
	   	ret += 1;
	}
	if (args->is_set_max_ram || args->max_ram) {
		ARG_TO_JSON(MaxRam, int, args->max_ram);
	   	ret += 1;
	}
	if (args->model_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ModelName\":", args->model_name);
	   	ret += 1;
	}
	if (args->is_set_vram || args->vram) {
		ARG_TO_JSON(VRam, int, args->vram);
	   	ret += 1;
	}
	return !!ret;
}
static int health_check_setter(struct health_check *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_check_interval || args->check_interval) {
		ARG_TO_JSON(CheckInterval, int, args->check_interval);
	   	ret += 1;
	}
	if (args->is_set_healthy_threshold || args->healthy_threshold) {
		ARG_TO_JSON(HealthyThreshold, int, args->healthy_threshold);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->is_set_port || args->port) {
		ARG_TO_JSON(Port, int, args->port);
	   	ret += 1;
	}
	if (args->protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Protocol\":", args->protocol);
	   	ret += 1;
	}
	if (args->is_set_timeout || args->timeout) {
		ARG_TO_JSON(Timeout, int, args->timeout);
	   	ret += 1;
	}
	if (args->is_set_unhealthy_threshold || args->unhealthy_threshold) {
		ARG_TO_JSON(UnhealthyThreshold, int, args->unhealthy_threshold);
	   	ret += 1;
	}
	return !!ret;
}
static int image_setter(struct image *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_alias) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountAlias\":", args->account_alias);
	   	ret += 1;
	}
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->architecture) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Architecture\":", args->architecture);
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_image *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_image_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->file_location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FileLocation\":", args->file_location);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->image_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageName\":", args->image_name);
	   	ret += 1;
	}
	if (args->image_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageType\":", args->image_type);
	   	ret += 1;
	}
	if (args->permissions_to_launch_str) {
		ARG_TO_JSON(PermissionsToLaunch, string, args->permissions_to_launch_str);
		ret += 1;
	} else if (args->is_set_permissions_to_launch) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"PermissionsToLaunch\": { " ));
	       STRY(permissions_on_resource_setter(&args->permissions_to_launch, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->root_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceName\":", args->root_device_name);
	   	ret += 1;
	}
	if (args->root_device_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceType\":", args->root_device_type);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->state_comment_str) {
		ARG_TO_JSON(StateComment, string, args->state_comment_str);
		ret += 1;
	} else if (args->is_set_state_comment) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"StateComment\": { " ));
	       STRY(state_comment_setter(&args->state_comment, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int image_export_task_setter(struct image_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->comment) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Comment\":", args->comment);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->osu_export_str) {
		ARG_TO_JSON(OsuExport, string, args->osu_export_str);
		ret += 1;
	} else if (args->is_set_osu_export) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuExport\": { " ));
	       STRY(osu_export_image_export_task_setter(&args->osu_export, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		ARG_TO_JSON(Progress, int, args->progress);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->task_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"TaskId\":", args->task_id);
	   	ret += 1;
	}
	return !!ret;
}
static int internet_service_setter(struct internet_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->internet_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InternetServiceId\":", args->internet_service_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int keypair_setter(struct keypair *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprint) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairFingerprint\":", args->keypair_fingerprint);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->keypair_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairType\":", args->keypair_type);
	   	ret += 1;
	}
	return !!ret;
}
static int keypair_created_setter(struct keypair_created *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->keypair_fingerprint) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairFingerprint\":", args->keypair_fingerprint);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->keypair_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairType\":", args->keypair_type);
	   	ret += 1;
	}
	if (args->private_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateKey\":", args->private_key);
	   	ret += 1;
	}
	return !!ret;
}
static int link_nic_setter(struct link_nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		ARG_TO_JSON(DeviceNumber, int, args->device_number);
	   	ret += 1;
	}
	if (args->link_nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkNicId\":", args->link_nic_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->vm_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmAccountId\":", args->vm_account_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	return !!ret;
}
static int link_nic_light_setter(struct link_nic_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		ARG_TO_JSON(DeviceNumber, int, args->device_number);
	   	ret += 1;
	}
	if (args->link_nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkNicId\":", args->link_nic_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	return !!ret;
}
static int link_nic_to_update_setter(struct link_nic_to_update *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->link_nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkNicId\":", args->link_nic_id);
	   	ret += 1;
	}
	return !!ret;
}
static int link_public_ip_setter(struct link_public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkPublicIpId\":", args->link_public_ip_id);
	   	ret += 1;
	}
	if (args->public_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicDnsName\":", args->public_dns_name);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpAccountId\":", args->public_ip_account_id);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
	return !!ret;
}
static int link_public_ip_light_for_vm_setter(struct link_public_ip_light_for_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->public_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicDnsName\":", args->public_dns_name);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpAccountId\":", args->public_ip_account_id);
	   	ret += 1;
	}
	return !!ret;
}
static int link_route_table_setter(struct link_route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkRouteTableId\":", args->link_route_table_id);
	   	ret += 1;
	}
	if (args->is_set_main) {
		ARG_TO_JSON(Main, bool, args->main);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	return !!ret;
}
static int linked_policy_setter(struct linked_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Orn\":", args->orn);
	   	ret += 1;
	}
	if (args->policy_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyId\":", args->policy_id);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	return !!ret;
}
static int linked_volume_setter(struct linked_volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	return !!ret;
}
static int listener_setter(struct listener *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_backend_port || args->backend_port) {
		ARG_TO_JSON(BackendPort, int, args->backend_port);
	   	ret += 1;
	}
	if (args->backend_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BackendProtocol\":", args->backend_protocol);
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		ARG_TO_JSON(LoadBalancerPort, int, args->load_balancer_port);
	   	ret += 1;
	}
	if (args->load_balancer_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerProtocol\":", args->load_balancer_protocol);
	   	ret += 1;
	}
	if (args->policy_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PolicyNames\":[" ));
		for (as = args->policy_names; *as; ++as) {
			if (as != args->policy_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->policy_names_str) {
		ARG_TO_JSON(PolicyNames, string, args->policy_names_str);
		ret += 1;
	}
	if (args->server_certificate_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServerCertificateId\":", args->server_certificate_id);
	   	ret += 1;
	}
	return !!ret;
}
static int listener_for_creation_setter(struct listener_for_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_backend_port || args->backend_port) {
		ARG_TO_JSON(BackendPort, int, args->backend_port);
	   	ret += 1;
	}
	if (args->backend_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"BackendProtocol\":", args->backend_protocol);
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		ARG_TO_JSON(LoadBalancerPort, int, args->load_balancer_port);
	   	ret += 1;
	}
	if (args->load_balancer_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerProtocol\":", args->load_balancer_protocol);
	   	ret += 1;
	}
	if (args->server_certificate_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServerCertificateId\":", args->server_certificate_id);
	   	ret += 1;
	}
	return !!ret;
}
static int listener_rule_setter(struct listener_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->action) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Action\":", args->action);
	   	ret += 1;
	}
	if (args->host_name_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"HostNamePattern\":", args->host_name_pattern);
	   	ret += 1;
	}
	if (args->is_set_listener_id || args->listener_id) {
		ARG_TO_JSON(ListenerId, int, args->listener_id);
	   	ret += 1;
	}
	if (args->is_set_listener_rule_id || args->listener_rule_id) {
		ARG_TO_JSON(ListenerRuleId, int, args->listener_rule_id);
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ListenerRuleName\":", args->listener_rule_name);
	   	ret += 1;
	}
	if (args->path_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPattern\":", args->path_pattern);
	   	ret += 1;
	}
	if (args->is_set_priority || args->priority) {
		ARG_TO_JSON(Priority, int, args->priority);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	return !!ret;
}
static int listener_rule_for_creation_setter(struct listener_rule_for_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->action) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Action\":", args->action);
	   	ret += 1;
	}
	if (args->host_name_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"HostNamePattern\":", args->host_name_pattern);
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ListenerRuleName\":", args->listener_rule_name);
	   	ret += 1;
	}
	if (args->path_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPattern\":", args->path_pattern);
	   	ret += 1;
	}
	if (args->is_set_priority || args->priority) {
		ARG_TO_JSON(Priority, int, args->priority);
	   	ret += 1;
	}
	return !!ret;
}
static int load_balancer_setter(struct load_balancer *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->access_log_str) {
		ARG_TO_JSON(AccessLog, string, args->access_log_str);
		ret += 1;
	} else if (args->is_set_access_log) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"AccessLog\": { " ));
	       STRY(access_log_setter(&args->access_log, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->application_sticky_cookie_policies) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ApplicationStickyCookiePolicies\":[" ));
		for (int i = 0; i < args->nb_application_sticky_cookie_policies; ++i) {
	       	    struct application_sticky_cookie_policy *p = &args->application_sticky_cookie_policies[i];
		    if (p != args->application_sticky_cookie_policies)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(application_sticky_cookie_policy_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->application_sticky_cookie_policies_str) {
		ARG_TO_JSON(ApplicationStickyCookiePolicies, string, args->application_sticky_cookie_policies_str);
		ret += 1;
	}
	if (args->backend_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendIps\":[" ));
		for (as = args->backend_ips; *as; ++as) {
			if (as != args->backend_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_ips_str) {
		ARG_TO_JSON(BackendIps, string, args->backend_ips_str);
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DnsName\":", args->dns_name);
	   	ret += 1;
	}
	if (args->health_check_str) {
		ARG_TO_JSON(HealthCheck, string, args->health_check_str);
		ret += 1;
	} else if (args->is_set_health_check) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"HealthCheck\": { " ));
	       STRY(health_check_setter(&args->health_check, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->listeners) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Listeners\":[" ));
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener *p = &args->listeners[i];
		    if (p != args->listeners)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(listener_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->listeners_str) {
		ARG_TO_JSON(Listeners, string, args->listeners_str);
		ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
        if (args->load_balancer_sticky_cookie_policies) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerStickyCookiePolicies\":[" ));
		for (int i = 0; i < args->nb_load_balancer_sticky_cookie_policies; ++i) {
	       	    struct load_balancer_sticky_cookie_policy *p = &args->load_balancer_sticky_cookie_policies[i];
		    if (p != args->load_balancer_sticky_cookie_policies)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(load_balancer_sticky_cookie_policy_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->load_balancer_sticky_cookie_policies_str) {
		ARG_TO_JSON(LoadBalancerStickyCookiePolicies, string, args->load_balancer_sticky_cookie_policies_str);
		ret += 1;
	}
	if (args->load_balancer_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerType\":", args->load_balancer_type);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->is_set_secured_cookies) {
		ARG_TO_JSON(SecuredCookies, bool, args->secured_cookies);
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (as = args->security_groups; *as; ++as) {
			if (as != args->security_groups)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->source_security_group_str) {
		ARG_TO_JSON(SourceSecurityGroup, string, args->source_security_group_str);
		ret += 1;
	} else if (args->is_set_source_security_group) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"SourceSecurityGroup\": { " ));
	       STRY(source_security_group_setter(&args->source_security_group, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->subnets) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Subnets\":[" ));
		for (as = args->subnets; *as; ++as) {
			if (as != args->subnets)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnets_str) {
		ARG_TO_JSON(Subnets, string, args->subnets_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int load_balancer_light_setter(struct load_balancer_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		ARG_TO_JSON(LoadBalancerPort, int, args->load_balancer_port);
	   	ret += 1;
	}
	return !!ret;
}
static int load_balancer_sticky_cookie_policy_setter(struct load_balancer_sticky_cookie_policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_cookie_expiration_period || args->cookie_expiration_period) {
		ARG_TO_JSON(CookieExpirationPeriod, int, args->cookie_expiration_period);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	return !!ret;
}
static int load_balancer_tag_setter(struct load_balancer_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Key\":", args->key);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->value) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Value\":", args->value);
	   	ret += 1;
	}
	return !!ret;
}
static int location_setter(struct location *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Code\":", args->code);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	return !!ret;
}
static int log_setter(struct log *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->is_set_call_duration || args->call_duration) {
		ARG_TO_JSON(CallDuration, int, args->call_duration);
	   	ret += 1;
	}
	if (args->query_access_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryAccessKey\":", args->query_access_key);
	   	ret += 1;
	}
	if (args->query_api_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryApiName\":", args->query_api_name);
	   	ret += 1;
	}
	if (args->query_api_version) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryApiVersion\":", args->query_api_version);
	   	ret += 1;
	}
	if (args->query_call_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryCallName\":", args->query_call_name);
	   	ret += 1;
	}
	if (args->query_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryDate\":", args->query_date);
	   	ret += 1;
	}
	if (args->query_header_raw) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryHeaderRaw\":", args->query_header_raw);
	   	ret += 1;
	}
	if (args->is_set_query_header_size || args->query_header_size) {
		ARG_TO_JSON(QueryHeaderSize, int, args->query_header_size);
	   	ret += 1;
	}
	if (args->query_ip_address) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryIpAddress\":", args->query_ip_address);
	   	ret += 1;
	}
	if (args->query_payload_raw) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryPayloadRaw\":", args->query_payload_raw);
	   	ret += 1;
	}
	if (args->is_set_query_payload_size || args->query_payload_size) {
		ARG_TO_JSON(QueryPayloadSize, int, args->query_payload_size);
	   	ret += 1;
	}
	if (args->query_user_agent) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QueryUserAgent\":", args->query_user_agent);
	   	ret += 1;
	}
	if (args->request_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RequestId\":", args->request_id);
	   	ret += 1;
	}
	if (args->is_set_response_size || args->response_size) {
		ARG_TO_JSON(ResponseSize, int, args->response_size);
	   	ret += 1;
	}
	if (args->is_set_response_status_code || args->response_status_code) {
		ARG_TO_JSON(ResponseStatusCode, int, args->response_status_code);
	   	ret += 1;
	}
	return !!ret;
}
static int maintenance_event_setter(struct maintenance_event *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Code\":", args->code);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->not_after) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NotAfter\":", args->not_after);
	   	ret += 1;
	}
	if (args->not_before) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NotBefore\":", args->not_before);
	   	ret += 1;
	}
	return !!ret;
}
static int nat_service_setter(struct nat_service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
        if (args->public_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PublicIps\":[" ));
		for (int i = 0; i < args->nb_public_ips; ++i) {
	       	    struct public_ip_light *p = &args->public_ips[i];
		    if (p != args->public_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(public_ip_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->public_ips_str) {
		ARG_TO_JSON(PublicIps, string, args->public_ips_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int net_setter(struct net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dhcp_options_set_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DhcpOptionsSetId\":", args->dhcp_options_set_id);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->tenancy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tenancy\":", args->tenancy);
	   	ret += 1;
	}
	return !!ret;
}
static int net_access_point_setter(struct net_access_point *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_access_point_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetAccessPointId\":", args->net_access_point_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteTableIds\":[" ));
		for (as = args->route_table_ids; *as; ++as) {
			if (as != args->route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_table_ids_str) {
		ARG_TO_JSON(RouteTableIds, string, args->route_table_ids_str);
		ret += 1;
	}
	if (args->service_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServiceName\":", args->service_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int net_peering_setter(struct net_peering *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->accepter_net_str) {
		ARG_TO_JSON(AccepterNet, string, args->accepter_net_str);
		ret += 1;
	} else if (args->is_set_accepter_net) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"AccepterNet\": { " ));
	       STRY(accepter_net_setter(&args->accepter_net, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	if (args->source_net_str) {
		ARG_TO_JSON(SourceNet, string, args->source_net_str);
		ret += 1;
	} else if (args->is_set_source_net) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"SourceNet\": { " ));
	       STRY(source_net_setter(&args->source_net, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->state_str) {
		ARG_TO_JSON(State, string, args->state_str);
		ret += 1;
	} else if (args->is_set_state) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"State\": { " ));
	       STRY(net_peering_state_setter(&args->state, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int net_peering_state_setter(struct net_peering_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->message) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Message\":", args->message);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	return !!ret;
}
static int net_to_virtual_gateway_link_setter(struct net_to_virtual_gateway_link *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	return !!ret;
}
static int nic_setter(struct nic *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->link_nic_str) {
		ARG_TO_JSON(LinkNic, string, args->link_nic_str);
		ret += 1;
	} else if (args->is_set_link_nic) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkNic\": { " ));
	       STRY(link_nic_setter(&args->link_nic, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->link_public_ip_str) {
		ARG_TO_JSON(LinkPublicIp, string, args->link_public_ip_str);
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkPublicIp\": { " ));
	       STRY(link_public_ip_setter(&args->link_public_ip, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->mac_address) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MacAddress\":", args->mac_address);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
        if (args->private_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(private_ip_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
        if (args->security_groups) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int nic_for_vm_creation_setter(struct nic_for_vm_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_device_number || args->device_number) {
		ARG_TO_JSON(DeviceNumber, int, args->device_number);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
        if (args->private_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(private_ip_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->is_set_secondary_private_ip_count || args->secondary_private_ip_count) {
		ARG_TO_JSON(SecondaryPrivateIpCount, int, args->secondary_private_ip_count);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	return !!ret;
}
static int nic_light_setter(struct nic_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->link_nic_str) {
		ARG_TO_JSON(LinkNic, string, args->link_nic_str);
		ret += 1;
	} else if (args->is_set_link_nic) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkNic\": { " ));
	       STRY(link_nic_light_setter(&args->link_nic, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->link_public_ip_str) {
		ARG_TO_JSON(LinkPublicIp, string, args->link_public_ip_str);
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkPublicIp\": { " ));
	       STRY(link_public_ip_light_for_vm_setter(&args->link_public_ip, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->mac_address) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MacAddress\":", args->mac_address);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
        if (args->private_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light_for_vm *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(private_ip_light_for_vm_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
        if (args->security_groups) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	return !!ret;
}
static int osu_api_key_setter(struct osu_api_key *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->api_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ApiKeyId\":", args->api_key_id);
	   	ret += 1;
	}
	if (args->secret_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecretKey\":", args->secret_key);
	   	ret += 1;
	}
	return !!ret;
}
static int osu_export_image_export_task_setter(struct osu_export_image_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DiskImageFormat\":", args->disk_image_format);
	   	ret += 1;
	}
	if (args->osu_bucket) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucket\":", args->osu_bucket);
	   	ret += 1;
	}
	if (args->osu_manifest_url) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuManifestUrl\":", args->osu_manifest_url);
	   	ret += 1;
	}
	if (args->osu_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuPrefix\":", args->osu_prefix);
	   	ret += 1;
	}
	return !!ret;
}
static int osu_export_snapshot_export_task_setter(struct osu_export_snapshot_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DiskImageFormat\":", args->disk_image_format);
	   	ret += 1;
	}
	if (args->osu_bucket) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucket\":", args->osu_bucket);
	   	ret += 1;
	}
	if (args->osu_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuPrefix\":", args->osu_prefix);
	   	ret += 1;
	}
	return !!ret;
}
static int osu_export_to_create_setter(struct osu_export_to_create *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->disk_image_format) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DiskImageFormat\":", args->disk_image_format);
	   	ret += 1;
	}
	if (args->osu_api_key_str) {
		ARG_TO_JSON(OsuApiKey, string, args->osu_api_key_str);
		ret += 1;
	} else if (args->is_set_osu_api_key) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuApiKey\": { " ));
	       STRY(osu_api_key_setter(&args->osu_api_key, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->osu_bucket) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuBucket\":", args->osu_bucket);
	   	ret += 1;
	}
	if (args->osu_manifest_url) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuManifestUrl\":", args->osu_manifest_url);
	   	ret += 1;
	}
	if (args->osu_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsuPrefix\":", args->osu_prefix);
	   	ret += 1;
	}
	return !!ret;
}
static int permissions_on_resource_setter(struct permissions_on_resource *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AccountIds\":[" ));
		for (as = args->account_ids; *as; ++as) {
			if (as != args->account_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->account_ids_str) {
		ARG_TO_JSON(AccountIds, string, args->account_ids_str);
		ret += 1;
	}
	if (args->is_set_global_permission) {
		ARG_TO_JSON(GlobalPermission, bool, args->global_permission);
	   	ret += 1;
	}
	return !!ret;
}
static int permissions_on_resource_creation_setter(struct permissions_on_resource_creation *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->additions_str) {
		ARG_TO_JSON(Additions, string, args->additions_str);
		ret += 1;
	} else if (args->is_set_additions) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Additions\": { " ));
	       STRY(permissions_on_resource_setter(&args->additions, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->removals_str) {
		ARG_TO_JSON(Removals, string, args->removals_str);
		ret += 1;
	} else if (args->is_set_removals) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Removals\": { " ));
	       STRY(permissions_on_resource_setter(&args->removals, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	return !!ret;
}
static int phase1_options_setter(struct phase1_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->dpd_timeout_action) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DpdTimeoutAction\":", args->dpd_timeout_action);
	   	ret += 1;
	}
	if (args->is_set_dpd_timeout_seconds || args->dpd_timeout_seconds) {
		ARG_TO_JSON(DpdTimeoutSeconds, int, args->dpd_timeout_seconds);
	   	ret += 1;
	}
	if (args->ike_versions) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IkeVersions\":[" ));
		for (as = args->ike_versions; *as; ++as) {
			if (as != args->ike_versions)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ike_versions_str) {
		ARG_TO_JSON(IkeVersions, string, args->ike_versions_str);
		ret += 1;
	}
	if (args->phase1_dh_group_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase1DhGroupNumbers\":[" ));
		for (ip = args->phase1_dh_group_numbers; *ip > 0; ++ip) {
			if (ip != args->phase1_dh_group_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase1_dh_group_numbers_str) {
		ARG_TO_JSON(Phase1DhGroupNumbers, string, args->phase1_dh_group_numbers_str);
		ret += 1;
	}
	if (args->phase1_encryption_algorithms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase1EncryptionAlgorithms\":[" ));
		for (as = args->phase1_encryption_algorithms; *as; ++as) {
			if (as != args->phase1_encryption_algorithms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase1_encryption_algorithms_str) {
		ARG_TO_JSON(Phase1EncryptionAlgorithms, string, args->phase1_encryption_algorithms_str);
		ret += 1;
	}
	if (args->phase1_integrity_algorithms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase1IntegrityAlgorithms\":[" ));
		for (as = args->phase1_integrity_algorithms; *as; ++as) {
			if (as != args->phase1_integrity_algorithms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase1_integrity_algorithms_str) {
		ARG_TO_JSON(Phase1IntegrityAlgorithms, string, args->phase1_integrity_algorithms_str);
		ret += 1;
	}
	if (args->is_set_phase1_lifetime_seconds || args->phase1_lifetime_seconds) {
		ARG_TO_JSON(Phase1LifetimeSeconds, int, args->phase1_lifetime_seconds);
	   	ret += 1;
	}
	if (args->is_set_replay_window_size || args->replay_window_size) {
		ARG_TO_JSON(ReplayWindowSize, int, args->replay_window_size);
	   	ret += 1;
	}
	if (args->startup_action) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StartupAction\":", args->startup_action);
	   	ret += 1;
	}
	return !!ret;
}
static int phase2_options_setter(struct phase2_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->phase2_dh_group_numbers) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase2DhGroupNumbers\":[" ));
		for (ip = args->phase2_dh_group_numbers; *ip > 0; ++ip) {
			if (ip != args->phase2_dh_group_numbers)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase2_dh_group_numbers_str) {
		ARG_TO_JSON(Phase2DhGroupNumbers, string, args->phase2_dh_group_numbers_str);
		ret += 1;
	}
	if (args->phase2_encryption_algorithms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase2EncryptionAlgorithms\":[" ));
		for (as = args->phase2_encryption_algorithms; *as; ++as) {
			if (as != args->phase2_encryption_algorithms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase2_encryption_algorithms_str) {
		ARG_TO_JSON(Phase2EncryptionAlgorithms, string, args->phase2_encryption_algorithms_str);
		ret += 1;
	}
	if (args->phase2_integrity_algorithms) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Phase2IntegrityAlgorithms\":[" ));
		for (as = args->phase2_integrity_algorithms; *as; ++as) {
			if (as != args->phase2_integrity_algorithms)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->phase2_integrity_algorithms_str) {
		ARG_TO_JSON(Phase2IntegrityAlgorithms, string, args->phase2_integrity_algorithms_str);
		ret += 1;
	}
	if (args->is_set_phase2_lifetime_seconds || args->phase2_lifetime_seconds) {
		ARG_TO_JSON(Phase2LifetimeSeconds, int, args->phase2_lifetime_seconds);
	   	ret += 1;
	}
	if (args->pre_shared_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PreSharedKey\":", args->pre_shared_key);
	   	ret += 1;
	}
	return !!ret;
}
static int phase2_options_to_update_setter(struct phase2_options_to_update *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->pre_shared_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PreSharedKey\":", args->pre_shared_key);
	   	ret += 1;
	}
	return !!ret;
}
static int placement_setter(struct placement *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->tenancy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tenancy\":", args->tenancy);
	   	ret += 1;
	}
	return !!ret;
}
static int policy_setter(struct policy *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_is_linkable) {
		ARG_TO_JSON(IsLinkable, bool, args->is_linkable);
	   	ret += 1;
	}
	if (args->last_modification_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastModificationDate\":", args->last_modification_date);
	   	ret += 1;
	}
	if (args->orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Orn\":", args->orn);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->policy_default_version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyDefaultVersionId\":", args->policy_default_version_id);
	   	ret += 1;
	}
	if (args->policy_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyId\":", args->policy_id);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->is_set_resources_count || args->resources_count) {
		ARG_TO_JSON(ResourcesCount, int, args->resources_count);
	   	ret += 1;
	}
	return !!ret;
}
static int policy_version_setter(struct policy_version *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->body) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Body\":", args->body);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->is_set_default_version) {
		ARG_TO_JSON(DefaultVersion, bool, args->default_version);
	   	ret += 1;
	}
	if (args->version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VersionId\":", args->version_id);
	   	ret += 1;
	}
	return !!ret;
}
static int private_ip_setter(struct private_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		ARG_TO_JSON(IsPrimary, bool, args->is_primary);
	   	ret += 1;
	}
	if (args->link_public_ip_str) {
		ARG_TO_JSON(LinkPublicIp, string, args->link_public_ip_str);
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkPublicIp\": { " ));
	       STRY(link_public_ip_setter(&args->link_public_ip, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	return !!ret;
}
static int private_ip_light_setter(struct private_ip_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		ARG_TO_JSON(IsPrimary, bool, args->is_primary);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	return !!ret;
}
static int private_ip_light_for_vm_setter(struct private_ip_light_for_vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_is_primary) {
		ARG_TO_JSON(IsPrimary, bool, args->is_primary);
	   	ret += 1;
	}
	if (args->link_public_ip_str) {
		ARG_TO_JSON(LinkPublicIp, string, args->link_public_ip_str);
		ret += 1;
	} else if (args->is_set_link_public_ip) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkPublicIp\": { " ));
	       STRY(link_public_ip_light_for_vm_setter(&args->link_public_ip, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	return !!ret;
}
static int product_type_setter(struct product_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->product_type_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ProductTypeId\":", args->product_type_id);
	   	ret += 1;
	}
	if (args->vendor) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Vendor\":", args->vendor);
	   	ret += 1;
	}
	return !!ret;
}
static int public_ip_setter(struct public_ip *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->link_public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkPublicIpId\":", args->link_public_ip_id);
	   	ret += 1;
	}
	if (args->nic_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicAccountId\":", args->nic_account_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	return !!ret;
}
static int public_ip_light_setter(struct public_ip_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
	return !!ret;
}
static int quota_setter(struct quota *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_max_value || args->max_value) {
		ARG_TO_JSON(MaxValue, int, args->max_value);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->quota_collection) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QuotaCollection\":", args->quota_collection);
	   	ret += 1;
	}
	if (args->short_description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ShortDescription\":", args->short_description);
	   	ret += 1;
	}
	if (args->is_set_used_value || args->used_value) {
		ARG_TO_JSON(UsedValue, int, args->used_value);
	   	ret += 1;
	}
	return !!ret;
}
static int quota_types_setter(struct quota_types *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->quota_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"QuotaType\":", args->quota_type);
	   	ret += 1;
	}
        if (args->quotas) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Quotas\":[" ));
		for (int i = 0; i < args->nb_quotas; ++i) {
	       	    struct quota *p = &args->quotas[i];
		    if (p != args->quotas)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(quota_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->quotas_str) {
		ARG_TO_JSON(Quotas, string, args->quotas_str);
		ret += 1;
	}
	return !!ret;
}
static int read_linked_policies_filters_setter(struct read_linked_policies_filters *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->path_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPrefix\":", args->path_prefix);
	   	ret += 1;
	}
	return !!ret;
}
static int read_policies_filters_setter(struct read_policies_filters *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_only_linked) {
		ARG_TO_JSON(OnlyLinked, bool, args->only_linked);
	   	ret += 1;
	}
	if (args->path_prefix) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPrefix\":", args->path_prefix);
	   	ret += 1;
	}
	if (args->scope) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Scope\":", args->scope);
	   	ret += 1;
	}
	return !!ret;
}
static int region_setter(struct region *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->endpoint) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Endpoint\":", args->endpoint);
	   	ret += 1;
	}
	if (args->region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RegionName\":", args->region_name);
	   	ret += 1;
	}
	return !!ret;
}
static int resource_load_balancer_tag_setter(struct resource_load_balancer_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Key\":", args->key);
	   	ret += 1;
	}
	return !!ret;
}
static int resource_tag_setter(struct resource_tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Key\":", args->key);
	   	ret += 1;
	}
	if (args->value) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Value\":", args->value);
	   	ret += 1;
	}
	return !!ret;
}
static int route_setter(struct route *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_method) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationMethod\":", args->creation_method);
	   	ret += 1;
	}
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->destination_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationServiceId\":", args->destination_service_id);
	   	ret += 1;
	}
	if (args->gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"GatewayId\":", args->gateway_id);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetAccessPointId\":", args->net_access_point_id);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->vm_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmAccountId\":", args->vm_account_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	return !!ret;
}
static int route_light_setter(struct route_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->route_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteType\":", args->route_type);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	return !!ret;
}
static int route_propagating_virtual_gateway_setter(struct route_propagating_virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	return !!ret;
}
static int route_table_setter(struct route_table *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->link_route_tables) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkRouteTables\":[" ));
		for (int i = 0; i < args->nb_link_route_tables; ++i) {
	       	    struct link_route_table *p = &args->link_route_tables[i];
		    if (p != args->link_route_tables)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(link_route_table_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->link_route_tables_str) {
		ARG_TO_JSON(LinkRouteTables, string, args->link_route_tables_str);
		ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
        if (args->route_propagating_virtual_gateways) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RoutePropagatingVirtualGateways\":[" ));
		for (int i = 0; i < args->nb_route_propagating_virtual_gateways; ++i) {
	       	    struct route_propagating_virtual_gateway *p = &args->route_propagating_virtual_gateways[i];
		    if (p != args->route_propagating_virtual_gateways)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(route_propagating_virtual_gateway_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->route_propagating_virtual_gateways_str) {
		ARG_TO_JSON(RoutePropagatingVirtualGateways, string, args->route_propagating_virtual_gateways_str);
		ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
        if (args->routes) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Routes\":[" ));
		for (int i = 0; i < args->nb_routes; ++i) {
	       	    struct route *p = &args->routes[i];
		    if (p != args->routes)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(route_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->routes_str) {
		ARG_TO_JSON(Routes, string, args->routes_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int security_group_setter(struct security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
        if (args->inbound_rules) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"InboundRules\":[" ));
		for (int i = 0; i < args->nb_inbound_rules; ++i) {
	       	    struct security_group_rule *p = &args->inbound_rules[i];
		    if (p != args->inbound_rules)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_rule_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->inbound_rules_str) {
		ARG_TO_JSON(InboundRules, string, args->inbound_rules_str);
		ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
        if (args->outbound_rules) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"OutboundRules\":[" ));
		for (int i = 0; i < args->nb_outbound_rules; ++i) {
	       	    struct security_group_rule *p = &args->outbound_rules[i];
		    if (p != args->outbound_rules)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_rule_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->outbound_rules_str) {
		ARG_TO_JSON(OutboundRules, string, args->outbound_rules_str);
		ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int security_group_light_setter(struct security_group_light *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
	return !!ret;
}
static int security_group_rule_setter(struct security_group_rule *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_from_port_range || args->from_port_range) {
		ARG_TO_JSON(FromPortRange, int, args->from_port_range);
	   	ret += 1;
	}
	if (args->ip_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpProtocol\":", args->ip_protocol);
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
        if (args->security_groups_members) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupsMembers\":[" ));
		for (int i = 0; i < args->nb_security_groups_members; ++i) {
	       	    struct security_groups_member *p = &args->security_groups_members[i];
		    if (p != args->security_groups_members)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_groups_member_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->security_groups_members_str) {
		ARG_TO_JSON(SecurityGroupsMembers, string, args->security_groups_members_str);
		ret += 1;
	}
	if (args->service_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ServiceIds\":[" ));
		for (as = args->service_ids; *as; ++as) {
			if (as != args->service_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->service_ids_str) {
		ARG_TO_JSON(ServiceIds, string, args->service_ids_str);
		ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		ARG_TO_JSON(ToPortRange, int, args->to_port_range);
	   	ret += 1;
	}
	return !!ret;
}
static int security_groups_member_setter(struct security_groups_member *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
	return !!ret;
}
static int server_certificate_setter(struct server_certificate *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Id\":", args->id);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Orn\":", args->orn);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->upload_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UploadDate\":", args->upload_date);
	   	ret += 1;
	}
	return !!ret;
}
static int service_setter(struct service *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	if (args->service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServiceId\":", args->service_id);
	   	ret += 1;
	}
	if (args->service_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServiceName\":", args->service_name);
	   	ret += 1;
	}
	return !!ret;
}
static int snapshot_setter(struct snapshot *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_alias) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountAlias\":", args->account_alias);
	   	ret += 1;
	}
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->permissions_to_create_volume_str) {
		ARG_TO_JSON(PermissionsToCreateVolume, string, args->permissions_to_create_volume_str);
		ret += 1;
	} else if (args->is_set_permissions_to_create_volume) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"PermissionsToCreateVolume\": { " ));
	       STRY(permissions_on_resource_setter(&args->permissions_to_create_volume, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		ARG_TO_JSON(Progress, int, args->progress);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		ARG_TO_JSON(VolumeSize, int, args->volume_size);
	   	ret += 1;
	}
	return !!ret;
}
static int snapshot_export_task_setter(struct snapshot_export_task *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->comment) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Comment\":", args->comment);
	   	ret += 1;
	}
	if (args->osu_export_str) {
		ARG_TO_JSON(OsuExport, string, args->osu_export_str);
		ret += 1;
	} else if (args->is_set_osu_export) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuExport\": { " ));
	       STRY(osu_export_snapshot_export_task_setter(&args->osu_export, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_progress || args->progress) {
		ARG_TO_JSON(Progress, int, args->progress);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->task_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"TaskId\":", args->task_id);
	   	ret += 1;
	}
	return !!ret;
}
static int source_net_setter(struct source_net *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccountId\":", args->account_id);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	return !!ret;
}
static int source_security_group_setter(struct source_security_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->security_group_account_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupAccountId\":", args->security_group_account_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
	return !!ret;
}
static int state_comment_setter(struct state_comment *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->state_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateCode\":", args->state_code);
	   	ret += 1;
	}
	if (args->state_message) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateMessage\":", args->state_message);
	   	ret += 1;
	}
	return !!ret;
}
static int subnet_setter(struct subnet *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_available_ips_count || args->available_ips_count) {
		ARG_TO_JSON(AvailableIpsCount, int, args->available_ips_count);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->is_set_map_public_ip_on_launch) {
		ARG_TO_JSON(MapPublicIpOnLaunch, bool, args->map_public_ip_on_launch);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	return !!ret;
}
static int subregion_setter(struct subregion *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->location_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LocationCode\":", args->location_code);
	   	ret += 1;
	}
	if (args->region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RegionName\":", args->region_name);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	return !!ret;
}
static int tag_setter(struct tag *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Key\":", args->key);
	   	ret += 1;
	}
	if (args->resource_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ResourceId\":", args->resource_id);
	   	ret += 1;
	}
	if (args->resource_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ResourceType\":", args->resource_type);
	   	ret += 1;
	}
	if (args->value) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Value\":", args->value);
	   	ret += 1;
	}
	return !!ret;
}
static int user_setter(struct user *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserId\":", args->user_id);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	return !!ret;
}
static int vgw_telemetry_setter(struct vgw_telemetry *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_accepted_route_count || args->accepted_route_count) {
		ARG_TO_JSON(AcceptedRouteCount, int, args->accepted_route_count);
	   	ret += 1;
	}
	if (args->last_state_change_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastStateChangeDate\":", args->last_state_change_date);
	   	ret += 1;
	}
	if (args->outside_ip_address) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OutsideIpAddress\":", args->outside_ip_address);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->state_description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateDescription\":", args->state_description);
	   	ret += 1;
	}
	return !!ret;
}
static int virtual_gateway_setter(struct virtual_gateway *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
        if (args->net_to_virtual_gateway_links) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NetToVirtualGatewayLinks\":[" ));
		for (int i = 0; i < args->nb_net_to_virtual_gateway_links; ++i) {
	       	    struct net_to_virtual_gateway_link *p = &args->net_to_virtual_gateway_links[i];
		    if (p != args->net_to_virtual_gateway_links)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(net_to_virtual_gateway_link_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->net_to_virtual_gateway_links_str) {
		ARG_TO_JSON(NetToVirtualGatewayLinks, string, args->net_to_virtual_gateway_links_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	return !!ret;
}
static int vm_setter(struct vm *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->architecture) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Architecture\":", args->architecture);
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_created *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_created_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		ARG_TO_JSON(DeletionProtection, bool, args->deletion_protection);
	   	ret += 1;
	}
	if (args->hypervisor) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Hypervisor\":", args->hypervisor);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_launch_number || args->launch_number) {
		ARG_TO_JSON(LaunchNumber, int, args->launch_number);
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		ARG_TO_JSON(NestedVirtualization, bool, args->nested_virtualization);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
        if (args->nics) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Nics\":[" ));
		for (int i = 0; i < args->nb_nics; ++i) {
	       	    struct nic_light *p = &args->nics[i];
		    if (p != args->nics)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(nic_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->nics_str) {
		ARG_TO_JSON(Nics, string, args->nics_str);
		ret += 1;
	}
	if (args->os_family) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"OsFamily\":", args->os_family);
	   	ret += 1;
	}
	if (args->performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Performance\":", args->performance);
	   	ret += 1;
	}
	if (args->placement_str) {
		ARG_TO_JSON(Placement, string, args->placement_str);
		ret += 1;
	} else if (args->is_set_placement) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Placement\": { " ));
	       STRY(placement_setter(&args->placement, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->private_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateDnsName\":", args->private_dns_name);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->public_dns_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicDnsName\":", args->public_dns_name);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->reservation_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ReservationId\":", args->reservation_id);
	   	ret += 1;
	}
	if (args->root_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceName\":", args->root_device_name);
	   	ret += 1;
	}
	if (args->root_device_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceType\":", args->root_device_type);
	   	ret += 1;
	}
        if (args->security_groups) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (int i = 0; i < args->nb_security_groups; ++i) {
	       	    struct security_group_light *p = &args->security_groups[i];
		    if (p != args->security_groups)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->state_reason) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateReason\":", args->state_reason);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->user_data) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserData\":", args->user_data);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmInitiatedShutdownBehavior\":", args->vm_initiated_shutdown_behavior);
	   	ret += 1;
	}
	if (args->vm_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmType\":", args->vm_type);
	   	ret += 1;
	}
	return !!ret;
}
static int vm_group_setter(struct vm_group *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->positioning_strategy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PositioningStrategy\":", args->positioning_strategy);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->is_set_vm_count || args->vm_count) {
		ARG_TO_JSON(VmCount, int, args->vm_count);
	   	ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	if (args->vm_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupName\":", args->vm_group_name);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	return !!ret;
}
static int vm_state_setter(struct vm_state *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->current_state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CurrentState\":", args->current_state);
	   	ret += 1;
	}
	if (args->previous_state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PreviousState\":", args->previous_state);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	return !!ret;
}
static int vm_states_setter(struct vm_states *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
        if (args->maintenance_events) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"MaintenanceEvents\":[" ));
		for (int i = 0; i < args->nb_maintenance_events; ++i) {
	       	    struct maintenance_event *p = &args->maintenance_events[i];
		    if (p != args->maintenance_events)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(maintenance_event_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->maintenance_events_str) {
		ARG_TO_JSON(MaintenanceEvents, string, args->maintenance_events_str);
		ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->vm_state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmState\":", args->vm_state);
	   	ret += 1;
	}
	return !!ret;
}
static int vm_template_setter(struct vm_template *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_cpu_cores || args->cpu_cores) {
		ARG_TO_JSON(CpuCores, int, args->cpu_cores);
	   	ret += 1;
	}
	if (args->cpu_generation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CpuGeneration\":", args->cpu_generation);
	   	ret += 1;
	}
	if (args->cpu_performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CpuPerformance\":", args->cpu_performance);
	   	ret += 1;
	}
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_ram || args->ram) {
		ARG_TO_JSON(Ram, int, args->ram);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	if (args->vm_template_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateName\":", args->vm_template_name);
	   	ret += 1;
	}
	return !!ret;
}
static int vm_type_setter(struct vm_type *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->ephemerals_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"EphemeralsType\":", args->ephemerals_type);
	   	ret += 1;
	}
	if (args->is_set_eth || args->eth) {
		ARG_TO_JSON(Eth, int, args->eth);
	   	ret += 1;
	}
	if (args->is_set_gpu || args->gpu) {
		ARG_TO_JSON(Gpu, int, args->gpu);
	   	ret += 1;
	}
	if (args->is_set_max_private_ips || args->max_private_ips) {
		ARG_TO_JSON(MaxPrivateIps, int, args->max_private_ips);
	   	ret += 1;
	}
	if (args->is_set_memory_size || args->memory_size) {
		ARG_TO_JSON(MemorySize, double, args->memory_size);
	   	ret += 1;
	}
	if (args->is_set_vcore_count || args->vcore_count) {
		ARG_TO_JSON(VcoreCount, int, args->vcore_count);
	   	ret += 1;
	}
	if (args->vm_type_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTypeName\":", args->vm_type_name);
	   	ret += 1;
	}
	if (args->is_set_volume_count || args->volume_count) {
		ARG_TO_JSON(VolumeCount, int, args->volume_count);
	   	ret += 1;
	}
	if (args->is_set_volume_size || args->volume_size) {
		ARG_TO_JSON(VolumeSize, int, args->volume_size);
	   	ret += 1;
	}
	return !!ret;
}
static int volume_setter(struct volume *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->creation_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CreationDate\":", args->creation_date);
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		ARG_TO_JSON(Iops, int, args->iops);
	   	ret += 1;
	}
        if (args->linked_volumes) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LinkedVolumes\":[" ));
		for (int i = 0; i < args->nb_linked_volumes; ++i) {
	       	    struct linked_volume *p = &args->linked_volumes[i];
		    if (p != args->linked_volumes)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(linked_volume_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->linked_volumes_str) {
		ARG_TO_JSON(LinkedVolumes, string, args->linked_volumes_str);
		ret += 1;
	}
	if (args->is_set_size || args->size) {
		ARG_TO_JSON(Size, int, args->size);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	if (args->volume_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeType\":", args->volume_type);
	   	ret += 1;
	}
	return !!ret;
}
static int vpn_connection_setter(struct vpn_connection *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->client_gateway_configuration) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayConfiguration\":", args->client_gateway_configuration);
	   	ret += 1;
	}
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
        if (args->routes) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Routes\":[" ));
		for (int i = 0; i < args->nb_routes; ++i) {
	       	    struct route_light *p = &args->routes[i];
		    if (p != args->routes)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(route_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->routes_str) {
		ARG_TO_JSON(Routes, string, args->routes_str);
		ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->is_set_static_routes_only) {
		ARG_TO_JSON(StaticRoutesOnly, bool, args->static_routes_only);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
        if (args->vgw_telemetries) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VgwTelemetries\":[" ));
		for (int i = 0; i < args->nb_vgw_telemetries; ++i) {
	       	    struct vgw_telemetry *p = &args->vgw_telemetries[i];
		    if (p != args->vgw_telemetries)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(vgw_telemetry_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->vgw_telemetries_str) {
		ARG_TO_JSON(VgwTelemetries, string, args->vgw_telemetries_str);
		ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	if (args->vpn_options_str) {
		ARG_TO_JSON(VpnOptions, string, args->vpn_options_str);
		ret += 1;
	} else if (args->is_set_vpn_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"VpnOptions\": { " ));
	       STRY(vpn_options_setter(&args->vpn_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	return !!ret;
}
static int vpn_options_setter(struct vpn_options *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->phase1_options_str) {
		ARG_TO_JSON(Phase1Options, string, args->phase1_options_str);
		ret += 1;
	} else if (args->is_set_phase1_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Phase1Options\": { " ));
	       STRY(phase1_options_setter(&args->phase1_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->phase2_options_str) {
		ARG_TO_JSON(Phase2Options, string, args->phase2_options_str);
		ret += 1;
	} else if (args->is_set_phase2_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Phase2Options\": { " ));
	       STRY(phase2_options_setter(&args->phase2_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->tunnel_inside_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"TunnelInsideIpRange\":", args->tunnel_inside_ip_range);
	   	ret += 1;
	}
	return !!ret;
}
static int vpn_options_to_update_setter(struct vpn_options_to_update *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->phase2_options_str) {
		ARG_TO_JSON(Phase2Options, string, args->phase2_options_str);
		ret += 1;
	} else if (args->is_set_phase2_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Phase2Options\": { " ));
	       STRY(phase2_options_to_update_setter(&args->phase2_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->tunnel_inside_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"TunnelInsideIpRange\":", args->tunnel_inside_ip_range);
	   	ret += 1;
	}
	return !!ret;
}
static int with_setter(struct with *args, struct osc_str *data) {
       int count_args = 0;
       int ret = 0;
	if (args->is_set_account_id) {
		ARG_TO_JSON(AccountId, bool, args->account_id);
	   	ret += 1;
	}
	if (args->is_set_call_duration) {
		ARG_TO_JSON(CallDuration, bool, args->call_duration);
	   	ret += 1;
	}
	if (args->is_set_query_access_key) {
		ARG_TO_JSON(QueryAccessKey, bool, args->query_access_key);
	   	ret += 1;
	}
	if (args->is_set_query_api_name) {
		ARG_TO_JSON(QueryApiName, bool, args->query_api_name);
	   	ret += 1;
	}
	if (args->is_set_query_api_version) {
		ARG_TO_JSON(QueryApiVersion, bool, args->query_api_version);
	   	ret += 1;
	}
	if (args->is_set_query_call_name) {
		ARG_TO_JSON(QueryCallName, bool, args->query_call_name);
	   	ret += 1;
	}
	if (args->is_set_query_date) {
		ARG_TO_JSON(QueryDate, bool, args->query_date);
	   	ret += 1;
	}
	if (args->is_set_query_header_raw) {
		ARG_TO_JSON(QueryHeaderRaw, bool, args->query_header_raw);
	   	ret += 1;
	}
	if (args->is_set_query_header_size) {
		ARG_TO_JSON(QueryHeaderSize, bool, args->query_header_size);
	   	ret += 1;
	}
	if (args->is_set_query_ip_address) {
		ARG_TO_JSON(QueryIpAddress, bool, args->query_ip_address);
	   	ret += 1;
	}
	if (args->is_set_query_payload_raw) {
		ARG_TO_JSON(QueryPayloadRaw, bool, args->query_payload_raw);
	   	ret += 1;
	}
	if (args->is_set_query_payload_size) {
		ARG_TO_JSON(QueryPayloadSize, bool, args->query_payload_size);
	   	ret += 1;
	}
	if (args->is_set_query_user_agent) {
		ARG_TO_JSON(QueryUserAgent, bool, args->query_user_agent);
	   	ret += 1;
	}
	if (args->is_set_request_id) {
		ARG_TO_JSON(RequestId, bool, args->request_id);
	   	ret += 1;
	}
	if (args->is_set_response_size) {
		ARG_TO_JSON(ResponseSize, bool, args->response_size);
	   	ret += 1;
	}
	if (args->is_set_response_status_code) {
		ARG_TO_JSON(ResponseStatusCode, bool, args->response_status_code);
	   	ret += 1;
	}
	return !!ret;
}

static  int update_vpn_connection_data(struct osc_update_vpn_connection_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	if (args->vpn_options_str) {
		ARG_TO_JSON(VpnOptions, string, args->vpn_options_str);
		ret += 1;
	} else if (args->is_set_vpn_options) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"VpnOptions\": { " ));
	       STRY(vpn_options_to_update_setter(&args->vpn_options, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_update_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_vpn_connection_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_volume_data(struct osc_update_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		ARG_TO_JSON(Iops, int, args->iops);
	   	ret += 1;
	}
	if (args->is_set_size || args->size) {
		ARG_TO_JSON(Size, int, args->size);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	if (args->volume_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeType\":", args->volume_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_volume(struct osc_env *e, struct osc_str *out, struct osc_update_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_vm_template_data(struct osc_update_vm_template_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	if (args->vm_template_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateName\":", args->vm_template_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_vm_template(struct osc_env *e, struct osc_str *out, struct osc_update_vm_template_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_vm_template_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateVmTemplate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_vm_group_data(struct osc_update_vm_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	if (args->vm_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupName\":", args->vm_group_name);
	   	ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_vm_group(struct osc_env *e, struct osc_str *out, struct osc_update_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_vm_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_vm_data(struct osc_update_vm_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_vm_update *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_vm_update_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		ARG_TO_JSON(DeletionProtection, bool, args->deletion_protection);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_is_source_dest_checked) {
		ARG_TO_JSON(IsSourceDestChecked, bool, args->is_source_dest_checked);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		ARG_TO_JSON(NestedVirtualization, bool, args->nested_virtualization);
	   	ret += 1;
	}
	if (args->performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Performance\":", args->performance);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->user_data) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserData\":", args->user_data);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmInitiatedShutdownBehavior\":", args->vm_initiated_shutdown_behavior);
	   	ret += 1;
	}
	if (args->vm_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmType\":", args->vm_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_vm(struct osc_env *e, struct osc_str *out, struct osc_update_vm_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_vm_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateVm");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_user_data(struct osc_update_user_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->new_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewPath\":", args->new_path);
	   	ret += 1;
	}
	if (args->new_user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewUserName\":", args->new_user_name);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_user(struct osc_env *e, struct osc_str *out, struct osc_update_user_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_user_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateUser");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_subnet_data(struct osc_update_subnet_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_map_public_ip_on_launch) {
		ARG_TO_JSON(MapPublicIpOnLaunch, bool, args->map_public_ip_on_launch);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_subnet(struct osc_env *e, struct osc_str *out, struct osc_update_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_subnet_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_snapshot_data(struct osc_update_snapshot_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->permissions_to_create_volume_str) {
		ARG_TO_JSON(PermissionsToCreateVolume, string, args->permissions_to_create_volume_str);
		ret += 1;
	} else if (args->is_set_permissions_to_create_volume) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"PermissionsToCreateVolume\": { " ));
	       STRY(permissions_on_resource_creation_setter(&args->permissions_to_create_volume, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_snapshot(struct osc_env *e, struct osc_str *out, struct osc_update_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_snapshot_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_server_certificate_data(struct osc_update_server_certificate_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->new_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewName\":", args->new_name);
	   	ret += 1;
	}
	if (args->new_path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NewPath\":", args->new_path);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_update_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_server_certificate_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_route_table_link_data(struct osc_update_route_table_link_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkRouteTableId\":", args->link_route_table_id);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_route_table_link(struct osc_env *e, struct osc_str *out, struct osc_update_route_table_link_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_route_table_link_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateRouteTableLink");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_route_propagation_data(struct osc_update_route_propagation_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_enable) {
		ARG_TO_JSON(Enable, bool, args->enable);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_route_propagation(struct osc_env *e, struct osc_str *out, struct osc_update_route_propagation_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_route_propagation_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateRoutePropagation");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_route_data(struct osc_update_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"GatewayId\":", args->gateway_id);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_route(struct osc_env *e, struct osc_str *out, struct osc_update_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_nic_data(struct osc_update_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_nic_str) {
		ARG_TO_JSON(LinkNic, string, args->link_nic_str);
		ret += 1;
	} else if (args->is_set_link_nic) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"LinkNic\": { " ));
	       STRY(link_nic_to_update_setter(&args->link_nic, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_nic(struct osc_env *e, struct osc_str *out, struct osc_update_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_net_access_point_data(struct osc_update_net_access_point_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->add_route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AddRouteTableIds\":[" ));
		for (as = args->add_route_table_ids; *as; ++as) {
			if (as != args->add_route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->add_route_table_ids_str) {
		ARG_TO_JSON(AddRouteTableIds, string, args->add_route_table_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetAccessPointId\":", args->net_access_point_id);
	   	ret += 1;
	}
	if (args->remove_route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RemoveRouteTableIds\":[" ));
		for (as = args->remove_route_table_ids; *as; ++as) {
			if (as != args->remove_route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->remove_route_table_ids_str) {
		ARG_TO_JSON(RemoveRouteTableIds, string, args->remove_route_table_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_update_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_net_access_point_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_net_data(struct osc_update_net_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->dhcp_options_set_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DhcpOptionsSetId\":", args->dhcp_options_set_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_net(struct osc_env *e, struct osc_str *out, struct osc_update_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_net_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_load_balancer_data(struct osc_update_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->access_log_str) {
		ARG_TO_JSON(AccessLog, string, args->access_log_str);
		ret += 1;
	} else if (args->is_set_access_log) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"AccessLog\": { " ));
	       STRY(access_log_setter(&args->access_log, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->health_check_str) {
		ARG_TO_JSON(HealthCheck, string, args->health_check_str);
		ret += 1;
	} else if (args->is_set_health_check) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"HealthCheck\": { " ));
	       STRY(health_check_setter(&args->health_check, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->is_set_load_balancer_port || args->load_balancer_port) {
		ARG_TO_JSON(LoadBalancerPort, int, args->load_balancer_port);
	   	ret += 1;
	}
	if (args->policy_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PolicyNames\":[" ));
		for (as = args->policy_names; *as; ++as) {
			if (as != args->policy_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->policy_names_str) {
		ARG_TO_JSON(PolicyNames, string, args->policy_names_str);
		ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->is_set_secured_cookies) {
		ARG_TO_JSON(SecuredCookies, bool, args->secured_cookies);
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (as = args->security_groups; *as; ++as) {
			if (as != args->security_groups)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->server_certificate_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServerCertificateId\":", args->server_certificate_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_update_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_listener_rule_data(struct osc_update_listener_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->host_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"HostPattern\":", args->host_pattern);
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ListenerRuleName\":", args->listener_rule_name);
	   	ret += 1;
	}
	if (args->path_pattern) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PathPattern\":", args->path_pattern);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_update_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_listener_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_image_data(struct osc_update_image_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->permissions_to_launch_str) {
		ARG_TO_JSON(PermissionsToLaunch, string, args->permissions_to_launch_str);
		ret += 1;
	} else if (args->is_set_permissions_to_launch) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"PermissionsToLaunch\": { " ));
	       STRY(permissions_on_resource_creation_setter(&args->permissions_to_launch, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_image(struct osc_env *e, struct osc_str *out, struct osc_update_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_image_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_flexible_gpu_data(struct osc_update_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_update_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_direct_link_interface_data(struct osc_update_direct_link_interface_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->direct_link_interface_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceId\":", args->direct_link_interface_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_mtu || args->mtu) {
		ARG_TO_JSON(Mtu, int, args->mtu);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_update_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_direct_link_interface_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_dedicated_group_data(struct osc_update_dedicated_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->dedicated_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DedicatedGroupId\":", args->dedicated_group_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_update_dedicated_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_dedicated_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateDedicatedGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_ca_data(struct osc_update_ca_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->ca_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaId\":", args->ca_id);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_ca(struct osc_env *e, struct osc_str *out, struct osc_update_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_ca_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_api_access_rule_data(struct osc_update_api_access_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->api_access_rule_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ApiAccessRuleId\":", args->api_access_rule_id);
	   	ret += 1;
	}
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->cns) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Cns\":[" ));
		for (as = args->cns; *as; ++as) {
			if (as != args->cns)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cns_str) {
		ARG_TO_JSON(Cns, string, args->cns_str);
		ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_update_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_api_access_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_api_access_policy_data(struct osc_update_api_access_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_max_access_key_expiration_seconds || args->max_access_key_expiration_seconds) {
		ARG_TO_JSON(MaxAccessKeyExpirationSeconds, int, args->max_access_key_expiration_seconds);
	   	ret += 1;
	}
	if (args->is_set_require_trusted_env) {
		ARG_TO_JSON(RequireTrustedEnv, bool, args->require_trusted_env);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_api_access_policy(struct osc_env *e, struct osc_str *out, struct osc_update_api_access_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_api_access_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateApiAccessPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_account_data(struct osc_update_account_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->additional_emails) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AdditionalEmails\":[" ));
		for (as = args->additional_emails; *as; ++as) {
			if (as != args->additional_emails)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->additional_emails_str) {
		ARG_TO_JSON(AdditionalEmails, string, args->additional_emails_str);
		ret += 1;
	}
	if (args->city) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"City\":", args->city);
	   	ret += 1;
	}
	if (args->company_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CompanyName\":", args->company_name);
	   	ret += 1;
	}
	if (args->country) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Country\":", args->country);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Email\":", args->email);
	   	ret += 1;
	}
	if (args->first_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FirstName\":", args->first_name);
	   	ret += 1;
	}
	if (args->job_title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"JobTitle\":", args->job_title);
	   	ret += 1;
	}
	if (args->last_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastName\":", args->last_name);
	   	ret += 1;
	}
	if (args->mobile_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MobileNumber\":", args->mobile_number);
	   	ret += 1;
	}
	if (args->phone_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PhoneNumber\":", args->phone_number);
	   	ret += 1;
	}
	if (args->state_province) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateProvince\":", args->state_province);
	   	ret += 1;
	}
	if (args->vat_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VatNumber\":", args->vat_number);
	   	ret += 1;
	}
	if (args->zip_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ZipCode\":", args->zip_code);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_account(struct osc_env *e, struct osc_str *out, struct osc_update_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_account_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int update_access_key_data(struct osc_update_access_key_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->state) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"State\":", args->state);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_update_access_key(struct osc_env *e, struct osc_str *out, struct osc_update_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = update_access_key_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UpdateAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_volume_data(struct osc_unlink_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_force_unlink) {
		ARG_TO_JSON(ForceUnlink, bool, args->force_unlink);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_volume(struct osc_env *e, struct osc_str *out, struct osc_unlink_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_virtual_gateway_data(struct osc_unlink_virtual_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_unlink_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_virtual_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_route_table_data(struct osc_unlink_route_table_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkRouteTableId\":", args->link_route_table_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_route_table(struct osc_env *e, struct osc_str *out, struct osc_unlink_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_route_table_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_public_ip_data(struct osc_unlink_public_ip_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkPublicIpId\":", args->link_public_ip_id);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_public_ip(struct osc_env *e, struct osc_str *out, struct osc_unlink_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_public_ip_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkPublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_private_ips_data(struct osc_unlink_private_ips_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_private_ips(struct osc_env *e, struct osc_str *out, struct osc_unlink_private_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_private_ips_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkPrivateIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_policy_data(struct osc_unlink_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_policy(struct osc_env *e, struct osc_str *out, struct osc_unlink_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_nic_data(struct osc_unlink_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->link_nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LinkNicId\":", args->link_nic_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_nic(struct osc_env *e, struct osc_str *out, struct osc_unlink_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_load_balancer_backend_machines_data(struct osc_unlink_load_balancer_backend_machines_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendIps\":[" ));
		for (as = args->backend_ips; *as; ++as) {
			if (as != args->backend_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_ips_str) {
		ARG_TO_JSON(BackendIps, string, args->backend_ips_str);
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_load_balancer_backend_machines(struct osc_env *e, struct osc_str *out, struct osc_unlink_load_balancer_backend_machines_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_load_balancer_backend_machines_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkLoadBalancerBackendMachines");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_internet_service_data(struct osc_unlink_internet_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->internet_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InternetServiceId\":", args->internet_service_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_internet_service(struct osc_env *e, struct osc_str *out, struct osc_unlink_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_internet_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int unlink_flexible_gpu_data(struct osc_unlink_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_unlink_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_unlink_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = unlink_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/UnlinkFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int stop_vms_data(struct osc_stop_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_force_stop) {
		ARG_TO_JSON(ForceStop, bool, args->force_stop);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_stop_vms(struct osc_env *e, struct osc_str *out, struct osc_stop_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = stop_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/StopVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int start_vms_data(struct osc_start_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_start_vms(struct osc_env *e, struct osc_str *out, struct osc_start_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = start_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/StartVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int set_default_policy_version_data(struct osc_set_default_policy_version_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VersionId\":", args->version_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_set_default_policy_version(struct osc_env *e, struct osc_str *out, struct osc_set_default_policy_version_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = set_default_policy_version_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/SetDefaultPolicyVersion");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int scale_up_vm_group_data(struct osc_scale_up_vm_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_vm_addition || args->vm_addition) {
		ARG_TO_JSON(VmAddition, int, args->vm_addition);
	   	ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_scale_up_vm_group(struct osc_env *e, struct osc_str *out, struct osc_scale_up_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = scale_up_vm_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ScaleUpVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int scale_down_vm_group_data(struct osc_scale_down_vm_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	if (args->is_set_vm_subtraction || args->vm_subtraction) {
		ARG_TO_JSON(VmSubtraction, int, args->vm_subtraction);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_scale_down_vm_group(struct osc_env *e, struct osc_str *out, struct osc_scale_down_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = scale_down_vm_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ScaleDownVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int reject_net_peering_data(struct osc_reject_net_peering_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_reject_net_peering(struct osc_env *e, struct osc_str *out, struct osc_reject_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = reject_net_peering_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/RejectNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int register_vms_in_load_balancer_data(struct osc_register_vms_in_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_register_vms_in_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_register_vms_in_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = register_vms_in_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/RegisterVmsInLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int reboot_vms_data(struct osc_reboot_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_reboot_vms(struct osc_env *e, struct osc_str *out, struct osc_reboot_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = reboot_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/RebootVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vpn_connections_data(struct osc_read_vpn_connections_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vpn_connection_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vpn_connections(struct osc_env *e, struct osc_str *out, struct osc_read_vpn_connections_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vpn_connections_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVpnConnections");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_volumes_data(struct osc_read_volumes_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_volume_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_volumes(struct osc_env *e, struct osc_str *out, struct osc_read_volumes_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_volumes_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVolumes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_state_data(struct osc_read_vms_state_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_all_vms) {
		ARG_TO_JSON(AllVms, bool, args->all_vms);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vms_state_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vms_state(struct osc_env *e, struct osc_str *out, struct osc_read_vms_state_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vms_state_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVmsState");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_health_data(struct osc_read_vms_health_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vms_health(struct osc_env *e, struct osc_str *out, struct osc_read_vms_health_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vms_health_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVmsHealth");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vms_data(struct osc_read_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vm_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vms(struct osc_env *e, struct osc_str *out, struct osc_read_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vm_types_data(struct osc_read_vm_types_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vm_type_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vm_types(struct osc_env *e, struct osc_str *out, struct osc_read_vm_types_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vm_types_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVmTypes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vm_templates_data(struct osc_read_vm_templates_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vm_template_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vm_templates(struct osc_env *e, struct osc_str *out, struct osc_read_vm_templates_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vm_templates_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVmTemplates");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_vm_groups_data(struct osc_read_vm_groups_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_vm_group_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_vm_groups(struct osc_env *e, struct osc_str *out, struct osc_read_vm_groups_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_vm_groups_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVmGroups");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_virtual_gateways_data(struct osc_read_virtual_gateways_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_virtual_gateway_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_virtual_gateways(struct osc_env *e, struct osc_str *out, struct osc_read_virtual_gateways_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_virtual_gateways_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadVirtualGateways");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_users_data(struct osc_read_users_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_users(struct osc_env *e, struct osc_str *out, struct osc_read_users_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_users_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadUsers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_tags_data(struct osc_read_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_tag_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_tags(struct osc_env *e, struct osc_str *out, struct osc_read_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_subregions_data(struct osc_read_subregions_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_subregion_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_subregions(struct osc_env *e, struct osc_str *out, struct osc_read_subregions_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_subregions_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSubregions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_subnets_data(struct osc_read_subnets_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_subnet_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_subnets(struct osc_env *e, struct osc_str *out, struct osc_read_subnets_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_subnets_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSubnets");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_snapshots_data(struct osc_read_snapshots_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_snapshot_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_snapshots(struct osc_env *e, struct osc_str *out, struct osc_read_snapshots_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_snapshots_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSnapshots");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_snapshot_export_tasks_data(struct osc_read_snapshot_export_tasks_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_export_task_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_snapshot_export_tasks(struct osc_env *e, struct osc_str *out, struct osc_read_snapshot_export_tasks_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_snapshot_export_tasks_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSnapshotExportTasks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_server_certificates_data(struct osc_read_server_certificates_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_server_certificate_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_server_certificates(struct osc_env *e, struct osc_str *out, struct osc_read_server_certificates_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_server_certificates_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadServerCertificates");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_security_groups_data(struct osc_read_security_groups_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_security_group_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_security_groups(struct osc_env *e, struct osc_str *out, struct osc_read_security_groups_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_security_groups_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSecurityGroups");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_secret_access_key_data(struct osc_read_secret_access_key_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_secret_access_key(struct osc_env *e, struct osc_str *out, struct osc_read_secret_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_secret_access_key_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadSecretAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_route_tables_data(struct osc_read_route_tables_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_route_table_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_route_tables(struct osc_env *e, struct osc_str *out, struct osc_read_route_tables_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_route_tables_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadRouteTables");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_regions_data(struct osc_read_regions_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_regions(struct osc_env *e, struct osc_str *out, struct osc_read_regions_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_regions_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadRegions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_quotas_data(struct osc_read_quotas_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_quota_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_quotas(struct osc_env *e, struct osc_str *out, struct osc_read_quotas_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_quotas_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadQuotas");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_public_ips_data(struct osc_read_public_ips_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_public_ip_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_public_ips(struct osc_env *e, struct osc_str *out, struct osc_read_public_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_public_ips_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPublicIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_public_ip_ranges_data(struct osc_read_public_ip_ranges_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_public_ip_ranges(struct osc_env *e, struct osc_str *out, struct osc_read_public_ip_ranges_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_public_ip_ranges_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPublicIpRanges");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_public_catalog_data(struct osc_read_public_catalog_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_public_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_public_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_public_catalog_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPublicCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_product_types_data(struct osc_read_product_types_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_product_type_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_product_types(struct osc_env *e, struct osc_str *out, struct osc_read_product_types_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_product_types_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadProductTypes");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_policy_versions_data(struct osc_read_policy_versions_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_policy_versions(struct osc_env *e, struct osc_str *out, struct osc_read_policy_versions_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_policy_versions_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPolicyVersions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_policy_version_data(struct osc_read_policy_version_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VersionId\":", args->version_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_policy_version(struct osc_env *e, struct osc_str *out, struct osc_read_policy_version_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_policy_version_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPolicyVersion");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_policy_data(struct osc_read_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_policy(struct osc_env *e, struct osc_str *out, struct osc_read_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_policies_data(struct osc_read_policies_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(read_policies_filters_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_policies(struct osc_env *e, struct osc_str *out, struct osc_read_policies_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_policies_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadPolicies");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_nics_data(struct osc_read_nics_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_nic_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_nics(struct osc_env *e, struct osc_str *out, struct osc_read_nics_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_nics_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNics");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_nets_data(struct osc_read_nets_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_net_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_nets(struct osc_env *e, struct osc_str *out, struct osc_read_nets_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_nets_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNets");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_net_peerings_data(struct osc_read_net_peerings_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_net_peering_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_net_peerings(struct osc_env *e, struct osc_str *out, struct osc_read_net_peerings_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_net_peerings_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNetPeerings");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_net_access_points_data(struct osc_read_net_access_points_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_net_access_point_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_net_access_points(struct osc_env *e, struct osc_str *out, struct osc_read_net_access_points_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_net_access_points_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNetAccessPoints");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_net_access_point_services_data(struct osc_read_net_access_point_services_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_service_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_net_access_point_services(struct osc_env *e, struct osc_str *out, struct osc_read_net_access_point_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_net_access_point_services_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNetAccessPointServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_nat_services_data(struct osc_read_nat_services_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_nat_service_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_nat_services(struct osc_env *e, struct osc_str *out, struct osc_read_nat_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_nat_services_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadNatServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_locations_data(struct osc_read_locations_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_locations(struct osc_env *e, struct osc_str *out, struct osc_read_locations_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_locations_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadLocations");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_load_balancers_data(struct osc_read_load_balancers_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_load_balancer_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_load_balancers(struct osc_env *e, struct osc_str *out, struct osc_read_load_balancers_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_load_balancers_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadLoadBalancers");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_load_balancer_tags_data(struct osc_read_load_balancer_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerNames\":[" ));
		for (as = args->load_balancer_names; *as; ++as) {
			if (as != args->load_balancer_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_names_str) {
		ARG_TO_JSON(LoadBalancerNames, string, args->load_balancer_names_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_read_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_load_balancer_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_listener_rules_data(struct osc_read_listener_rules_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_listener_rule_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_listener_rules(struct osc_env *e, struct osc_str *out, struct osc_read_listener_rules_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_listener_rules_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadListenerRules");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_linked_policies_data(struct osc_read_linked_policies_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(read_linked_policies_filters_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_first_item || args->first_item) {
		ARG_TO_JSON(FirstItem, int, args->first_item);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_linked_policies(struct osc_env *e, struct osc_str *out, struct osc_read_linked_policies_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_linked_policies_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadLinkedPolicies");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_keypairs_data(struct osc_read_keypairs_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_keypair_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_keypairs(struct osc_env *e, struct osc_str *out, struct osc_read_keypairs_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_keypairs_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadKeypairs");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_internet_services_data(struct osc_read_internet_services_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_internet_service_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_internet_services(struct osc_env *e, struct osc_str *out, struct osc_read_internet_services_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_internet_services_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadInternetServices");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_images_data(struct osc_read_images_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_image_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_images(struct osc_env *e, struct osc_str *out, struct osc_read_images_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_images_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadImages");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_image_export_tasks_data(struct osc_read_image_export_tasks_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_export_task_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_image_export_tasks(struct osc_env *e, struct osc_str *out, struct osc_read_image_export_tasks_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_image_export_tasks_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadImageExportTasks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_flexible_gpus_data(struct osc_read_flexible_gpus_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_flexible_gpu_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_flexible_gpus(struct osc_env *e, struct osc_str *out, struct osc_read_flexible_gpus_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_flexible_gpus_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadFlexibleGpus");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_flexible_gpu_catalog_data(struct osc_read_flexible_gpu_catalog_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_flexible_gpu_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_flexible_gpu_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_flexible_gpu_catalog_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadFlexibleGpuCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_direct_links_data(struct osc_read_direct_links_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_direct_link_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_direct_links(struct osc_env *e, struct osc_str *out, struct osc_read_direct_links_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_direct_links_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadDirectLinks");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_direct_link_interfaces_data(struct osc_read_direct_link_interfaces_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_direct_link_interface_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_direct_link_interfaces(struct osc_env *e, struct osc_str *out, struct osc_read_direct_link_interfaces_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_direct_link_interfaces_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadDirectLinkInterfaces");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_dhcp_options_data(struct osc_read_dhcp_options_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_dhcp_options_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_read_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_dhcp_options_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_dedicated_groups_data(struct osc_read_dedicated_groups_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_dedicated_group_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_dedicated_groups(struct osc_env *e, struct osc_str *out, struct osc_read_dedicated_groups_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_dedicated_groups_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadDedicatedGroups");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_consumption_account_data(struct osc_read_consumption_account_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->from_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FromDate\":", args->from_date);
	   	ret += 1;
	}
	if (args->is_set_overall) {
		ARG_TO_JSON(Overall, bool, args->overall);
	   	ret += 1;
	}
	if (args->is_set_show_price) {
		ARG_TO_JSON(ShowPrice, bool, args->show_price);
	   	ret += 1;
	}
	if (args->to_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ToDate\":", args->to_date);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_consumption_account(struct osc_env *e, struct osc_str *out, struct osc_read_consumption_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_consumption_account_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadConsumptionAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_console_output_data(struct osc_read_console_output_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_console_output(struct osc_env *e, struct osc_str *out, struct osc_read_console_output_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_console_output_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadConsoleOutput");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_client_gateways_data(struct osc_read_client_gateways_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_client_gateway_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_client_gateways(struct osc_env *e, struct osc_str *out, struct osc_read_client_gateways_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_client_gateways_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadClientGateways");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_catalogs_data(struct osc_read_catalogs_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_catalogs_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_catalogs(struct osc_env *e, struct osc_str *out, struct osc_read_catalogs_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_catalogs_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadCatalogs");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_catalog_data(struct osc_read_catalog_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_catalog(struct osc_env *e, struct osc_str *out, struct osc_read_catalog_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_catalog_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadCatalog");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_cas_data(struct osc_read_cas_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_ca_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_cas(struct osc_env *e, struct osc_str *out, struct osc_read_cas_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_cas_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadCas");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_api_logs_data(struct osc_read_api_logs_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_api_log_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->next_page_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NextPageToken\":", args->next_page_token);
	   	ret += 1;
	}
	if (args->is_set_results_per_page || args->results_per_page) {
		ARG_TO_JSON(ResultsPerPage, int, args->results_per_page);
	   	ret += 1;
	}
	if (args->with_str) {
		ARG_TO_JSON(With, string, args->with_str);
		ret += 1;
	} else if (args->is_set_with) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"With\": { " ));
	       STRY(with_setter(&args->with, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_api_logs(struct osc_env *e, struct osc_str *out, struct osc_read_api_logs_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_api_logs_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadApiLogs");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_api_access_rules_data(struct osc_read_api_access_rules_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_api_access_rule_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_api_access_rules(struct osc_env *e, struct osc_str *out, struct osc_read_api_access_rules_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_api_access_rules_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadApiAccessRules");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_api_access_policy_data(struct osc_read_api_access_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_api_access_policy(struct osc_env *e, struct osc_str *out, struct osc_read_api_access_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_api_access_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadApiAccessPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_admin_password_data(struct osc_read_admin_password_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_admin_password(struct osc_env *e, struct osc_str *out, struct osc_read_admin_password_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_admin_password_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadAdminPassword");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_accounts_data(struct osc_read_accounts_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_accounts(struct osc_env *e, struct osc_str *out, struct osc_read_accounts_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_accounts_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadAccounts");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int read_access_keys_data(struct osc_read_access_keys_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->filters_str) {
		ARG_TO_JSON(Filters, string, args->filters_str);
		ret += 1;
	} else if (args->is_set_filters) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Filters\": { " ));
	       STRY(filters_access_keys_setter(&args->filters, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_read_access_keys(struct osc_env *e, struct osc_str *out, struct osc_read_access_keys_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = read_access_keys_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/ReadAccessKeys");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_volume_data(struct osc_link_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DeviceName\":", args->device_name);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_volume(struct osc_env *e, struct osc_str *out, struct osc_link_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_virtual_gateway_data(struct osc_link_virtual_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_link_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_virtual_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_route_table_data(struct osc_link_route_table_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_route_table(struct osc_env *e, struct osc_str *out, struct osc_link_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_route_table_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_public_ip_data(struct osc_link_public_ip_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_allow_relink) {
		ARG_TO_JSON(AllowRelink, bool, args->allow_relink);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateIp\":", args->private_ip);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_public_ip(struct osc_env *e, struct osc_str *out, struct osc_link_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_public_ip_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkPublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_private_ips_data(struct osc_link_private_ips_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_allow_relink) {
		ARG_TO_JSON(AllowRelink, bool, args->allow_relink);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->is_set_secondary_private_ip_count || args->secondary_private_ip_count) {
		ARG_TO_JSON(SecondaryPrivateIpCount, int, args->secondary_private_ip_count);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_private_ips(struct osc_env *e, struct osc_str *out, struct osc_link_private_ips_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_private_ips_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkPrivateIps");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_policy_data(struct osc_link_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_policy(struct osc_env *e, struct osc_str *out, struct osc_link_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_nic_data(struct osc_link_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_device_number || args->device_number) {
		ARG_TO_JSON(DeviceNumber, int, args->device_number);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_nic(struct osc_env *e, struct osc_str *out, struct osc_link_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_load_balancer_backend_machines_data(struct osc_link_load_balancer_backend_machines_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendIps\":[" ));
		for (as = args->backend_ips; *as; ++as) {
			if (as != args->backend_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_ips_str) {
		ARG_TO_JSON(BackendIps, string, args->backend_ips_str);
		ret += 1;
	}
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_load_balancer_backend_machines(struct osc_env *e, struct osc_str *out, struct osc_link_load_balancer_backend_machines_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_load_balancer_backend_machines_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkLoadBalancerBackendMachines");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_internet_service_data(struct osc_link_internet_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->internet_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InternetServiceId\":", args->internet_service_id);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_internet_service(struct osc_env *e, struct osc_str *out, struct osc_link_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_internet_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int link_flexible_gpu_data(struct osc_link_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_link_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_link_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = link_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/LinkFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int deregister_vms_in_load_balancer_data(struct osc_deregister_vms_in_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->backend_vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BackendVmIds\":[" ));
		for (as = args->backend_vm_ids; *as; ++as) {
			if (as != args->backend_vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->backend_vm_ids_str) {
		ARG_TO_JSON(BackendVmIds, string, args->backend_vm_ids_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_deregister_vms_in_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_deregister_vms_in_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = deregister_vms_in_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeregisterVmsInLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_vpn_connection_route_data(struct osc_delete_vpn_connection_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_vpn_connection_route(struct osc_env *e, struct osc_str *out, struct osc_delete_vpn_connection_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_vpn_connection_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVpnConnectionRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_vpn_connection_data(struct osc_delete_vpn_connection_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_delete_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_vpn_connection_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_volume_data(struct osc_delete_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_volume(struct osc_env *e, struct osc_str *out, struct osc_delete_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_vms_data(struct osc_delete_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_vms(struct osc_env *e, struct osc_str *out, struct osc_delete_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_vm_template_data(struct osc_delete_vm_template_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_vm_template(struct osc_env *e, struct osc_str *out, struct osc_delete_vm_template_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_vm_template_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVmTemplate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_vm_group_data(struct osc_delete_vm_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vm_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupId\":", args->vm_group_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_vm_group(struct osc_env *e, struct osc_str *out, struct osc_delete_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_vm_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_virtual_gateway_data(struct osc_delete_virtual_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_delete_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_virtual_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_user_data(struct osc_delete_user_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_user(struct osc_env *e, struct osc_str *out, struct osc_delete_user_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_user_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteUser");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_tags_data(struct osc_delete_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->resource_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResourceIds\":[" ));
		for (as = args->resource_ids; *as; ++as) {
			if (as != args->resource_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->resource_ids_str) {
		ARG_TO_JSON(ResourceIds, string, args->resource_ids_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_tags(struct osc_env *e, struct osc_str *out, struct osc_delete_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_subnet_data(struct osc_delete_subnet_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_subnet(struct osc_env *e, struct osc_str *out, struct osc_delete_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_subnet_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_snapshot_data(struct osc_delete_snapshot_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_snapshot(struct osc_env *e, struct osc_str *out, struct osc_delete_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_snapshot_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_server_certificate_data(struct osc_delete_server_certificate_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_delete_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_server_certificate_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_security_group_rule_data(struct osc_delete_security_group_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flow) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Flow\":", args->flow);
	   	ret += 1;
	}
	if (args->is_set_from_port_range || args->from_port_range) {
		ARG_TO_JSON(FromPortRange, int, args->from_port_range);
	   	ret += 1;
	}
	if (args->ip_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpProtocol\":", args->ip_protocol);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
        if (args->rules) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Rules\":[" ));
		for (int i = 0; i < args->nb_rules; ++i) {
	       	    struct security_group_rule *p = &args->rules[i];
		    if (p != args->rules)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_rule_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->rules_str) {
		ARG_TO_JSON(Rules, string, args->rules_str);
		ret += 1;
	}
	if (args->security_group_account_id_to_unlink) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupAccountIdToUnlink\":", args->security_group_account_id_to_unlink);
	   	ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name_to_unlink) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupNameToUnlink\":", args->security_group_name_to_unlink);
	   	ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		ARG_TO_JSON(ToPortRange, int, args->to_port_range);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_security_group_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_security_group_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_security_group_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteSecurityGroupRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_security_group_data(struct osc_delete_security_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_security_group(struct osc_env *e, struct osc_str *out, struct osc_delete_security_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_security_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteSecurityGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_route_table_data(struct osc_delete_route_table_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_route_table(struct osc_env *e, struct osc_str *out, struct osc_delete_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_route_table_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_route_data(struct osc_delete_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_route(struct osc_env *e, struct osc_str *out, struct osc_delete_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_public_ip_data(struct osc_delete_public_ip_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_public_ip(struct osc_env *e, struct osc_str *out, struct osc_delete_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_public_ip_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeletePublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_policy_version_data(struct osc_delete_policy_version_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->version_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VersionId\":", args->version_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_policy_version(struct osc_env *e, struct osc_str *out, struct osc_delete_policy_version_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_policy_version_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeletePolicyVersion");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_policy_data(struct osc_delete_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeletePolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_nic_data(struct osc_delete_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_nic(struct osc_env *e, struct osc_str *out, struct osc_delete_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_peering_data(struct osc_delete_net_peering_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_net_peering(struct osc_env *e, struct osc_str *out, struct osc_delete_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_net_peering_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_access_point_data(struct osc_delete_net_access_point_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_access_point_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetAccessPointId\":", args->net_access_point_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_delete_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_net_access_point_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_net_data(struct osc_delete_net_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_net(struct osc_env *e, struct osc_str *out, struct osc_delete_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_net_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_nat_service_data(struct osc_delete_nat_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_nat_service(struct osc_env *e, struct osc_str *out, struct osc_delete_nat_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_nat_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteNatService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_tags_data(struct osc_delete_load_balancer_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerNames\":[" ));
		for (as = args->load_balancer_names; *as; ++as) {
			if (as != args->load_balancer_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_names_str) {
		ARG_TO_JSON(LoadBalancerNames, string, args->load_balancer_names_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_load_balancer_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_load_balancer_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_load_balancer_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_policy_data(struct osc_delete_load_balancer_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_load_balancer_policy(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_load_balancer_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_listeners_data(struct osc_delete_load_balancer_listeners_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->load_balancer_ports) {
		int *ip;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerPorts\":[" ));
		for (ip = args->load_balancer_ports; *ip > 0; ++ip) {
			if (ip != args->load_balancer_ports)
				STRY(osc_str_append_string(data, "," ));
			STRY(osc_str_append_int(data, *ip));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_ports_str) {
		ARG_TO_JSON(LoadBalancerPorts, string, args->load_balancer_ports_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_load_balancer_listeners(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_listeners_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_load_balancer_listeners_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancerListeners");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_load_balancer_data(struct osc_delete_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_delete_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_listener_rule_data(struct osc_delete_listener_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->listener_rule_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ListenerRuleName\":", args->listener_rule_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_listener_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_keypair_data(struct osc_delete_keypair_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_keypair(struct osc_env *e, struct osc_str *out, struct osc_delete_keypair_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_keypair_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteKeypair");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_internet_service_data(struct osc_delete_internet_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->internet_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"InternetServiceId\":", args->internet_service_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_internet_service(struct osc_env *e, struct osc_str *out, struct osc_delete_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_internet_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_image_data(struct osc_delete_image_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_image(struct osc_env *e, struct osc_str *out, struct osc_delete_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_image_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_flexible_gpu_data(struct osc_delete_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flexible_gpu_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FlexibleGpuId\":", args->flexible_gpu_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_delete_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_export_task_data(struct osc_delete_export_task_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->export_task_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExportTaskId\":", args->export_task_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_export_task(struct osc_env *e, struct osc_str *out, struct osc_delete_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_export_task_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_direct_link_interface_data(struct osc_delete_direct_link_interface_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->direct_link_interface_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkInterfaceId\":", args->direct_link_interface_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_delete_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_direct_link_interface_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_direct_link_data(struct osc_delete_direct_link_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->direct_link_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkId\":", args->direct_link_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_direct_link(struct osc_env *e, struct osc_str *out, struct osc_delete_direct_link_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_direct_link_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteDirectLink");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_dhcp_options_data(struct osc_delete_dhcp_options_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->dhcp_options_set_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DhcpOptionsSetId\":", args->dhcp_options_set_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_delete_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_dhcp_options_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_dedicated_group_data(struct osc_delete_dedicated_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->dedicated_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DedicatedGroupId\":", args->dedicated_group_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_force) {
		ARG_TO_JSON(Force, bool, args->force);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_delete_dedicated_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_dedicated_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteDedicatedGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_client_gateway_data(struct osc_delete_client_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_client_gateway(struct osc_env *e, struct osc_str *out, struct osc_delete_client_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_client_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteClientGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_ca_data(struct osc_delete_ca_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->ca_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaId\":", args->ca_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_ca(struct osc_env *e, struct osc_str *out, struct osc_delete_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_ca_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_api_access_rule_data(struct osc_delete_api_access_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->api_access_rule_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ApiAccessRuleId\":", args->api_access_rule_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_delete_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_api_access_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int delete_access_key_data(struct osc_delete_access_key_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->access_key_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccessKeyId\":", args->access_key_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_delete_access_key(struct osc_env *e, struct osc_str *out, struct osc_delete_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = delete_access_key_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/DeleteAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_vpn_connection_route_data(struct osc_create_vpn_connection_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vpn_connection_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VpnConnectionId\":", args->vpn_connection_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_vpn_connection_route(struct osc_env *e, struct osc_str *out, struct osc_create_vpn_connection_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_vpn_connection_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVpnConnectionRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_vpn_connection_data(struct osc_create_vpn_connection_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->client_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientGatewayId\":", args->client_gateway_id);
	   	ret += 1;
	}
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_static_routes_only) {
		ARG_TO_JSON(StaticRoutesOnly, bool, args->static_routes_only);
	   	ret += 1;
	}
	if (args->virtual_gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VirtualGatewayId\":", args->virtual_gateway_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_vpn_connection(struct osc_env *e, struct osc_str *out, struct osc_create_vpn_connection_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_vpn_connection_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVpnConnection");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_volume_data(struct osc_create_volume_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->is_set_iops || args->iops) {
		ARG_TO_JSON(Iops, int, args->iops);
	   	ret += 1;
	}
	if (args->is_set_size || args->size) {
		ARG_TO_JSON(Size, int, args->size);
	   	ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	if (args->volume_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeType\":", args->volume_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_volume(struct osc_env *e, struct osc_str *out, struct osc_create_volume_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_volume_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVolume");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_vms_data(struct osc_create_vms_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_vm_creation *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_vm_creation_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->is_set_boot_on_creation) {
		ARG_TO_JSON(BootOnCreation, bool, args->boot_on_creation);
	   	ret += 1;
	}
	if (args->is_set_bsu_optimized) {
		ARG_TO_JSON(BsuOptimized, bool, args->bsu_optimized);
	   	ret += 1;
	}
	if (args->client_token) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ClientToken\":", args->client_token);
	   	ret += 1;
	}
	if (args->is_set_deletion_protection) {
		ARG_TO_JSON(DeletionProtection, bool, args->deletion_protection);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_max_vms_count || args->max_vms_count) {
		ARG_TO_JSON(MaxVmsCount, int, args->max_vms_count);
	   	ret += 1;
	}
	if (args->is_set_min_vms_count || args->min_vms_count) {
		ARG_TO_JSON(MinVmsCount, int, args->min_vms_count);
	   	ret += 1;
	}
	if (args->is_set_nested_virtualization) {
		ARG_TO_JSON(NestedVirtualization, bool, args->nested_virtualization);
	   	ret += 1;
	}
        if (args->nics) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Nics\":[" ));
		for (int i = 0; i < args->nb_nics; ++i) {
	       	    struct nic_for_vm_creation *p = &args->nics[i];
		    if (p != args->nics)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(nic_for_vm_creation_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->nics_str) {
		ARG_TO_JSON(Nics, string, args->nics_str);
		ret += 1;
	}
	if (args->performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Performance\":", args->performance);
	   	ret += 1;
	}
	if (args->placement_str) {
		ARG_TO_JSON(Placement, string, args->placement_str);
		ret += 1;
	} else if (args->is_set_placement) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Placement\": { " ));
	       STRY(placement_setter(&args->placement, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->private_ips) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (as = args->private_ips; *as; ++as) {
			if (as != args->private_ips)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->security_groups) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (as = args->security_groups; *as; ++as) {
			if (as != args->security_groups)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	if (args->user_data) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserData\":", args->user_data);
	   	ret += 1;
	}
	if (args->vm_initiated_shutdown_behavior) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmInitiatedShutdownBehavior\":", args->vm_initiated_shutdown_behavior);
	   	ret += 1;
	}
	if (args->vm_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmType\":", args->vm_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_vms(struct osc_env *e, struct osc_str *out, struct osc_create_vms_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_vms_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVms");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_vm_template_data(struct osc_create_vm_template_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_cpu_cores || args->cpu_cores) {
		ARG_TO_JSON(CpuCores, int, args->cpu_cores);
	   	ret += 1;
	}
	if (args->cpu_generation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CpuGeneration\":", args->cpu_generation);
	   	ret += 1;
	}
	if (args->cpu_performance) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CpuPerformance\":", args->cpu_performance);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->is_set_ram || args->ram) {
		ARG_TO_JSON(Ram, int, args->ram);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->vm_template_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateName\":", args->vm_template_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_vm_template(struct osc_env *e, struct osc_str *out, struct osc_create_vm_template_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_vm_template_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVmTemplate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_vm_group_data(struct osc_create_vm_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->positioning_strategy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PositioningStrategy\":", args->positioning_strategy);
	   	ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	if (args->is_set_vm_count || args->vm_count) {
		ARG_TO_JSON(VmCount, int, args->vm_count);
	   	ret += 1;
	}
	if (args->vm_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmGroupName\":", args->vm_group_name);
	   	ret += 1;
	}
	if (args->vm_template_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmTemplateId\":", args->vm_template_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_vm_group(struct osc_env *e, struct osc_str *out, struct osc_create_vm_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_vm_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVmGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_virtual_gateway_data(struct osc_create_virtual_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_virtual_gateway(struct osc_env *e, struct osc_str *out, struct osc_create_virtual_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_virtual_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateVirtualGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_user_data(struct osc_create_user_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_user(struct osc_env *e, struct osc_str *out, struct osc_create_user_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_user_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateUser");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_tags_data(struct osc_create_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->resource_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ResourceIds\":[" ));
		for (as = args->resource_ids; *as; ++as) {
			if (as != args->resource_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->resource_ids_str) {
		ARG_TO_JSON(ResourceIds, string, args->resource_ids_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_tags(struct osc_env *e, struct osc_str *out, struct osc_create_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_subnet_data(struct osc_create_subnet_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_subnet(struct osc_env *e, struct osc_str *out, struct osc_create_subnet_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_subnet_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSubnet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_snapshot_export_task_data(struct osc_create_snapshot_export_task_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->osu_export_str) {
		ARG_TO_JSON(OsuExport, string, args->osu_export_str);
		ret += 1;
	} else if (args->is_set_osu_export) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuExport\": { " ));
	       STRY(osu_export_to_create_setter(&args->osu_export, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SnapshotId\":", args->snapshot_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_snapshot_export_task(struct osc_env *e, struct osc_str *out, struct osc_create_snapshot_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_snapshot_export_task_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSnapshotExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_snapshot_data(struct osc_create_snapshot_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->file_location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FileLocation\":", args->file_location);
	   	ret += 1;
	}
	if (args->is_set_snapshot_size || args->snapshot_size) {
		ARG_TO_JSON(SnapshotSize, int, args->snapshot_size);
	   	ret += 1;
	}
	if (args->source_region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceRegionName\":", args->source_region_name);
	   	ret += 1;
	}
	if (args->source_snapshot_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceSnapshotId\":", args->source_snapshot_id);
	   	ret += 1;
	}
	if (args->volume_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VolumeId\":", args->volume_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_snapshot(struct osc_env *e, struct osc_str *out, struct osc_create_snapshot_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_snapshot_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSnapshot");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_server_certificate_data(struct osc_create_server_certificate_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->body) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Body\":", args->body);
	   	ret += 1;
	}
	if (args->chain) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Chain\":", args->chain);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->private_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PrivateKey\":", args->private_key);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_server_certificate(struct osc_env *e, struct osc_str *out, struct osc_create_server_certificate_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_server_certificate_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateServerCertificate");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_security_group_rule_data(struct osc_create_security_group_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->flow) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Flow\":", args->flow);
	   	ret += 1;
	}
	if (args->is_set_from_port_range || args->from_port_range) {
		ARG_TO_JSON(FromPortRange, int, args->from_port_range);
	   	ret += 1;
	}
	if (args->ip_protocol) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpProtocol\":", args->ip_protocol);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
        if (args->rules) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Rules\":[" ));
		for (int i = 0; i < args->nb_rules; ++i) {
	       	    struct security_group_rule *p = &args->rules[i];
		    if (p != args->rules)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(security_group_rule_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->rules_str) {
		ARG_TO_JSON(Rules, string, args->rules_str);
		ret += 1;
	}
	if (args->security_group_account_id_to_link) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupAccountIdToLink\":", args->security_group_account_id_to_link);
	   	ret += 1;
	}
	if (args->security_group_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupId\":", args->security_group_id);
	   	ret += 1;
	}
	if (args->security_group_name_to_link) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupNameToLink\":", args->security_group_name_to_link);
	   	ret += 1;
	}
	if (args->is_set_to_port_range || args->to_port_range) {
		ARG_TO_JSON(ToPortRange, int, args->to_port_range);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_security_group_rule(struct osc_env *e, struct osc_str *out, struct osc_create_security_group_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_security_group_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSecurityGroupRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_security_group_data(struct osc_create_security_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->security_group_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SecurityGroupName\":", args->security_group_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_security_group(struct osc_env *e, struct osc_str *out, struct osc_create_security_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_security_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateSecurityGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_route_table_data(struct osc_create_route_table_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_route_table(struct osc_env *e, struct osc_str *out, struct osc_create_route_table_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_route_table_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateRouteTable");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_route_data(struct osc_create_route_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->destination_ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DestinationIpRange\":", args->destination_ip_range);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->gateway_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"GatewayId\":", args->gateway_id);
	   	ret += 1;
	}
	if (args->nat_service_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NatServiceId\":", args->nat_service_id);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	if (args->nic_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NicId\":", args->nic_id);
	   	ret += 1;
	}
	if (args->route_table_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RouteTableId\":", args->route_table_id);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_route(struct osc_env *e, struct osc_str *out, struct osc_create_route_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_route_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateRoute");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_public_ip_data(struct osc_create_public_ip_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_public_ip(struct osc_env *e, struct osc_str *out, struct osc_create_public_ip_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_public_ip_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreatePublicIp");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_product_type_data(struct osc_create_product_type_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->vendor) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Vendor\":", args->vendor);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_product_type(struct osc_env *e, struct osc_str *out, struct osc_create_product_type_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_product_type_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateProductType");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_policy_version_data(struct osc_create_policy_version_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->document) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Document\":", args->document);
	   	ret += 1;
	}
	if (args->policy_orn) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyOrn\":", args->policy_orn);
	   	ret += 1;
	}
	if (args->is_set_set_as_default) {
		ARG_TO_JSON(SetAsDefault, bool, args->set_as_default);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_policy_version(struct osc_env *e, struct osc_str *out, struct osc_create_policy_version_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_policy_version_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreatePolicyVersion");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_policy_data(struct osc_create_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->document) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Document\":", args->document);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->path) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Path\":", args->path);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_policy(struct osc_env *e, struct osc_str *out, struct osc_create_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreatePolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_nic_data(struct osc_create_nic_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->private_ips) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"PrivateIps\":[" ));
		for (int i = 0; i < args->nb_private_ips; ++i) {
	       	    struct private_ip_light *p = &args->private_ips[i];
		    if (p != args->private_ips)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(private_ip_light_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->private_ips_str) {
		ARG_TO_JSON(PrivateIps, string, args->private_ips_str);
		ret += 1;
	}
	if (args->security_group_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroupIds\":[" ));
		for (as = args->security_group_ids; *as; ++as) {
			if (as != args->security_group_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_group_ids_str) {
		ARG_TO_JSON(SecurityGroupIds, string, args->security_group_ids_str);
		ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_nic(struct osc_env *e, struct osc_str *out, struct osc_create_nic_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_nic_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNic");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_net_peering_data(struct osc_create_net_peering_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->accepter_net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"AccepterNetId\":", args->accepter_net_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->source_net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceNetId\":", args->source_net_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_net_peering(struct osc_env *e, struct osc_str *out, struct osc_create_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_net_peering_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_net_access_point_data(struct osc_create_net_access_point_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetId\":", args->net_id);
	   	ret += 1;
	}
	if (args->route_table_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"RouteTableIds\":[" ));
		for (as = args->route_table_ids; *as; ++as) {
			if (as != args->route_table_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->route_table_ids_str) {
		ARG_TO_JSON(RouteTableIds, string, args->route_table_ids_str);
		ret += 1;
	}
	if (args->service_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ServiceName\":", args->service_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_net_access_point(struct osc_env *e, struct osc_str *out, struct osc_create_net_access_point_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_net_access_point_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNetAccessPoint");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_net_data(struct osc_create_net_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->ip_range) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"IpRange\":", args->ip_range);
	   	ret += 1;
	}
	if (args->tenancy) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Tenancy\":", args->tenancy);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_net(struct osc_env *e, struct osc_str *out, struct osc_create_net_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_net_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNet");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_nat_service_data(struct osc_create_nat_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->public_ip_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIpId\":", args->public_ip_id);
	   	ret += 1;
	}
	if (args->subnet_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubnetId\":", args->subnet_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_nat_service(struct osc_env *e, struct osc_str *out, struct osc_create_nat_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_nat_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateNatService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_tags_data(struct osc_create_load_balancer_tags_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LoadBalancerNames\":[" ));
		for (as = args->load_balancer_names; *as; ++as) {
			if (as != args->load_balancer_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->load_balancer_names_str) {
		ARG_TO_JSON(LoadBalancerNames, string, args->load_balancer_names_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_load_balancer_tags(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_tags_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_load_balancer_tags_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerTags");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_policy_data(struct osc_create_load_balancer_policy_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_cookie_expiration_period || args->cookie_expiration_period) {
		ARG_TO_JSON(CookieExpirationPeriod, int, args->cookie_expiration_period);
	   	ret += 1;
	}
	if (args->cookie_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CookieName\":", args->cookie_name);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->policy_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyName\":", args->policy_name);
	   	ret += 1;
	}
	if (args->policy_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PolicyType\":", args->policy_type);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_load_balancer_policy(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_policy_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_load_balancer_policy_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerPolicy");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_listeners_data(struct osc_create_load_balancer_listeners_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->listeners) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Listeners\":[" ));
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener_for_creation *p = &args->listeners[i];
		    if (p != args->listeners)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(listener_for_creation_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->listeners_str) {
		ARG_TO_JSON(Listeners, string, args->listeners_str);
		ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_load_balancer_listeners(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_listeners_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_load_balancer_listeners_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancerListeners");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_load_balancer_data(struct osc_create_load_balancer_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
        if (args->listeners) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Listeners\":[" ));
		for (int i = 0; i < args->nb_listeners; ++i) {
	       	    struct listener_for_creation *p = &args->listeners[i];
		    if (p != args->listeners)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(listener_for_creation_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->listeners_str) {
		ARG_TO_JSON(Listeners, string, args->listeners_str);
		ret += 1;
	}
	if (args->load_balancer_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerName\":", args->load_balancer_name);
	   	ret += 1;
	}
	if (args->load_balancer_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LoadBalancerType\":", args->load_balancer_type);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	if (args->security_groups) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SecurityGroups\":[" ));
		for (as = args->security_groups; *as; ++as) {
			if (as != args->security_groups)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->security_groups_str) {
		ARG_TO_JSON(SecurityGroups, string, args->security_groups_str);
		ret += 1;
	}
	if (args->subnets) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Subnets\":[" ));
		for (as = args->subnets; *as; ++as) {
			if (as != args->subnets)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subnets_str) {
		ARG_TO_JSON(Subnets, string, args->subnets_str);
		ret += 1;
	}
	if (args->subregion_names) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"SubregionNames\":[" ));
		for (as = args->subregion_names; *as; ++as) {
			if (as != args->subregion_names)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->subregion_names_str) {
		ARG_TO_JSON(SubregionNames, string, args->subregion_names_str);
		ret += 1;
	}
        if (args->tags) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Tags\":[" ));
		for (int i = 0; i < args->nb_tags; ++i) {
	       	    struct resource_tag *p = &args->tags[i];
		    if (p != args->tags)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(resource_tag_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->tags_str) {
		ARG_TO_JSON(Tags, string, args->tags_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_load_balancer(struct osc_env *e, struct osc_str *out, struct osc_create_load_balancer_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_load_balancer_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateLoadBalancer");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_listener_rule_data(struct osc_create_listener_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->listener_str) {
		ARG_TO_JSON(Listener, string, args->listener_str);
		ret += 1;
	} else if (args->is_set_listener) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"Listener\": { " ));
	       STRY(load_balancer_light_setter(&args->listener, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->listener_rule_str) {
		ARG_TO_JSON(ListenerRule, string, args->listener_rule_str);
		ret += 1;
	} else if (args->is_set_listener_rule) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"ListenerRule\": { " ));
	       STRY(listener_rule_for_creation_setter(&args->listener_rule, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->vm_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"VmIds\":[" ));
		for (as = args->vm_ids; *as; ++as) {
			if (as != args->vm_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->vm_ids_str) {
		ARG_TO_JSON(VmIds, string, args->vm_ids_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_listener_rule(struct osc_env *e, struct osc_str *out, struct osc_create_listener_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_listener_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateListenerRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_keypair_data(struct osc_create_keypair_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->keypair_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"KeypairName\":", args->keypair_name);
	   	ret += 1;
	}
	if (args->public_key) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicKey\":", args->public_key);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_keypair(struct osc_env *e, struct osc_str *out, struct osc_create_keypair_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_keypair_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateKeypair");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_internet_service_data(struct osc_create_internet_service_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_internet_service(struct osc_env *e, struct osc_str *out, struct osc_create_internet_service_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_internet_service_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateInternetService");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_image_export_task_data(struct osc_create_image_export_task_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageId\":", args->image_id);
	   	ret += 1;
	}
	if (args->osu_export_str) {
		ARG_TO_JSON(OsuExport, string, args->osu_export_str);
		ret += 1;
	} else if (args->is_set_osu_export) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"OsuExport\": { " ));
	       STRY(osu_export_to_create_setter(&args->osu_export, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_image_export_task(struct osc_env *e, struct osc_str *out, struct osc_create_image_export_task_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_image_export_task_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateImageExportTask");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_image_data(struct osc_create_image_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->architecture) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Architecture\":", args->architecture);
	   	ret += 1;
	}
        if (args->block_device_mappings) {
	        TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"BlockDeviceMappings\":[" ));
		for (int i = 0; i < args->nb_block_device_mappings; ++i) {
	       	    struct block_device_mapping_image *p = &args->block_device_mappings[i];
		    if (p != args->block_device_mappings)
		        STRY(osc_str_append_string(data, "," ));
		    STRY(osc_str_append_string(data, "{ " ));
	       	    STRY(block_device_mapping_image_setter(p, data) < 0);
	       	    STRY(osc_str_append_string(data, "}" ));
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else
	if (args->block_device_mappings_str) {
		ARG_TO_JSON(BlockDeviceMappings, string, args->block_device_mappings_str);
		ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->file_location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FileLocation\":", args->file_location);
	   	ret += 1;
	}
	if (args->image_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ImageName\":", args->image_name);
	   	ret += 1;
	}
	if (args->is_set_no_reboot) {
		ARG_TO_JSON(NoReboot, bool, args->no_reboot);
	   	ret += 1;
	}
	if (args->product_codes) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"ProductCodes\":[" ));
		for (as = args->product_codes; *as; ++as) {
			if (as != args->product_codes)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->product_codes_str) {
		ARG_TO_JSON(ProductCodes, string, args->product_codes_str);
		ret += 1;
	}
	if (args->root_device_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"RootDeviceName\":", args->root_device_name);
	   	ret += 1;
	}
	if (args->source_image_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceImageId\":", args->source_image_id);
	   	ret += 1;
	}
	if (args->source_region_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SourceRegionName\":", args->source_region_name);
	   	ret += 1;
	}
	if (args->vm_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VmId\":", args->vm_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_image(struct osc_env *e, struct osc_str *out, struct osc_create_image_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_image_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateImage");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_flexible_gpu_data(struct osc_create_flexible_gpu_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_delete_on_vm_deletion) {
		ARG_TO_JSON(DeleteOnVmDeletion, bool, args->delete_on_vm_deletion);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->generation) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Generation\":", args->generation);
	   	ret += 1;
	}
	if (args->model_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ModelName\":", args->model_name);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_flexible_gpu(struct osc_env *e, struct osc_str *out, struct osc_create_flexible_gpu_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_flexible_gpu_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateFlexibleGpu");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_direct_link_interface_data(struct osc_create_direct_link_interface_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->direct_link_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkId\":", args->direct_link_id);
	   	ret += 1;
	}
	if (args->direct_link_interface_str) {
		ARG_TO_JSON(DirectLinkInterface, string, args->direct_link_interface_str);
		ret += 1;
	} else if (args->is_set_direct_link_interface) {
	       TRY_APPEND_COL(count_args, data);
	       STRY(osc_str_append_string(data, "\"DirectLinkInterface\": { " ));
	       STRY(direct_link_interface_setter(&args->direct_link_interface, data) < 0);
	       STRY(osc_str_append_string(data, "}" ));
	       ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_direct_link_interface(struct osc_env *e, struct osc_str *out, struct osc_create_direct_link_interface_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_direct_link_interface_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateDirectLinkInterface");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_direct_link_data(struct osc_create_direct_link_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->bandwidth) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Bandwidth\":", args->bandwidth);
	   	ret += 1;
	}
	if (args->direct_link_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DirectLinkName\":", args->direct_link_name);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->location) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Location\":", args->location);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_direct_link(struct osc_env *e, struct osc_str *out, struct osc_create_direct_link_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_direct_link_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateDirectLink");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_dhcp_options_data(struct osc_create_dhcp_options_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->domain_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"DomainName\":", args->domain_name);
	   	ret += 1;
	}
	if (args->domain_name_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"DomainNameServers\":[" ));
		for (as = args->domain_name_servers; *as; ++as) {
			if (as != args->domain_name_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->domain_name_servers_str) {
		ARG_TO_JSON(DomainNameServers, string, args->domain_name_servers_str);
		ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->log_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"LogServers\":[" ));
		for (as = args->log_servers; *as; ++as) {
			if (as != args->log_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->log_servers_str) {
		ARG_TO_JSON(LogServers, string, args->log_servers_str);
		ret += 1;
	}
	if (args->ntp_servers) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"NtpServers\":[" ));
		for (as = args->ntp_servers; *as; ++as) {
			if (as != args->ntp_servers)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ntp_servers_str) {
		ARG_TO_JSON(NtpServers, string, args->ntp_servers_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_dhcp_options(struct osc_env *e, struct osc_str *out, struct osc_create_dhcp_options_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_dhcp_options_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateDhcpOptions");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_dedicated_group_data(struct osc_create_dedicated_group_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_cpu_generation || args->cpu_generation) {
		ARG_TO_JSON(CpuGeneration, int, args->cpu_generation);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Name\":", args->name);
	   	ret += 1;
	}
	if (args->subregion_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"SubregionName\":", args->subregion_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_dedicated_group(struct osc_env *e, struct osc_str *out, struct osc_create_dedicated_group_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_dedicated_group_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateDedicatedGroup");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_client_gateway_data(struct osc_create_client_gateway_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_bgp_asn || args->bgp_asn) {
		ARG_TO_JSON(BgpAsn, int, args->bgp_asn);
	   	ret += 1;
	}
	if (args->connection_type) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ConnectionType\":", args->connection_type);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->public_ip) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PublicIp\":", args->public_ip);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_client_gateway(struct osc_env *e, struct osc_str *out, struct osc_create_client_gateway_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_client_gateway_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateClientGateway");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_ca_data(struct osc_create_ca_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->ca_pem) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CaPem\":", args->ca_pem);
	   	ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_ca(struct osc_env *e, struct osc_str *out, struct osc_create_ca_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_ca_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateCa");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_api_access_rule_data(struct osc_create_api_access_rule_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->ca_ids) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"CaIds\":[" ));
		for (as = args->ca_ids; *as; ++as) {
			if (as != args->ca_ids)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ca_ids_str) {
		ARG_TO_JSON(CaIds, string, args->ca_ids_str);
		ret += 1;
	}
	if (args->cns) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"Cns\":[" ));
		for (as = args->cns; *as; ++as) {
			if (as != args->cns)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->cns_str) {
		ARG_TO_JSON(Cns, string, args->cns_str);
		ret += 1;
	}
	if (args->description) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Description\":", args->description);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->ip_ranges) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"IpRanges\":[" ));
		for (as = args->ip_ranges; *as; ++as) {
			if (as != args->ip_ranges)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->ip_ranges_str) {
		ARG_TO_JSON(IpRanges, string, args->ip_ranges_str);
		ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_api_access_rule(struct osc_env *e, struct osc_str *out, struct osc_create_api_access_rule_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_api_access_rule_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateApiAccessRule");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_account_data(struct osc_create_account_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->additional_emails) {
		char **as;

	   	TRY_APPEND_COL(count_args, data);
		STRY(osc_str_append_string(data, "\"AdditionalEmails\":[" ));
		for (as = args->additional_emails; *as; ++as) {
			if (as != args->additional_emails)
				STRY(osc_str_append_string(data, "," ));
			ARG_TO_JSON_STR("", *as);
		}
		STRY(osc_str_append_string(data, "]" ));
		ret += 1;
	} else if (args->additional_emails_str) {
		ARG_TO_JSON(AdditionalEmails, string, args->additional_emails_str);
		ret += 1;
	}
	if (args->city) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"City\":", args->city);
	   	ret += 1;
	}
	if (args->company_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CompanyName\":", args->company_name);
	   	ret += 1;
	}
	if (args->country) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Country\":", args->country);
	   	ret += 1;
	}
	if (args->customer_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"CustomerId\":", args->customer_id);
	   	ret += 1;
	}
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->email) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Email\":", args->email);
	   	ret += 1;
	}
	if (args->first_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"FirstName\":", args->first_name);
	   	ret += 1;
	}
	if (args->job_title) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"JobTitle\":", args->job_title);
	   	ret += 1;
	}
	if (args->last_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"LastName\":", args->last_name);
	   	ret += 1;
	}
	if (args->mobile_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"MobileNumber\":", args->mobile_number);
	   	ret += 1;
	}
	if (args->phone_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"PhoneNumber\":", args->phone_number);
	   	ret += 1;
	}
	if (args->state_province) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"StateProvince\":", args->state_province);
	   	ret += 1;
	}
	if (args->vat_number) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"VatNumber\":", args->vat_number);
	   	ret += 1;
	}
	if (args->zip_code) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ZipCode\":", args->zip_code);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_account(struct osc_env *e, struct osc_str *out, struct osc_create_account_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_account_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateAccount");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int create_access_key_data(struct osc_create_access_key_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->expiration_date) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"ExpirationDate\":", args->expiration_date);
	   	ret += 1;
	}
	if (args->user_name) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"UserName\":", args->user_name);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_create_access_key(struct osc_env *e, struct osc_str *out, struct osc_create_access_key_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = create_access_key_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CreateAccessKey");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int check_authentication_data(struct osc_check_authentication_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->login) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Login\":", args->login);
	   	ret += 1;
	}
	if (args->password) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"Password\":", args->password);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_check_authentication(struct osc_env *e, struct osc_str *out, struct osc_check_authentication_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = check_authentication_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/CheckAuthentication");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}
static  int accept_net_peering_data(struct osc_accept_net_peering_arg *args, struct osc_str *data)
{
	int ret = 0;
	int count_args = 0;

	if (!args)
		return 0;
	osc_str_append_string(data, "{");
	if (args->is_set_dry_run) {
		ARG_TO_JSON(DryRun, bool, args->dry_run);
	   	ret += 1;
	}
	if (args->net_peering_id) {
		TRY_APPEND_COL(count_args, data);
	        ARG_TO_JSON_STR("\"NetPeeringId\":", args->net_peering_id);
	   	ret += 1;
	}
	osc_str_append_string(data, "}");
	return !!ret;
}

int osc_accept_net_peering(struct osc_env *e, struct osc_str *out, struct osc_accept_net_peering_arg *args)
{
	CURLcode res = CURLE_OUT_OF_MEMORY;
	struct osc_str data;
	struct osc_str end_call;
	int r;

	osc_init_str(&data);
	osc_init_str(&end_call);
	r = accept_net_peering_data(args, &data);
	if (r < 0)
		goto out;

	osc_str_append_string(&end_call, e->endpoint.buf);
	osc_str_append_string(&end_call, "/api/v1/AcceptNetPeering");
	curl_easy_setopt(e->c, CURLOPT_URL, end_call.buf);
	curl_easy_setopt(e->c, CURLOPT_POSTFIELDS, r ? data.buf : "");
	curl_easy_setopt(e->c, CURLOPT_WRITEDATA, out);
	if (e->flag & OSC_VERBOSE_MODE) {
	  printf("<Data send to curl>\n%s\n</Data send to curl>\n", data.buf);
	}
	res = curl_easy_perform(e->c);
out:
	osc_deinit_str(&end_call);
	osc_deinit_str(&data);
	return res;
}


int osc_sdk_set_useragent(struct osc_env *e, const char *str)
{
	return curl_easy_setopt(e->c, CURLOPT_USERAGENT, str);
}

static inline char *cfg_login(struct osc_env_conf *cfg)
{
	if (!cfg)
		return NULL;
	return cfg->login;
}

static inline char *cfg_pass(struct osc_env_conf *cfg)
{
	if (!cfg)
		return NULL;
	return cfg->password;
}

int osc_init_sdk_ext(struct osc_env *e, const char *profile, unsigned int flag,
		     struct osc_env_conf *cfg)
{
	char *ca = getenv("CURL_CA_BUNDLE");
	char *endpoint;
	char user_agent[sizeof "osc-sdk-c/" + OSC_SDK_VERSON_L];
	char *cert = getenv("OSC_X509_CLIENT_CERT");
	char *sslkey = getenv("OSC_X509_CLIENT_KEY");
	char *auth = getenv("OSC_AUTH_METHOD");
	char *force_log = cfg_login(cfg);
	char *force_pass = cfg_pass(cfg);

	strcpy(stpcpy(user_agent, "osc-sdk-c/"), osc_sdk_version_str());
	e->region = getenv("OSC_REGION");
	e->flag = flag;
	e->auth_method = cfg ? cfg->auth_method : OSC_AKSK_METHOD;
	endpoint = getenv("OSC_ENDPOINT_API");
	osc_init_str(&e->endpoint);

	if (auth && (!strcmp(auth, "password") || !strcmp(auth, "basic"))) {
		e->auth_method = OSC_PASSWORD_METHOD;
	} else if (auth && !strcmp(auth, "none")) {
		e->auth_method = OSC_NONE_METHOD;
	} else if (auth && strcmp(auth, "accesskey")) {
		fprintf(stderr, "'%s' invalid authentication method\n", auth);
		return -1;
	}

	if (force_log)
		e->ak = force_log;
	if (force_pass)
		e->sk = force_pass;
	if (!profile && e->auth_method != OSC_NONE_METHOD) {
		profile = getenv("OSC_PROFILE");
		if (e->auth_method == OSC_PASSWORD_METHOD) {
			if (!force_log)
				e->ak = getenv("OSC_LOGIN");
			if (!force_pass)
				e->sk =  getenv("OSC_PASSWORD");
		} else {
			if (!force_log)
				e->ak = getenv("OSC_ACCESS_KEY");
			if (!force_pass)
				e->sk = getenv("OSC_SECRET_KEY");
		}
		if (!profile && (!e->ak || !e->sk))
			profile = "default";
	}

	if (profile && e->auth_method != OSC_NONE_METHOD) {
		int f;

		if (e->auth_method == OSC_PASSWORD_METHOD) {
			STRY(osc_load_loging_password_from_conf(
				    profile, force_log ? NULL : &e->ak,
				    force_pass ? NULL : &e->sk) < 0);
			if (!force_log)
				e->flag |= OSC_ENV_FREE_AK;
			if (!force_pass) {
				if (!e->sk)
					e->sk = getenv("OSC_PASSWORD");
				else
					e->flag |= OSC_ENV_FREE_SK;
			}
		} else {
			STRY(osc_load_ak_sk_from_conf(
				    profile, force_log ? NULL : &e->ak,
				    force_pass ? NULL : &e->sk) < 0);
			if (!force_log)
				e->flag |= OSC_ENV_FREE_AK;
			if (!force_pass)
				e->flag |= OSC_ENV_FREE_SK;
		}
		if (!osc_load_region_from_conf(profile, &e->region))
			e->flag |= OSC_ENV_FREE_REGION;
		f = osc_load_cert_from_conf(profile, &e->cert, &e->sslkey);
		if (f < 0)
			return -1;
		e->flag |= f;
	}

	if (!e->region)
		e->region = "eu-west-2";

	if (!endpoint) {
		osc_str_append_string(&e->endpoint, "https://api.");
		osc_str_append_string(&e->endpoint, e->region);
		osc_str_append_string(&e->endpoint, ".outscale.com");
	} else {
		osc_str_append_string(&e->endpoint, endpoint);
	}

	if (e->auth_method == OSC_AKSK_METHOD) {
		if (!e->ak || !e->sk) {
			fprintf(stderr, "access key and secret key needed\n");
			return -1;
		}

		if (strlen(e->ak) != AK_SIZE || strlen(e->sk) != SK_SIZE) {
			fprintf(stderr, "Wrong access key or secret key size\n");
			return -1;
		}
	} else if (e->auth_method == OSC_PASSWORD_METHOD) {
		if (!e->ak || !e->sk) {
			fprintf(stderr, "login and password needed\n");
			return -1;
		}
	}

	e->headers = NULL;
	e->c = curl_easy_init();

	#ifdef _WIN32
	curl_easy_setopt(e->c, CURLOPT_SSL_OPTIONS, (long)CURLSSLOPT_NATIVE_CA);
	#endif

	/* Setting HEADERS */
	if (flag & OSC_VERBOSE_MODE)
		curl_easy_setopt(e->c, CURLOPT_VERBOSE, 1);
	if (flag & OSC_INSECURE_MODE)
		curl_easy_setopt(e->c, CURLOPT_SSL_VERIFYPEER, 0);
	if (cert)
		curl_easy_setopt(e->c, CURLOPT_SSLCERT, cert);
	if (sslkey)
		curl_easy_setopt(e->c, CURLOPT_SSLKEY, sslkey);
	curl_easy_setopt(e->c, CURLOPT_WRITEFUNCTION, write_data);
	curl_easy_setopt(e->c, CURLOPT_USERAGENT, user_agent);

	/* setting CA if CURL_CA_BUNDLE is set */
	if (ca)
	  curl_easy_setopt(e->c, CURLOPT_CAINFO, ca);

	e->headers = curl_slist_append(e->headers, "Content-Type: application/json");

	/* For authentification we specify the method and our acces key / secret key */
	if (e->auth_method == OSC_AKSK_METHOD) {
		curl_easy_setopt(e->c, CURLOPT_AWS_SIGV4, "osc");
	} else if (e->auth_method == OSC_PASSWORD_METHOD) {
		time_t clock;
		struct tm tm;
		struct tm *tmp;
		char time_hdr[TIME_HDR_KEY_L + TIMESTAMP_SIZE] = TIME_HDR_KEY;

		time(&clock);
#if SAFE_C == 1
		TRY(!gmtime_r(&clock, &tm), "gmtime_r fail\n");\
		tmp = &tm;
#else
		(void)tm;
		tmp = gmtime(&clock);
		TRY(!tmp, "gmtime fail\n");
#endif
		strftime(time_hdr + TIME_HDR_KEY_L - 1,
			 TIMESTAMP_SIZE, "%Y%m%dT%H%M%SZ", tmp);
		e->headers = curl_slist_append(e->headers, time_hdr);
	}
	curl_easy_setopt(e->c, CURLOPT_HTTPHEADER, e->headers);

	if (e->auth_method != OSC_NONE_METHOD) {
		curl_easy_setopt(e->c, CURLOPT_USERNAME, e->ak);
		curl_easy_setopt(e->c, CURLOPT_PASSWORD, e->sk);
	}

	return 0;
}

int osc_init_sdk(struct osc_env *e, const char *profile, unsigned int flag)
{
	return osc_init_sdk_ext(e, profile, flag, NULL);
}

void osc_deinit_sdk(struct osc_env *e)
{
	curl_slist_free_all(e->headers);
	curl_easy_cleanup(e->c);
	osc_deinit_str(&e->endpoint);
	if (e->flag & OSC_ENV_FREE_AK) {
		free(e->ak);
		e->ak = NULL;
	}
	if (e->flag & OSC_ENV_FREE_SK) {
		free(e->sk);
		e->sk = NULL;
	}
	if (e->flag & OSC_ENV_FREE_REGION) {
		free(e->region);
		e->region = NULL;
	}

	if (e->flag & OSC_ENV_FREE_CERT) {
		free(e->cert);
	}
	if (e->flag & OSC_ENV_FREE_SSLKEY) {
		free(e->sslkey);
	}

	e->c = NULL;
	e->flag = 0;
}
